/**
 * State-based routing for AngularJS 1.x
 * NOTICE: This monolithic bundle also bundles the @uirouter/core code.
 *         This causes it to be incompatible with plugins that depend on @uirouter/core.
 *         We recommend switching to the ui-router-core.js and ui-router-angularjs.js bundles instead.
 *         For more information, see https://ui-router.github.io/blog/uirouter-for-angularjs-umd-bundles
 * @version v1.0.25
 * @link https://ui-router.github.io
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular')) :
    typeof define === 'function' && define.amd ? define(['exports', 'angular'], factory) :
    (global = global || self, factory(global['@uirouter/angularjs'] = {}, global.angular));
}(this, (function (exports, ng_from_import) { 'use strict';

    /** @publicapi @module ng1 */ /** */
    /** @hidden */ var ng_from_global = angular;
    /** @hidden */ var ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global;

    /**
     * Higher order functions
     *
     * These utility functions are exported, but are subject to change without notice.
     *
     * @module common_hof
     */ /** */
    var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    /**
     * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
     *
     * Given a function with N parameters, returns a new function that supports partial application.
     * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
     * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
     * accept more parameters until all N parameters have been supplied.
     *
     *
     * This contrived example uses a partially applied function as an predicate, which returns true
     * if an object is found in both arrays.
     * @example
     * ```
     * // returns true if an object is in both of the two arrays
     * function inBoth(array1, array2, object) {
     *   return array1.indexOf(object) !== -1 &&
     *          array2.indexOf(object) !== 1;
     * }
     * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
     * let foos = [obj1, obj3]
     * let bars = [obj3, obj4, obj5]
     *
     * // A curried "copy" of inBoth
     * let curriedInBoth = curry(inBoth);
     * // Partially apply both the array1 and array2
     * let inFoosAndBars = curriedInBoth(foos, bars);
     *
     * // Supply the final argument; since all arguments are
     * // supplied, the original inBoth function is then called.
     * let obj1InBoth = inFoosAndBars(obj1); // false
     *
     * // Use the inFoosAndBars as a predicate.
     * // Filter, on each iteration, supplies the final argument
     * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
     * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
     *
     * ```
     *
     * @param fn
     * @returns {*|function(): (*|any)}
     */
    function curry(fn) {
        return function curried() {
            if (arguments.length >= fn.length) {
                return fn.apply(this, arguments);
            }
            var args = Array.prototype.slice.call(arguments);
            return curried.bind.apply(curried, __spreadArrays([this], args));
        };
    }
    /**
     * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
     * given: f(x), g(x), h(x)
     * let composed = compose(f,g,h)
     * then, composed is: f(g(h(x)))
     */
    function compose() {
        var args = arguments;
        var start = args.length - 1;
        return function () {
            var i = start, result = args[start].apply(this, arguments);
            while (i--)
                result = args[i].call(this, result);
            return result;
        };
    }
    /**
     * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
     * given: f(x), g(x), h(x)
     * let piped = pipe(f,g,h);
     * then, piped is: h(g(f(x)))
     */
    function pipe() {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        return compose.apply(null, [].slice.call(arguments).reverse());
    }
    /**
     * Given a property name, returns a function that returns that property from an object
     * let obj = { foo: 1, name: "blarg" };
     * let getName = prop("name");
     * getName(obj) === "blarg"
     */
    var prop = function (name) { return function (obj) { return obj && obj[name]; }; };
    /**
     * Given a property name and a value, returns a function that returns a boolean based on whether
     * the passed object has a property that matches the value
     * let obj = { foo: 1, name: "blarg" };
     * let getName = propEq("name", "blarg");
     * getName(obj) === true
     */
    var propEq = curry(function (name, _val, obj) { return obj && obj[name] === _val; });
    /**
     * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
     * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
     * let getName = prop("nestedObj.name");
     * getName(obj) === "blarg"
     * let propNotFound = prop("this.property.doesnt.exist");
     * propNotFound(obj) === undefined
     */
    var parse = function (name) { return pipe.apply(null, name.split('.').map(prop)); };
    /**
     * Given a function that returns a truthy or falsey value, returns a
     * function that returns the opposite (falsey or truthy) value given the same inputs
     */
    var not = function (fn) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return !fn.apply(null, args);
    }; };
    /**
     * Given two functions that return truthy or falsey values, returns a function that returns truthy
     * if both functions return truthy for the given arguments
     */
    function and(fn1, fn2) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fn1.apply(null, args) && fn2.apply(null, args);
        };
    }
    /**
     * Given two functions that return truthy or falsey values, returns a function that returns truthy
     * if at least one of the functions returns truthy for the given arguments
     */
    function or(fn1, fn2) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fn1.apply(null, args) || fn2.apply(null, args);
        };
    }
    /**
     * Check if all the elements of an array match a predicate function
     *
     * @param fn1 a predicate function `fn1`
     * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
     */
    var all = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); }; };
    // tslint:disable-next-line:variable-name
    var any = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); }; };
    /** Given a class, returns a Predicate function that returns true if the object is of that class */
    var is = function (ctor) { return function (obj) {
        return (obj != null && obj.constructor === ctor) || obj instanceof ctor;
    }; };
    /** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */
    var eq = function (value) { return function (other) { return value === other; }; };
    /** Given a value, returns a function which returns the value */
    var val = function (v) { return function () { return v; }; };
    function invoke(fnName, args) {
        return function (obj) { return obj[fnName].apply(obj, args); };
    }
    /**
     * Sorta like Pattern Matching (a functional programming conditional construct)
     *
     * See http://c2.com/cgi/wiki?PatternMatching
     *
     * This is a conditional construct which allows a series of predicates and output functions
     * to be checked and then applied.  Each predicate receives the input.  If the predicate
     * returns truthy, then its matching output function (mapping function) is provided with
     * the input and, then the result is returned.
     *
     * Each combination (2-tuple) of predicate + output function should be placed in an array
     * of size 2: [ predicate, mapFn ]
     *
     * These 2-tuples should be put in an outer array.
     *
     * @example
     * ```
     *
     * // Here's a 2-tuple where the first element is the isString predicate
     * // and the second element is a function that returns a description of the input
     * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
     *
     * // Second tuple: predicate "isNumber", mapfn returns a description
     * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
     *
     * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
     *
     * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
     *
     * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
     *
     * console.log(descriptionOf(undefined)); // 'notdefined'
     * console.log(descriptionOf(55)); // '(55) That's a number!'
     * console.log(descriptionOf("foo")); // 'Here's your string foo'
     * ```
     *
     * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
     * with a Predicate and a mapping/output function
     * @returns {function(any): *}
     */
    function pattern(struct) {
        return function (x) {
            for (var i = 0; i < struct.length; i++) {
                if (struct[i][0](x))
                    return struct[i][1](x);
            }
        };
    }

    /** Predicates
     *
     * These predicates return true/false based on the input.
     * Although these functions are exported, they are subject to change without notice.
     *
     * @module common_predicates
     */ /** */
    var toStr = Object.prototype.toString;
    var tis = function (t) { return function (x) { return typeof x === t; }; };
    var isUndefined = tis('undefined');
    var isDefined = not(isUndefined);
    var isNull = function (o) { return o === null; };
    var isNullOrUndefined = or(isNull, isUndefined);
    var isFunction = tis('function');
    var isNumber = tis('number');
    var isString = tis('string');
    var isObject = function (x) { return x !== null && typeof x === 'object'; };
    var isArray = Array.isArray;
    var isDate = (function (x) { return toStr.call(x) === '[object Date]'; });
    var isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });
    /**
     * Predicate which checks if a value is injectable
     *
     * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
     * where all the elements in the array are Strings, except the last one, which is a Function
     */
    function isInjectable(val) {
        if (isArray(val) && val.length) {
            var head = val.slice(0, -1), tail = val.slice(-1);
            return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);
        }
        return isFunction(val);
    }
    /**
     * Predicate which checks if a value looks like a Promise
     *
     * It is probably a Promise if it's an object, and it has a `then` property which is a Function
     */
    var isPromise = and(isObject, pipe(prop('then'), isFunction));

    var noImpl = function (fnname) { return function () {
        throw new Error("No implementation for " + fnname + ". The framework specific code did not implement this method.");
    }; };
    var makeStub = function (service, methods) {
        return methods.reduce(function (acc, key) { return ((acc[key] = noImpl(service + "." + key + "()")), acc); }, {});
    };
    var services = {
        $q: undefined,
        $injector: undefined,
    };

    var __spreadArrays$1 = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    var root = (typeof self === 'object' && self.self === self && self) ||
        (typeof global === 'object' && global.global === global && global) ||
        undefined;
    var angular$1 = root.angular || {};
    var fromJson = angular$1.fromJson || JSON.parse.bind(JSON);
    var toJson = angular$1.toJson || JSON.stringify.bind(JSON);
    var forEach = angular$1.forEach || _forEach;
    var extend = Object.assign || _extend;
    var equals = angular$1.equals || _equals;
    function identity(x) {
        return x;
    }
    function noop() { }
    /**
     * Builds proxy functions on the `to` object which pass through to the `from` object.
     *
     * For each key in `fnNames`, creates a proxy function on the `to` object.
     * The proxy function calls the real function on the `from` object.
     *
     *
     * #### Example:
     * This example creates an new class instance whose functions are prebound to the new'd object.
     * ```js
     * class Foo {
     *   constructor(data) {
     *     // Binds all functions from Foo.prototype to 'this',
     *     // then copies them to 'this'
     *     bindFunctions(Foo.prototype, this, this);
     *     this.data = data;
     *   }
     *
     *   log() {
     *     console.log(this.data);
     *   }
     * }
     *
     * let myFoo = new Foo([1,2,3]);
     * var logit = myFoo.log;
     * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
     * ```
     *
     * #### Example:
     * This example creates a bound version of a service function, and copies it to another object
     * ```
     *
     * var SomeService = {
     *   this.data = [3, 4, 5];
     *   this.log = function() {
     *     console.log(this.data);
     *   }
     * }
     *
     * // Constructor fn
     * function OtherThing() {
     *   // Binds all functions from SomeService to SomeService,
     *   // then copies them to 'this'
     *   bindFunctions(SomeService, this, SomeService);
     * }
     *
     * let myOtherThing = new OtherThing();
     * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
     * ```
     *
     * @param source A function that returns the source object which contains the original functions to be bound
     * @param target A function that returns the target object which will receive the bound functions
     * @param bind A function that returns the object which the functions will be bound to
     * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
     * @param latebind If true, the binding of the function is delayed until the first time it's invoked
     */
    function createProxyFunctions(source, target, bind, fnNames, latebind) {
        if (latebind === void 0) { latebind = false; }
        var bindFunction = function (fnName) { return source()[fnName].bind(bind()); };
        var makeLateRebindFn = function (fnName) {
            return function lateRebindFunction() {
                target[fnName] = bindFunction(fnName);
                return target[fnName].apply(null, arguments);
            };
        };
        fnNames = fnNames || Object.keys(source());
        return fnNames.reduce(function (acc, name) {
            acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
            return acc;
        }, target);
    }
    /**
     * prototypal inheritance helper.
     * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
     */
    var inherit = function (parent, extra) { return extend(Object.create(parent), extra); };
    /** Given an array, returns true if the object is found in the array, (using indexOf) */
    var inArray = curry(_inArray);
    function _inArray(array, obj) {
        return array.indexOf(obj) !== -1;
    }
    /**
     * Given an array, and an item, if the item is found in the array, it removes it (in-place).
     * The same array is returned
     */
    var removeFrom = curry(_removeFrom);
    function _removeFrom(array, obj) {
        var idx = array.indexOf(obj);
        if (idx >= 0)
            array.splice(idx, 1);
        return array;
    }
    /** pushes a values to an array and returns the value */
    var pushTo = curry(_pushTo);
    function _pushTo(arr, val) {
        return arr.push(val), val;
    }
    /** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */
    var deregAll = function (functions) {
        return functions.slice().forEach(function (fn) {
            typeof fn === 'function' && fn();
            removeFrom(functions, fn);
        });
    };
    /**
     * Applies a set of defaults to an options object.  The options object is filtered
     * to only those properties of the objects in the defaultsList.
     * Earlier objects in the defaultsList take precedence when applying defaults.
     */
    function defaults(opts) {
        var defaultsList = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            defaultsList[_i - 1] = arguments[_i];
        }
        var defaultVals = extend.apply(void 0, __spreadArrays$1([{}], defaultsList.reverse()));
        return extend(defaultVals, pick(opts || {}, Object.keys(defaultVals)));
    }
    /** Reduce function that merges each element of the list into a single object, using extend */
    var mergeR = function (memo, item) { return extend(memo, item); };
    /**
     * Finds the common ancestor path between two states.
     *
     * @param {Object} first The first state.
     * @param {Object} second The second state.
     * @return {Array} Returns an array of state names in descending order, not including the root.
     */
    function ancestors(first, second) {
        var path = [];
        // tslint:disable-next-line:forin
        for (var n in first.path) {
            if (first.path[n] !== second.path[n])
                break;
            path.push(first.path[n]);
        }
        return path;
    }
    /**
     * Return a copy of the object only containing the whitelisted properties.
     *
     * #### Example:
     * ```
     * var foo = { a: 1, b: 2, c: 3 };
     * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
     * ```
     * @param obj the source object
     * @param propNames an Array of strings, which are the whitelisted property names
     */
    function pick(obj, propNames) {
        var objCopy = {};
        for (var _prop in obj) {
            if (propNames.indexOf(_prop) !== -1) {
                objCopy[_prop] = obj[_prop];
            }
        }
        return objCopy;
    }
    /**
     * Return a copy of the object omitting the blacklisted properties.
     *
     * @example
     * ```
     *
     * var foo = { a: 1, b: 2, c: 3 };
     * var ab = omit(foo, ['a', 'b']); // { c: 3 }
     * ```
     * @param obj the source object
     * @param propNames an Array of strings, which are the blacklisted property names
     */
    function omit(obj, propNames) {
        return Object.keys(obj)
            .filter(not(inArray(propNames)))
            .reduce(function (acc, key) { return ((acc[key] = obj[key]), acc); }, {});
    }
    /**
     * Maps an array, or object to a property (by name)
     */
    function pluck(collection, propName) {
        return map(collection, prop(propName));
    }
    /** Filters an Array or an Object's properties based on a predicate */
    function filter(collection, callback) {
        var arr = isArray(collection), result = arr ? [] : {};
        var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return (result[key] = x); };
        forEach(collection, function (item, i) {
            if (callback(item, i))
                accept(item, i);
        });
        return result;
    }
    /** Finds an object from an array, or a property of an object, that matches a predicate */
    function find(collection, callback) {
        var result;
        forEach(collection, function (item, i) {
            if (result)
                return;
            if (callback(item, i))
                result = item;
        });
        return result;
    }
    /** Given an object, returns a new object, where each property is transformed by the callback function */
    var mapObj = map;
    /** Maps an array or object properties using a callback function */
    function map(collection, callback, target) {
        target = target || (isArray(collection) ? [] : {});
        forEach(collection, function (item, i) { return (target[i] = callback(item, i)); });
        return target;
    }
    /**
     * Given an object, return its enumerable property values
     *
     * @example
     * ```
     *
     * let foo = { a: 1, b: 2, c: 3 }
     * let vals = values(foo); // [ 1, 2, 3 ]
     * ```
     */
    var values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };
    /**
     * Reduce function that returns true if all of the values are truthy.
     *
     * @example
     * ```
     *
     * let vals = [ 1, true, {}, "hello world"];
     * vals.reduce(allTrueR, true); // true
     *
     * vals.push(0);
     * vals.reduce(allTrueR, true); // false
     * ```
     */
    var allTrueR = function (memo, elem) { return memo && elem; };
    /**
     * Reduce function that returns true if any of the values are truthy.
     *
     *  * @example
     * ```
     *
     * let vals = [ 0, null, undefined ];
     * vals.reduce(anyTrueR, true); // false
     *
     * vals.push("hello world");
     * vals.reduce(anyTrueR, true); // true
     * ```
     */
    var anyTrueR = function (memo, elem) { return memo || elem; };
    /**
     * Reduce function which un-nests a single level of arrays
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
     * ```
     */
    var unnestR = function (memo, elem) { return memo.concat(elem); };
    /**
     * Reduce function which recursively un-nests all arrays
     *
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
     * ```
     */
    var flattenR = function (memo, elem) {
        return isArray(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem);
    };
    /**
     * Reduce function that pushes an object to an array, then returns the array.
     * Mostly just for [[flattenR]] and [[uniqR]]
     */
    function pushR(arr, obj) {
        arr.push(obj);
        return arr;
    }
    /** Reduce function that filters out duplicates */
    var uniqR = function (acc, token) { return (inArray(acc, token) ? acc : pushR(acc, token)); };
    /**
     * Return a new array with a single level of arrays unnested.
     *
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
     * ```
     */
    var unnest = function (arr) { return arr.reduce(unnestR, []); };
    /**
     * Return a completely flattened version of an array.
     *
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]
     * ```
     */
    var flatten = function (arr) { return arr.reduce(flattenR, []); };
    /**
     * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
     * @example
     * ```
     *
     * let isNumber = (obj) => typeof(obj) === 'number';
     * let allNumbers = [ 1, 2, 3, 4, 5 ];
     * allNumbers.filter(assertPredicate(isNumber)); //OK
     *
     * let oneString = [ 1, 2, 3, 4, "5" ];
     * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
     * ```
     */
    var assertPredicate = assertFn;
    /**
     * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.
     * @example
     * ```
     *
     * var data = { foo: 1, bar: 2 };
     *
     * let keys = [ 'foo', 'bar' ]
     * let values = keys.map(assertMap(key => data[key], "Key not found"));
     * // values is [1, 2]
     *
     * let keys = [ 'foo', 'bar', 'baz' ]
     * let values = keys.map(assertMap(key => data[key], "Key not found"));
     * // throws Error("Key not found")
     * ```
     */
    var assertMap = assertFn;
    function assertFn(predicateOrMap, errMsg) {
        if (errMsg === void 0) { errMsg = 'assert failure'; }
        return function (obj) {
            var result = predicateOrMap(obj);
            if (!result) {
                throw new Error(isFunction(errMsg) ? errMsg(obj) : errMsg);
            }
            return result;
        };
    }
    /**
     * Like _.pairs: Given an object, returns an array of key/value pairs
     *
     * @example
     * ```
     *
     * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]
     * ```
     */
    var pairs = function (obj) { return Object.keys(obj).map(function (key) { return [key, obj[key]]; }); };
    /**
     * Given two or more parallel arrays, returns an array of tuples where
     * each tuple is composed of [ a[i], b[i], ... z[i] ]
     *
     * @example
     * ```
     *
     * let foo = [ 0, 2, 4, 6 ];
     * let bar = [ 1, 3, 5, 7 ];
     * let baz = [ 10, 30, 50, 70 ];
     * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
     * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
     * ```
     */
    function arrayTuples() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0)
            return [];
        var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 âˆ’ 1 aka Number.MAX_SAFE_INTEGER
        var result = [];
        var _loop_1 = function (i) {
            // This is a hot function
            // Unroll when there are 1-4 arguments
            switch (args.length) {
                case 1:
                    result.push([args[0][i]]);
                    break;
                case 2:
                    result.push([args[0][i], args[1][i]]);
                    break;
                case 3:
                    result.push([args[0][i], args[1][i], args[2][i]]);
                    break;
                case 4:
                    result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                    break;
                default:
                    result.push(args.map(function (array) { return array[i]; }));
                    break;
            }
        };
        for (var i = 0; i < maxArrayLen; i++) {
            _loop_1(i);
        }
        return result;
    }
    /**
     * Reduce function which builds an object from an array of [key, value] pairs.
     *
     * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
     *
     * Each keyValueTuple should be an array with values [ key: string, value: any ]
     *
     * @example
     * ```
     *
     * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
     *
     * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
     * // pairsToObj == { fookey: "fooval", barkey: "barval" }
     *
     * // Or, more simply:
     * var pairsToObj = pairs.reduce(applyPairs, {})
     * // pairsToObj == { fookey: "fooval", barkey: "barval" }
     * ```
     */
    function applyPairs(memo, keyValTuple) {
        var key, value;
        if (isArray(keyValTuple))
            key = keyValTuple[0], value = keyValTuple[1];
        if (!isString(key))
            throw new Error('invalid parameters to applyPairs');
        memo[key] = value;
        return memo;
    }
    /** Get the last element of an array */
    function tail(arr) {
        return (arr.length && arr[arr.length - 1]) || undefined;
    }
    /**
     * shallow copy from src to dest
     */
    function copy(src, dest) {
        if (dest)
            Object.keys(dest).forEach(function (key) { return delete dest[key]; });
        if (!dest)
            dest = {};
        return extend(dest, src);
    }
    /** Naive forEach implementation works with Objects or Arrays */
    function _forEach(obj, cb, _this) {
        if (isArray(obj))
            return obj.forEach(cb, _this);
        Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });
    }
    function _extend(toObj) {
        for (var i = 1; i < arguments.length; i++) {
            var obj = arguments[i];
            if (!obj)
                continue;
            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; j++) {
                toObj[keys[j]] = obj[keys[j]];
            }
        }
        return toObj;
    }
    function _equals(o1, o2) {
        if (o1 === o2)
            return true;
        if (o1 === null || o2 === null)
            return false;
        if (o1 !== o1 && o2 !== o2)
            return true; // NaN === NaN
        var t1 = typeof o1, t2 = typeof o2;
        if (t1 !== t2 || t1 !== 'object')
            return false;
        var tup = [o1, o2];
        if (all(isArray)(tup))
            return _arraysEq(o1, o2);
        if (all(isDate)(tup))
            return o1.getTime() === o2.getTime();
        if (all(isRegExp)(tup))
            return o1.toString() === o2.toString();
        if (all(isFunction)(tup))
            return true; // meh
        var predicates = [isFunction, isArray, isDate, isRegExp];
        if (predicates.map(any).reduce(function (b, fn) { return b || !!fn(tup); }, false))
            return false;
        var keys = {};
        // tslint:disable-next-line:forin
        for (var key in o1) {
            if (!_equals(o1[key], o2[key]))
                return false;
            keys[key] = true;
        }
        for (var key in o2) {
            if (!keys[key])
                return false;
        }
        return true;
    }
    function _arraysEq(a1, a2) {
        if (a1.length !== a2.length)
            return false;
        return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);
    }
    // issue #2676
    var silenceUncaughtInPromise = function (promise) { return promise.catch(function (e) { return 0; }) && promise; };
    var silentRejection = function (error) { return silenceUncaughtInPromise(services.$q.reject(error)); };

    /** @publicapi @module core */
    /**
     * Matches state names using glob-like pattern strings.
     *
     * Globs can be used in specific APIs including:
     *
     * - [[StateService.is]]
     * - [[StateService.includes]]
     * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
     *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
     *
     * A `Glob` string is a pattern which matches state names.
     * Nested state names are split into segments (separated by a dot) when processing.
     * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
     *
     * Globs work according to the following rules:
     *
     * ### Exact match:
     *
     * The glob `'A.B'` matches the state named exactly `'A.B'`.
     *
     * | Glob        |Matches states named|Does not match state named|
     * |:------------|:--------------------|:---------------------|
     * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
     * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
     * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
     *
     * ### Single star (`*`)
     *
     * A single star (`*`) is a wildcard that matches exactly one segment.
     *
     * | Glob        |Matches states named  |Does not match state named |
     * |:------------|:---------------------|:--------------------------|
     * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
     * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
     * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
     *
     * ### Double star (`**`)
     *
     * A double star (`'**'`) is a wildcard that matches *zero or more segments*
     *
     * | Glob        |Matches states named                           |Does not match state named         |
     * |:------------|:----------------------------------------------|:----------------------------------|
     * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
     * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
     * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
     * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
     *
     */
    var Glob = /** @class */ (function () {
        function Glob(text) {
            this.text = text;
            this.glob = text.split('.');
            var regexpString = this.text
                .split('.')
                .map(function (seg) {
                if (seg === '**')
                    return '(?:|(?:\\.[^.]*)*)';
                if (seg === '*')
                    return '\\.[^.]*';
                return '\\.' + seg;
            })
                .join('');
            this.regexp = new RegExp('^' + regexpString + '$');
        }
        /** Returns true if the string has glob-like characters in it */
        Glob.is = function (text) {
            return !!/[!,*]+/.exec(text);
        };
        /** Returns a glob from the string, or null if the string isn't Glob-like */
        Glob.fromString = function (text) {
            return Glob.is(text) ? new Glob(text) : null;
        };
        Glob.prototype.matches = function (name) {
            return this.regexp.test('.' + name);
        };
        return Glob;
    }());

    /** @publicapi @module common */ /** */
    var Queue = /** @class */ (function () {
        function Queue(_items, _limit) {
            if (_items === void 0) { _items = []; }
            if (_limit === void 0) { _limit = null; }
            this._items = _items;
            this._limit = _limit;
            this._evictListeners = [];
            this.onEvict = pushTo(this._evictListeners);
        }
        Queue.prototype.enqueue = function (item) {
            var items = this._items;
            items.push(item);
            if (this._limit && items.length > this._limit)
                this.evict();
            return item;
        };
        Queue.prototype.evict = function () {
            var item = this._items.shift();
            this._evictListeners.forEach(function (fn) { return fn(item); });
            return item;
        };
        Queue.prototype.dequeue = function () {
            if (this.size())
                return this._items.splice(0, 1)[0];
        };
        Queue.prototype.clear = function () {
            var current = this._items;
            this._items = [];
            return current;
        };
        Queue.prototype.size = function () {
            return this._items.length;
        };
        Queue.prototype.remove = function (item) {
            var idx = this._items.indexOf(item);
            return idx > -1 && this._items.splice(idx, 1)[0];
        };
        Queue.prototype.peekTail = function () {
            return this._items[this._items.length - 1];
        };
        Queue.prototype.peekHead = function () {
            if (this.size())
                return this._items[0];
        };
        return Queue;
    }());

    /** @publicapi @module transition */ /** */

    (function (RejectType) {
        /**
         * A new transition superseded this one.
         *
         * While this transition was running, a new transition started.
         * This transition is cancelled because it was superseded by new transition.
         */
        RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
        /**
         * The transition was aborted
         *
         * The transition was aborted by a hook which returned `false`
         */
        RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
        /**
         * The transition was invalid
         *
         * The transition was never started because it was invalid
         */
        RejectType[RejectType["INVALID"] = 4] = "INVALID";
        /**
         * The transition was ignored
         *
         * The transition was ignored because it would have no effect.
         *
         * Either:
         *
         * - The transition is targeting the current state and parameter values
         * - The transition is targeting the same state and parameter values as the currently running transition.
         */
        RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
        /**
         * The transition errored.
         *
         * This generally means a hook threw an error or returned a rejected promise
         */
        RejectType[RejectType["ERROR"] = 6] = "ERROR";
    })(exports.RejectType || (exports.RejectType = {}));
    /** @hidden */
    var id = 0;
    var Rejection = /** @class */ (function () {
        function Rejection(type, message, detail) {
            /** @hidden */
            this.$id = id++;
            this.type = type;
            this.message = message;
            this.detail = detail;
        }
        /** Returns true if the obj is a rejected promise created from the `asPromise` factory */
        Rejection.isRejectionPromise = function (obj) {
            return obj && typeof obj.then === 'function' && is(Rejection)(obj._transitionRejection);
        };
        /** Returns a Rejection due to transition superseded */
        Rejection.superseded = function (detail, options) {
            var message = 'The transition has been superseded by a different transition';
            var rejection = new Rejection(exports.RejectType.SUPERSEDED, message, detail);
            if (options && options.redirected) {
                rejection.redirected = true;
            }
            return rejection;
        };
        /** Returns a Rejection due to redirected transition */
        Rejection.redirected = function (detail) {
            return Rejection.superseded(detail, { redirected: true });
        };
        /** Returns a Rejection due to invalid transition */
        Rejection.invalid = function (detail) {
            var message = 'This transition is invalid';
            return new Rejection(exports.RejectType.INVALID, message, detail);
        };
        /** Returns a Rejection due to ignored transition */
        Rejection.ignored = function (detail) {
            var message = 'The transition was ignored';
            return new Rejection(exports.RejectType.IGNORED, message, detail);
        };
        /** Returns a Rejection due to aborted transition */
        Rejection.aborted = function (detail) {
            var message = 'The transition has been aborted';
            return new Rejection(exports.RejectType.ABORTED, message, detail);
        };
        /** Returns a Rejection due to aborted transition */
        Rejection.errored = function (detail) {
            var message = 'The transition errored';
            return new Rejection(exports.RejectType.ERROR, message, detail);
        };
        /**
         * Returns a Rejection
         *
         * Normalizes a value as a Rejection.
         * If the value is already a Rejection, returns it.
         * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
         *
         * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
         */
        Rejection.normalize = function (detail) {
            return is(Rejection)(detail) ? detail : Rejection.errored(detail);
        };
        Rejection.prototype.toString = function () {
            var detailString = function (d) { return (d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d)); };
            var detail = detailString(this.detail);
            var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
            return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
        };
        Rejection.prototype.toPromise = function () {
            return extend(silentRejection(this), { _transitionRejection: this });
        };
        return Rejection;
    }());

    /**
     * Functions that manipulate strings
     *
     * Although these functions are exported, they are subject to change without notice.
     *
     * @module common_strings
     */ /** */
    /**
     * Returns a string shortened to a maximum length
     *
     * If the string is already less than the `max` length, return the string.
     * Else return the string, shortened to `max - 3` and append three dots ("...").
     *
     * @param max the maximum length of the string to return
     * @param str the input string
     */
    function maxLength(max, str) {
        if (str.length <= max)
            return str;
        return str.substr(0, max - 3) + '...';
    }
    /**
     * Returns a string, with spaces added to the end, up to a desired str length
     *
     * If the string is already longer than the desired length, return the string.
     * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
     *
     * @param length the desired length of the string to return
     * @param str the input string
     */
    function padString(length, str) {
        while (str.length < length)
            str += ' ';
        return str;
    }
    function kebobString(camelCase) {
        return camelCase
            .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char
            .replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); }); // replace rest
    }
    function functionToString(fn) {
        var fnStr = fnToString(fn);
        var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
        var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
        var fnName = fn['name'] || '';
        if (fnName && toStr.match(/function \(/)) {
            return 'function ' + fnName + toStr.substr(9);
        }
        return toStr;
    }
    function fnToString(fn) {
        var _fn = isArray(fn) ? fn.slice(-1)[0] : fn;
        return (_fn && _fn.toString()) || 'undefined';
    }
    var isRejection = Rejection.isRejectionPromise;
    var hasToString = function (obj) {
        return isObject(obj) && !isArray(obj) && obj.constructor !== Object && isFunction(obj.toString);
    };
    var stringifyPattern = pattern([
        [isUndefined, val('undefined')],
        [isNull, val('null')],
        [isPromise, val('[Promise]')],
        [isRejection, function (x) { return x._transitionRejection.toString(); }],
        [hasToString, function (x) { return x.toString(); }],
        [isInjectable, functionToString],
        [val(true), identity],
    ]);
    function stringify(o) {
        var seen = [];
        function format(value) {
            if (isObject(value)) {
                if (seen.indexOf(value) !== -1)
                    return '[circular ref]';
                seen.push(value);
            }
            return stringifyPattern(value);
        }
        if (isUndefined(o)) {
            // Workaround for IE & Edge Spec incompatibility where replacer function would not be called when JSON.stringify
            // is given `undefined` as value. To work around that, we simply detect `undefined` and bail out early by
            // manually stringifying it.
            return format(o);
        }
        return JSON.stringify(o, function (key, value) { return format(value); }).replace(/\\"/g, '"');
    }
    /** Returns a function that splits a string on a character or substring */
    var beforeAfterSubstr = function (char) { return function (str) {
        if (!str)
            return ['', ''];
        var idx = str.indexOf(char);
        if (idx === -1)
            return [str, ''];
        return [str.substr(0, idx), str.substr(idx + 1)];
    }; };
    var hostRegex = new RegExp('^(?:[a-z]+:)?//[^/]+/');
    var stripLastPathElement = function (str) { return str.replace(/\/[^/]*$/, ''); };
    var splitHash = beforeAfterSubstr('#');
    var splitQuery = beforeAfterSubstr('?');
    var splitEqual = beforeAfterSubstr('=');
    var trimHashVal = function (str) { return (str ? str.replace(/^#/, '') : ''); };
    /**
     * Splits on a delimiter, but returns the delimiters in the array
     *
     * #### Example:
     * ```js
     * var splitOnSlashes = splitOnDelim('/');
     * splitOnSlashes("/foo"); // ["/", "foo"]
     * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
     * ```
     */
    function splitOnDelim(delim) {
        var re = new RegExp('(' + delim + ')', 'g');
        return function (str) { return str.split(re).filter(identity); };
    }
    /**
     * Reduce fn that joins neighboring strings
     *
     * Given an array of strings, returns a new array
     * where all neighboring strings have been joined.
     *
     * #### Example:
     * ```js
     * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
     * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
     * ```
     */
    function joinNeighborsR(acc, x) {
        if (isString(tail(acc)) && isString(x))
            return acc.slice(0, -1).concat(tail(acc) + x);
        return pushR(acc, x);
    }

    /** workaround for missing console object in IE9 when dev tools haven't been opened o_O */
    var noopConsoleStub = { log: noop, error: noop, table: noop };
    function ie9Console(console) {
        var bound = function (fn) { return Function.prototype.bind.call(fn, console); };
        return {
            log: bound(console.log),
            error: bound(console.log),
            table: bound(console.log),
        };
    }
    function fallbackConsole(console) {
        var log = console.log.bind(console);
        var error = console.error ? console.error.bind(console) : log;
        var table = console.table ? console.table.bind(console) : log;
        return { log: log, error: error, table: table };
    }
    function getSafeConsole() {
        // @ts-ignore
        var isIE9 = typeof document !== 'undefined' && document.documentMode && document.documentMode === 9;
        if (isIE9) {
            return window && window.console ? ie9Console(window.console) : noopConsoleStub;
        }
        else if (!console.table || !console.error) {
            return fallbackConsole(console);
        }
        else {
            return console;
        }
    }
    var safeConsole = getSafeConsole();

    /**
     * # Transition tracing (debug)
     *
     * Enable transition tracing to print transition information to the console,
     * in order to help debug your application.
     * Tracing logs detailed information about each Transition to your console.
     *
     * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
     *
     * ### ES6
     * ```js
     * import {trace} from "@uirouter/core";
     * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
     * ```
     *
     * ### CJS
     * ```js
     * let trace = require("@uirouter/core").trace;
     * trace.enable("TRANSITION", "VIEWCONFIG");
     * ```
     *
     * ### Globals
     * ```js
     * let trace = window["@uirouter/core"].trace;
     * trace.enable(); // Trace everything (very verbose)
     * ```
     *
     * ### Angular 1:
     * ```js
     * app.run($trace => $trace.enable());
     * ```
     *
     * @publicapi @module trace
     */
    /** @hidden */
    function uiViewString(uiview) {
        if (!uiview)
            return 'ui-view (defunct)';
        var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';
        return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";
    }
    /** @hidden */
    var viewConfigString = function (viewConfig) {
        var view = viewConfig.viewDecl;
        var state = view.$context.name || '(root)';
        return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'";
    };
    /** @hidden */
    function normalizedCat(input) {
        return isNumber(input) ? exports.Category[input] : exports.Category[exports.Category[input]];
    }
    /**
     * Trace categories Enum
     *
     * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
     *
     * `trace.enable(Category.TRANSITION)`
     *
     * These can also be provided using a matching string, or position ordinal
     *
     * `trace.enable("TRANSITION")`
     *
     * `trace.enable(1)`
     */

    (function (Category) {
        Category[Category["RESOLVE"] = 0] = "RESOLVE";
        Category[Category["TRANSITION"] = 1] = "TRANSITION";
        Category[Category["HOOK"] = 2] = "HOOK";
        Category[Category["UIVIEW"] = 3] = "UIVIEW";
        Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
    })(exports.Category || (exports.Category = {}));
    /** @hidden */
    var _tid = parse('$id');
    /** @hidden */
    var _rid = parse('router.$id');
    /** @hidden */
    var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };
    /**
     * Prints UI-Router Transition trace information to the console.
     */
    var Trace = /** @class */ (function () {
        /** @hidden */
        function Trace() {
            /** @hidden */
            this._enabled = {};
            this.approximateDigests = 0;
        }
        /** @hidden */
        Trace.prototype._set = function (enabled, categories) {
            var _this = this;
            if (!categories.length) {
                categories = Object.keys(exports.Category)
                    .map(function (k) { return parseInt(k, 10); })
                    .filter(function (k) { return !isNaN(k); })
                    .map(function (key) { return exports.Category[key]; });
            }
            categories.map(normalizedCat).forEach(function (category) { return (_this._enabled[category] = enabled); });
        };
        Trace.prototype.enable = function () {
            var categories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i] = arguments[_i];
            }
            this._set(true, categories);
        };
        Trace.prototype.disable = function () {
            var categories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i] = arguments[_i];
            }
            this._set(false, categories);
        };
        /**
         * Retrieves the enabled stateus of a [[Category]]
         *
         * ```js
         * trace.enabled("VIEWCONFIG"); // true or false
         * ```
         *
         * @returns boolean true if the category is enabled
         */
        Trace.prototype.enabled = function (category) {
            return !!this._enabled[normalizedCat(category)];
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceTransitionStart = function (trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": Started  -> " + stringify(trans));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceTransitionIgnored = function (trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": Ignored  <> " + stringify(trans));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceHookInvocation = function (step, trans, options) {
            if (!this.enabled(exports.Category.HOOK))
                return;
            var event = parse('traceData.hookType')(options) || 'internal', context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown', name = functionToString(step.registeredHook.callback);
            safeConsole.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + maxLength(200, name));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {
            if (!this.enabled(exports.Category.HOOK))
                return;
            safeConsole.log(transLbl(trans) + ":   <- Hook returned: " + maxLength(200, stringify(hookResult)));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceResolvePath = function (path, when, trans) {
            if (!this.enabled(exports.Category.RESOLVE))
                return;
            safeConsole.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceResolvableResolved = function (resolvable, trans) {
            if (!this.enabled(exports.Category.RESOLVE))
                return;
            safeConsole.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + maxLength(200, stringify(resolvable.data)));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceError = function (reason, trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": <- Rejected " + stringify(trans) + ", reason: " + reason);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceSuccess = function (finalState, trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": <- Success  " + stringify(trans) + ", final state: " + finalState.name);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {
            if (extra === void 0) { extra = ''; }
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            safeConsole.log("ui-view: " + padString(30, event) + " " + uiViewString(viewData) + extra);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            this.traceUIViewEvent('Updating', viewData, " with ViewConfig from context='" + context + "'");
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceUIViewFill = function (viewData, html) {
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            this.traceUIViewEvent('Fill', viewData, " with: " + maxLength(200, html));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceViewSync = function (pairs) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            var uivheader = 'uiview component fqn';
            var cfgheader = 'view config state (view name)';
            var mapping = pairs
                .map(function (_a) {
                var _b;
                var uiView = _a.uiView, viewConfig = _a.viewConfig;
                var uiv = uiView && uiView.fqn;
                var cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";
                return _b = {}, _b[uivheader] = uiv, _b[cfgheader] = cfg, _b;
            })
                .sort(function (a, b) { return (a[uivheader] || '').localeCompare(b[uivheader] || ''); });
            safeConsole.table(mapping);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            safeConsole.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            safeConsole.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
        };
        return Trace;
    }());
    /**
     * The [[Trace]] singleton
     *
     * #### Example:
     * ```js
     * import {trace} from "@uirouter/core";
     * trace.enable(1, 5);
     * ```
     */
    var trace = new Trace();

    /** @publicapi @module params */ /** */
    /**
     * An internal class which implements [[ParamTypeDefinition]].
     *
     * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
     * When a param type definition is registered, an instance of this class is created internally.
     *
     * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
     *
     * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
     *
     * #### Example:
     * ```js
     * var paramTypeDef = {
     *   decode: function(val) { return parseInt(val, 10); },
     *   encode: function(val) { return val && val.toString(); },
     *   equals: function(a, b) { return this.is(a) && a === b; },
     *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
     *   pattern: /\d+/
     * }
     *
     * var paramType = new ParamType(paramTypeDef);
     * ```
     * @internalapi
     */
    var ParamType = /** @class */ (function () {
        /**
         * @param def  A configuration object which contains the custom type definition.  The object's
         *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
         * @returns a new ParamType object
         */
        function ParamType(def) {
            /** @inheritdoc */
            this.pattern = /.*/;
            /** @inheritdoc */
            this.inherit = true;
            extend(this, def);
        }
        // consider these four methods to be "abstract methods" that should be overridden
        /** @inheritdoc */
        ParamType.prototype.is = function (val, key) {
            return true;
        };
        /** @inheritdoc */
        ParamType.prototype.encode = function (val, key) {
            return val;
        };
        /** @inheritdoc */
        ParamType.prototype.decode = function (val, key) {
            return val;
        };
        /** @inheritdoc */
        ParamType.prototype.equals = function (a, b) {
            // tslint:disable-next-line:triple-equals
            return a == b;
        };
        ParamType.prototype.$subPattern = function () {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2);
        };
        ParamType.prototype.toString = function () {
            return "{ParamType:" + this.name + "}";
        };
        /** Given an encoded string, or a decoded object, returns a decoded object */
        ParamType.prototype.$normalize = function (val) {
            return this.is(val) ? val : this.decode(val);
        };
        /**
         * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
         * e.g.:
         * - urlmatcher pattern "/path?{queryParam[]:int}"
         * - url: "/path?queryParam=1&queryParam=2
         * - $stateParams.queryParam will be [1, 2]
         * if `mode` is "auto", then
         * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
         * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
         */
        ParamType.prototype.$asArray = function (mode, isSearch) {
            if (!mode)
                return this;
            if (mode === 'auto' && !isSearch)
                throw new Error("'auto' array mode is for query parameters only");
            return new ArrayType(this, mode);
        };
        return ParamType;
    }());
    /**
     * Wraps up a `ParamType` object to handle array values.
     * @internalapi
     */
    function ArrayType(type, mode) {
        var _this = this;
        // Wrap non-array value as array
        function arrayWrap(val) {
            return isArray(val) ? val : isDefined(val) ? [val] : [];
        }
        // Unwrap array value for "auto" mode. Return undefined for empty array.
        function arrayUnwrap(val) {
            switch (val.length) {
                case 0:
                    return undefined;
                case 1:
                    return mode === 'auto' ? val[0] : val;
                default:
                    return val;
            }
        }
        // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
        function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
                if (isArray(val) && val.length === 0)
                    return val;
                var arr = arrayWrap(val);
                var result = map(arr, callback);
                return allTruthyMode === true ? filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);
            };
        }
        // Wraps type (.equals) functions to operate on each value of an array
        function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
                var left = arrayWrap(val1), right = arrayWrap(val2);
                if (left.length !== right.length)
                    return false;
                for (var i = 0; i < left.length; i++) {
                    if (!callback(left[i], right[i]))
                        return false;
                }
                return true;
            };
        }
        ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {
            var paramTypeFn = type[name].bind(type);
            var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;
            _this[name] = wrapperFn(paramTypeFn);
        });
        extend(this, {
            dynamic: type.dynamic,
            name: type.name,
            pattern: type.pattern,
            inherit: type.inherit,
            raw: type.raw,
            is: arrayHandler(type.is.bind(type), true),
            $arrayMode: mode,
        });
    }

    /** @publicapi @module params */ /** */
    /** @hidden */
    var hasOwn = Object.prototype.hasOwnProperty;
    /** @hidden */
    var isShorthand = function (cfg) {
        return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;
    };
    /** @internalapi */

    (function (DefType) {
        DefType[DefType["PATH"] = 0] = "PATH";
        DefType[DefType["SEARCH"] = 1] = "SEARCH";
        DefType[DefType["CONFIG"] = 2] = "CONFIG";
    })(exports.DefType || (exports.DefType = {}));
    /** @internalapi */
    function getParamDeclaration(paramName, location, state) {
        var noReloadOnSearch = (state.reloadOnSearch === false && location === exports.DefType.SEARCH) || undefined;
        var dynamic = find([state.dynamic, noReloadOnSearch], isDefined);
        var defaultConfig = isDefined(dynamic) ? { dynamic: dynamic } : {};
        var paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);
        return extend(defaultConfig, paramConfig);
    }
    /** @hidden */
    function unwrapShorthand(cfg) {
        cfg = isShorthand(cfg) ? { value: cfg } : cfg;
        getStaticDefaultValue['__cacheable'] = true;
        function getStaticDefaultValue() {
            return cfg.value;
        }
        var $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;
        return extend(cfg, { $$fn: $$fn });
    }
    /** @hidden */
    function getType(cfg, urlType, location, id, paramTypes) {
        if (cfg.type && urlType && urlType.name !== 'string')
            throw new Error("Param '" + id + "' has two type configurations.");
        if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))
            return paramTypes.type(cfg.type);
        if (urlType)
            return urlType;
        if (!cfg.type) {
            var type = location === exports.DefType.CONFIG
                ? 'any'
                : location === exports.DefType.PATH
                    ? 'path'
                    : location === exports.DefType.SEARCH
                        ? 'query'
                        : 'string';
            return paramTypes.type(type);
        }
        return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
    }
    /**
     * @internalapi
     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
     */
    function getSquashPolicy(config, isOptional, defaultPolicy) {
        var squash = config.squash;
        if (!isOptional || squash === false)
            return false;
        if (!isDefined(squash) || squash == null)
            return defaultPolicy;
        if (squash === true || isString(squash))
            return squash;
        throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }
    /** @internalapi */
    function getReplace(config, arrayMode, isOptional, squash) {
        var defaultPolicy = [
            { from: '', to: isOptional || arrayMode ? undefined : '' },
            { from: null, to: isOptional || arrayMode ? undefined : '' },
        ];
        var replace = isArray(config.replace) ? config.replace : [];
        if (isString(squash))
            replace.push({ from: squash, to: undefined });
        var configuredKeys = map(replace, prop('from'));
        return filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);
    }
    /** @internalapi */
    var Param = /** @class */ (function () {
        function Param(id, type, location, urlConfig, state) {
            var config = getParamDeclaration(id, location, state);
            type = getType(config, type, location, id, urlConfig.paramTypes);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === exports.DefType.SEARCH) : type;
            var isOptional = config.value !== undefined || location === exports.DefType.SEARCH;
            var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
            var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;
            var squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());
            var replace = getReplace(config, arrayMode, isOptional, squash);
            var inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
            // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
            function getArrayMode() {
                var arrayDefaults = { array: location === exports.DefType.SEARCH ? 'auto' : false };
                var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });
        }
        Param.values = function (params, values) {
            if (values === void 0) { values = {}; }
            var paramValues = {};
            for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                var param = params_1[_i];
                paramValues[param.id] = param.value(values[param.id]);
            }
            return paramValues;
        };
        /**
         * Finds [[Param]] objects which have different param values
         *
         * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
         *
         * @param params: The list of Param objects to filter
         * @param values1: The first set of parameter values
         * @param values2: the second set of parameter values
         *
         * @returns any Param objects whose values were different between values1 and values2
         */
        Param.changed = function (params, values1, values2) {
            if (values1 === void 0) { values1 = {}; }
            if (values2 === void 0) { values2 = {}; }
            return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });
        };
        /**
         * Checks if two param value objects are equal (for a set of [[Param]] objects)
         *
         * @param params The list of [[Param]] objects to check
         * @param values1 The first set of param values
         * @param values2 The second set of param values
         *
         * @returns true if the param values in values1 and values2 are equal
         */
        Param.equals = function (params, values1, values2) {
            if (values1 === void 0) { values1 = {}; }
            if (values2 === void 0) { values2 = {}; }
            return Param.changed(params, values1, values2).length === 0;
        };
        /** Returns true if a the parameter values are valid, according to the Param definitions */
        Param.validates = function (params, values) {
            if (values === void 0) { values = {}; }
            return params.map(function (param) { return param.validates(values[param.id]); }).reduce(allTrueR, true);
        };
        Param.prototype.isDefaultValue = function (value) {
            return this.isOptional && this.type.equals(this.value(), value);
        };
        /**
         * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
         * default value, which may be the result of an injectable function.
         */
        Param.prototype.value = function (value) {
            var _this = this;
            /**
             * [Internal] Get the default value of a parameter, which may be an injectable function.
             */
            var getDefaultValue = function () {
                if (_this._defaultValueCache)
                    return _this._defaultValueCache.defaultValue;
                if (!services.$injector)
                    throw new Error('Injectable functions cannot be called at configuration time');
                var defaultValue = services.$injector.invoke(_this.config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                    throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
                if (_this.config.$$fn['__cacheable']) {
                    _this._defaultValueCache = { defaultValue: defaultValue };
                }
                return defaultValue;
            };
            var replaceSpecialValues = function (val) {
                for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                    var tuple = _a[_i];
                    if (tuple.from === val)
                        return tuple.to;
                }
                return val;
            };
            value = replaceSpecialValues(value);
            return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
        };
        Param.prototype.isSearch = function () {
            return this.location === exports.DefType.SEARCH;
        };
        Param.prototype.validates = function (value) {
            // There was no parameter value, but the param is optional
            if ((isUndefined(value) || value === null) && this.isOptional)
                return true;
            // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
            var normalized = this.type.$normalize(value);
            if (!this.type.is(normalized))
                return false;
            // The value was of the correct type, but when encoded, did not match the ParamType's regexp
            var encoded = this.type.encode(normalized);
            return !(isString(encoded) && !this.type.pattern.exec(encoded));
        };
        Param.prototype.toString = function () {
            return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
        };
        return Param;
    }());

    /** @publicapi @module params */ /** */
    /**
     * A registry for parameter types.
     *
     * This registry manages the built-in (and custom) parameter types.
     *
     * The built-in parameter types are:
     *
     * - [[string]]
     * - [[path]]
     * - [[query]]
     * - [[hash]]
     * - [[int]]
     * - [[bool]]
     * - [[date]]
     * - [[json]]
     * - [[any]]
     *
     * To register custom parameter types, use [[UrlConfig.type]], i.e.,
     *
     * ```js
     * router.urlService.config.type(customType)
     * ```
     */
    var ParamTypes = /** @class */ (function () {
        /** @internalapi */
        function ParamTypes() {
            /** @hidden */
            this.enqueue = true;
            /** @hidden */
            this.typeQueue = [];
            /** @internalapi */
            this.defaultTypes = pick(ParamTypes.prototype, [
                'hash',
                'string',
                'query',
                'path',
                'int',
                'bool',
                'date',
                'json',
                'any',
            ]);
            // Register default types. Store them in the prototype of this.types.
            var makeType = function (definition, name) { return new ParamType(extend({ name: name }, definition)); };
            this.types = inherit(map(this.defaultTypes, makeType), {});
        }
        /** @internalapi */
        ParamTypes.prototype.dispose = function () {
            this.types = {};
        };
        /**
         * Registers a parameter type
         *
         * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
         */
        ParamTypes.prototype.type = function (name, definition, definitionFn) {
            if (!isDefined(definition))
                return this.types[name];
            if (this.types.hasOwnProperty(name))
                throw new Error("A type named '" + name + "' has already been defined.");
            this.types[name] = new ParamType(extend({ name: name }, definition));
            if (definitionFn) {
                this.typeQueue.push({ name: name, def: definitionFn });
                if (!this.enqueue)
                    this._flushTypeQueue();
            }
            return this;
        };
        /** @internalapi */
        ParamTypes.prototype._flushTypeQueue = function () {
            while (this.typeQueue.length) {
                var type = this.typeQueue.shift();
                if (type.pattern)
                    throw new Error("You cannot override a type's .pattern at runtime.");
                extend(this.types[type.name], services.$injector.invoke(type.def));
            }
        };
        return ParamTypes;
    }());
    /** @hidden */
    function initDefaultTypes() {
        var makeDefaultType = function (def) {
            var valToString = function (val) { return (val != null ? val.toString() : val); };
            var defaultTypeBase = {
                encode: valToString,
                decode: valToString,
                is: is(String),
                pattern: /.*/,
                // tslint:disable-next-line:triple-equals
                equals: function (a, b) { return a == b; },
            };
            return extend({}, defaultTypeBase, def);
        };
        // Default Parameter Type Definitions
        extend(ParamTypes.prototype, {
            string: makeDefaultType({}),
            path: makeDefaultType({
                pattern: /[^/]*/,
            }),
            query: makeDefaultType({}),
            hash: makeDefaultType({
                inherit: false,
            }),
            int: makeDefaultType({
                decode: function (val) { return parseInt(val, 10); },
                is: function (val) {
                    return !isNullOrUndefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /-?\d+/,
            }),
            bool: makeDefaultType({
                encode: function (val) { return (val && 1) || 0; },
                decode: function (val) { return parseInt(val, 10) !== 0; },
                is: is(Boolean),
                pattern: /0|1/,
            }),
            date: makeDefaultType({
                encode: function (val) {
                    return !this.is(val)
                        ? undefined
                        : [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join('-');
                },
                decode: function (val) {
                    if (this.is(val))
                        return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },
                equals: function (l, r) {
                    return ['getFullYear', 'getMonth', 'getDate'].reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
            }),
            json: makeDefaultType({
                encode: toJson,
                decode: fromJson,
                is: is(Object),
                equals: equals,
                pattern: /[^/]*/,
            }),
            // does not encode/decode
            any: makeDefaultType({
                encode: identity,
                decode: identity,
                is: function () { return true; },
                equals: equals,
            }),
        });
    }
    initDefaultTypes();

    /** @publicapi @module params */ /** */
    /** @internalapi */
    var StateParams = /** @class */ (function () {
        function StateParams(params) {
            if (params === void 0) { params = {}; }
            extend(this, params);
        }
        /**
         * Merges a set of parameters with all parameters inherited between the common parents of the
         * current state and a given destination state.
         *
         * @param {Object} newParams The set of parameters which will be composited with inherited params.
         * @param {Object} $current Internal definition of object representing the current state.
         * @param {Object} $to Internal definition of object representing state to transition to.
         */
        StateParams.prototype.$inherit = function (newParams, $current, $to) {
            var parentParams;
            var parents = ancestors($current, $to), inherited = {}, inheritList = [];
            for (var i in parents) {
                if (!parents[i] || !parents[i].params)
                    continue;
                parentParams = Object.keys(parents[i].params);
                if (!parentParams.length)
                    continue;
                for (var j in parentParams) {
                    if (inheritList.indexOf(parentParams[j]) >= 0)
                        continue;
                    inheritList.push(parentParams[j]);
                    inherited[parentParams[j]] = this[parentParams[j]];
                }
            }
            return extend({}, inherited, newParams);
        };
        return StateParams;
    }());

    /** @internalapi @module path */ /** */
    /**
     * A node in a [[TreeChanges]] path
     *
     * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
     * Each PathNode corresponds to a state being entered, exited, or retained.
     * The stateful information includes parameter values and resolve data.
     */
    var PathNode = /** @class */ (function () {
        function PathNode(stateOrNode) {
            if (stateOrNode instanceof PathNode) {
                var node = stateOrNode;
                this.state = node.state;
                this.paramSchema = node.paramSchema.slice();
                this.paramValues = extend({}, node.paramValues);
                this.resolvables = node.resolvables.slice();
                this.views = node.views && node.views.slice();
            }
            else {
                var state = stateOrNode;
                this.state = state;
                this.paramSchema = state.parameters({ inherit: false });
                this.paramValues = {};
                this.resolvables = state.resolvables.map(function (res) { return res.clone(); });
            }
        }
        PathNode.prototype.clone = function () {
            return new PathNode(this);
        };
        /** Sets [[paramValues]] for the node, from the values of an object hash */
        PathNode.prototype.applyRawParams = function (params) {
            var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };
            this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return applyPairs(memo, getParamVal(pDef)); }, {});
            return this;
        };
        /** Gets a specific [[Param]] metadata that belongs to the node */
        PathNode.prototype.parameter = function (name) {
            return find(this.paramSchema, propEq('id', name));
        };
        /**
         * @returns true if the state and parameter values for another PathNode are
         * equal to the state and param values for this PathNode
         */
        PathNode.prototype.equals = function (node, paramsFn) {
            var diff = this.diff(node, paramsFn);
            return diff && diff.length === 0;
        };
        /**
         * Finds Params with different parameter values on another PathNode.
         *
         * Given another node (of the same state), finds the parameter values which differ.
         * Returns the [[Param]] (schema objects) whose parameter values differ.
         *
         * Given another node for a different state, returns `false`
         *
         * @param node The node to compare to
         * @param paramsFn A function that returns which parameters should be compared.
         * @returns The [[Param]]s which differ, or null if the two nodes are for different states
         */
        PathNode.prototype.diff = function (node, paramsFn) {
            if (this.state !== node.state)
                return false;
            var params = paramsFn ? paramsFn(this) : this.paramSchema;
            return Param.changed(params, this.paramValues, node.paramValues);
        };
        /**
         * Returns a clone of the PathNode
         * @deprecated use instance method `node.clone()`
         */
        PathNode.clone = function (node) { return node.clone(); };
        return PathNode;
    }());

    /** @publicapi @module state */ /** */
    /**
     * Encapsulate the target (destination) state/params/options of a [[Transition]].
     *
     * This class is frequently used to redirect a transition to a new destination.
     *
     * See:
     *
     * - [[HookResult]]
     * - [[TransitionHookFn]]
     * - [[TransitionService.onStart]]
     *
     * To create a `TargetState`, use [[StateService.target]].
     *
     * ---
     *
     * This class wraps:
     *
     * 1) an identifier for a state
     * 2) a set of parameters
     * 3) and transition options
     * 4) the registered state object (the [[StateDeclaration]])
     *
     * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
     * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
     * The `TargetState` class normalizes those options.
     *
     * A `TargetState` may be valid (the state being targeted exists in the registry)
     * or invalid (the state being targeted is not registered).
     */
    var TargetState = /** @class */ (function () {
        /**
         * The TargetState constructor
         *
         * Note: Do not construct a `TargetState` manually.
         * To create a `TargetState`, use the [[StateService.target]] factory method.
         *
         * @param _stateRegistry The StateRegistry to use to look up the _definition
         * @param _identifier An identifier for a state.
         *    Either a fully-qualified state name, or the object used to define the state.
         * @param _params Parameters for the target state
         * @param _options Transition options.
         *
         * @internalapi
         */
        function TargetState(_stateRegistry, _identifier, _params, _options) {
            this._stateRegistry = _stateRegistry;
            this._identifier = _identifier;
            this._identifier = _identifier;
            this._params = extend({}, _params || {});
            this._options = extend({}, _options || {});
            this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);
        }
        /** The name of the state this object targets */
        TargetState.prototype.name = function () {
            return (this._definition && this._definition.name) || this._identifier;
        };
        /** The identifier used when creating this TargetState */
        TargetState.prototype.identifier = function () {
            return this._identifier;
        };
        /** The target parameter values */
        TargetState.prototype.params = function () {
            return this._params;
        };
        /** The internal state object (if it was found) */
        TargetState.prototype.$state = function () {
            return this._definition;
        };
        /** The internal state declaration (if it was found) */
        TargetState.prototype.state = function () {
            return this._definition && this._definition.self;
        };
        /** The target options */
        TargetState.prototype.options = function () {
            return this._options;
        };
        /** True if the target state was found */
        TargetState.prototype.exists = function () {
            return !!(this._definition && this._definition.self);
        };
        /** True if the object is valid */
        TargetState.prototype.valid = function () {
            return !this.error();
        };
        /** If the object is invalid, returns the reason why */
        TargetState.prototype.error = function () {
            var base = this.options().relative;
            if (!this._definition && !!base) {
                var stateName = base.name ? base.name : base;
                return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
            }
            if (!this._definition)
                return "No such state '" + this.name() + "'";
            if (!this._definition.self)
                return "State '" + this.name() + "' has an invalid definition";
        };
        TargetState.prototype.toString = function () {
            return "'" + this.name() + "'" + stringify(this.params());
        };
        /**
         * Returns a copy of this TargetState which targets a different state.
         * The new TargetState has the same parameter values and transition options.
         *
         * @param state The new state that should be targeted
         */
        TargetState.prototype.withState = function (state) {
            return new TargetState(this._stateRegistry, state, this._params, this._options);
        };
        /**
         * Returns a copy of this TargetState, using the specified parameter values.
         *
         * @param params the new parameter values to use
         * @param replace When false (default) the new parameter values will be merged with the current values.
         *                When true the parameter values will be used instead of the current values.
         */
        TargetState.prototype.withParams = function (params, replace) {
            if (replace === void 0) { replace = false; }
            var newParams = replace ? params : extend({}, this._params, params);
            return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);
        };
        /**
         * Returns a copy of this TargetState, using the specified Transition Options.
         *
         * @param options the new options to use
         * @param replace When false (default) the new options will be merged with the current options.
         *                When true the options will be used instead of the current options.
         */
        TargetState.prototype.withOptions = function (options, replace) {
            if (replace === void 0) { replace = false; }
            var newOpts = replace ? options : extend({}, this._options, options);
            return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);
        };
        /** Returns true if the object has a state property that might be a state or state name */
        TargetState.isDef = function (obj) { return obj && obj.state && (isString(obj.state) || isString(obj.state.name)); };
        return TargetState;
    }());

    /** @internalapi @module path */ /** */
    /**
     * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
     */
    var PathUtils = /** @class */ (function () {
        function PathUtils() {
        }
        /** Given a PathNode[], create an TargetState */
        PathUtils.makeTargetState = function (registry, path) {
            var state = tail(path).state;
            return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});
        };
        PathUtils.buildPath = function (targetState) {
            var toParams = targetState.params();
            return targetState.$state().path.map(function (state) { return new PathNode(state).applyRawParams(toParams); });
        };
        /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
        PathUtils.buildToPath = function (fromPath, targetState) {
            var toPath = PathUtils.buildPath(targetState);
            if (targetState.options().inherit) {
                return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
            }
            return toPath;
        };
        /**
         * Creates ViewConfig objects and adds to nodes.
         *
         * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
         */
        PathUtils.applyViewConfigs = function ($view, path, states) {
            // Only apply the viewConfigs to the nodes for the given states
            path
                .filter(function (node) { return inArray(states, node.state); })
                .forEach(function (node) {
                var viewDecls = values(node.state.views || {});
                var subPath = PathUtils.subPath(path, function (n) { return n === node; });
                var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });
                node.views = viewConfigs.reduce(unnestR, []);
            });
        };
        /**
         * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
         *
         * For a parameter in a node to be inherited from the from path:
         * - The toPath's node must have a matching node in the fromPath (by state).
         * - The parameter name must not be found in the toKeys parameter array.
         *
         * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
         * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
         * it is not inherited from the fromPath.
         */
        PathUtils.inheritParams = function (fromPath, toPath, toKeys) {
            if (toKeys === void 0) { toKeys = []; }
            function nodeParamVals(path, state) {
                var node = find(path, propEq('state', state));
                return extend({}, node && node.paramValues);
            }
            var noInherit = fromPath
                .map(function (node) { return node.paramSchema; })
                .reduce(unnestR, [])
                .filter(function (param) { return !param.inherit; })
                .map(prop('id'));
            /**
             * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
             * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
             */
            function makeInheritedParamsNode(toNode) {
                // All param values for the node (may include default key/vals, when key was not found in toParams)
                var toParamVals = extend({}, toNode && toNode.paramValues);
                // limited to only those keys found in toParams
                var incomingParamVals = pick(toParamVals, toKeys);
                toParamVals = omit(toParamVals, toKeys);
                var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
                // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
                var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);
                return new PathNode(toNode.state).applyRawParams(ownParamVals);
            }
            // The param keys specified by the incoming toParams
            return toPath.map(makeInheritedParamsNode);
        };
        /**
         * Computes the tree changes (entering, exiting) between a fromPath and toPath.
         */
        PathUtils.treeChanges = function (fromPath, toPath, reloadState) {
            var max = Math.min(fromPath.length, toPath.length);
            var keep = 0;
            var nodesMatch = function (node1, node2) { return node1.equals(node2, PathUtils.nonDynamicParams); };
            while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
                keep++;
            }
            /** Given a retained node, return a new node which uses the to node's param values */
            function applyToParams(retainedNode, idx) {
                var cloned = retainedNode.clone();
                cloned.paramValues = toPath[idx].paramValues;
                return cloned;
            }
            var from, retained, exiting, entering, to;
            from = fromPath;
            retained = from.slice(0, keep);
            exiting = from.slice(keep);
            // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
            var retainedWithToParams = retained.map(applyToParams);
            entering = toPath.slice(keep);
            to = retainedWithToParams.concat(entering);
            return { from: from, to: to, retained: retained, retainedWithToParams: retainedWithToParams, exiting: exiting, entering: entering };
        };
        /**
         * Returns a new path which is: the subpath of the first path which matches the second path.
         *
         * The new path starts from root and contains any nodes that match the nodes in the second path.
         * It stops before the first non-matching node.
         *
         * Nodes are compared using their state property and their parameter values.
         * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
         *
         * @param pathA the first path
         * @param pathB the second path
         * @param paramsFn a function which returns the parameters to consider when comparing
         *
         * @returns an array of PathNodes from the first path which match the nodes in the second path
         */
        PathUtils.matching = function (pathA, pathB, paramsFn) {
            var done = false;
            var tuples = arrayTuples(pathA, pathB);
            return tuples.reduce(function (matching, _a) {
                var nodeA = _a[0], nodeB = _a[1];
                done = done || !nodeA.equals(nodeB, paramsFn);
                return done ? matching : matching.concat(nodeA);
            }, []);
        };
        /**
         * Returns true if two paths are identical.
         *
         * @param pathA
         * @param pathB
         * @param paramsFn a function which returns the parameters to consider when comparing
         * @returns true if the the states and parameter values for both paths are identical
         */
        PathUtils.equals = function (pathA, pathB, paramsFn) {
            return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
        };
        /**
         * Return a subpath of a path, which stops at the first matching node
         *
         * Given an array of nodes, returns a subset of the array starting from the first node,
         * stopping when the first node matches the predicate.
         *
         * @param path a path of [[PathNode]]s
         * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
         * @returns a subpath up to the matching node, or undefined if no match is found
         */
        PathUtils.subPath = function (path, predicate) {
            var node = find(path, predicate);
            var elementIdx = path.indexOf(node);
            return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
        };
        PathUtils.nonDynamicParams = function (node) {
            return node.state.parameters({ inherit: false }).filter(function (param) { return !param.dynamic; });
        };
        /** Gets the raw parameter values from a path */
        PathUtils.paramValues = function (path) { return path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {}); };
        return PathUtils;
    }());

    /** @internalapi */
    var resolvePolicies = {
        when: {
            LAZY: 'LAZY',
            EAGER: 'EAGER',
        },
        async: {
            WAIT: 'WAIT',
            NOWAIT: 'NOWAIT',
        },
    };

    /** @publicapi @module resolve */ /** */
    // TODO: explicitly make this user configurable
    var defaultResolvePolicy = {
        when: 'LAZY',
        async: 'WAIT',
    };
    /**
     * The basic building block for the resolve system.
     *
     * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
     * and the unwrapped-when-complete (.data) result of the resolveFn.
     *
     * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
     * resolveFn) and returns the resulting promise.
     *
     * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
     * parameter to those fns.
     */
    var Resolvable = /** @class */ (function () {
        function Resolvable(arg1, resolveFn, deps, policy, data) {
            this.resolved = false;
            this.promise = undefined;
            if (arg1 instanceof Resolvable) {
                extend(this, arg1);
            }
            else if (isFunction(resolveFn)) {
                if (isNullOrUndefined(arg1))
                    throw new Error('new Resolvable(): token argument is required');
                if (!isFunction(resolveFn))
                    throw new Error('new Resolvable(): resolveFn argument must be a function');
                this.token = arg1;
                this.policy = policy;
                this.resolveFn = resolveFn;
                this.deps = deps || [];
                this.data = data;
                this.resolved = data !== undefined;
                this.promise = this.resolved ? services.$q.when(this.data) : undefined;
            }
            else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {
                var literal = arg1;
                return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
            }
        }
        Resolvable.prototype.getPolicy = function (state) {
            var thisPolicy = this.policy || {};
            var statePolicy = (state && state.resolvePolicy) || {};
            return {
                when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
                async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,
            };
        };
        /**
         * Asynchronously resolve this Resolvable's data
         *
         * Given a ResolveContext that this Resolvable is found in:
         * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
         * and update the Resolvable's state
         */
        Resolvable.prototype.resolve = function (resolveContext, trans) {
            var _this = this;
            var $q = services.$q;
            // Gets all dependencies from ResolveContext and wait for them to be resolved
            var getResolvableDependencies = function () {
                return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) { return resolvable.get(resolveContext, trans); }));
            };
            // Invokes the resolve function passing the resolved dependencies as arguments
            var invokeResolveFn = function (resolvedDeps) { return _this.resolveFn.apply(null, resolvedDeps); };
            var node = resolveContext.findNode(this);
            var state = node && node.state;
            var asyncPolicy = this.getPolicy(state).async;
            var customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity;
            // After the final value has been resolved, update the state of the Resolvable
            var applyResolvedValue = function (resolvedValue) {
                _this.data = resolvedValue;
                _this.resolved = true;
                _this.resolveFn = null;
                trace.traceResolvableResolved(_this, trans);
                return _this.data;
            };
            // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
            return (this.promise = $q
                .when()
                .then(getResolvableDependencies)
                .then(invokeResolveFn)
                .then(customAsyncPolicy)
                .then(applyResolvedValue));
        };
        /**
         * Gets a promise for this Resolvable's data.
         *
         * Fetches the data and returns a promise.
         * Returns the existing promise if it has already been fetched once.
         */
        Resolvable.prototype.get = function (resolveContext, trans) {
            return this.promise || this.resolve(resolveContext, trans);
        };
        Resolvable.prototype.toString = function () {
            return "Resolvable(token: " + stringify(this.token) + ", requires: [" + this.deps.map(stringify) + "])";
        };
        Resolvable.prototype.clone = function () {
            return new Resolvable(this);
        };
        Resolvable.fromData = function (token, data) { return new Resolvable(token, function () { return data; }, null, null, data); };
        return Resolvable;
    }());

    /** @publicapi @module resolve */ /** */
    var whens = resolvePolicies.when;
    var ALL_WHENS = [whens.EAGER, whens.LAZY];
    var EAGER_WHENS = [whens.EAGER];
    // tslint:disable-next-line:no-inferrable-types
    var NATIVE_INJECTOR_TOKEN = 'Native Injector';
    /**
     * Encapsulates Dependency Injection for a path of nodes
     *
     * UI-Router states are organized as a tree.
     * A nested state has a path of ancestors to the root of the tree.
     * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
     * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
     *
     * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
     */
    var ResolveContext = /** @class */ (function () {
        function ResolveContext(_path) {
            this._path = _path;
        }
        /** Gets all the tokens found in the resolve context, de-duplicated */
        ResolveContext.prototype.getTokens = function () {
            return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(uniqR, []);
        };
        /**
         * Gets the Resolvable that matches the token
         *
         * Gets the last Resolvable that matches the token in this context, or undefined.
         * Throws an error if it doesn't exist in the ResolveContext
         */
        ResolveContext.prototype.getResolvable = function (token) {
            var matching = this._path
                .map(function (node) { return node.resolvables; })
                .reduce(unnestR, [])
                .filter(function (r) { return r.token === token; });
            return tail(matching);
        };
        /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
        ResolveContext.prototype.getPolicy = function (resolvable) {
            var node = this.findNode(resolvable);
            return resolvable.getPolicy(node.state);
        };
        /**
         * Returns a ResolveContext that includes a portion of this one
         *
         * Given a state, this method creates a new ResolveContext from this one.
         * The new context starts at the first node (root) and stops at the node for the `state` parameter.
         *
         * #### Why
         *
         * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
         * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
         * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
         * This method is used to create a narrower context when injecting ancestor nodes.
         *
         * @example
         * `let ABCD = new ResolveContext([A, B, C, D]);`
         *
         * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
         * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
         * However, `B` should only be able to access resolvables from `A`, `B`.
         *
         * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
         * `let AB = ABCD.subcontext(a)`
         */
        ResolveContext.prototype.subContext = function (state) {
            return new ResolveContext(PathUtils.subPath(this._path, function (node) { return node.state === state; }));
        };
        /**
         * Adds Resolvables to the node that matches the state
         *
         * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
         * The resolvable is added to the node matching the `state` parameter.
         *
         * These new resolvables are not automatically fetched.
         * The calling code should either fetch them, fetch something that depends on them,
         * or rely on [[resolvePath]] being called when some state is being entered.
         *
         * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
         *
         * @param newResolvables the new Resolvables
         * @param state Used to find the node to put the resolvable on
         */
        ResolveContext.prototype.addResolvables = function (newResolvables, state) {
            var node = find(this._path, propEq('state', state));
            var keys = newResolvables.map(function (r) { return r.token; });
            node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);
        };
        /**
         * Returns a promise for an array of resolved path Element promises
         *
         * @param when
         * @param trans
         * @returns {Promise<any>|any}
         */
        ResolveContext.prototype.resolvePath = function (when, trans) {
            var _this = this;
            if (when === void 0) { when = 'LAZY'; }
            // This option determines which 'when' policy Resolvables we are about to fetch.
            var whenOption = inArray(ALL_WHENS, when) ? when : 'LAZY';
            // If the caller specified EAGER, only the EAGER Resolvables are fetched.
            // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
            var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
            // get the subpath to the state argument, if provided
            trace.traceResolvePath(this._path, when, trans);
            var matchesPolicy = function (acceptedVals, whenOrAsync) { return function (resolvable) {
                return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
            }; };
            // Trigger all the (matching) Resolvables in the path
            // Reduce all the "WAIT" Resolvables into an array
            var promises = this._path.reduce(function (acc, node) {
                var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));
                var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));
                var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));
                // For the matching Resolvables, start their async fetch process.
                var subContext = _this.subContext(node.state);
                var getResult = function (r) {
                    return r
                        .get(subContext, trans)
                        // Return a tuple that includes the Resolvable's token
                        .then(function (value) { return ({ token: r.token, value: value }); });
                };
                nowait.forEach(getResult);
                return acc.concat(wait.map(getResult));
            }, []);
            // Wait for all the "WAIT" resolvables
            return services.$q.all(promises);
        };
        ResolveContext.prototype.injector = function () {
            return this._injector || (this._injector = new UIInjectorImpl(this));
        };
        ResolveContext.prototype.findNode = function (resolvable) {
            return find(this._path, function (node) { return inArray(node.resolvables, resolvable); });
        };
        /**
         * Gets the async dependencies of a Resolvable
         *
         * Given a Resolvable, returns its dependencies as a Resolvable[]
         */
        ResolveContext.prototype.getDependencies = function (resolvable) {
            var _this = this;
            var node = this.findNode(resolvable);
            // Find which other resolvables are "visible" to the `resolvable` argument
            // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
            var subPath = PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;
            var availableResolvables = subPath
                .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, []) // all of subpath's resolvables
                .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument
            var getDependency = function (token) {
                var matching = availableResolvables.filter(function (r) { return r.token === token; });
                if (matching.length)
                    return tail(matching);
                var fromInjector = _this.injector().getNative(token);
                if (isUndefined(fromInjector)) {
                    throw new Error('Could not find Dependency Injection token: ' + stringify(token));
                }
                return new Resolvable(token, function () { return fromInjector; }, [], fromInjector);
            };
            return resolvable.deps.map(getDependency);
        };
        return ResolveContext;
    }());
    /** @internalapi */
    var UIInjectorImpl = /** @class */ (function () {
        function UIInjectorImpl(context) {
            this.context = context;
            this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;
        }
        UIInjectorImpl.prototype.get = function (token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable) {
                if (this.context.getPolicy(resolvable).async === 'NOWAIT') {
                    return resolvable.get(this.context);
                }
                if (!resolvable.resolved) {
                    throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));
                }
                return resolvable.data;
            }
            return this.getNative(token);
        };
        UIInjectorImpl.prototype.getAsync = function (token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable)
                return resolvable.get(this.context);
            return services.$q.when(this.native.get(token));
        };
        UIInjectorImpl.prototype.getNative = function (token) {
            return this.native && this.native.get(token);
        };
        return UIInjectorImpl;
    }());

    /** @publicapi @module state */ /** */
    var parseUrl = function (url) {
        if (!isString(url))
            return false;
        var root = url.charAt(0) === '^';
        return { val: root ? url.substring(1) : url, root: root };
    };
    function nameBuilder(state) {
        return state.name;
    }
    function selfBuilder(state) {
        state.self.$$state = function () { return state; };
        return state.self;
    }
    function dataBuilder(state) {
        if (state.parent && state.parent.data) {
            state.data = state.self.data = inherit(state.parent.data, state.data);
        }
        return state.data;
    }
    var getUrlBuilder = function ($urlMatcherFactoryProvider, root) {
        return function urlBuilder(stateObject) {
            var stateDec = stateObject.self;
            // For future states, i.e., states whose name ends with `.**`,
            // match anything that starts with the url prefix
            if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
                var newStateDec = {};
                copy(stateDec, newStateDec);
                newStateDec.url += '{remainder:any}'; // match any path (.*)
                stateDec = newStateDec;
            }
            var parent = stateObject.parent;
            var parsed = parseUrl(stateDec.url);
            var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, { state: stateDec });
            if (!url)
                return null;
            if (!$urlMatcherFactoryProvider.isMatcher(url))
                throw new Error("Invalid url '" + url + "' in state '" + stateObject + "'");
            return parsed && parsed.root ? url : ((parent && parent.navigable) || root()).url.append(url);
        };
    };
    var getNavigableBuilder = function (isRoot) {
        return function navigableBuilder(state) {
            return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;
        };
    };
    var getParamsBuilder = function (paramFactory) {
        return function paramsBuilder(state) {
            var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, state.self); };
            var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];
            var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));
            return urlParams
                .concat(nonUrlParams)
                .map(function (p) { return [p.id, p]; })
                .reduce(applyPairs, {});
        };
    };
    function pathBuilder(state) {
        return state.parent ? state.parent.path.concat(state) : /*root*/ [state];
    }
    function includesBuilder(state) {
        var includes = state.parent ? extend({}, state.parent.includes) : {};
        includes[state.name] = true;
        return includes;
    }
    /**
     * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * validates the `resolve` property and converts it to a [[Resolvable]] array.
     *
     * resolve: input value can be:
     *
     * {
     *   // analyzed but not injected
     *   myFooResolve: function() { return "myFooData"; },
     *
     *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
     *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
     *
     *   // Array split; "DependencyName" dep as string
     *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
     *
     *   // Array split; DependencyType dep as token (compared using ===)
     *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
     *
     *   // val.$inject used as deps
     *   // where:
     *   //     corgeResolve.$inject = ["DependencyName"];
     *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
     *   // then "DependencyName" dep as string
     *   myCorgeResolve: corgeResolve,
     *
     *  // inject service by name
     *  // When a string is found, desugar creating a resolve that injects the named service
     *   myGraultResolve: "SomeService"
     * }
     *
     * or:
     *
     * [
     *   new Resolvable("myFooResolve", function() { return "myFooData" }),
     *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
     *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
     * ]
     */
    function resolvablesBuilder(state) {
        /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
        var objects2Tuples = function (resolveObj, resolvePolicies) {
            return Object.keys(resolveObj || {}).map(function (token) { return ({
                token: token,
                val: resolveObj[token],
                deps: undefined,
                policy: resolvePolicies[token],
            }); });
        };
        /** fetch DI annotations from a function or ng1-style array */
        var annotate = function (fn) {
            var $injector = services.$injector;
            // ng1 doesn't have an $injector until runtime.
            // If the $injector doesn't exist, use "deferred" literal as a
            // marker indicating they should be annotated when runtime starts
            return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || 'deferred';
        };
        /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
        var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };
        /** true if the object looks like a provide literal, or a ng2 Provider */
        var isLikeNg2Provider = function (obj) {
            return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));
        };
        /** true if the object looks like a tuple from obj2Tuples */
        var isTupleFromObj = function (obj) {
            return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));
        };
        /** extracts the token from a Provider or provide literal */
        var getToken = function (p) { return p.provide || p.token; };
        // prettier-ignore: Given a literal resolve or provider object, returns a Resolvable
        var literal2Resolvable = pattern([
            [prop('resolveFn'), function (p) { return new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy); }],
            [prop('useFactory'), function (p) { return new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy); }],
            [prop('useClass'), function (p) { return new Resolvable(getToken(p), function () { return new p.useClass(); }, [], p.policy); }],
            [prop('useValue'), function (p) { return new Resolvable(getToken(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],
            [prop('useExisting'), function (p) { return new Resolvable(getToken(p), identity, [p.useExisting], p.policy); }],
        ]);
        // prettier-ignore
        var tuple2Resolvable = pattern([
            [pipe(prop('val'), isString), function (tuple) { return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy); }],
            [pipe(prop('val'), isArray), function (tuple) { return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],
            [pipe(prop('val'), isFunction), function (tuple) { return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],
        ]);
        // prettier-ignore
        var item2Resolvable = pattern([
            [is(Resolvable), function (r) { return r; }],
            [isResolveLiteral, literal2Resolvable],
            [isLikeNg2Provider, literal2Resolvable],
            [isTupleFromObj, tuple2Resolvable],
            [val(true), function (obj) { throw new Error('Invalid resolve value: ' + stringify(obj)); },],
        ]);
        // If resolveBlock is already an array, use it as-is.
        // Otherwise, assume it's an object and convert to an Array of tuples
        var decl = state.resolve;
        var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
        return items.map(item2Resolvable);
    }
    /**
     * @internalapi A internal global service
     *
     * StateBuilder is a factory for the internal [[StateObject]] objects.
     *
     * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
     * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
     * [[StateObject]] object, which has an API and is used internally.
     *
     * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
     * using the [[builder]] method.
     */
    var StateBuilder = /** @class */ (function () {
        function StateBuilder(matcher, urlMatcherFactory) {
            this.matcher = matcher;
            var self = this;
            var root = function () { return matcher.find(''); };
            var isRoot = function (state) { return state.name === ''; };
            function parentBuilder(state) {
                if (isRoot(state))
                    return null;
                return matcher.find(self.parentName(state)) || root();
            }
            this.builders = {
                name: [nameBuilder],
                self: [selfBuilder],
                parent: [parentBuilder],
                data: [dataBuilder],
                // Build a URLMatcher if necessary, either via a relative or absolute URL
                url: [getUrlBuilder(urlMatcherFactory, root)],
                // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
                navigable: [getNavigableBuilder(isRoot)],
                params: [getParamsBuilder(urlMatcherFactory.paramFactory)],
                // Each framework-specific ui-router implementation should define its own `views` builder
                // e.g., src/ng1/statebuilders/views.ts
                views: [],
                // Keep a full path from the root down to this state as this is needed for state activation.
                path: [pathBuilder],
                // Speed up $state.includes() as it's used a lot
                includes: [includesBuilder],
                resolvables: [resolvablesBuilder],
            };
        }
        /**
         * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
         * More than one BuilderFunction can be registered for a given property.
         *
         * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
         *
         * @param name The name of the State property being registered for.
         * @param fn The BuilderFunction which will be used to build the State property
         * @returns a function which deregisters the BuilderFunction
         */
        StateBuilder.prototype.builder = function (name, fn) {
            var builders = this.builders;
            var array = builders[name] || [];
            // Backwards compat: if only one builder exists, return it, else return whole arary.
            if (isString(name) && !isDefined(fn))
                return array.length > 1 ? array : array[0];
            if (!isString(name) || !isFunction(fn))
                return;
            builders[name] = array;
            builders[name].push(fn);
            return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };
        };
        /**
         * Builds all of the properties on an essentially blank State object, returning a State object which has all its
         * properties and API built.
         *
         * @param state an uninitialized State object
         * @returns the built State object
         */
        StateBuilder.prototype.build = function (state) {
            var _a = this, matcher = _a.matcher, builders = _a.builders;
            var parent = this.parentName(state);
            if (parent && !matcher.find(parent, undefined, false)) {
                return null;
            }
            for (var key in builders) {
                if (!builders.hasOwnProperty(key))
                    continue;
                var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, noop);
                state[key] = chain(state);
            }
            return state;
        };
        StateBuilder.prototype.parentName = function (state) {
            // name = 'foo.bar.baz.**'
            var name = state.name || '';
            // segments = ['foo', 'bar', 'baz', '.**']
            var segments = name.split('.');
            // segments = ['foo', 'bar', 'baz']
            var lastSegment = segments.pop();
            // segments = ['foo', 'bar'] (ignore .** segment for future states)
            if (lastSegment === '**')
                segments.pop();
            if (segments.length) {
                if (state.parent) {
                    throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
                }
                // 'foo.bar'
                return segments.join('.');
            }
            if (!state.parent)
                return '';
            return isString(state.parent) ? state.parent : state.parent.name;
        };
        StateBuilder.prototype.name = function (state) {
            var name = state.name;
            if (name.indexOf('.') !== -1 || !state.parent)
                return name;
            var parentName = isString(state.parent) ? state.parent : state.parent.name;
            return parentName ? parentName + '.' + name : name;
        };
        return StateBuilder;
    }());

    /**
     * Internal representation of a UI-Router state.
     *
     * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
     *
     * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
     *
     * This class prototypally inherits from the corresponding [[StateDeclaration]].
     * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
     */
    var StateObject = /** @class */ (function () {
        /** @deprecated use State.create() */
        function StateObject(config) {
            return StateObject.create(config || {});
        }
        /**
         * Create a state object to put the private/internal implementation details onto.
         * The object's prototype chain looks like:
         * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)
         *
         * @param stateDecl the user-supplied State Declaration
         * @returns {StateObject} an internal State object
         */
        StateObject.create = function (stateDecl) {
            stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
            var state = inherit(inherit(stateDecl, StateObject.prototype));
            stateDecl.$$state = function () { return state; };
            state.self = stateDecl;
            state.__stateObjectCache = {
                nameGlob: Glob.fromString(state.name),
            };
            return state;
        };
        /**
         * Returns true if the provided parameter is the same state.
         *
         * Compares the identity of the state against the passed value, which is either an object
         * reference to the actual `State` instance, the original definition object passed to
         * `$stateProvider.state()`, or the fully-qualified name.
         *
         * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
         *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
         * @returns Returns `true` if `ref` matches the current `State` instance.
         */
        StateObject.prototype.is = function (ref) {
            return this === ref || this.self === ref || this.fqn() === ref;
        };
        /**
         * @deprecated this does not properly handle dot notation
         * @returns Returns a dot-separated name of the state.
         */
        StateObject.prototype.fqn = function () {
            if (!this.parent || !(this.parent instanceof this.constructor))
                return this.name;
            var name = this.parent.fqn();
            return name ? name + '.' + this.name : this.name;
        };
        /**
         * Returns the root node of this state's tree.
         *
         * @returns The root of this state's tree.
         */
        StateObject.prototype.root = function () {
            return (this.parent && this.parent.root()) || this;
        };
        /**
         * Gets the state's `Param` objects
         *
         * Gets the list of [[Param]] objects owned by the state.
         * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
         * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
         *
         * @param opts options
         */
        StateObject.prototype.parameters = function (opts) {
            opts = defaults(opts, { inherit: true, matchingKeys: null });
            var inherited = (opts.inherit && this.parent && this.parent.parameters()) || [];
            return inherited
                .concat(values(this.params))
                .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });
        };
        /**
         * Returns a single [[Param]] that is owned by the state
         *
         * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
         * @param id the name of the [[Param]] to return
         * @param opts options
         */
        StateObject.prototype.parameter = function (id, opts) {
            if (opts === void 0) { opts = {}; }
            return ((this.url && this.url.parameter(id, opts)) ||
                find(values(this.params), propEq('id', id)) ||
                (opts.inherit && this.parent && this.parent.parameter(id)));
        };
        StateObject.prototype.toString = function () {
            return this.fqn();
        };
        /** Predicate which returns true if the object is an class with @State() decorator */
        StateObject.isStateClass = function (stateDecl) {
            return isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;
        };
        /** Predicate which returns true if the object is an internal [[StateObject]] object */
        StateObject.isState = function (obj) { return isObject(obj['__stateObjectCache']); };
        return StateObject;
    }());

    /** @publicapi @module state */ /** */
    var StateMatcher = /** @class */ (function () {
        function StateMatcher(_states) {
            this._states = _states;
        }
        StateMatcher.prototype.isRelative = function (stateName) {
            stateName = stateName || '';
            return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;
        };
        StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {
            if (matchGlob === void 0) { matchGlob = true; }
            if (!stateOrName && stateOrName !== '')
                return undefined;
            var isStr = isString(stateOrName);
            var name = isStr ? stateOrName : stateOrName.name;
            if (this.isRelative(name))
                name = this.resolvePath(name, base);
            var state = this._states[name];
            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
                return state;
            }
            else if (isStr && matchGlob) {
                var _states = values(this._states);
                var matches = _states.filter(function (_state) { return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name); });
                if (matches.length > 1) {
                    safeConsole.error("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));
                }
                return matches[0];
            }
            return undefined;
        };
        StateMatcher.prototype.resolvePath = function (name, base) {
            if (!base)
                throw new Error("No reference point given for path '" + name + "'");
            var baseState = this.find(base);
            var splitName = name.split('.');
            var pathLength = splitName.length;
            var i = 0, current = baseState;
            for (; i < pathLength; i++) {
                if (splitName[i] === '' && i === 0) {
                    current = baseState;
                    continue;
                }
                if (splitName[i] === '^') {
                    if (!current.parent)
                        throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                    current = current.parent;
                    continue;
                }
                break;
            }
            var relName = splitName.slice(i).join('.');
            return current.name + (current.name && relName ? '.' : '') + relName;
        };
        return StateMatcher;
    }());

    /** @publicapi @module state */ /** */
    /** @internalapi */
    var StateQueueManager = /** @class */ (function () {
        function StateQueueManager(router, states, builder, listeners) {
            this.router = router;
            this.states = states;
            this.builder = builder;
            this.listeners = listeners;
            this.queue = [];
        }
        /** @internalapi */
        StateQueueManager.prototype.dispose = function () {
            this.queue = [];
        };
        StateQueueManager.prototype.register = function (stateDecl) {
            var queue = this.queue;
            var state = StateObject.create(stateDecl);
            var name = state.name;
            if (!isString(name))
                throw new Error('State must have a valid name');
            if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))
                throw new Error("State '" + name + "' is already defined");
            queue.push(state);
            this.flush();
            return state;
        };
        StateQueueManager.prototype.flush = function () {
            var _this = this;
            var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
            var registered = [], // states that got registered
            orphans = [], // states that don't yet have a parent registered
            previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered
            var getState = function (name) { return _this.states.hasOwnProperty(name) && _this.states[name]; };
            var notifyListeners = function () {
                if (registered.length) {
                    _this.listeners.forEach(function (listener) { return listener('registered', registered.map(function (s) { return s.self; })); });
                }
            };
            while (queue.length > 0) {
                var state = queue.shift();
                var name_1 = state.name;
                var result = builder.build(state);
                var orphanIdx = orphans.indexOf(state);
                if (result) {
                    var existingState = getState(name_1);
                    if (existingState && existingState.name === name_1) {
                        throw new Error("State '" + name_1 + "' is already defined");
                    }
                    var existingFutureState = getState(name_1 + '.**');
                    if (existingFutureState) {
                        // Remove future state of the same name
                        this.router.stateRegistry.deregister(existingFutureState);
                    }
                    states[name_1] = state;
                    this.attachRoute(state);
                    if (orphanIdx >= 0)
                        orphans.splice(orphanIdx, 1);
                    registered.push(state);
                    continue;
                }
                var prev = previousQueueLength[name_1];
                previousQueueLength[name_1] = queue.length;
                if (orphanIdx >= 0 && prev === queue.length) {
                    // Wait until two consecutive iterations where no additional states were dequeued successfully.
                    // throw new Error(`Cannot register orphaned state '${name}'`);
                    queue.push(state);
                    notifyListeners();
                    return states;
                }
                else if (orphanIdx < 0) {
                    orphans.push(state);
                }
                queue.push(state);
            }
            notifyListeners();
            return states;
        };
        StateQueueManager.prototype.attachRoute = function (state) {
            if (state.abstract || !state.url)
                return;
            var rulesApi = this.router.urlService.rules;
            rulesApi.rule(rulesApi.urlRuleFactory.create(state));
        };
        return StateQueueManager;
    }());

    /** @publicapi @module state */ /** */
    var StateRegistry = /** @class */ (function () {
        /** @internalapi */
        function StateRegistry(router) {
            this.router = router;
            this.states = {};
            this.listeners = [];
            this.matcher = new StateMatcher(this.states);
            this.builder = new StateBuilder(this.matcher, router.urlMatcherFactory);
            this.stateQueue = new StateQueueManager(router, this.states, this.builder, this.listeners);
            this._registerRoot();
        }
        /** @internalapi */
        StateRegistry.prototype._registerRoot = function () {
            var rootStateDef = {
                name: '',
                url: '^',
                views: null,
                params: {
                    '#': { value: null, type: 'hash', dynamic: true },
                },
                abstract: true,
            };
            var _root = (this._root = this.stateQueue.register(rootStateDef));
            _root.navigable = null;
        };
        /** @internalapi */
        StateRegistry.prototype.dispose = function () {
            var _this = this;
            this.stateQueue.dispose();
            this.listeners = [];
            this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });
        };
        /**
         * Listen for a State Registry events
         *
         * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
         *
         * #### Example:
         * ```js
         * let allStates = registry.get();
         *
         * // Later, invoke deregisterFn() to remove the listener
         * let deregisterFn = registry.onStatesChanged((event, states) => {
         *   switch(event) {
         *     case: 'registered':
         *       states.forEach(state => allStates.push(state));
         *       break;
         *     case: 'deregistered':
         *       states.forEach(state => {
         *         let idx = allStates.indexOf(state);
         *         if (idx !== -1) allStates.splice(idx, 1);
         *       });
         *       break;
         *   }
         * });
         * ```
         *
         * @param listener a callback function invoked when the registered states changes.
         *        The function receives two parameters, `event` and `state`.
         *        See [[StateRegistryListener]]
         * @return a function that deregisters the listener
         */
        StateRegistry.prototype.onStatesChanged = function (listener) {
            this.listeners.push(listener);
            return function deregisterListener() {
                removeFrom(this.listeners)(listener);
            }.bind(this);
        };
        /**
         * Gets the implicit root state
         *
         * Gets the root of the state tree.
         * The root state is implicitly created by UI-Router.
         * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
         *
         * @return the root [[StateObject]]
         */
        StateRegistry.prototype.root = function () {
            return this._root;
        };
        /**
         * Adds a state to the registry
         *
         * Registers a [[StateDeclaration]] or queues it for registration.
         *
         * Note: a state will be queued if the state's parent isn't yet registered.
         *
         * @param stateDefinition the definition of the state to register.
         * @returns the internal [[StateObject]] object.
         *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
         *          If the state was only queued, then the object is not fully built.
         */
        StateRegistry.prototype.register = function (stateDefinition) {
            return this.stateQueue.register(stateDefinition);
        };
        /** @hidden */
        StateRegistry.prototype._deregisterTree = function (state) {
            var _this = this;
            var all = this.get().map(function (s) { return s.$$state(); });
            var getChildren = function (states) {
                var _children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });
                return _children.length === 0 ? _children : _children.concat(getChildren(_children));
            };
            var children = getChildren([state]);
            var deregistered = [state].concat(children).reverse();
            deregistered.forEach(function (_state) {
                var rulesApi = _this.router.urlService.rules;
                // Remove URL rule
                rulesApi
                    .rules()
                    .filter(propEq('state', _state))
                    .forEach(function (rule) { return rulesApi.removeRule(rule); });
                // Remove state from registry
                delete _this.states[_state.name];
            });
            return deregistered;
        };
        /**
         * Removes a state from the registry
         *
         * This removes a state from the registry.
         * If the state has children, they are are also removed from the registry.
         *
         * @param stateOrName the state's name or object representation
         * @returns {StateObject[]} a list of removed states
         */
        StateRegistry.prototype.deregister = function (stateOrName) {
            var _state = this.get(stateOrName);
            if (!_state)
                throw new Error("Can't deregister state; not found: " + stateOrName);
            var deregisteredStates = this._deregisterTree(_state.$$state());
            this.listeners.forEach(function (listener) { return listener('deregistered', deregisteredStates.map(function (s) { return s.self; })); });
            return deregisteredStates;
        };
        StateRegistry.prototype.get = function (stateOrName, base) {
            var _this = this;
            if (arguments.length === 0)
                return Object.keys(this.states).map(function (name) { return _this.states[name].self; });
            var found = this.matcher.find(stateOrName, base);
            return (found && found.self) || null;
        };
        StateRegistry.prototype.decorator = function (name, func) {
            return this.builder.builder(name, func);
        };
        return StateRegistry;
    }());

    (function (TransitionHookPhase) {
        TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
        TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
        TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
        TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
        TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
    })(exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));

    (function (TransitionHookScope) {
        TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
        TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
    })(exports.TransitionHookScope || (exports.TransitionHookScope = {}));

    /** @publicapi @module transition */ /** */
    var defaultOptions = {
        current: noop,
        transition: null,
        traceData: {},
        bind: null,
    };
    /** @hidden */
    var TransitionHook = /** @class */ (function () {
        function TransitionHook(transition, stateContext, registeredHook, options) {
            var _this = this;
            this.transition = transition;
            this.stateContext = stateContext;
            this.registeredHook = registeredHook;
            this.options = options;
            this.isSuperseded = function () { return _this.type.hookPhase === exports.TransitionHookPhase.RUN && !_this.options.transition.isActive(); };
            this.options = defaults(options, defaultOptions);
            this.type = registeredHook.eventType;
        }
        /**
         * Chains together an array of TransitionHooks.
         *
         * Given a list of [[TransitionHook]] objects, chains them together.
         * Each hook is invoked after the previous one completes.
         *
         * #### Example:
         * ```js
         * var hooks: TransitionHook[] = getHooks();
         * let promise: Promise<any> = TransitionHook.chain(hooks);
         *
         * promise.then(handleSuccess, handleError);
         * ```
         *
         * @param hooks the list of hooks to chain together
         * @param waitFor if provided, the chain is `.then()`'ed off this promise
         * @returns a `Promise` for sequentially invoking the hooks (in order)
         */
        TransitionHook.chain = function (hooks, waitFor) {
            // Chain the next hook off the previous
            var createHookChainR = function (prev, nextHook) { return prev.then(function () { return nextHook.invokeHook(); }); };
            return hooks.reduce(createHookChainR, waitFor || services.$q.when());
        };
        /**
         * Invokes all the provided TransitionHooks, in order.
         * Each hook's return value is checked.
         * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
         * If no hook returns a promise, then all hooks are processed synchronously.
         *
         * @param hooks the list of TransitionHooks to invoke
         * @param doneCallback a callback that is invoked after all the hooks have successfully completed
         *
         * @returns a promise for the async result, or the result of the callback
         */
        TransitionHook.invokeHooks = function (hooks, doneCallback) {
            for (var idx = 0; idx < hooks.length; idx++) {
                var hookResult = hooks[idx].invokeHook();
                if (isPromise(hookResult)) {
                    var remainingHooks = hooks.slice(idx + 1);
                    return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);
                }
            }
            return doneCallback();
        };
        /**
         * Run all TransitionHooks, ignoring their return value.
         */
        TransitionHook.runAllHooks = function (hooks) {
            hooks.forEach(function (hook) { return hook.invokeHook(); });
        };
        TransitionHook.prototype.logError = function (err) {
            this.transition.router.stateService.defaultErrorHandler()(err);
        };
        TransitionHook.prototype.invokeHook = function () {
            var _this = this;
            var hook = this.registeredHook;
            if (hook._deregistered)
                return;
            var notCurrent = this.getNotCurrentRejection();
            if (notCurrent)
                return notCurrent;
            var options = this.options;
            trace.traceHookInvocation(this, this.transition, options);
            var invokeCallback = function () { return hook.callback.call(options.bind, _this.transition, _this.stateContext); };
            var normalizeErr = function (err) { return Rejection.normalize(err).toPromise(); };
            var handleError = function (err) { return hook.eventType.getErrorHandler(_this)(err); };
            var handleResult = function (result) { return hook.eventType.getResultHandler(_this)(result); };
            try {
                var result = invokeCallback();
                if (!this.type.synchronous && isPromise(result)) {
                    return result.catch(normalizeErr).then(handleResult, handleError);
                }
                else {
                    return handleResult(result);
                }
            }
            catch (err) {
                // If callback throws (synchronously)
                return handleError(Rejection.normalize(err));
            }
            finally {
                if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
                    hook.deregister();
                }
            }
        };
        /**
         * This method handles the return value of a Transition Hook.
         *
         * A hook can return false (cancel), a TargetState (redirect),
         * or a promise (which may later resolve to false or a redirect)
         *
         * This also handles "transition superseded" -- when a new transition
         * was started while the hook was still running
         */
        TransitionHook.prototype.handleHookResult = function (result) {
            var _this = this;
            var notCurrent = this.getNotCurrentRejection();
            if (notCurrent)
                return notCurrent;
            // Hook returned a promise
            if (isPromise(result)) {
                // Wait for the promise, then reprocess with the resulting value
                return result.then(function (val) { return _this.handleHookResult(val); });
            }
            trace.traceHookResult(result, this.transition, this.options);
            // Hook returned false
            if (result === false) {
                // Abort this Transition
                return Rejection.aborted('Hook aborted transition').toPromise();
            }
            var isTargetState = is(TargetState);
            // hook returned a TargetState
            if (isTargetState(result)) {
                // Halt the current Transition and redirect (a new Transition) to the TargetState.
                return Rejection.redirected(result).toPromise();
            }
        };
        /**
         * Return a Rejection promise if the transition is no longer current due
         * to a stopped router (disposed), or a new transition has started and superseded this one.
         */
        TransitionHook.prototype.getNotCurrentRejection = function () {
            var router = this.transition.router;
            // The router is stopped
            if (router._disposed) {
                return Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
            }
            if (this.transition._aborted) {
                return Rejection.aborted().toPromise();
            }
            // This transition is no longer current.
            // Another transition started while this hook was still running.
            if (this.isSuperseded()) {
                // Abort this transition
                return Rejection.superseded(this.options.current()).toPromise();
            }
        };
        TransitionHook.prototype.toString = function () {
            var _a = this, options = _a.options, registeredHook = _a.registeredHook;
            var event = parse('traceData.hookType')(options) || 'internal', context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown', name = fnToString(registeredHook.callback);
            return event + " context: " + context + ", " + maxLength(200, name);
        };
        /**
         * These GetResultHandler(s) are used by [[invokeHook]] below
         * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
         */
        TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {
            return hook.handleHookResult(result);
        }; };
        /**
         * If the result is a promise rejection, log it.
         * Otherwise, ignore the result.
         */
        TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {
            isPromise(result) && result.catch(function (err) { return hook.logError(Rejection.normalize(err)); });
            return undefined;
        }; };
        /**
         * These GetErrorHandler(s) are used by [[invokeHook]] below
         * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
         */
        TransitionHook.LOG_ERROR = function (hook) { return function (error) { return hook.logError(error); }; };
        TransitionHook.REJECT_ERROR = function (hook) { return function (error) { return silentRejection(error); }; };
        TransitionHook.THROW_ERROR = function (hook) { return function (error) {
            throw error;
        }; };
        return TransitionHook;
    }());

    /** @publicapi @module transition */ /** */
    /**
     * Determines if the given state matches the matchCriteria
     *
     * @hidden
     *
     * @param state a State Object to test against
     * @param criterion
     * - If a string, matchState uses the string as a glob-matcher against the state name
     * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
     *   and returns a positive match if any of the globs match.
     * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
     * @returns {boolean}
     */
    function matchState(state, criterion, transition) {
        var toMatch = isString(criterion) ? [criterion] : criterion;
        function matchGlobs(_state) {
            var globStrings = toMatch;
            for (var i = 0; i < globStrings.length; i++) {
                var glob = new Glob(globStrings[i]);
                if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {
                    return true;
                }
            }
            return false;
        }
        var matchFn = (isFunction(toMatch) ? toMatch : matchGlobs);
        return !!matchFn(state, transition);
    }
    /**
     * @internalapi
     * The registration data for a registered transition hook
     */
    var RegisteredHook = /** @class */ (function () {
        function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
            if (options === void 0) { options = {}; }
            this.tranSvc = tranSvc;
            this.eventType = eventType;
            this.callback = callback;
            this.matchCriteria = matchCriteria;
            this.removeHookFromRegistry = removeHookFromRegistry;
            this.invokeCount = 0;
            this._deregistered = false;
            this.priority = options.priority || 0;
            this.bind = options.bind || null;
            this.invokeLimit = options.invokeLimit;
        }
        /**
         * Gets the matching [[PathNode]]s
         *
         * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
         * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
         *
         * Returning `null` is significant to distinguish between the default
         * "match-all criterion value" of `true` compared to a `() => true` function,
         * when the nodes is an empty array.
         *
         * This is useful to allow a transition match criteria of `entering: true`
         * to still match a transition, even when `entering === []`.  Contrast that
         * with `entering: (state) => true` which only matches when a state is actually
         * being entered.
         */
        RegisteredHook.prototype._matchingNodes = function (nodes, criterion, transition) {
            if (criterion === true)
                return nodes;
            var matching = nodes.filter(function (node) { return matchState(node.state, criterion, transition); });
            return matching.length ? matching : null;
        };
        /**
         * Gets the default match criteria (all `true`)
         *
         * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
         *
         * ```js
         * {
         *   to: true,
         *   from: true,
         *   entering: true,
         *   exiting: true,
         *   retained: true,
         * }
         */
        RegisteredHook.prototype._getDefaultMatchCriteria = function () {
            return mapObj(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });
        };
        /**
         * Gets matching nodes as [[IMatchingNodes]]
         *
         * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
         *
         * ```js
         * let matches: IMatchingNodes = {
         *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
         *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
         *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
         *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
         *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
         * };
         * ```
         */
        RegisteredHook.prototype._getMatchingNodes = function (treeChanges, transition) {
            var _this = this;
            var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);
            var paths = values(this.tranSvc._pluginapi._getPathTypes());
            return paths.reduce(function (mn, pathtype) {
                // STATE scope criteria matches against every node in the path.
                // TRANSITION scope criteria matches against only the last node in the path
                var isStateHook = pathtype.scope === exports.TransitionHookScope.STATE;
                var path = treeChanges[pathtype.name] || [];
                var nodes = isStateHook ? path : [tail(path)];
                mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name], transition);
                return mn;
            }, {});
        };
        /**
         * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
         *
         * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
         * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
         */
        RegisteredHook.prototype.matches = function (treeChanges, transition) {
            var matches = this._getMatchingNodes(treeChanges, transition);
            // Check if all the criteria matched the TreeChanges object
            var allMatched = values(matches).every(identity);
            return allMatched ? matches : null;
        };
        RegisteredHook.prototype.deregister = function () {
            this.removeHookFromRegistry(this);
            this._deregistered = true;
        };
        return RegisteredHook;
    }());
    /** @hidden Return a registration function of the requested type. */
    function makeEvent(registry, transitionService, eventType) {
        // Create the object which holds the registered transition hooks.
        var _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});
        var hooks = (_registeredHooks[eventType.name] = []);
        var removeHookFn = removeFrom(hooks);
        // Create hook registration function on the IHookRegistry for the event
        registry[eventType.name] = hookRegistrationFn;
        function hookRegistrationFn(matchObject, callback, options) {
            if (options === void 0) { options = {}; }
            var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
            hooks.push(registeredHook);
            return registeredHook.deregister.bind(registeredHook);
        }
        return hookRegistrationFn;
    }

    /** @publicapi @module transition */ /** */
    /**
     * This class returns applicable TransitionHooks for a specific Transition instance.
     *
     * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
     * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
     * determined by the type of hook)
     *
     * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
     *
     * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
     * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
     * in the Transition class, so we must also provide the Transition's _treeChanges)
     *
     */
    var HookBuilder = /** @class */ (function () {
        function HookBuilder(transition) {
            this.transition = transition;
        }
        HookBuilder.prototype.buildHooksForPhase = function (phase) {
            var _this = this;
            var $transitions = this.transition.router.transitionService;
            return $transitions._pluginapi
                ._getEvents(phase)
                .map(function (type) { return _this.buildHooks(type); })
                .reduce(unnestR, [])
                .filter(identity);
        };
        /**
         * Returns an array of newly built TransitionHook objects.
         *
         * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
         * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
         * - For each of the [[PathNode]]s, creates a TransitionHook
         *
         * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
         */
        HookBuilder.prototype.buildHooks = function (hookType) {
            var transition = this.transition;
            var treeChanges = transition.treeChanges();
            // Find all the matching registered hooks for a given hook type
            var matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);
            if (!matchingHooks)
                return [];
            var baseHookOptions = {
                transition: transition,
                current: transition.options().current,
            };
            var makeTransitionHooks = function (hook) {
                // Fetch the Nodes that caused this hook to match.
                var matches = hook.matches(treeChanges, transition);
                // Select the PathNode[] that will be used as TransitionHook context objects
                var matchingNodes = matches[hookType.criteriaMatchPath.name];
                // Return an array of HookTuples
                return matchingNodes.map(function (node) {
                    var _options = extend({
                        bind: hook.bind,
                        traceData: { hookType: hookType.name, context: node },
                    }, baseHookOptions);
                    var state = hookType.criteriaMatchPath.scope === exports.TransitionHookScope.STATE ? node.state.self : null;
                    var transitionHook = new TransitionHook(transition, state, hook, _options);
                    return { hook: hook, node: node, transitionHook: transitionHook };
                });
            };
            return matchingHooks
                .map(makeTransitionHooks)
                .reduce(unnestR, [])
                .sort(tupleSort(hookType.reverseSort))
                .map(function (tuple) { return tuple.transitionHook; });
        };
        /**
         * Finds all RegisteredHooks from:
         * - The Transition object instance hook registry
         * - The TransitionService ($transitions) global hook registry
         *
         * which matched:
         * - the eventType
         * - the matchCriteria (to, from, exiting, retained, entering)
         *
         * @returns an array of matched [[RegisteredHook]]s
         */
        HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges, transition) {
            var isCreate = hookType.hookPhase === exports.TransitionHookPhase.CREATE;
            // Instance and Global hook registries
            var $transitions = this.transition.router.transitionService;
            var registries = isCreate ? [$transitions] : [this.transition, $transitions];
            return registries
                .map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries
                .filter(assertPredicate(isArray, "broken event named: " + hookType.name)) // Sanity check
                .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
                .filter(function (hook) { return hook.matches(treeChanges, transition); }); // Only those satisfying matchCriteria
        };
        return HookBuilder;
    }());
    /**
     * A factory for a sort function for HookTuples.
     *
     * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
     * the EventHook priority.
     *
     * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
     * @returns a tuple sort function
     */
    function tupleSort(reverseDepthSort) {
        if (reverseDepthSort === void 0) { reverseDepthSort = false; }
        return function nodeDepthThenPriority(l, r) {
            var factor = reverseDepthSort ? -1 : 1;
            var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
            return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
        };
    }

    /** @publicapi @module transition */ /** */
    /** @hidden */
    var stateSelf = prop('self');
    /**
     * Represents a transition between two states.
     *
     * When navigating to a state, we are transitioning **from** the current state **to** the new state.
     *
     * This object contains all contextual information about the to/from states, parameters, resolves.
     * It has information about all states being entered and exited as a result of the transition.
     */
    var Transition = /** @class */ (function () {
        /**
         * Creates a new Transition object.
         *
         * If the target state is not valid, an error is thrown.
         *
         * @internalapi
         *
         * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
         *        encapsulates the "from state".
         * @param targetState The target state and parameters being transitioned to (also, the transition options)
         * @param router The [[UIRouter]] instance
         */
        function Transition(fromPath, targetState, router) {
            var _this = this;
            /** @hidden */
            this._deferred = services.$q.defer();
            /**
             * This promise is resolved or rejected based on the outcome of the Transition.
             *
             * When the transition is successful, the promise is resolved
             * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
             */
            this.promise = this._deferred.promise;
            /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */
            this._registeredHooks = {};
            /** @hidden */
            this._hookBuilder = new HookBuilder(this);
            /** Checks if this transition is currently active/running. */
            this.isActive = function () { return _this.router.globals.transition === _this; };
            this.router = router;
            this._targetState = targetState;
            if (!targetState.valid()) {
                throw new Error(targetState.error());
            }
            // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
            this._options = extend({ current: val(this) }, targetState.options());
            this.$id = router.transitionService._transitionCount++;
            var toPath = PathUtils.buildToPath(fromPath, targetState);
            this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
            this.createTransitionHookRegFns();
            var onCreateHooks = this._hookBuilder.buildHooksForPhase(exports.TransitionHookPhase.CREATE);
            TransitionHook.invokeHooks(onCreateHooks, function () { return null; });
            this.applyViewConfigs(router);
        }
        /** @hidden */
        Transition.prototype.onBefore = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onStart = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onExit = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onRetain = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onEnter = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onFinish = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onSuccess = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onError = function (criteria, callback, options) {
            return;
        };
        /** @hidden
         * Creates the transition-level hook registration functions
         * (which can then be used to register hooks)
         */
        Transition.prototype.createTransitionHookRegFns = function () {
            var _this = this;
            this.router.transitionService._pluginapi
                ._getEvents()
                .filter(function (type) { return type.hookPhase !== exports.TransitionHookPhase.CREATE; })
                .forEach(function (type) { return makeEvent(_this, _this.router.transitionService, type); });
        };
        /** @internalapi */
        Transition.prototype.getHooks = function (hookName) {
            return this._registeredHooks[hookName];
        };
        Transition.prototype.applyViewConfigs = function (router) {
            var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });
            PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
        };
        /**
         * @internalapi
         *
         * @returns the internal from [State] object
         */
        Transition.prototype.$from = function () {
            return tail(this._treeChanges.from).state;
        };
        /**
         * @internalapi
         *
         * @returns the internal to [State] object
         */
        Transition.prototype.$to = function () {
            return tail(this._treeChanges.to).state;
        };
        /**
         * Returns the "from state"
         *
         * Returns the state that the transition is coming *from*.
         *
         * @returns The state declaration object for the Transition's ("from state").
         */
        Transition.prototype.from = function () {
            return this.$from().self;
        };
        /**
         * Returns the "to state"
         *
         * Returns the state that the transition is going *to*.
         *
         * @returns The state declaration object for the Transition's target state ("to state").
         */
        Transition.prototype.to = function () {
            return this.$to().self;
        };
        /**
         * Gets the Target State
         *
         * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
         *
         * @returns the [[TargetState]] of this Transition
         */
        Transition.prototype.targetState = function () {
            return this._targetState;
        };
        /**
         * Determines whether two transitions are equivalent.
         * @deprecated
         */
        Transition.prototype.is = function (compare) {
            if (compare instanceof Transition) {
                // TODO: Also compare parameters
                return this.is({ to: compare.$to().name, from: compare.$from().name });
            }
            return !((compare.to && !matchState(this.$to(), compare.to, this)) ||
                (compare.from && !matchState(this.$from(), compare.from, this)));
        };
        Transition.prototype.params = function (pathname) {
            if (pathname === void 0) { pathname = 'to'; }
            return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));
        };
        Transition.prototype.paramsChanged = function () {
            var fromParams = this.params('from');
            var toParams = this.params('to');
            // All the parameters declared on both the "to" and "from" paths
            var allParamDescriptors = []
                .concat(this._treeChanges.to)
                .concat(this._treeChanges.from)
                .map(function (pathNode) { return pathNode.paramSchema; })
                .reduce(flattenR, [])
                .reduce(uniqR, []);
            var changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);
            return changedParamDescriptors.reduce(function (changedValues, descriptor) {
                changedValues[descriptor.id] = toParams[descriptor.id];
                return changedValues;
            }, {});
        };
        /**
         * Creates a [[UIInjector]] Dependency Injector
         *
         * Returns a Dependency Injector for the Transition's target state (to state).
         * The injector provides resolve values which the target state has access to.
         *
         * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).
         *
         * #### Example:
         * ```js
         * .onEnter({ entering: 'myState' }, trans => {
         *   var myResolveValue = trans.injector().get('myResolve');
         *   // Inject a global service from the global/native injector (if it exists)
         *   var MyService = trans.injector().get('MyService');
         * })
         * ```
         *
         * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.
         * You can use [[UIInjector.getAsync]] to get a promise for the data.
         * #### Example:
         * ```js
         * .onBefore({}, trans => {
         *   return trans.injector().getAsync('myResolve').then(myResolveValue =>
         *     return myResolveValue !== 'ABORT';
         *   });
         * });
         * ```
         *
         * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.
         * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.
         * #### Example:
         * ```js
         * .onEnter({ to: 'foo.bar' }, trans => {
         *   // returns result of `foo` state's `myResolve` resolve
         *   // even though `foo.bar` also has a `myResolve` resolve
         *   var fooData = trans.injector('foo').get('myResolve');
         * });
         * ```
         *
         * If you need resolve data from the exiting states, pass `'from'` as `pathName`.
         * The resolve data from the `from` path will be returned.
         * #### Example:
         * ```js
         * .onExit({ exiting: 'foo.bar' }, trans => {
         *   // Gets the resolve value of `myResolve` from the state being exited
         *   var fooData = trans.injector(null, 'from').get('myResolve');
         * });
         * ```
         *
         *
         * @param state Limits the resolves provided to only the resolves the provided state has access to.
         * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.
         *
         * @returns a [[UIInjector]]
         */
        Transition.prototype.injector = function (state, pathName) {
            if (pathName === void 0) { pathName = 'to'; }
            var path = this._treeChanges[pathName];
            if (state)
                path = PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });
            return new ResolveContext(path).injector();
        };
        /**
         * Gets all available resolve tokens (keys)
         *
         * This method can be used in conjunction with [[injector]] to inspect the resolve values
         * available to the Transition.
         *
         * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
         * in the Transition's [[TreeChanges.to]] path.
         *
         * #### Example:
         * This example logs all resolve values
         * ```js
         * let tokens = trans.getResolveTokens();
         * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
         * ```
         *
         * #### Example:
         * This example creates promises for each resolve value.
         * This triggers fetches of resolves (if any have not yet been fetched).
         * When all promises have all settled, it logs the resolve values.
         * ```js
         * let tokens = trans.getResolveTokens();
         * let promise = tokens.map(token => trans.injector().getAsync(token));
         * Promise.all(promises).then(values => console.log("Resolved values: " + values));
         * ```
         *
         * Note: Angular 1 users whould use `$q.all()`
         *
         * @param pathname resolve context's path name (e.g., `to` or `from`)
         *
         * @returns an array of resolve tokens (keys)
         */
        Transition.prototype.getResolveTokens = function (pathname) {
            if (pathname === void 0) { pathname = 'to'; }
            return new ResolveContext(this._treeChanges[pathname]).getTokens();
        };
        /**
         * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
         *
         * Allows a transition hook to dynamically add a Resolvable to this Transition.
         *
         * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).
         *
         * If a `state` argument is provided, the Resolvable is processed when that state is being entered.
         * If no `state` is provided then the root state is used.
         * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.
         * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.
         *
         * The `state` argument also scopes the resolved data.
         * The resolved data is available from the injector for that `state` and any children states.
         *
         * #### Example:
         * ```js
         * transitionService.onBefore({}, transition => {
         *   transition.addResolvable({
         *     token: 'myResolve',
         *     deps: ['MyService'],
         *     resolveFn: myService => myService.getData()
         *   });
         * });
         * ```
         *
         * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
         * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
         */
        Transition.prototype.addResolvable = function (resolvable, state) {
            if (state === void 0) { state = ''; }
            resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);
            var stateName = typeof state === 'string' ? state : state.name;
            var topath = this._treeChanges.to;
            var targetNode = find(topath, function (node) { return node.state.name === stateName; });
            var resolveContext = new ResolveContext(topath);
            resolveContext.addResolvables([resolvable], targetNode.state);
        };
        /**
         * Gets the transition from which this transition was redirected.
         *
         * If the current transition is a redirect, this method returns the transition that was redirected.
         *
         * #### Example:
         * ```js
         * let transitionA = $state.go('A').transition
         * transitionA.onStart({}, () => $state.target('B'));
         * $transitions.onSuccess({ to: 'B' }, (trans) => {
         *   trans.to().name === 'B'; // true
         *   trans.redirectedFrom() === transitionA; // true
         * });
         * ```
         *
         * @returns The previous Transition, or null if this Transition is not the result of a redirection
         */
        Transition.prototype.redirectedFrom = function () {
            return this._options.redirectedFrom || null;
        };
        /**
         * Gets the original transition in a redirect chain
         *
         * A transition might belong to a long chain of multiple redirects.
         * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
         *
         * #### Example:
         * ```js
         * // states
         * registry.register({ name: 'A', redirectTo: 'B' });
         * registry.register({ name: 'B', redirectTo: 'C' });
         * registry.register({ name: 'C', redirectTo: 'D' });
         * registry.register({ name: 'D' });
         *
         * let transitionA = $state.go('A').transition
         *
         * $transitions.onSuccess({ to: 'D' }, (trans) => {
         *   trans.to().name === 'D'; // true
         *   trans.redirectedFrom().to().name === 'C'; // true
         *   trans.originalTransition() === transitionA; // true
         *   trans.originalTransition().to().name === 'A'; // true
         * });
         * ```
         *
         * @returns The original Transition that started a redirect chain
         */
        Transition.prototype.originalTransition = function () {
            var rf = this.redirectedFrom();
            return (rf && rf.originalTransition()) || this;
        };
        /**
         * Get the transition options
         *
         * @returns the options for this Transition.
         */
        Transition.prototype.options = function () {
            return this._options;
        };
        /**
         * Gets the states being entered.
         *
         * @returns an array of states that will be entered during this transition.
         */
        Transition.prototype.entering = function () {
            return map(this._treeChanges.entering, prop('state')).map(stateSelf);
        };
        /**
         * Gets the states being exited.
         *
         * @returns an array of states that will be exited during this transition.
         */
        Transition.prototype.exiting = function () {
            return map(this._treeChanges.exiting, prop('state'))
                .map(stateSelf)
                .reverse();
        };
        /**
         * Gets the states being retained.
         *
         * @returns an array of states that are already entered from a previous Transition, that will not be
         *    exited during this Transition
         */
        Transition.prototype.retained = function () {
            return map(this._treeChanges.retained, prop('state')).map(stateSelf);
        };
        /**
         * Get the [[ViewConfig]]s associated with this Transition
         *
         * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
         * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
         *
         * @param pathname the name of the path to fetch views for:
         *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
         * @param state If provided, only returns the `ViewConfig`s for a single state in the path
         *
         * @returns a list of ViewConfig objects for the given path.
         */
        Transition.prototype.views = function (pathname, state) {
            if (pathname === void 0) { pathname = 'entering'; }
            var path = this._treeChanges[pathname];
            path = !state ? path : path.filter(propEq('state', state));
            return path
                .map(prop('views'))
                .filter(identity)
                .reduce(unnestR, []);
        };
        Transition.prototype.treeChanges = function (pathname) {
            return pathname ? this._treeChanges[pathname] : this._treeChanges;
        };
        /**
         * Creates a new transition that is a redirection of the current one.
         *
         * This transition can be returned from a [[TransitionService]] hook to
         * redirect a transition to a new state and/or set of parameters.
         *
         * @internalapi
         *
         * @returns Returns a new [[Transition]] instance.
         */
        Transition.prototype.redirect = function (targetState) {
            var redirects = 1, trans = this;
            // tslint:disable-next-line:no-conditional-assignment
            while ((trans = trans.redirectedFrom()) != null) {
                if (++redirects > 20)
                    throw new Error("Too many consecutive Transition redirects (20+)");
            }
            var redirectOpts = { redirectedFrom: this, source: 'redirect' };
            // If the original transition was caused by URL sync, then use { location: 'replace' }
            // on the new transition (unless the target state explicitly specifies location: false).
            // This causes the original url to be replaced with the url for the redirect target
            // so the original url disappears from the browser history.
            if (this.options().source === 'url' && targetState.options().location !== false) {
                redirectOpts.location = 'replace';
            }
            var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);
            targetState = targetState.withOptions(newOptions, true);
            var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
            var originalEnteringNodes = this._treeChanges.entering;
            var redirectEnteringNodes = newTransition._treeChanges.entering;
            // --- Re-use resolve data from original transition ---
            // When redirecting from a parent state to a child state where the parent parameter values haven't changed
            // (because of the redirect), the resolves fetched by the original transition are still valid in the
            // redirected transition.
            //
            // This allows you to define a redirect on a parent state which depends on an async resolve value.
            // You can wait for the resolve, then redirect to a child state based on the result.
            // The redirected transition does not have to re-fetch the resolve.
            // ---------------------------------------------------------
            var nodeIsReloading = function (reloadState) { return function (node) {
                return reloadState && node.state.includes[reloadState.name];
            }; };
            // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
            var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams).filter(not(nodeIsReloading(targetState.options().reloadState)));
            // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
            matchingEnteringNodes.forEach(function (node, idx) {
                node.resolvables = originalEnteringNodes[idx].resolvables;
            });
            return newTransition;
        };
        /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
        Transition.prototype._changedParams = function () {
            var tc = this._treeChanges;
            /** Return undefined if it's not a "dynamic" transition, for the following reasons */
            // If user explicitly wants a reload
            if (this._options.reload)
                return undefined;
            // If any states are exiting or entering
            if (tc.exiting.length || tc.entering.length)
                return undefined;
            // If to/from path lengths differ
            if (tc.to.length !== tc.from.length)
                return undefined;
            // If the to/from paths are different
            var pathsDiffer = arrayTuples(tc.to, tc.from)
                .map(function (tuple) { return tuple[0].state !== tuple[1].state; })
                .reduce(anyTrueR, false);
            if (pathsDiffer)
                return undefined;
            // Find any parameter values that differ
            var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });
            var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];
            var tuples = arrayTuples(nodeSchemas, toValues, fromValues);
            return tuples.map(function (_a) {
                var schema = _a[0], toVals = _a[1], fromVals = _a[2];
                return Param.changed(schema, toVals, fromVals);
            }).reduce(unnestR, []);
        };
        /**
         * Returns true if the transition is dynamic.
         *
         * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
         *
         * @returns true if the Transition is dynamic
         */
        Transition.prototype.dynamic = function () {
            var changes = this._changedParams();
            return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(anyTrueR, false);
        };
        /**
         * Returns true if the transition is ignored.
         *
         * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
         *
         * @returns true if the Transition is ignored.
         */
        Transition.prototype.ignored = function () {
            return !!this._ignoredReason();
        };
        /** @hidden */
        Transition.prototype._ignoredReason = function () {
            var pending = this.router.globals.transition;
            var reloadState = this._options.reloadState;
            var same = function (pathA, pathB) {
                if (pathA.length !== pathB.length)
                    return false;
                var matching = PathUtils.matching(pathA, pathB);
                return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;
            };
            var newTC = this.treeChanges();
            var pendTC = pending && pending.treeChanges();
            if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
                return 'SameAsPending';
            if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
                return 'SameAsCurrent';
        };
        /**
         * Runs the transition
         *
         * This method is generally called from the [[StateService.transitionTo]]
         *
         * @internalapi
         *
         * @returns a promise for a successful transition.
         */
        Transition.prototype.run = function () {
            var _this = this;
            var runAllHooks = TransitionHook.runAllHooks;
            // Gets transition hooks array for the given phase
            var getHooksFor = function (phase) { return _this._hookBuilder.buildHooksForPhase(phase); };
            // When the chain is complete, then resolve or reject the deferred
            var transitionSuccess = function () {
                trace.traceSuccess(_this.$to(), _this);
                _this.success = true;
                _this._deferred.resolve(_this.to());
                runAllHooks(getHooksFor(exports.TransitionHookPhase.SUCCESS));
            };
            var transitionError = function (reason) {
                trace.traceError(reason, _this);
                _this.success = false;
                _this._deferred.reject(reason);
                _this._error = reason;
                runAllHooks(getHooksFor(exports.TransitionHookPhase.ERROR));
            };
            var runTransition = function () {
                // Wait to build the RUN hook chain until the BEFORE hooks are done
                // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
                var allRunHooks = getHooksFor(exports.TransitionHookPhase.RUN);
                var done = function () { return services.$q.when(undefined); };
                return TransitionHook.invokeHooks(allRunHooks, done);
            };
            var startTransition = function () {
                var globals = _this.router.globals;
                globals.lastStartedTransitionId = _this.$id;
                globals.transition = _this;
                globals.transitionHistory.enqueue(_this);
                trace.traceTransitionStart(_this);
                return services.$q.when(undefined);
            };
            var allBeforeHooks = getHooksFor(exports.TransitionHookPhase.BEFORE);
            TransitionHook.invokeHooks(allBeforeHooks, startTransition)
                .then(runTransition)
                .then(transitionSuccess, transitionError);
            return this.promise;
        };
        /**
         * Checks if the Transition is valid
         *
         * @returns true if the Transition is valid
         */
        Transition.prototype.valid = function () {
            return !this.error() || this.success !== undefined;
        };
        /**
         * Aborts this transition
         *
         * Imperative API to abort a Transition.
         * This only applies to Transitions that are not yet complete.
         */
        Transition.prototype.abort = function () {
            // Do not set flag if the transition is already complete
            if (isUndefined(this.success)) {
                this._aborted = true;
            }
        };
        /**
         * The Transition error reason.
         *
         * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
         * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
         *
         * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.
         */
        Transition.prototype.error = function () {
            var state = this.$to();
            if (state.self.abstract) {
                return Rejection.invalid("Cannot transition to abstract state '" + state.name + "'");
            }
            var paramDefs = state.parameters();
            var values = this.params();
            var invalidParams = paramDefs.filter(function (param) { return !param.validates(values[param.id]); });
            if (invalidParams.length) {
                var invalidValues = invalidParams.map(function (param) { return "[" + param.id + ":" + stringify(values[param.id]) + "]"; }).join(', ');
                var detail = "The following parameter values are not valid for state '" + state.name + "': " + invalidValues;
                return Rejection.invalid(detail);
            }
            if (this.success === false)
                return this._error;
        };
        /**
         * A string representation of the Transition
         *
         * @returns A string representation of the Transition
         */
        Transition.prototype.toString = function () {
            var fromStateOrName = this.from();
            var toStateOrName = this.to();
            var avoidEmptyHash = function (params) {
                return params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);
            };
            // (X) means the to state is invalid.
            var id = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))), toValid = this.valid() ? '' : '(X) ', to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = stringify(avoidEmptyHash(this.params()));
            return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
        };
        /** @hidden */
        Transition.diToken = Transition;
        return Transition;
    }());

    /** @publicapi @module url */ /** */
    /** @hidden */
    function quoteRegExp(str, param) {
        var surroundPattern = ['', ''], result = str.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&');
        if (!param)
            return result;
        switch (param.squash) {
            case false:
                surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
                break;
            case true:
                result = result.replace(/\/$/, '');
                surroundPattern = ['(?:/(', ')|/)?'];
                break;
            default:
                surroundPattern = ["(" + param.squash + "|", ')?'];
                break;
        }
        return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
    }
    /** @hidden */
    var memoizeTo = function (obj, _prop, fn) { return (obj[_prop] = obj[_prop] || fn()); };
    /** @hidden */
    var splitOnSlash = splitOnDelim('/');
    /** @hidden */
    var defaultConfig = {
        state: { params: {} },
        strict: true,
        caseInsensitive: true,
    };
    /**
     * Matches URLs against patterns.
     *
     * Matches URLs against patterns and extracts named parameters from the path or the search
     * part of the URL.
     *
     * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
     * parameters. Multiple search parameter names are separated by '&'. Search parameters
     * do not influence whether or not a URL is matched, but their values are passed through into
     * the matched parameters returned by [[UrlMatcher.exec]].
     *
     * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
     * or colon placeholders (`/somePath/:param`).
     *
     * - *A parameter RegExp* may be defined for a param after a colon
     * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
     * The regexp must match for the url to be matched.
     * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
     *
     * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
     *
     * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
     *   See [[UrlMatcherFactory.type]] for more information.
     *
     * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
     *   A catch-all * parameter value will contain the remainder of the URL.
     *
     * ---
     *
     * Parameter names may contain only word characters (latin letters, digits, and underscore) and
     * must be unique within the pattern (across both path and search parameters).
     * A path parameter matches any number of characters other than '/'. For catch-all
     * placeholders the path parameter matches any number of characters.
     *
     * Examples:
     *
     * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
     *   trailing slashes, and patterns have to match the entire path, not just a prefix.
     * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
     *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
     * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
     * * `'/user/{id:[^/]*}'` - Same as the previous example.
     * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
     *   parameter consists of 1 to 8 hex digits.
     * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
     *   path into the parameter 'path'.
     * * `'/files/*path'` - ditto.
     * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
     *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
     *
     */
    var UrlMatcher = /** @class */ (function () {
        /**
         * @param pattern The pattern to compile into a matcher.
         * @param paramTypes The [[ParamTypes]] registry
         * @param paramFactory A [[ParamFactory]] object
         * @param config  A [[UrlMatcherCompileConfig]] configuration object
         */
        function UrlMatcher(pattern, paramTypes, paramFactory, config) {
            var _this = this;
            /** @hidden */
            this._cache = { path: [this] };
            /** @hidden */
            this._children = [];
            /** @hidden */
            this._params = [];
            /** @hidden */
            this._segments = [];
            /** @hidden */
            this._compiled = [];
            this.config = config = defaults(config, defaultConfig);
            this.pattern = pattern;
            // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
            //   '*' name
            //   ':' name
            //   '{' name '}'
            //   '{' name ':' regexp '}'
            // The regular expression is somewhat complicated due to the need to allow curly braces
            // inside the regular expression. The placeholder regexp breaks down as follows:
            //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
            //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
            //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
            //    [^{}\\]+                       - anything other than curly braces or backslash
            //    \\.                            - a backslash escape
            //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
            var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
            var searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
            var patterns = [];
            var last = 0;
            var matchArray;
            var checkParamErrors = function (id) {
                if (!UrlMatcher.nameValidator.test(id))
                    throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
                if (find(_this._params, propEq('id', id)))
                    throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            };
            // Split into static segments separated by path parameter placeholders.
            // The number of segments is always 1 more than the number of parameters.
            var matchDetails = function (m, isSearch) {
                // IE[78] returns '' for unmatched groups instead of null
                var id = m[2] || m[3];
                var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\s\\S]*' : null);
                var makeRegexpType = function (str) {
                    return inherit(paramTypes.type(isSearch ? 'query' : 'path'), {
                        pattern: new RegExp(str, _this.config.caseInsensitive ? 'i' : undefined),
                    });
                };
                return {
                    id: id,
                    regexp: regexp,
                    segment: pattern.substring(last, m.index),
                    type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp),
                };
            };
            var details;
            var segment;
            // tslint:disable-next-line:no-conditional-assignment
            while ((matchArray = placeholder.exec(pattern))) {
                details = matchDetails(matchArray, false);
                if (details.segment.indexOf('?') >= 0)
                    break; // we're into the search part
                checkParamErrors(details.id);
                this._params.push(paramFactory.fromPath(details.id, details.type, config.state));
                this._segments.push(details.segment);
                patterns.push([details.segment, tail(this._params)]);
                last = placeholder.lastIndex;
            }
            segment = pattern.substring(last);
            // Find any search parameter names and remove them from the last segment
            var i = segment.indexOf('?');
            if (i >= 0) {
                var search = segment.substring(i);
                segment = segment.substring(0, i);
                if (search.length > 0) {
                    last = 0;
                    // tslint:disable-next-line:no-conditional-assignment
                    while ((matchArray = searchPlaceholder.exec(search))) {
                        details = matchDetails(matchArray, true);
                        checkParamErrors(details.id);
                        this._params.push(paramFactory.fromSearch(details.id, details.type, config.state));
                        last = placeholder.lastIndex;
                        // check if ?&
                    }
                }
            }
            this._segments.push(segment);
            this._compiled = patterns.map(function (_pattern) { return quoteRegExp.apply(null, _pattern); }).concat(quoteRegExp(segment));
        }
        /** @hidden */
        UrlMatcher.encodeDashes = function (str) {
            // Replace dashes with encoded "\-"
            return encodeURIComponent(str).replace(/-/g, function (c) {
                return "%5C%" + c
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
            });
        };
        /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */
        UrlMatcher.pathSegmentsAndParams = function (matcher) {
            var staticSegments = matcher._segments;
            var pathParams = matcher._params.filter(function (p) { return p.location === exports.DefType.PATH; });
            return arrayTuples(staticSegments, pathParams.concat(undefined))
                .reduce(unnestR, [])
                .filter(function (x) { return x !== '' && isDefined(x); });
        };
        /** @hidden Given a matcher, return an array with the matcher's query params */
        UrlMatcher.queryParams = function (matcher) {
            return matcher._params.filter(function (p) { return p.location === exports.DefType.SEARCH; });
        };
        /**
         * Compare two UrlMatchers
         *
         * This comparison function converts a UrlMatcher into static and dynamic path segments.
         * Each static path segment is a static string between a path separator (slash character).
         * Each dynamic segment is a path parameter.
         *
         * The comparison function sorts static segments before dynamic ones.
         */
        UrlMatcher.compare = function (a, b) {
            /**
             * Turn a UrlMatcher and all its parent matchers into an array
             * of slash literals '/', string literals, and Param objects
             *
             * This example matcher matches strings like "/foo/:param/tail":
             * var matcher = $umf.compile("/foo").append($umf.compile("/:param")).append($umf.compile("/")).append($umf.compile("tail"));
             * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]
             *
             * Caches the result as `matcher._cache.segments`
             */
            var segments = function (matcher) {
                return (matcher._cache.segments =
                    matcher._cache.segments ||
                        matcher._cache.path
                            .map(UrlMatcher.pathSegmentsAndParams)
                            .reduce(unnestR, [])
                            .reduce(joinNeighborsR, [])
                            .map(function (x) { return (isString(x) ? splitOnSlash(x) : x); })
                            .reduce(unnestR, []));
            };
            /**
             * Gets the sort weight for each segment of a UrlMatcher
             *
             * Caches the result as `matcher._cache.weights`
             */
            var weights = function (matcher) {
                return (matcher._cache.weights =
                    matcher._cache.weights ||
                        segments(matcher).map(function (segment) {
                            // Sort slashes first, then static strings, the Params
                            if (segment === '/')
                                return 1;
                            if (isString(segment))
                                return 2;
                            if (segment instanceof Param)
                                return 3;
                        }));
            };
            /**
             * Pads shorter array in-place (mutates)
             */
            var padArrays = function (l, r, padVal) {
                var len = Math.max(l.length, r.length);
                while (l.length < len)
                    l.push(padVal);
                while (r.length < len)
                    r.push(padVal);
            };
            var weightsA = weights(a), weightsB = weights(b);
            padArrays(weightsA, weightsB, 0);
            var _pairs = arrayTuples(weightsA, weightsB);
            var cmp, i;
            for (i = 0; i < _pairs.length; i++) {
                cmp = _pairs[i][0] - _pairs[i][1];
                if (cmp !== 0)
                    return cmp;
            }
            return 0;
        };
        /**
         * Creates a new concatenated UrlMatcher
         *
         * Builds a new UrlMatcher by appending another UrlMatcher to this one.
         *
         * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
         */
        UrlMatcher.prototype.append = function (url) {
            this._children.push(url);
            url._cache = {
                path: this._cache.path.concat(url),
                parent: this,
                pattern: null,
            };
            return url;
        };
        /** @hidden */
        UrlMatcher.prototype.isRoot = function () {
            return this._cache.path[0] === this;
        };
        /** Returns the input pattern string */
        UrlMatcher.prototype.toString = function () {
            return this.pattern;
        };
        /**
         * Tests the specified url/path against this matcher.
         *
         * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
         * parameter values.  Returns null if the path does not match.
         *
         * The returned object contains the values
         * of any search parameters that are mentioned in the pattern, but their value may be null if
         * they are not present in `search`. This means that search parameters are always treated
         * as optional.
         *
         * #### Example:
         * ```js
         * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
         *   x: '1', q: 'hello'
         * });
         * // returns { id: 'bob', q: 'hello', r: null }
         * ```
         *
         * @param path    The URL path to match, e.g. `$location.path()`.
         * @param search  URL search parameters, e.g. `$location.search()`.
         * @param hash    URL hash e.g. `$location.hash()`.
         * @param options
         *
         * @returns The captured parameter values.
         */
        UrlMatcher.prototype.exec = function (path, search, hash, options) {
            var _this = this;
            if (search === void 0) { search = {}; }
            var match = memoizeTo(this._cache, 'pattern', function () {
                return new RegExp([
                    '^',
                    unnest(_this._cache.path.map(prop('_compiled'))).join(''),
                    _this.config.strict === false ? '/?' : '',
                    '$',
                ].join(''), _this.config.caseInsensitive ? 'i' : undefined);
            }).exec(path);
            if (!match)
                return null;
            // options = defaults(options, { isolate: false });
            var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};
            if (nPathSegments !== match.length - 1)
                throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
            function decodePathArray(paramVal) {
                var reverseString = function (str) {
                    return str
                        .split('')
                        .reverse()
                        .join('');
                };
                var unquoteDashes = function (str) { return str.replace(/\\-/g, '-'); };
                var split = reverseString(paramVal).split(/-(?!\\)/);
                var allReversed = map(split, reverseString);
                return map(allReversed, unquoteDashes).reverse();
            }
            for (var i = 0; i < nPathSegments; i++) {
                var param = pathParams[i];
                var value = match[i + 1];
                // if the param value matches a pre-replace pair, replace the value before decoding.
                for (var j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === value)
                        value = param.replace[j].to;
                }
                if (value && param.array === true)
                    value = decodePathArray(value);
                if (isDefined(value))
                    value = param.type.decode(value);
                values[param.id] = param.value(value);
            }
            searchParams.forEach(function (param) {
                var value = search[param.id];
                for (var j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === value)
                        value = param.replace[j].to;
                }
                if (isDefined(value))
                    value = param.type.decode(value);
                values[param.id] = param.value(value);
            });
            if (hash)
                values['#'] = hash;
            return values;
        };
        /**
         * @hidden
         * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
         *
         * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
         *    pattern has no parameters, an empty array is returned.
         */
        UrlMatcher.prototype.parameters = function (opts) {
            if (opts === void 0) { opts = {}; }
            if (opts.inherit === false)
                return this._params;
            return unnest(this._cache.path.map(function (matcher) { return matcher._params; }));
        };
        /**
         * @hidden
         * Returns a single parameter from this UrlMatcher by id
         *
         * @param id
         * @param opts
         * @returns {T|Param|any|boolean|UrlMatcher|null}
         */
        UrlMatcher.prototype.parameter = function (id, opts) {
            var _this = this;
            if (opts === void 0) { opts = {}; }
            var findParam = function () {
                for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                    var param = _a[_i];
                    if (param.id === id)
                        return param;
                }
            };
            var parent = this._cache.parent;
            return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;
        };
        /**
         * Validates the input parameter values against this UrlMatcher
         *
         * Checks an object hash of parameters to validate their correctness according to the parameter
         * types of this `UrlMatcher`.
         *
         * @param params The object hash of parameters to validate.
         * @returns Returns `true` if `params` validates, otherwise `false`.
         */
        UrlMatcher.prototype.validates = function (params) {
            var validParamVal = function (param, val) { return !param || param.validates(val); };
            params = params || {};
            // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
            var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });
            return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(allTrueR, true);
        };
        /**
         * Given a set of parameter values, creates a URL from this UrlMatcher.
         *
         * Creates a URL that matches this pattern by substituting the specified values
         * for the path and search parameters.
         *
         * #### Example:
         * ```js
         * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
         * // returns '/user/bob?q=yes'
         * ```
         *
         * @param values  the values to substitute for the parameters in this pattern.
         * @returns the formatted URL (path and optionally search part).
         */
        UrlMatcher.prototype.format = function (values) {
            if (values === void 0) { values = {}; }
            // Build the full path of UrlMatchers (including all parent UrlMatchers)
            var urlMatchers = this._cache.path;
            // Extract all the static segments and Params (processed as ParamDetails)
            // into an ordered array
            var pathSegmentsAndParams = urlMatchers
                .map(UrlMatcher.pathSegmentsAndParams)
                .reduce(unnestR, [])
                .map(function (x) { return (isString(x) ? x : getDetails(x)); });
            // Extract the query params into a separate array
            var queryParams = urlMatchers
                .map(UrlMatcher.queryParams)
                .reduce(unnestR, [])
                .map(getDetails);
            var isInvalid = function (param) { return param.isValid === false; };
            if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
                return null;
            }
            /**
             * Given a Param, applies the parameter value, then returns detailed information about it
             */
            function getDetails(param) {
                // Normalize to typed value
                var value = param.value(values[param.id]);
                var isValid = param.validates(value);
                var isDefaultValue = param.isDefaultValue(value);
                // Check if we're in squash mode for the parameter
                var squash = isDefaultValue ? param.squash : false;
                // Allow the Parameter's Type to encode the value
                var encoded = param.type.encode(value);
                return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };
            }
            // Build up the path-portion from the list of static segments and parameters
            var pathString = pathSegmentsAndParams.reduce(function (acc, x) {
                // The element is a static segment (a raw string); just append it
                if (isString(x))
                    return acc + x;
                // Otherwise, it's a ParamDetails.
                var squash = x.squash, encoded = x.encoded, param = x.param;
                // If squash is === true, try to remove a slash from the path
                if (squash === true)
                    return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
                // If squash is a string, use the string for the param value
                if (isString(squash))
                    return acc + squash;
                if (squash !== false)
                    return acc; // ?
                if (encoded == null)
                    return acc;
                // If this parameter value is an array, encode the value using encodeDashes
                if (isArray(encoded))
                    return acc + map(encoded, UrlMatcher.encodeDashes).join('-');
                // If the parameter type is "raw", then do not encodeURIComponent
                if (param.raw)
                    return acc + encoded;
                // Encode the value
                return acc + encodeURIComponent(encoded);
            }, '');
            // Build the query string by applying parameter values (array or regular)
            // then mapping to key=value, then flattening and joining using "&"
            var queryString = queryParams
                .map(function (paramDetails) {
                var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
                if (encoded == null || (isDefaultValue && squash !== false))
                    return;
                if (!isArray(encoded))
                    encoded = [encoded];
                if (encoded.length === 0)
                    return;
                if (!param.raw)
                    encoded = map(encoded, encodeURIComponent);
                return encoded.map(function (val) { return param.id + "=" + val; });
            })
                .filter(identity)
                .reduce(unnestR, [])
                .join('&');
            // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
            return pathString + (queryString ? "?" + queryString : '') + (values['#'] ? '#' + values['#'] : '');
        };
        /** @hidden */
        UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
        return UrlMatcher;
    }());

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    /** @internalapi */
    var ParamFactory = /** @class */ (function () {
        function ParamFactory(router) {
            this.router = router;
        }
        ParamFactory.prototype.fromConfig = function (id, type, state) {
            return new Param(id, type, exports.DefType.CONFIG, this.router.urlService.config, state);
        };
        ParamFactory.prototype.fromPath = function (id, type, state) {
            return new Param(id, type, exports.DefType.PATH, this.router.urlService.config, state);
        };
        ParamFactory.prototype.fromSearch = function (id, type, state) {
            return new Param(id, type, exports.DefType.SEARCH, this.router.urlService.config, state);
        };
        return ParamFactory;
    }());
    /**
     * Factory for [[UrlMatcher]] instances.
     *
     * The factory is available to ng1 services as
     * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.
     *
     * @internalapi
     */
    var UrlMatcherFactory = /** @class */ (function () {
        // TODO: move implementations to UrlConfig (urlService.config)
        function UrlMatcherFactory(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @internalapi Creates a new [[Param]] for a given location (DefType) */
            this.paramFactory = new ParamFactory(this.router);
            /** @deprecated use [[UrlConfig.caseInsensitive]] */
            this.caseInsensitive = function (value) { return _this.router.urlService.config.caseInsensitive(value); };
            /** @deprecated use [[UrlConfig.defaultSquashPolicy]] */
            this.defaultSquashPolicy = function (value) { return _this.router.urlService.config.defaultSquashPolicy(value); };
            /** @deprecated use [[UrlConfig.strictMode]] */
            this.strictMode = function (value) { return _this.router.urlService.config.strictMode(value); };
            /** @deprecated use [[UrlConfig.type]] */
            this.type = function (name, definition, definitionFn) {
                return _this.router.urlService.config.type(name, definition, definitionFn) || _this;
            };
            extend(this, { UrlMatcher: UrlMatcher, Param: Param });
        }
        /**
         * Creates a [[UrlMatcher]] for the specified pattern.
         *
         * @param pattern  The URL pattern.
         * @param config  The config object hash.
         * @returns The UrlMatcher.
         */
        UrlMatcherFactory.prototype.compile = function (pattern, config) {
            var urlConfig = this.router.urlService.config;
            // backward-compatible support for config.params -> config.state.params
            var params = config && !config.state && config.params;
            config = params ? __assign({ state: { params: params } }, config) : config;
            var globalConfig = { strict: urlConfig._isStrictMode, caseInsensitive: urlConfig._isCaseInsensitive };
            return new UrlMatcher(pattern, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));
        };
        /**
         * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
         *
         * @param object  The object to perform the type check against.
         * @returns `true` if the object matches the `UrlMatcher` interface, by
         *          implementing all the same methods.
         */
        UrlMatcherFactory.prototype.isMatcher = function (object) {
            // TODO: typeof?
            if (!isObject(object))
                return false;
            var result = true;
            forEach(UrlMatcher.prototype, function (val, name) {
                if (isFunction(val))
                    result = result && (isDefined(object[name]) && isFunction(object[name]));
            });
            return result;
        };
        /** @hidden */
        UrlMatcherFactory.prototype.$get = function () {
            var urlConfig = this.router.urlService.config;
            urlConfig.paramTypes.enqueue = false;
            urlConfig.paramTypes._flushTypeQueue();
            return this;
        };
        return UrlMatcherFactory;
    }());

    /** @publicapi @module url */ /** */
    /**
     * Creates a [[UrlRule]]
     *
     * Creates a [[UrlRule]] from a:
     *
     * - `string`
     * - [[UrlMatcher]]
     * - `RegExp`
     * - [[StateObject]]
     * @internalapi
     */
    var UrlRuleFactory = /** @class */ (function () {
        function UrlRuleFactory(router) {
            this.router = router;
        }
        UrlRuleFactory.prototype.compile = function (str) {
            return this.router.urlMatcherFactory.compile(str);
        };
        UrlRuleFactory.prototype.create = function (what, handler) {
            var _this = this;
            var isState = StateObject.isState;
            var makeRule = pattern([
                [isString, function (_what) { return makeRule(_this.compile(_what)); }],
                [is(UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],
                [isState, function (_what) { return _this.fromState(_what, _this.router); }],
                [is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],
                [isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],
            ]);
            var rule = makeRule(what);
            if (!rule)
                throw new Error("invalid 'what' in when()");
            return rule;
        };
        /**
         * A UrlRule which matches based on a UrlMatcher
         *
         * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
         *
         * ## Handler as a function
         *
         * If `handler` is a function, the function is invoked with:
         *
         * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
         * - url: the current Url ([[UrlParts]])
         * - router: the router object ([[UIRouter]])
         *
         * #### Example:
         * ```js
         * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
         * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match); // '/home/123/456'
         * ```
         *
         * ## Handler as UrlMatcher
         *
         * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
         * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
         * The url is replaced with the result.
         *
         * #### Example:
         * ```js
         * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
         * var handler = $umf.compile("/home/:fooId/:barId");
         * var rule = factory.fromUrlMatcher(urlMatcher, handler);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match); // '/home/123/456'
         * ```
         */
        UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {
            var _handler = handler;
            if (isString(handler))
                handler = this.router.urlMatcherFactory.compile(handler);
            if (is(UrlMatcher)(handler))
                _handler = function (match) { return handler.format(match); };
            function matchUrlParamters(url) {
                var params = urlMatcher.exec(url.path, url.search, url.hash);
                return urlMatcher.validates(params) && params;
            }
            // Prioritize URLs, lowest to highest:
            // - Some optional URL parameters, but none matched
            // - No optional parameters in URL
            // - Some optional parameters, some matched
            // - Some optional parameters, all matched
            function matchPriority(params) {
                var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });
                if (!optional.length)
                    return 0.000001;
                var matched = optional.filter(function (param) { return params[param.id]; });
                return matched.length / optional.length;
            }
            var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: 'URLMATCHER' };
            return extend(new BaseUrlRule(matchUrlParamters, _handler), details);
        };
        /**
         * A UrlRule which matches a state by its url
         *
         * #### Example:
         * ```js
         * var rule = factory.fromState($state.get('foo'), router);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match);
         * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
         * ```
         */
        UrlRuleFactory.prototype.fromState = function (state, router) {
            /**
             * Handles match by transitioning to matched state
             *
             * First checks if the router should start a new transition.
             * A new transition is not required if the current state's URL
             * and the new URL are already identical
             */
            var handler = function (match) {
                var $state = router.stateService;
                var globals = router.globals;
                if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                    $state.transitionTo(state, match, { inherit: true, source: 'url' });
                }
            };
            var details = { state: state, type: 'STATE' };
            return extend(this.fromUrlMatcher(state.url, handler), details);
        };
        /**
         * A UrlRule which matches based on a regular expression
         *
         * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
         *
         * ## Handler as a function
         *
         * If `handler` is a function, the function is invoked with:
         *
         * - regexp match array (from `regexp`)
         * - url: the current Url ([[UrlParts]])
         * - router: the router object ([[UIRouter]])
         *
         * #### Example:
         * ```js
         * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
         * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
         * var result = rule.handler(match); // '/home/bar'
         * ```
         *
         * ## Handler as string
         *
         * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
         * The string is first interpolated using `string.replace()` style pattern.
         *
         * #### Example:
         * ```js
         * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
         * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
         * var result = rule.handler(match); // '/home/bar'
         * ```
         */
        UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {
            if (regexp.global || regexp.sticky)
                throw new Error('Rule RegExp must not be global or sticky');
            /**
             * If handler is a string, the url will be replaced by the string.
             * If the string has any String.replace() style variables in it (like `$2`),
             * they will be replaced by the captures from [[match]]
             */
            var redirectUrlTo = function (match) {
                // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
                return handler.replace(/\$(\$|\d{1,2})/, function (m, what) { return match[what === '$' ? 0 : Number(what)]; });
            };
            var _handler = isString(handler) ? redirectUrlTo : handler;
            var matchParamsFromRegexp = function (url) { return regexp.exec(url.path); };
            var details = { regexp: regexp, type: 'REGEXP' };
            return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);
        };
        UrlRuleFactory.isUrlRule = function (obj) { return obj && ['type', 'match', 'handler'].every(function (key) { return isDefined(obj[key]); }); };
        return UrlRuleFactory;
    }());
    /**
     * A base rule which calls `match`
     *
     * The value from the `match` function is passed through to the `handler`.
     * @internalapi
     */
    var BaseUrlRule = /** @class */ (function () {
        function BaseUrlRule(match, handler) {
            var _this = this;
            this.match = match;
            this.type = 'RAW';
            this.matchPriority = function (match) { return 0 - _this.$id; };
            this.handler = handler || identity;
        }
        return BaseUrlRule;
    }());

    /** @publicapi @module url */ /** */
    /** @hidden */
    function appendBasePath(url, isHtml5, absolute, baseHref) {
        if (baseHref === '/')
            return url;
        if (isHtml5)
            return stripLastPathElement(baseHref) + url;
        if (absolute)
            return baseHref.slice(1) + url;
        return url;
    }
    /**
     * Updates URL and responds to URL changes
     *
     * ### Deprecation warning:
     * This class is now considered to be an internal API
     * Use the [[UrlService]] instead.
     * For configuring URL rules, use the [[UrlRules]] which can be found as [[UrlService.rules]].
     *
     * @internalapi
     */
    var UrlRouter = /** @class */ (function () {
        /** @hidden */
        function UrlRouter(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            // Delegate these calls to [[UrlService]]
            /** @deprecated use [[UrlService.sync]]*/
            this.sync = function (evt) { return _this.router.urlService.sync(evt); };
            /** @deprecated use [[UrlService.listen]]*/
            this.listen = function (enabled) { return _this.router.urlService.listen(enabled); };
            /** @deprecated use [[UrlService.deferIntercept]]*/
            this.deferIntercept = function (defer) { return _this.router.urlService.deferIntercept(defer); };
            /** @deprecated use [[UrlService.match]]*/
            this.match = function (urlParts) { return _this.router.urlService.match(urlParts); };
            // Delegate these calls to [[UrlRules]]
            /** @deprecated use [[UrlRules.initial]]*/
            this.initial = function (handler) {
                return _this.router.urlService.rules.initial(handler);
            };
            /** @deprecated use [[UrlRules.otherwise]]*/
            this.otherwise = function (handler) {
                return _this.router.urlService.rules.otherwise(handler);
            };
            /** @deprecated use [[UrlRules.removeRule]]*/
            this.removeRule = function (rule) { return _this.router.urlService.rules.removeRule(rule); };
            /** @deprecated use [[UrlRules.rule]]*/
            this.rule = function (rule) { return _this.router.urlService.rules.rule(rule); };
            /** @deprecated use [[UrlRules.rules]]*/
            this.rules = function () { return _this.router.urlService.rules.rules(); };
            /** @deprecated use [[UrlRules.sort]]*/
            this.sort = function (compareFn) { return _this.router.urlService.rules.sort(compareFn); };
            /** @deprecated use [[UrlRules.when]]*/
            this.when = function (matcher, handler, options) { return _this.router.urlService.rules.when(matcher, handler, options); };
            this.urlRuleFactory = new UrlRuleFactory(router);
        }
        /**
         * Internal API.
         * @internalapi
         */
        UrlRouter.prototype.update = function (read) {
            var $url = this.router.locationService;
            if (read) {
                this.location = $url.url();
                return;
            }
            if ($url.url() === this.location)
                return;
            $url.url(this.location, true);
        };
        /**
         * Internal API.
         *
         * Pushes a new location to the browser history.
         *
         * @internalapi
         * @param urlMatcher
         * @param params
         * @param options
         */
        UrlRouter.prototype.push = function (urlMatcher, params, options) {
            var replace = options && !!options.replace;
            this.router.urlService.url(urlMatcher.format(params || {}), replace);
        };
        /**
         * Builds and returns a URL with interpolated parameters
         *
         * #### Example:
         * ```js
         * matcher = $umf.compile("/about/:person");
         * params = { person: "bob" };
         * $bob = $urlRouter.href(matcher, params);
         * // $bob == "/about/bob";
         * ```
         *
         * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
         * @param params An object of parameter values to fill the matcher's required parameters.
         * @param options Options object. The options are:
         *
         * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
         *
         * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
         */
        UrlRouter.prototype.href = function (urlMatcher, params, options) {
            var url = urlMatcher.format(params);
            if (url == null)
                return null;
            options = options || { absolute: false };
            var cfg = this.router.urlService.config;
            var isHtml5 = cfg.html5Mode();
            if (!isHtml5 && url !== null) {
                url = '#' + cfg.hashPrefix() + url;
            }
            url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
            if (!options.absolute || !url) {
                return url;
            }
            var slash = !isHtml5 && url ? '/' : '';
            var cfgPort = cfg.port();
            var port = (cfgPort === 80 || cfgPort === 443 ? '' : ':' + cfgPort);
            return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
        };
        Object.defineProperty(UrlRouter.prototype, "interceptDeferred", {
            /** @deprecated use [[UrlService.interceptDeferred]]*/
            get: function () {
                return this.router.urlService.interceptDeferred;
            },
            enumerable: true,
            configurable: true
        });
        return UrlRouter;
    }());

    /** @publicapi @module view */ /** */
    /**
     * The View service
     *
     * This service pairs existing `ui-view` components (which live in the DOM)
     * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
     *
     * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
     *   The views from exited states are deactivated via [[deactivateViewConfig]].
     *   (See: the [[registerActivateViews]] Transition Hook)
     *
     * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].
     *
     * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])
     * are configured with the matching [[ViewConfig]](s)
     *
     */
    var ViewService = /** @class */ (function () {
        /** @hidden */
        function ViewService(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @hidden */ this._uiViews = [];
            /** @hidden */ this._viewConfigs = [];
            /** @hidden */ this._viewConfigFactories = {};
            /** @hidden */ this._listeners = [];
            /** @internalapi */
            this._pluginapi = {
                _rootViewContext: this._rootViewContext.bind(this),
                _viewConfigFactory: this._viewConfigFactory.bind(this),
                _registeredUIView: function (id) { return find(_this._uiViews, function (view) { return _this.router.$id + "." + view.id === id; }); },
                _registeredUIViews: function () { return _this._uiViews; },
                _activeViewConfigs: function () { return _this._viewConfigs; },
                _onSync: function (listener) {
                    _this._listeners.push(listener);
                    return function () { return removeFrom(_this._listeners, listener); };
                },
            };
        }
        /**
         * Normalizes a view's name from a state.views configuration block.
         *
         * This should be used by a framework implementation to calculate the values for
         * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].
         *
         * @param context the context object (state declaration) that the view belongs to
         * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
         *
         * @returns the normalized uiViewName and uiViewContextAnchor that the view targets
         */
        ViewService.normalizeUIViewTarget = function (context, rawViewName) {
            if (rawViewName === void 0) { rawViewName = ''; }
            // TODO: Validate incoming view name with a regexp to allow:
            // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
            // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
            var viewAtContext = rawViewName.split('@');
            var uiViewName = viewAtContext[0] || '$default'; // default to unnamed view
            var uiViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : '^'; // default to parent context
            // Handle relative view-name sugar syntax.
            // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
            var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
            if (relativeViewNameSugar) {
                // Clobbers existing contextAnchor (rawViewName validation will fix this)
                uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
                uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
            }
            if (uiViewName.charAt(0) === '!') {
                uiViewName = uiViewName.substr(1);
                uiViewContextAnchor = ''; // target absolutely from root
            }
            // handle parent relative targeting "^.^.^"
            var relativeMatch = /^(\^(?:\.\^)*)$/;
            if (relativeMatch.exec(uiViewContextAnchor)) {
                var anchorState = uiViewContextAnchor.split('.').reduce(function (anchor, x) { return anchor.parent; }, context);
                uiViewContextAnchor = anchorState.name;
            }
            else if (uiViewContextAnchor === '.') {
                uiViewContextAnchor = context.name;
            }
            return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
        };
        /** @hidden */
        ViewService.prototype._rootViewContext = function (context) {
            return (this._rootContext = context || this._rootContext);
        };
        /** @hidden */
        ViewService.prototype._viewConfigFactory = function (viewType, factory) {
            this._viewConfigFactories[viewType] = factory;
        };
        ViewService.prototype.createViewConfig = function (path, decl) {
            var cfgFactory = this._viewConfigFactories[decl.$type];
            if (!cfgFactory)
                throw new Error('ViewService: No view config factory registered for type ' + decl.$type);
            var cfgs = cfgFactory(path, decl);
            return isArray(cfgs) ? cfgs : [cfgs];
        };
        /**
         * Deactivates a ViewConfig.
         *
         * This function deactivates a `ViewConfig`.
         * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.
         *
         * @param viewConfig The ViewConfig view to deregister.
         */
        ViewService.prototype.deactivateViewConfig = function (viewConfig) {
            trace.traceViewServiceEvent('<- Removing', viewConfig);
            removeFrom(this._viewConfigs, viewConfig);
        };
        ViewService.prototype.activateViewConfig = function (viewConfig) {
            trace.traceViewServiceEvent('-> Registering', viewConfig);
            this._viewConfigs.push(viewConfig);
        };
        ViewService.prototype.sync = function () {
            var _this = this;
            var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(applyPairs, {});
            // Return a weighted depth value for a uiView.
            // The depth is the nesting depth of ui-views (based on FQN; times 10,000)
            // plus the depth of the state that is populating the uiView
            function uiViewDepth(uiView) {
                var stateDepth = function (context) { return (context && context.parent ? stateDepth(context.parent) + 1 : 1); };
                return uiView.fqn.split('.').length * 10000 + stateDepth(uiView.creationContext);
            }
            // Return the ViewConfig's context's depth in the context tree.
            function viewConfigDepth(config) {
                var context = config.viewDecl.$context, count = 0;
                while (++count && context.parent)
                    context = context.parent;
                return count;
            }
            // Given a depth function, returns a compare function which can return either ascending or descending order
            var depthCompare = curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
            var matchingConfigPair = function (uiView) {
                var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
                if (matchingConfigs.length > 1) {
                    // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)
                    // Sort by depth and return the match from the deepest child
                    // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);
                    matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
                }
                return { uiView: uiView, viewConfig: matchingConfigs[0] };
            };
            var configureUIView = function (tuple) {
                // If a parent ui-view is reconfigured, it could destroy child ui-views.
                // Before configuring a child ui-view, make sure it's still in the active uiViews array.
                if (_this._uiViews.indexOf(tuple.uiView) !== -1)
                    tuple.uiView.configUpdated(tuple.viewConfig);
            };
            // Sort views by FQN and state depth. Process uiviews nearest the root first.
            var uiViewTuples = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);
            var matchedViewConfigs = uiViewTuples.map(function (tuple) { return tuple.viewConfig; });
            var unmatchedConfigTuples = this._viewConfigs
                .filter(function (config) { return !inArray(matchedViewConfigs, config); })
                .map(function (viewConfig) { return ({ uiView: undefined, viewConfig: viewConfig }); });
            uiViewTuples.forEach(configureUIView);
            var allTuples = uiViewTuples.concat(unmatchedConfigTuples);
            this._listeners.forEach(function (cb) { return cb(allTuples); });
            trace.traceViewSync(allTuples);
        };
        /**
         * Registers a `ui-view` component
         *
         * When a `ui-view` component is created, it uses this method to register itself.
         * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].
         *
         * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,
         * and what the view's state context is.
         *
         * Note: There is no corresponding `deregisterUIView`.
         *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
         *
         * @param uiView The metadata for a UIView
         * @return a de-registration function used when the view is destroyed.
         */
        ViewService.prototype.registerUIView = function (uiView) {
            trace.traceViewServiceUIViewEvent('-> Registering', uiView);
            var uiViews = this._uiViews;
            var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };
            if (uiViews.filter(fqnAndTypeMatches).length)
                trace.traceViewServiceUIViewEvent('!!!! duplicate uiView named:', uiView);
            uiViews.push(uiView);
            this.sync();
            return function () {
                var idx = uiViews.indexOf(uiView);
                if (idx === -1) {
                    trace.traceViewServiceUIViewEvent('Tried removing non-registered uiView', uiView);
                    return;
                }
                trace.traceViewServiceUIViewEvent('<- Deregistering', uiView);
                removeFrom(uiViews)(uiView);
            };
        };
        /**
         * Returns the list of views currently available on the page, by fully-qualified name.
         *
         * @return {Array} Returns an array of fully-qualified view names.
         */
        ViewService.prototype.available = function () {
            return this._uiViews.map(prop('fqn'));
        };
        /**
         * Returns the list of views on the page containing loaded content.
         *
         * @return {Array} Returns an array of fully-qualified view names.
         */
        ViewService.prototype.active = function () {
            return this._uiViews.filter(prop('$config')).map(prop('name'));
        };
        /**
         * Given a ui-view and a ViewConfig, determines if they "match".
         *
         * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
         * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
         *
         * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
         * can be a segmented ui-view path, describing a portion of a ui-view fqn.
         *
         * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type
         *
         * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
         * - the ui-view's name matches the ViewConfig's target name
         * - the ui-view's context matches the ViewConfig's anchor
         *
         * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
         * - There exists a parent ui-view where:
         *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
         *    - the parent ui-view's context matches the ViewConfig's anchor
         * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
         *
         * Example:
         *
         * DOM:
         * <ui-view>                        <!-- created in the root context (name: "") -->
         *   <ui-view name="foo">                <!-- created in the context named: "A"      -->
         *     <ui-view>                    <!-- created in the context named: "A.B"    -->
         *       <ui-view name="bar">            <!-- created in the context named: "A.B.C"  -->
         *       </ui-view>
         *     </ui-view>
         *   </ui-view>
         * </ui-view>
         *
         * uiViews: [
         *  { fqn: "$default",                  creationContext: { name: "" } },
         *  { fqn: "$default.foo",              creationContext: { name: "A" } },
         *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
         *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
         * ]
         *
         * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
         *
         * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
         * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
         * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
         * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
         *
         * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
         * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
         * - There exists a parent ui-view (which has fqn: "$default.foo") where:
         *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
         *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
         * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
         *   the tail of the ui-view's fqn "default.bar"
         *
         * @internalapi
         */
        ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {
            // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc
            if (uiView.$type !== viewConfig.viewDecl.$type)
                return false;
            // Split names apart from both viewConfig and uiView into segments
            var vc = viewConfig.viewDecl;
            var vcSegments = vc.$uiViewName.split('.');
            var uivSegments = uiView.fqn.split('.');
            // Check if the tails of the segment arrays match. ex, these arrays' tails match:
            // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
            if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
                return false;
            // Now check if the fqn ending at the first segment of the viewConfig matches the context:
            // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
            var negOffset = 1 - vcSegments.length || undefined;
            var fqnToFirstSegment = uivSegments.slice(0, negOffset).join('.');
            var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
            return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
        }; };
        return ViewService;
    }());

    /** @publicapi @module core */ /** */
    /**
     * Global router state
     *
     * This is where we hold the global mutable state such as current state, current
     * params, current transition, etc.
     */
    var UIRouterGlobals = /** @class */ (function () {
        function UIRouterGlobals() {
            /**
             * Current parameter values
             *
             * The parameter values from the latest successful transition
             */
            this.params = new StateParams();
            /** @internalapi */
            this.lastStartedTransitionId = -1;
            /** @internalapi */
            this.transitionHistory = new Queue([], 1);
            /** @internalapi */
            this.successfulTransitions = new Queue([], 1);
        }
        UIRouterGlobals.prototype.dispose = function () {
            this.transitionHistory.clear();
            this.successfulTransitions.clear();
            this.transition = null;
        };
        return UIRouterGlobals;
    }());

    /** @hidden */
    var prioritySort = function (a, b) { return (b.priority || 0) - (a.priority || 0); };
    /** @hidden */
    var typeSort = function (a, b) {
        var weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
        return (weights[a.type] || 0) - (weights[b.type] || 0);
    };
    /** @hidden */
    var urlMatcherSort = function (a, b) {
        return !a.urlMatcher || !b.urlMatcher ? 0 : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);
    };
    /** @hidden */
    var idSort = function (a, b) {
        // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL
        var useMatchPriority = { STATE: true, URLMATCHER: true };
        var equal = useMatchPriority[a.type] && useMatchPriority[b.type];
        return equal ? 0 : (a.$id || 0) - (b.$id || 0);
    };
    /**
     * Default rule priority sorting function.
     *
     * Sorts rules by:
     *
     * - Explicit priority (set rule priority using [[UrlRules.when]])
     * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
     * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
     * - Rule registration order (for rule types other than STATE and URLMATCHER)
     *   - Equally sorted State and UrlMatcher rules will each match the URL.
     *     Then, the *best* match is chosen based on how many parameter values were matched.
     *
     * @publicapi
     */
    var defaultRuleSortFn;
    defaultRuleSortFn = function (a, b) {
        var cmp = prioritySort(a, b);
        if (cmp !== 0)
            return cmp;
        cmp = typeSort(a, b);
        if (cmp !== 0)
            return cmp;
        cmp = urlMatcherSort(a, b);
        if (cmp !== 0)
            return cmp;
        return idSort(a, b);
    };
    /** @hidden */
    function getHandlerFn(handler) {
        if (!isFunction(handler) && !isString(handler) && !is(TargetState)(handler) && !TargetState.isDef(handler)) {
            throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
        }
        return isFunction(handler) ? handler : val(handler);
    }
    /**
     * API for managing URL rules
     *
     * This API is used to create and manage URL rules.
     * URL rules are a mechanism to respond to specific URL patterns.
     *
     * The most commonly used methods are [[otherwise]] and [[when]].
     *
     * This API is a property of [[UrlService]] as [[UrlService.rules]]
     *
     * @publicapi
     */
    var UrlRules = /** @class */ (function () {
        /** @hidden */
        function UrlRules(/** @hidden */ router) {
            this.router = router;
            /** @hidden */ this._sortFn = defaultRuleSortFn;
            /** @hidden */ this._rules = [];
            /** @hidden */ this._id = 0;
            this.urlRuleFactory = new UrlRuleFactory(router);
        }
        /** @hidden */
        UrlRules.prototype.dispose = function (router) {
            this._rules = [];
            delete this._otherwiseFn;
        };
        /**
         * Defines the initial state, path, or behavior to use when the app starts.
         *
         * This rule defines the initial/starting state for the application.
         *
         * This rule is triggered the first time the URL is checked (when the app initially loads).
         * The rule is triggered only when the url matches either `""` or `"/"`.
         *
         * Note: The rule is intended to be used when the root of the application is directly linked to.
         * When the URL is *not* `""` or `"/"` and doesn't match other rules, the [[otherwise]] rule is triggered.
         * This allows 404-like behavior when an unknown URL is deep-linked.
         *
         * #### Example:
         * Start app at `home` state.
         * ```js
         * .initial({ state: 'home' });
         * ```
         *
         * #### Example:
         * Start app at `/home` (by url)
         * ```js
         * .initial('/home');
         * ```
         *
         * #### Example:
         * When no other url rule matches, go to `home` state
         * ```js
         * .initial((matchValue, url, router) => {
         *   console.log('initial state');
         *   return { state: 'home' };
         * })
         * ```
         *
         * @param handler The initial state or url path, or a function which returns the state or url path (or performs custom logic).
         */
        UrlRules.prototype.initial = function (handler) {
            var handlerFn = getHandlerFn(handler);
            var matchFn = function (urlParts, router) {
                return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
            };
            this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
        };
        /**
         * Defines the state, url, or behavior to use when no other rule matches the URL.
         *
         * This rule is matched when *no other rule* matches.
         * It is generally used to handle unknown URLs (similar to "404" behavior, but on the client side).
         *
         * - If `handler` a string, it is treated as a url redirect
         *
         * #### Example:
         * When no other url rule matches, redirect to `/index`
         * ```js
         * .otherwise('/index');
         * ```
         *
         * - If `handler` is an object with a `state` property, the state is activated.
         *
         * #### Example:
         * When no other url rule matches, redirect to `home` and provide a `dashboard` parameter value.
         * ```js
         * .otherwise({ state: 'home', params: { dashboard: 'default' } });
         * ```
         *
         * - If `handler` is a function, the function receives the current url ([[UrlParts]]) and the [[UIRouter]] object.
         *   The function can perform actions, and/or return a value.
         *
         * #### Example:
         * When no other url rule matches, manually trigger a transition to the `home` state
         * ```js
         * .otherwise((matchValue, urlParts, router) => {
         *   router.stateService.go('home');
         * });
         * ```
         *
         * #### Example:
         * When no other url rule matches, go to `home` state
         * ```js
         * .otherwise((matchValue, urlParts, router) => {
         *   return { state: 'home' };
         * });
         * ```
         *
         * @param handler The url path to redirect to, or a function which returns the url path (or performs custom logic).
         */
        UrlRules.prototype.otherwise = function (handler) {
            var handlerFn = getHandlerFn(handler);
            this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);
            this._sorted = false;
        };
        /**
         * Remove a rule previously registered
         *
         * @param rule the matcher rule that was previously registered using [[rule]]
         */
        UrlRules.prototype.removeRule = function (rule) {
            removeFrom(this._rules, rule);
        };
        /**
         * Manually adds a URL Rule.
         *
         * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
         * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
         * Rules can be created using [[urlRuleFactory]], or created manually as simple objects.
         *
         * A rule should have a `match` function which returns truthy if the rule matched.
         * It should also have a `handler` function which is invoked if the rule is the best match.
         *
         * @return a function that deregisters the rule
         */
        UrlRules.prototype.rule = function (rule) {
            var _this = this;
            if (!UrlRuleFactory.isUrlRule(rule))
                throw new Error('invalid rule');
            rule.$id = this._id++;
            rule.priority = rule.priority || 0;
            this._rules.push(rule);
            this._sorted = false;
            return function () { return _this.removeRule(rule); };
        };
        /**
         * Gets all registered rules
         *
         * @returns an array of all the registered rules
         */
        UrlRules.prototype.rules = function () {
            this.ensureSorted();
            return this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : []);
        };
        /**
         * Defines URL Rule priorities
         *
         * More than one rule ([[UrlRule]]) might match a given URL.
         * This `compareFn` is used to sort the rules by priority.
         * Higher priority rules should sort earlier.
         *
         * The [[defaultRuleSortFn]] is used by default.
         *
         * You only need to call this function once.
         * The `compareFn` will be used to sort the rules as each is registered.
         *
         * If called without any parameter, it will re-sort the rules.
         *
         * ---
         *
         * Url rules may come from multiple sources: states's urls ([[StateDeclaration.url]]), [[when]], and [[rule]].
         * Each rule has a (user-provided) [[UrlRule.priority]], a [[UrlRule.type]], and a [[UrlRule.$id]]
         * The `$id` is is the order in which the rule was registered.
         *
         * The sort function should use these data, or data found on a specific type
         * of [[UrlRule]] (such as [[StateRule.state]]), to order the rules as desired.
         *
         * #### Example:
         * This compare function prioritizes rules by the order in which the rules were registered.
         * A rule registered earlier has higher priority.
         *
         * ```js
         * function compareFn(a, b) {
         *   return a.$id - b.$id;
         * }
         * ```
         *
         * @param compareFn a function that compares to [[UrlRule]] objects.
         *    The `compareFn` should abide by the `Array.sort` compare function rules.
         *    Given two rules, `a` and `b`, return a negative number if `a` should be higher priority.
         *    Return a positive number if `b` should be higher priority.
         *    Return `0` if the rules are identical.
         *
         *    See the [mozilla reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description)
         *    for details.
         */
        UrlRules.prototype.sort = function (compareFn) {
            var sorted = this.stableSort(this._rules, (this._sortFn = compareFn || this._sortFn));
            // precompute _sortGroup values and apply to each rule
            var group = 0;
            for (var i = 0; i < sorted.length; i++) {
                sorted[i]._group = group;
                if (i < sorted.length - 1 && this._sortFn(sorted[i], sorted[i + 1]) !== 0) {
                    group++;
                }
            }
            this._rules = sorted;
            this._sorted = true;
        };
        /** @hidden */
        UrlRules.prototype.ensureSorted = function () {
            this._sorted || this.sort();
        };
        /** @hidden */
        UrlRules.prototype.stableSort = function (arr, compareFn) {
            var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });
            arrOfWrapper.sort(function (wrapperA, wrapperB) {
                var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
                return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
            });
            return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });
        };
        /**
         * Registers a `matcher` and `handler` for custom URLs handling.
         *
         * The `matcher` can be:
         *
         * - a [[UrlMatcher]]: See: [[UrlMatcherFactory.compile]]
         * - a `string`: The string is compiled to a [[UrlMatcher]]
         * - a `RegExp`: The regexp is used to match the url.
         *
         * The `handler` can be:
         *
         * - a string: The url is redirected to the value of the string.
         * - a function: The url is redirected to the return value of the function.
         *
         * ---
         *
         * When the `handler` is a `string` and the `matcher` is a `UrlMatcher` (or string), the redirect
         * string is interpolated with parameter values.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when("/foo/:param1", "/bar/:param1")
         * ```
         *
         * ---
         *
         * When the `handler` is a string and the `matcher` is a `RegExp`, the redirect string is
         * interpolated with capture groups from the RegExp.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when(new RegExp("^/foo/(.*)$"), "/bar/$1");
         * ```
         *
         * ---
         *
         * When the handler is a function, it receives the matched value, the current URL, and the `UIRouter` object (See [[UrlRuleHandlerFn]]).
         * The "matched value" differs based on the `matcher`.
         * For [[UrlMatcher]]s, it will be the matched state params.
         * For `RegExp`, it will be the match array from `regexp.exec()`.
         *
         * If the handler returns a string, the URL is redirected to the string.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when(new RegExp("^/foo/(.*)$"), match => "/bar/" + match[1]);
         * ```
         *
         * Note: the `handler` may also invoke arbitrary code, such as `$state.go()`
         *
         * @param matcher A pattern `string` to match, compiled as a [[UrlMatcher]], or a `RegExp`.
         * @param handler The path to redirect to, or a function that returns the path.
         * @param options `{ priority: number }`
         *
         * @return the registered [[UrlRule]]
         */
        UrlRules.prototype.when = function (matcher, handler, options) {
            var rule = this.urlRuleFactory.create(matcher, handler);
            if (isDefined(options && options.priority))
                rule.priority = options.priority;
            this.rule(rule);
            return rule;
        };
        return UrlRules;
    }());

    /**
     * An API to customize the URL behavior and retrieve URL configuration
     *
     * This API is used to customize the behavior of the URL.
     * This includes optional trailing slashes ([[strictMode]]), case sensitivity ([[caseInsensitive]]),
     * and custom parameter encoding (custom [[type]]).
     *
     * It also has information about the location (url) configuration such as [[port]] and [[baseHref]].
     * This information can be used to build absolute URLs, such as
     * `https://example.com:443/basepath/state/substate?param1=a#hashvalue`;
     *
     * This API is a property of [[UrlService]] as [[UrlService.config]].
     */
    var UrlConfig = /** @class */ (function () {
        /** @hidden */ function UrlConfig(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @hidden */ this.paramTypes = new ParamTypes();
            /** @hidden */ this._isCaseInsensitive = false;
            /** @hidden */ this._isStrictMode = true;
            /** @hidden */ this._defaultSquashPolicy = false;
            /** @internalapi */ this.dispose = function () { return _this.paramTypes.dispose(); };
            // Delegate these calls to the current LocationConfig implementation
            /**
             * Gets the base Href, e.g., `http://localhost/approot/`
             *
             * @return the application's base href
             */
            this.baseHref = function () { return _this.router.locationConfig.baseHref(); };
            /**
             * Gets or sets the hashPrefix
             *
             * This only applies when not running in [[html5Mode]] (pushstate mode)
             *
             * If the current url is `http://localhost/app#!/uirouter/path/#anchor`, it returns `!` which is the prefix for the "hashbang" portion.
             *
             * @return the hash prefix
             */
            this.hashPrefix = function (newprefix) { return _this.router.locationConfig.hashPrefix(newprefix); };
            /**
             * Gets the host, e.g., `localhost`
             *
             * @return the protocol
             */
            this.host = function () { return _this.router.locationConfig.host(); };
            /**
             * Returns true when running in pushstate mode
             *
             * @return true when running in html5 mode (pushstate mode).
             */
            this.html5Mode = function () { return _this.router.locationConfig.html5Mode(); };
            /**
             * Gets the port, e.g., `80`
             *
             * @return the port number
             */
            this.port = function () { return _this.router.locationConfig.port(); };
            /**
             * Gets the protocol, e.g., `http`
             *
             * @return the protocol
             */
            this.protocol = function () { return _this.router.locationConfig.protocol(); };
        }
        /**
         * Defines whether URL matching should be case sensitive (the default behavior), or not.
         *
         * #### Example:
         * ```js
         * // Allow case insensitive url matches
         * urlService.config.caseInsensitive(true);
         * ```
         *
         * @param value `false` to match URL in a case sensitive manner; otherwise `true`;
         * @returns the current value of caseInsensitive
         */
        UrlConfig.prototype.caseInsensitive = function (value) {
            return (this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive);
        };
        /**
         * Sets the default behavior when generating or matching URLs with default parameter values.
         *
         * #### Example:
         * ```js
         * // Remove default parameter values from the url
         * urlService.config.defaultSquashPolicy(true);
         * ```
         *
         * @param value A string that defines the default parameter URL squashing behavior.
         *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
         *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
         *      parameter is surrounded by slashes, squash (remove) one slash from the URL
         *    - any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
         *      the parameter value from the URL and replace it with this string.
         * @returns the current value of defaultSquashPolicy
         */
        UrlConfig.prototype.defaultSquashPolicy = function (value) {
            if (isDefined(value) && value !== true && value !== false && !isString(value))
                throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return (this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy);
        };
        /**
         * Defines whether URLs should match trailing slashes, or not (the default behavior).
         *
         * #### Example:
         * ```js
         * // Allow optional trailing slashes
         * urlService.config.strictMode(false);
         * ```
         *
         * @param value `false` to match trailing slashes in URLs, otherwise `true`.
         * @returns the current value of strictMode
         */
        UrlConfig.prototype.strictMode = function (value) {
            return (this._isStrictMode = isDefined(value) ? value : this._isStrictMode);
        };
        /**
         * Creates and registers a custom [[ParamType]] object
         *
         * A custom parameter type can be used to generate URLs with typed parameters or custom encoding/decoding.
         *
         * #### Note: Register custom types *before using them* in a state definition.
         *
         * #### Example:
         * ```js
         * // Encode object parameter as JSON string
         * urlService.config.type('myjson', {
         *   encode: (obj) => JSON.stringify(obj),
         *   decode: (str) => JSON.parse(str),
         *   is: (val) => typeof(val) === 'object',
         *   pattern: /[^/]+/,
         *   equals: (a, b) => _.isEqual(a, b),
         * });
         * ```
         *
         * See [[ParamTypeDefinition]] for more examples
         *
         * @param name The type name.
         * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
         * @param definitionFn A function that is injected before the app runtime starts.
         *        The result of this function should be a [[ParamTypeDefinition]].
         *        The result is merged into the existing `definition`.
         *        See [[ParamType]] for information on the values accepted.
         *
         * @returns if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
         */
        UrlConfig.prototype.type = function (name, definition, definitionFn) {
            var type = this.paramTypes.type(name, definition, definitionFn);
            return !isDefined(definition) ? type : this;
        };
        return UrlConfig;
    }());

    /** API for URL management */
    var UrlService = /** @class */ (function () {
        /** @hidden */
        function UrlService(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @hidden */ this.interceptDeferred = false;
            /**
             * The nested [[UrlRules]] API for managing URL rules and rewrites
             *
             * See: [[UrlRules]] for details
             */
            this.rules = new UrlRules(this.router);
            /**
             * The nested [[UrlConfig]] API to configure the URL and retrieve URL information
             *
             * See: [[UrlConfig]] for details
             */
            this.config = new UrlConfig(this.router);
            // Delegate these calls to the current LocationServices implementation
            /**
             * Gets the current url, or updates the url
             *
             * ### Getting the current URL
             *
             * When no arguments are passed, returns the current URL.
             * The URL is normalized using the internal [[path]]/[[search]]/[[hash]] values.
             *
             * For example, the URL may be stored in the hash ([[HashLocationServices]]) or
             * have a base HREF prepended ([[PushStateLocationServices]]).
             *
             * The raw URL in the browser might be:
             *
             * ```
             * http://mysite.com/somepath/index.html#/internal/path/123?param1=foo#anchor
             * ```
             *
             * or
             *
             * ```
             * http://mysite.com/basepath/internal/path/123?param1=foo#anchor
             * ```
             *
             * then this method returns:
             *
             * ```
             * /internal/path/123?param1=foo#anchor
             * ```
             *
             *
             * #### Example:
             * ```js
             * locationServices.url(); // "/some/path?query=value#anchor"
             * ```
             *
             * ### Updating the URL
             *
             * When `newurl` arguments is provided, changes the URL to reflect `newurl`
             *
             * #### Example:
             * ```js
             * locationServices.url("/some/path?query=value#anchor", true);
             * ```
             *
             * @param newurl The new value for the URL.
             *               This url should reflect only the new internal [[path]], [[search]], and [[hash]] values.
             *               It should not include the protocol, site, port, or base path of an absolute HREF.
             * @param replace When true, replaces the current history entry (instead of appending it) with this new url
             * @param state The history's state object, i.e., pushState (if the LocationServices implementation supports it)
             *
             * @return the url (after potentially being processed)
             */
            this.url = function (newurl, replace, state) {
                return _this.router.locationService.url(newurl, replace, state);
            };
            /**
             * Gets the path part of the current url
             *
             * If the current URL is `/some/path?query=value#anchor`, this returns `/some/path`
             *
             * @return the path portion of the url
             */
            this.path = function () { return _this.router.locationService.path(); };
            /**
             * Gets the search part of the current url as an object
             *
             * If the current URL is `/some/path?query=value#anchor`, this returns `{ query: 'value' }`
             *
             * @return the search (query) portion of the url, as an object
             */
            this.search = function () { return _this.router.locationService.search(); };
            /**
             * Gets the hash part of the current url
             *
             * If the current URL is `/some/path?query=value#anchor`, this returns `anchor`
             *
             * @return the hash (anchor) portion of the url
             */
            this.hash = function () { return _this.router.locationService.hash(); };
            /**
             * @internalapi
             *
             * Registers a low level url change handler
             *
             * Note: Because this is a low level handler, it's not recommended for general use.
             *
             * #### Example:
             * ```js
             * let deregisterFn = locationServices.onChange((evt) => console.log("url change", evt));
             * ```
             *
             * @param callback a function that will be called when the url is changing
             * @return a function that de-registers the callback
             */
            this.onChange = function (callback) { return _this.router.locationService.onChange(callback); };
        }
        /** @hidden */
        UrlService.prototype.dispose = function () {
            this.listen(false);
            this.rules.dispose();
        };
        /**
         * Gets the current URL parts
         *
         * This method returns the different parts of the current URL (the [[path]], [[search]], and [[hash]]) as a [[UrlParts]] object.
         */
        UrlService.prototype.parts = function () {
            return { path: this.path(), search: this.search(), hash: this.hash() };
        };
        /**
         * Activates the best rule for the current URL
         *
         * Checks the current URL for a matching [[UrlRule]], then invokes that rule's handler.
         * This method is called internally any time the URL has changed.
         *
         * This effectively activates the state (or redirect, etc) which matches the current URL.
         *
         * #### Example:
         * ```js
         * urlService.deferIntercept();
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   urlService.listen();
         *   // Find the matching URL and invoke the handler.
         *   urlService.sync();
         * });
         * ```
         */
        UrlService.prototype.sync = function (evt) {
            if (evt && evt.defaultPrevented)
                return;
            var _a = this.router, urlService = _a.urlService, stateService = _a.stateService;
            var url = { path: urlService.path(), search: urlService.search(), hash: urlService.hash() };
            var best = this.match(url);
            var applyResult = pattern([
                [isString, function (newurl) { return urlService.url(newurl, true); }],
                [TargetState.isDef, function (def) { return stateService.go(def.state, def.params, def.options); }],
                [is(TargetState), function (target) { return stateService.go(target.state(), target.params(), target.options()); }],
            ]);
            applyResult(best && best.rule.handler(best.match, url, this.router));
        };
        /**
         * Starts or stops listening for URL changes
         *
         * Call this sometime after calling [[deferIntercept]] to start monitoring the url.
         * This causes UI-Router to start listening for changes to the URL, if it wasn't already listening.
         *
         * If called with `false`, UI-Router will stop listening (call listen(true) to start listening again).
         *
         * #### Example:
         * ```js
         * urlService.deferIntercept();
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   // Start responding to URL changes
         *   urlService.listen();
         *   urlService.sync();
         * });
         * ```
         *
         * @param enabled `true` or `false` to start or stop listening to URL changes
         */
        UrlService.prototype.listen = function (enabled) {
            var _this = this;
            if (enabled === false) {
                this._stopListeningFn && this._stopListeningFn();
                delete this._stopListeningFn;
            }
            else {
                return (this._stopListeningFn = this._stopListeningFn || this.router.urlService.onChange(function (evt) { return _this.sync(evt); }));
            }
        };
        /**
         * Disables monitoring of the URL.
         *
         * Call this method before UI-Router has bootstrapped.
         * It will stop UI-Router from performing the initial url sync.
         *
         * This can be useful to perform some asynchronous initialization before the router starts.
         * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.
         *
         * #### Example:
         * ```js
         * // Prevent UI-Router from automatically intercepting URL changes when it starts;
         * urlService.deferIntercept();
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   urlService.listen();
         *   urlService.sync();
         * });
         * ```
         *
         * @param defer Indicates whether to defer location change interception.
         *        Passing no parameter is equivalent to `true`.
         */
        UrlService.prototype.deferIntercept = function (defer) {
            if (defer === undefined)
                defer = true;
            this.interceptDeferred = defer;
        };
        /**
         * Matches a URL
         *
         * Given a URL (as a [[UrlParts]] object), check all rules and determine the best matching rule.
         * Return the result as a [[MatchResult]].
         */
        UrlService.prototype.match = function (url) {
            var _this = this;
            url = extend({ path: '', search: {}, hash: '' }, url);
            var rules = this.rules.rules();
            // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
            var checkRule = function (rule) {
                var match = rule.match(url, _this.router);
                return match && { match: match, rule: rule, weight: rule.matchPriority(match) };
            };
            // The rules are pre-sorted.
            // - Find the first matching rule.
            // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
            // - Choose the rule with the highest match weight.
            var best;
            for (var i = 0; i < rules.length; i++) {
                // Stop when there is a 'best' rule and the next rule sorts differently than it.
                if (best && best.rule._group !== rules[i]._group)
                    break;
                var current = checkRule(rules[i]);
                // Pick the best MatchResult
                best = !best || (current && current.weight > best.weight) ? current : best;
            }
            return best;
        };
        return UrlService;
    }());

    /** @publicapi @module core */ /** */
    /** @hidden */
    var _routerInstance = 0;
    /** @hidden */
    var locSvcFns = ['url', 'path', 'search', 'hash', 'onChange'];
    /** @hidden */
    var locCfgFns = ['port', 'protocol', 'host', 'baseHref', 'html5Mode', 'hashPrefix'];
    /** @hidden */
    var locationServiceStub = makeStub('LocationServices', locSvcFns);
    /** @hidden */
    var locationConfigStub = makeStub('LocationConfig', locCfgFns);
    /**
     * The master class used to instantiate an instance of UI-Router.
     *
     * UI-Router (for each specific framework) will create an instance of this class during bootstrap.
     * This class instantiates and wires the UI-Router services together.
     *
     * After a new instance of the UIRouter class is created, it should be configured for your app.
     * For instance, app states should be registered with the [[UIRouter.stateRegistry]].
     *
     * ---
     *
     * Normally the framework code will bootstrap UI-Router.
     * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling
     * [[UrlService.listen]] then [[UrlService.sync]].
     */
    var UIRouter = /** @class */ (function () {
        /**
         * Creates a new `UIRouter` object
         *
         * @param locationService a [[LocationServices]] implementation
         * @param locationConfig a [[LocationConfig]] implementation
         * @internalapi
         */
        function UIRouter(locationService, locationConfig) {
            if (locationService === void 0) { locationService = locationServiceStub; }
            if (locationConfig === void 0) { locationConfig = locationConfigStub; }
            this.locationService = locationService;
            this.locationConfig = locationConfig;
            /** @hidden */ this.$id = _routerInstance++;
            /** @hidden */ this._disposed = false;
            /** @hidden */ this._disposables = [];
            /** Provides trace information to the console */
            this.trace = trace;
            /** Provides services related to ui-view synchronization */
            this.viewService = new ViewService(this);
            /** Global router state */
            this.globals = new UIRouterGlobals();
            /** Provides services related to Transitions */
            this.transitionService = new TransitionService(this);
            /**
             * Deprecated for public use. Use [[urlService]] instead.
             * @deprecated Use [[urlService]] instead
             */
            this.urlMatcherFactory = new UrlMatcherFactory(this);
            /**
             * Deprecated for public use. Use [[urlService]] instead.
             * @deprecated Use [[urlService]] instead
             */
            this.urlRouter = new UrlRouter(this);
            /** Provides services related to the URL */
            this.urlService = new UrlService(this);
            /** Provides a registry for states, and related registration services */
            this.stateRegistry = new StateRegistry(this);
            /** Provides services related to states */
            this.stateService = new StateService(this);
            /** @hidden plugin instances are registered here */
            this._plugins = {};
            this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
            this.globals.$current = this.stateRegistry.root();
            this.globals.current = this.globals.$current.self;
            this.disposable(this.globals);
            this.disposable(this.stateService);
            this.disposable(this.stateRegistry);
            this.disposable(this.transitionService);
            this.disposable(this.urlService);
            this.disposable(locationService);
            this.disposable(locationConfig);
        }
        /** Registers an object to be notified when the router is disposed */
        UIRouter.prototype.disposable = function (disposable) {
            this._disposables.push(disposable);
        };
        /**
         * Disposes this router instance
         *
         * When called, clears resources retained by the router by calling `dispose(this)` on all
         * registered [[disposable]] objects.
         *
         * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.
         *
         * @param disposable (optional) the disposable to dispose
         */
        UIRouter.prototype.dispose = function (disposable) {
            var _this = this;
            if (disposable && isFunction(disposable.dispose)) {
                disposable.dispose(this);
                return undefined;
            }
            this._disposed = true;
            this._disposables.slice().forEach(function (d) {
                try {
                    typeof d.dispose === 'function' && d.dispose(_this);
                    removeFrom(_this._disposables, d);
                }
                catch (ignored) { }
            });
        };
        /**
         * Adds a plugin to UI-Router
         *
         * This method adds a UI-Router Plugin.
         * A plugin can enhance or change UI-Router behavior using any public API.
         *
         * #### Example:
         * ```js
         * import { MyCoolPlugin } from "ui-router-cool-plugin";
         *
         * var plugin = router.addPlugin(MyCoolPlugin);
         * ```
         *
         * ### Plugin authoring
         *
         * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.
         *
         * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].
         * For example, it may configure router options or add a Transition Hook.
         *
         * The plugin can then be published as a separate module.
         *
         * #### Example:
         * ```js
         * export class MyAuthPlugin implements UIRouterPlugin {
         *   constructor(router: UIRouter, options: any) {
         *     this.name = "MyAuthPlugin";
         *     let $transitions = router.transitionService;
         *     let $state = router.stateService;
         *
         *     let authCriteria = {
         *       to: (state) => state.data && state.data.requiresAuth
         *     };
         *
         *     function authHook(transition: Transition) {
         *       let authService = transition.injector().get('AuthService');
         *       if (!authService.isAuthenticated()) {
         *         return $state.target('login');
         *       }
         *     }
         *
         *     $transitions.onStart(authCriteria, authHook);
         *   }
         * }
         * ```
         *
         * @param plugin one of:
         *        - a plugin class which implements [[UIRouterPlugin]]
         *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance
         *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance
         * @param options options to pass to the plugin class/factory
         * @returns the registered plugin instance
         */
        UIRouter.prototype.plugin = function (plugin, options) {
            if (options === void 0) { options = {}; }
            var pluginInstance = new plugin(this, options);
            if (!pluginInstance.name)
                throw new Error('Required property `name` missing on plugin: ' + pluginInstance);
            this._disposables.push(pluginInstance);
            return (this._plugins[pluginInstance.name] = pluginInstance);
        };
        UIRouter.prototype.getPlugin = function (pluginName) {
            return pluginName ? this._plugins[pluginName] : values(this._plugins);
        };
        return UIRouter;
    }());

    /** @internalapi @module hooks */ /** */
    function addCoreResolvables(trans) {
        trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');
        trans.addResolvable(Resolvable.fromData(Transition, trans), '');
        trans.addResolvable(Resolvable.fromData('$transition$', trans), '');
        trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');
        trans.entering().forEach(function (state) {
            trans.addResolvable(Resolvable.fromData('$state$', state), state);
        });
    }
    var registerAddCoreResolvables = function (transitionService) {
        return transitionService.onCreate({}, addCoreResolvables);
    };
    var TRANSITION_TOKENS = ['$transition$', Transition];
    var isTransition = inArray(TRANSITION_TOKENS);
    // References to Transition in the treeChanges pathnodes makes all
    // previous Transitions reachable in memory, causing a memory leak
    // This function removes resolves for '$transition$' and `Transition` from the treeChanges.
    // Do not use this on current transitions, only on old ones.
    var treeChangesCleanup = function (trans) {
        var nodes = values(trans.treeChanges())
            .reduce(unnestR, [])
            .reduce(uniqR, []);
        // If the resolvable is a Transition, return a new resolvable with null data
        var replaceTransitionWithNull = function (r) {
            return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;
        };
        nodes.forEach(function (node) {
            node.resolvables = node.resolvables.map(replaceTransitionWithNull);
        });
    };

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] that redirects to a different state or params
     *
     * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
     *
     * See [[StateDeclaration.redirectTo]]
     */
    var redirectToHook = function (trans) {
        var redirect = trans.to().redirectTo;
        if (!redirect)
            return;
        var $state = trans.router.stateService;
        function handleResult(result) {
            if (!result)
                return;
            if (result instanceof TargetState)
                return result;
            if (isString(result))
                return $state.target(result, trans.params(), trans.options());
            if (result['state'] || result['params'])
                return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());
        }
        if (isFunction(redirect)) {
            return services.$q.when(redirect(trans)).then(handleResult);
        }
        return handleResult(redirect);
    };
    var registerRedirectToHook = function (transitionService) {
        return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);
    };

    /**
     * A factory which creates an onEnter, onExit or onRetain transition hook function
     *
     * The returned function invokes the (for instance) state.onEnter hook when the
     * state is being entered.
     *
     * @hidden
     */
    function makeEnterExitRetainHook(hookName) {
        return function (transition, state) {
            var _state = state.$$state();
            var hookFn = _state[hookName];
            return hookFn(transition, state);
        };
    }
    /**
     * The [[TransitionStateHookFn]] for onExit
     *
     * When the state is being exited, the state's .onExit function is invoked.
     *
     * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
     *
     * See: [[IHookRegistry.onExit]]
     */
    var onExitHook = makeEnterExitRetainHook('onExit');
    var registerOnExitHook = function (transitionService) {
        return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);
    };
    /**
     * The [[TransitionStateHookFn]] for onRetain
     *
     * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
     *
     * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
     *
     * See: [[IHookRegistry.onRetain]]
     */
    var onRetainHook = makeEnterExitRetainHook('onRetain');
    var registerOnRetainHook = function (transitionService) {
        return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);
    };
    /**
     * The [[TransitionStateHookFn]] for onEnter
     *
     * When the state is being entered, the state's .onEnter function is invoked.
     *
     * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
     *
     * See: [[IHookRegistry.onEnter]]
     */
    var onEnterHook = makeEnterExitRetainHook('onEnter');
    var registerOnEnterHook = function (transitionService) {
        return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);
    };

    /** @internalapi @module hooks */ /** */
    var RESOLVE_HOOK_PRIORITY = 1000;
    /**
     * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
     *
     * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`
     *
     * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
     *
     * See [[StateDeclaration.resolve]]
     */
    var eagerResolvePath = function (trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);
    };
    var registerEagerResolvePath = function (transitionService) {
        return transitionService.onStart({}, eagerResolvePath, { priority: RESOLVE_HOOK_PRIORITY });
    };
    /**
     * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
     *
     * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`
     *
     * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
     *
     * See [[StateDeclaration.resolve]]
     */
    var lazyResolveState = function (trans, state) {
        return new ResolveContext(trans.treeChanges().to)
            .subContext(state.$$state())
            .resolvePath('LAZY', trans)
            .then(noop);
    };
    var registerLazyResolveState = function (transitionService) {
        return transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: RESOLVE_HOOK_PRIORITY });
    };
    /**
     * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.
     *
     * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`
     *
     * After all entering states have been entered, this hook resolves any remaining Resolvables.
     * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].
     *
     * See [[StateDeclaration.resolve]]
     */
    var resolveRemaining = function (trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);
    };
    var registerResolveRemaining = function (transitionService) {
        return transitionService.onFinish({}, resolveRemaining, { priority: RESOLVE_HOOK_PRIORITY });
    };

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] which waits for the views to load
     *
     * Registered using `transitionService.onStart({}, loadEnteringViews);`
     *
     * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
     * In angular 1, this includes loading the templates.
     */
    var loadEnteringViews = function (transition) {
        var $q = services.$q;
        var enteringViews = transition.views('entering');
        if (!enteringViews.length)
            return;
        return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(noop);
    };
    var registerLoadEnteringViews = function (transitionService) {
        return transitionService.onFinish({}, loadEnteringViews);
    };
    /**
     * A [[TransitionHookFn]] which activates the new views when a transition is successful.
     *
     * Registered using `transitionService.onSuccess({}, activateViews);`
     *
     * After a transition is complete, this hook deactivates the old views from the previous state,
     * and activates the new views from the destination state.
     *
     * See [[ViewService]]
     */
    var activateViews = function (transition) {
        var enteringViews = transition.views('entering');
        var exitingViews = transition.views('exiting');
        if (!enteringViews.length && !exitingViews.length)
            return;
        var $view = transition.router.viewService;
        exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });
        enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });
        $view.sync();
    };
    var registerActivateViews = function (transitionService) {
        return transitionService.onSuccess({}, activateViews);
    };

    /**
     * A [[TransitionHookFn]] which updates global UI-Router state
     *
     * Registered using `transitionService.onBefore({}, updateGlobalState);`
     *
     * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
     * After a successful [[Transition]], updates the global values of "the current state"
     * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
     *
     * See also the deprecated properties:
     * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
     */
    var updateGlobalState = function (trans) {
        var globals = trans.router.globals;
        var transitionSuccessful = function () {
            globals.successfulTransitions.enqueue(trans);
            globals.$current = trans.$to();
            globals.current = globals.$current.self;
            copy(trans.params(), globals.params);
        };
        var clearCurrentTransition = function () {
            // Do not clear globals.transition if a different transition has started in the meantime
            if (globals.transition === trans)
                globals.transition = null;
        };
        trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
        trans.promise.then(clearCurrentTransition, clearCurrentTransition);
    };
    var registerUpdateGlobalState = function (transitionService) {
        return transitionService.onCreate({}, updateGlobalState);
    };

    /**
     * A [[TransitionHookFn]] which updates the URL after a successful transition
     *
     * Registered using `transitionService.onSuccess({}, updateUrl);`
     */
    var updateUrl = function (transition) {
        var options = transition.options();
        var $state = transition.router.stateService;
        var $urlRouter = transition.router.urlRouter;
        // Dont update the url in these situations:
        // The transition was triggered by a URL sync (options.source === 'url')
        // The user doesn't want the url to update (options.location === false)
        // The destination state, and all parents have no navigable url
        if (options.source !== 'url' && options.location && $state.$current.navigable) {
            var urlOptions = { replace: options.location === 'replace' };
            $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
        }
        $urlRouter.update(true);
    };
    var registerUpdateUrl = function (transitionService) {
        return transitionService.onSuccess({}, updateUrl, { priority: 9999 });
    };

    /**
     * A [[TransitionHookFn]] that performs lazy loading
     *
     * When entering a state "abc" which has a `lazyLoad` function defined:
     * - Invoke the `lazyLoad` function (unless it is already in process)
     *   - Flag the hook function as "in process"
     *   - The function should return a promise (that resolves when lazy loading is complete)
     * - Wait for the promise to settle
     *   - If the promise resolves to a [[LazyLoadResult]], then register those states
     *   - Flag the hook function as "not in process"
     * - If the hook was successful
     *   - Remove the `lazyLoad` function from the state declaration
     * - If all the hooks were successful
     *   - Retry the transition (by returning a TargetState)
     *
     * ```
     * .state('abc', {
     *   component: 'fooComponent',
     *   lazyLoad: () => import('./fooComponent')
     *   });
     * ```
     *
     * See [[StateDeclaration.lazyLoad]]
     */
    var lazyLoadHook = function (transition) {
        var router = transition.router;
        function retryTransition() {
            if (transition.originalTransition().options().source !== 'url') {
                // The original transition was not triggered via url sync
                // The lazy state should be loaded now, so re-try the original transition
                var orig = transition.targetState();
                return router.stateService.target(orig.identifier(), orig.params(), orig.options());
            }
            // The original transition was triggered via url sync
            // Run the URL rules and find the best match
            var $url = router.urlService;
            var result = $url.match($url.parts());
            var rule = result && result.rule;
            // If the best match is a state, redirect the transition (instead
            // of calling sync() which supersedes the current transition)
            if (rule && rule.type === 'STATE') {
                var state = rule.state;
                var params = result.match;
                return router.stateService.target(state, params, transition.options());
            }
            // No matching state found, so let .sync() choose the best non-state match/otherwise
            router.urlService.sync();
        }
        var promises = transition
            .entering()
            .filter(function (state) { return !!state.$$state().lazyLoad; })
            .map(function (state) { return lazyLoadState(transition, state); });
        return services.$q.all(promises).then(retryTransition);
    };
    var registerLazyLoadHook = function (transitionService) {
        return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);
    };
    /**
     * Invokes a state's lazy load function
     *
     * @param transition a Transition context
     * @param state the state to lazy load
     * @returns A promise for the lazy load result
     */
    function lazyLoadState(transition, state) {
        var lazyLoadFn = state.$$state().lazyLoad;
        // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
        var promise = lazyLoadFn['_promise'];
        if (!promise) {
            var success = function (result) {
                delete state.lazyLoad;
                delete state.$$state().lazyLoad;
                delete lazyLoadFn['_promise'];
                return result;
            };
            var error = function (err) {
                delete lazyLoadFn['_promise'];
                return services.$q.reject(err);
            };
            promise = lazyLoadFn['_promise'] = services.$q
                .when(lazyLoadFn(transition, state))
                .then(updateStateRegistry)
                .then(success, error);
        }
        /** Register any lazy loaded state definitions */
        function updateStateRegistry(result) {
            if (result && Array.isArray(result.states)) {
                result.states.forEach(function (_state) { return transition.router.stateRegistry.register(_state); });
            }
            return result;
        }
        return promise;
    }

    /**
     * This class defines a type of hook, such as `onBefore` or `onEnter`.
     * Plugins can define custom hook types, such as sticky states does for `onInactive`.
     *
     * @interalapi
     */
    var TransitionEventType = /** @class */ (function () {
        /* tslint:disable:no-inferrable-types */
        function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            if (reverseSort === void 0) { reverseSort = false; }
            if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }
            if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }
            if (synchronous === void 0) { synchronous = false; }
            this.name = name;
            this.hookPhase = hookPhase;
            this.hookOrder = hookOrder;
            this.criteriaMatchPath = criteriaMatchPath;
            this.reverseSort = reverseSort;
            this.getResultHandler = getResultHandler;
            this.getErrorHandler = getErrorHandler;
            this.synchronous = synchronous;
        }
        return TransitionEventType;
    }());

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] that skips a transition if it should be ignored
     *
     * This hook is invoked at the end of the onBefore phase.
     *
     * If the transition should be ignored (because no parameter or states changed)
     * then the transition is ignored and not processed.
     */
    function ignoredHook(trans) {
        var ignoredReason = trans._ignoredReason();
        if (!ignoredReason)
            return;
        trace.traceTransitionIgnored(trans);
        var pending = trans.router.globals.transition;
        // The user clicked a link going back to the *current state* ('A')
        // However, there is also a pending transition in flight (to 'B')
        // Abort the transition to 'B' because the user now wants to be back at 'A'.
        if (ignoredReason === 'SameAsCurrent' && pending) {
            pending.abort();
        }
        return Rejection.ignored().toPromise();
    }
    var registerIgnoredTransitionHook = function (transitionService) {
        return transitionService.onBefore({}, ignoredHook, { priority: -9999 });
    };

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] that rejects the Transition if it is invalid
     *
     * This hook is invoked at the end of the onBefore phase.
     * If the transition is invalid (for example, param values do not validate)
     * then the transition is rejected.
     */
    function invalidTransitionHook(trans) {
        if (!trans.valid()) {
            throw new Error(trans.error().toString());
        }
    }
    var registerInvalidTransitionHook = function (transitionService) {
        return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });
    };

    /** @publicapi @module transition */ /** */
    /**
     * The default [[Transition]] options.
     *
     * Include this object when applying custom defaults:
     * let reloadOpts = { reload: true, notify: true }
     * let options = defaults(theirOpts, customDefaults, defaultOptions);
     */
    var defaultTransOpts = {
        location: true,
        relative: null,
        inherit: false,
        notify: true,
        reload: false,
        supercede: true,
        custom: {},
        current: function () { return null; },
        source: 'unknown',
    };
    /**
     * This class provides services related to Transitions.
     *
     * - Most importantly, it allows global Transition Hooks to be registered.
     * - It allows the default transition error handler to be set.
     * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
     *
     * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
     */
    var TransitionService = /** @class */ (function () {
        /** @hidden */
        function TransitionService(_router) {
            /** @hidden */
            this._transitionCount = 0;
            /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */
            this._eventTypes = [];
            /** @hidden The registered transition hooks */
            this._registeredHooks = {};
            /** @hidden The  paths on a criteria object */
            this._criteriaPaths = {};
            this._router = _router;
            this.$view = _router.viewService;
            this._deregisterHookFns = {};
            this._pluginapi = (createProxyFunctions(val(this), {}, val(this), [
                '_definePathType',
                '_defineEvent',
                '_getPathTypes',
                '_getEvents',
                'getHooks',
            ]));
            this._defineCorePaths();
            this._defineCoreEvents();
            this._registerCoreTransitionHooks();
            _router.globals.successfulTransitions.onEvict(treeChangesCleanup);
        }
        /**
         * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
         *
         * Registers a transition lifecycle hook, which is invoked during transition construction.
         *
         * This low level hook should only be used by plugins.
         * This can be a useful time for plugins to add resolves or mutate the transition as needed.
         * The Sticky States plugin uses this hook to modify the treechanges.
         *
         * ### Lifecycle
         *
         * `onCreate` hooks are invoked *while a transition is being constructed*.
         *
         * ### Return value
         *
         * The hook's return value is ignored
         *
         * @internalapi
         * @param criteria defines which Transitions the Hook should be invoked for.
         * @param callback the hook function which will be invoked.
         * @param options the registration options
         * @returns a function which deregisters the hook.
         */
        TransitionService.prototype.onCreate = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onBefore = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onStart = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onExit = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onRetain = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onEnter = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onFinish = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onSuccess = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onError = function (criteria, callback, options) {
            return;
        };
        /**
         * dispose
         * @internalapi
         */
        TransitionService.prototype.dispose = function (router) {
            values(this._registeredHooks).forEach(function (hooksArray) {
                return hooksArray.forEach(function (hook) {
                    hook._deregistered = true;
                    removeFrom(hooksArray, hook);
                });
            });
        };
        /**
         * Creates a new [[Transition]] object
         *
         * This is a factory function for creating new Transition objects.
         * It is used internally by the [[StateService]] and should generally not be called by application code.
         *
         * @param fromPath the path to the current state (the from state)
         * @param targetState the target state (destination)
         * @returns a Transition
         */
        TransitionService.prototype.create = function (fromPath, targetState) {
            return new Transition(fromPath, targetState, this._router);
        };
        /** @hidden */
        TransitionService.prototype._defineCoreEvents = function () {
            var Phase = exports.TransitionHookPhase;
            var TH = TransitionHook;
            var paths = this._criteriaPaths;
            var NORMAL_SORT = false, REVERSE_SORT = true;
            var SYNCHRONOUS = true;
            this._defineEvent('onCreate', Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
            this._defineEvent('onBefore', Phase.BEFORE, 0, paths.to);
            this._defineEvent('onStart', Phase.RUN, 0, paths.to);
            this._defineEvent('onExit', Phase.RUN, 100, paths.exiting, REVERSE_SORT);
            this._defineEvent('onRetain', Phase.RUN, 200, paths.retained);
            this._defineEvent('onEnter', Phase.RUN, 300, paths.entering);
            this._defineEvent('onFinish', Phase.RUN, 400, paths.to);
            this._defineEvent('onSuccess', Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
            this._defineEvent('onError', Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        };
        /** @hidden */
        TransitionService.prototype._defineCorePaths = function () {
            var STATE = exports.TransitionHookScope.STATE, TRANSITION = exports.TransitionHookScope.TRANSITION;
            this._definePathType('to', TRANSITION);
            this._definePathType('from', TRANSITION);
            this._definePathType('exiting', STATE);
            this._definePathType('retained', STATE);
            this._definePathType('entering', STATE);
        };
        /** @hidden */
        TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            if (reverseSort === void 0) { reverseSort = false; }
            if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }
            if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }
            if (synchronous === void 0) { synchronous = false; }
            var eventType = new TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
            this._eventTypes.push(eventType);
            makeEvent(this, this, eventType);
        };
        /** @hidden */
        // tslint:disable-next-line
        TransitionService.prototype._getEvents = function (phase) {
            var transitionHookTypes = isDefined(phase)
                ? this._eventTypes.filter(function (type) { return type.hookPhase === phase; })
                : this._eventTypes.slice();
            return transitionHookTypes.sort(function (l, r) {
                var cmpByPhase = l.hookPhase - r.hookPhase;
                return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
            });
        };
        /**
         * Adds a Path to be used as a criterion against a TreeChanges path
         *
         * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
         * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
         * Each state in the exiting path is checked against the criteria and returned as part of the match.
         *
         * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
         * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
         * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
         *
         * @hidden
         */
        TransitionService.prototype._definePathType = function (name, hookScope) {
            this._criteriaPaths[name] = { name: name, scope: hookScope };
        };
        /** * @hidden */
        // tslint:disable-next-line
        TransitionService.prototype._getPathTypes = function () {
            return this._criteriaPaths;
        };
        /** @hidden */
        TransitionService.prototype.getHooks = function (hookName) {
            return this._registeredHooks[hookName];
        };
        /** @hidden */
        TransitionService.prototype._registerCoreTransitionHooks = function () {
            var fns = this._deregisterHookFns;
            fns.addCoreResolves = registerAddCoreResolvables(this);
            fns.ignored = registerIgnoredTransitionHook(this);
            fns.invalid = registerInvalidTransitionHook(this);
            // Wire up redirectTo hook
            fns.redirectTo = registerRedirectToHook(this);
            // Wire up onExit/Retain/Enter state hooks
            fns.onExit = registerOnExitHook(this);
            fns.onRetain = registerOnRetainHook(this);
            fns.onEnter = registerOnEnterHook(this);
            // Wire up Resolve hooks
            fns.eagerResolve = registerEagerResolvePath(this);
            fns.lazyResolve = registerLazyResolveState(this);
            fns.resolveAll = registerResolveRemaining(this);
            // Wire up the View management hooks
            fns.loadViews = registerLoadEnteringViews(this);
            fns.activateViews = registerActivateViews(this);
            // Updates global state after a transition
            fns.updateGlobals = registerUpdateGlobalState(this);
            // After globals.current is updated at priority: 10000
            fns.updateUrl = registerUpdateUrl(this);
            // Lazy load state trees
            fns.lazyLoad = registerLazyLoadHook(this);
        };
        return TransitionService;
    }());

    /** @publicapi @module state */ /** */
    /**
     * Provides state related service functions
     *
     * This class provides services related to ui-router states.
     * An instance of this class is located on the global [[UIRouter]] object.
     */
    var StateService = /** @class */ (function () {
        /** @internalapi */
        function StateService(/** @hidden */ router) {
            this.router = router;
            /** @internalapi */
            this.invalidCallbacks = [];
            /** @hidden */
            this._defaultErrorHandler = function $defaultErrorHandler($error$) {
                if ($error$ instanceof Error && $error$.stack) {
                    console.error($error$);
                    console.error($error$.stack);
                }
                else if ($error$ instanceof Rejection) {
                    console.error($error$.toString());
                    if ($error$.detail && $error$.detail.stack)
                        console.error($error$.detail.stack);
                }
                else {
                    console.error($error$);
                }
            };
            var getters = ['current', '$current', 'params', 'transition'];
            var boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));
            createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);
        }
        Object.defineProperty(StateService.prototype, "transition", {
            /**
             * The [[Transition]] currently in progress (or null)
             *
             * This is a passthrough through to [[UIRouterGlobals.transition]]
             */
            get: function () {
                return this.router.globals.transition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "params", {
            /**
             * The latest successful state parameters
             *
             * This is a passthrough through to [[UIRouterGlobals.params]]
             */
            get: function () {
                return this.router.globals.params;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "current", {
            /**
             * The current [[StateDeclaration]]
             *
             * This is a passthrough through to [[UIRouterGlobals.current]]
             */
            get: function () {
                return this.router.globals.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "$current", {
            /**
             * The current [[StateObject]]
             *
             * This is a passthrough through to [[UIRouterGlobals.$current]]
             */
            get: function () {
                return this.router.globals.$current;
            },
            enumerable: true,
            configurable: true
        });
        /** @internalapi */
        StateService.prototype.dispose = function () {
            this.defaultErrorHandler(noop);
            this.invalidCallbacks = [];
        };
        /**
         * Handler for when [[transitionTo]] is called with an invalid state.
         *
         * Invokes the [[onInvalid]] callbacks, in natural order.
         * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
         * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.
         *
         * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
         *
         * @internalapi
         */
        StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {
            var _this = this;
            var fromState = PathUtils.makeTargetState(this.router.stateRegistry, fromPath);
            var globals = this.router.globals;
            var latestThing = function () { return globals.transitionHistory.peekTail(); };
            var latest = latestThing();
            var callbackQueue = new Queue(this.invalidCallbacks.slice());
            var injector = new ResolveContext(fromPath).injector();
            var checkForRedirect = function (result) {
                if (!(result instanceof TargetState)) {
                    return;
                }
                var target = result;
                // Recreate the TargetState, in case the state is now defined.
                target = _this.target(target.identifier(), target.params(), target.options());
                if (!target.valid()) {
                    return Rejection.invalid(target.error()).toPromise();
                }
                if (latestThing() !== latest) {
                    return Rejection.superseded().toPromise();
                }
                return _this.transitionTo(target.identifier(), target.params(), target.options());
            };
            function invokeNextCallback() {
                var nextCallback = callbackQueue.dequeue();
                if (nextCallback === undefined)
                    return Rejection.invalid(toState.error()).toPromise();
                var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));
                return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });
            }
            return invokeNextCallback();
        };
        /**
         * Registers an Invalid State handler
         *
         * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
         * has been called with an invalid state reference parameter
         *
         * Example:
         * ```js
         * stateService.onInvalid(function(to, from, injector) {
         *   if (to.name() === 'foo') {
         *     let lazyLoader = injector.get('LazyLoadService');
         *     return lazyLoader.load('foo')
         *         .then(() => stateService.target('foo'));
         *   }
         * });
         * ```
         *
         * @param {function} callback invoked when the toState is invalid
         *   This function receives the (invalid) toState, the fromState, and an injector.
         *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
         *   If one is returned, it is treated as a redirect.
         *
         * @returns a function which deregisters the callback
         */
        StateService.prototype.onInvalid = function (callback) {
            this.invalidCallbacks.push(callback);
            return function deregisterListener() {
                removeFrom(this.invalidCallbacks)(callback);
            }.bind(this);
        };
        /**
         * Reloads the current state
         *
         * A method that force reloads the current state, or a partial state hierarchy.
         * All resolves are re-resolved, and components reinstantiated.
         *
         * #### Example:
         * ```js
         * let app angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.reload = function(){
         *     $state.reload();
         *   }
         * });
         * ```
         *
         * Note: `reload()` is just an alias for:
         *
         * ```js
         * $state.transitionTo($state.current, $state.params, {
         *   reload: true, inherit: false
         * });
         * ```
         *
         * @param reloadState A state name or a state object.
         *    If present, this state and all its children will be reloaded, but ancestors will not reload.
         *
         * #### Example:
         * ```js
         * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
         * //and current state is 'contacts.detail.item'
         * let app angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.reload = function(){
         *     //will reload 'contact.detail' and nested 'contact.detail.item' states
         *     $state.reload('contact.detail');
         *   }
         * });
         * ```
         *
         * @returns A promise representing the state of the new transition. See [[StateService.go]]
         */
        StateService.prototype.reload = function (reloadState) {
            return this.transitionTo(this.current, this.params, {
                reload: isDefined(reloadState) ? reloadState : true,
                inherit: false,
                notify: false,
            });
        };
        /**
         * Transition to a different state and/or parameters
         *
         * Convenience method for transitioning to a new state.
         *
         * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
         * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
         * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
         * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
         * inherit from the current parameter values (because of `inherit: true`).
         *
         * #### Example:
         * ```js
         * let app = angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.changeState = function () {
         *     $state.go('contact.detail');
         *   };
         * });
         * ```
         *
         * @param to Absolute state name, state object, or relative state path (relative to current state).
         *
         * Some examples:
         *
         * - `$state.go('contact.detail')` - will go to the `contact.detail` state
         * - `$state.go('^')` - will go to the parent state
         * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
         * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
         *
         * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
         *
         *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
         *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
         *
         * @param options Transition options
         *
         * @returns {promise} A promise representing the state of the new transition.
         */
        StateService.prototype.go = function (to, params, options) {
            var defautGoOpts = { relative: this.$current, inherit: true };
            var transOpts = defaults(options, defautGoOpts, defaultTransOpts);
            return this.transitionTo(to, params, transOpts);
        };
        /**
         * Creates a [[TargetState]]
         *
         * This is a factory method for creating a TargetState
         *
         * This may be returned from a Transition Hook to redirect a transition, for example.
         */
        StateService.prototype.target = function (identifier, params, options) {
            if (options === void 0) { options = {}; }
            // If we're reloading, find the state object to reload from
            if (isObject(options.reload) && !options.reload.name)
                throw new Error('Invalid reload state object');
            var reg = this.router.stateRegistry;
            options.reloadState =
                options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
            if (options.reload && !options.reloadState)
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
            return new TargetState(this.router.stateRegistry, identifier, params, options);
        };
        StateService.prototype.getCurrentPath = function () {
            var _this = this;
            var globals = this.router.globals;
            var latestSuccess = globals.successfulTransitions.peekTail();
            var rootPath = function () { return [new PathNode(_this.router.stateRegistry.root())]; };
            return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
        };
        /**
         * Low-level method for transitioning to a new state.
         *
         * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
         *
         * #### Example:
         * ```js
         * let app = angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.changeState = function () {
         *     $state.transitionTo('contact.detail');
         *   };
         * });
         * ```
         *
         * @param to State name or state object.
         * @param toParams A map of the parameters that will be sent to the state,
         *      will populate $stateParams.
         * @param options Transition options
         *
         * @returns A promise representing the state of the new transition. See [[go]]
         */
        StateService.prototype.transitionTo = function (to, toParams, options) {
            var _this = this;
            if (toParams === void 0) { toParams = {}; }
            if (options === void 0) { options = {}; }
            var router = this.router;
            var globals = router.globals;
            options = defaults(options, defaultTransOpts);
            var getCurrent = function () { return globals.transition; };
            options = extend(options, { current: getCurrent });
            var ref = this.target(to, toParams, options);
            var currentPath = this.getCurrentPath();
            if (!ref.exists())
                return this._handleInvalidTargetState(currentPath, ref);
            if (!ref.valid())
                return silentRejection(ref.error());
            if (options.supercede === false && getCurrent()) {
                return Rejection.ignored('Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.').toPromise();
            }
            /**
             * Special handling for Ignored, Aborted, and Redirected transitions
             *
             * The semantics for the transition.run() promise and the StateService.transitionTo()
             * promise differ. For instance, the run() promise may be rejected because it was
             * IGNORED, but the transitionTo() promise is resolved because from the user perspective
             * no error occurred.  Likewise, the transition.run() promise may be rejected because of
             * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
             */
            var rejectedTransitionHandler = function (trans) { return function (error) {
                if (error instanceof Rejection) {
                    var isLatest = router.globals.lastStartedTransitionId <= trans.$id;
                    if (error.type === exports.RejectType.IGNORED) {
                        isLatest && router.urlRouter.update();
                        // Consider ignored `Transition.run()` as a successful `transitionTo`
                        return services.$q.when(globals.current);
                    }
                    var detail = error.detail;
                    if (error.type === exports.RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {
                        // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
                        // by returning the promise for the new (redirect) `Transition.run()`.
                        var redirect = trans.redirect(detail);
                        return redirect.run().catch(rejectedTransitionHandler(redirect));
                    }
                    if (error.type === exports.RejectType.ABORTED) {
                        isLatest && router.urlRouter.update();
                        return services.$q.reject(error);
                    }
                }
                var errorHandler = _this.defaultErrorHandler();
                errorHandler(error);
                return services.$q.reject(error);
            }; };
            var transition = this.router.transitionService.create(currentPath, ref);
            var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
            silenceUncaughtInPromise(transitionToPromise); // issue #2676
            // Return a promise for the transition, which also has the transition object on it.
            return extend(transitionToPromise, { transition: transition });
        };
        /**
         * Checks if the current state *is* the provided state
         *
         * Similar to [[includes]] but only checks for the full state name.
         * If params is supplied then it will be tested for strict equality against the current
         * active params object, so all params must match with none missing and no extras.
         *
         * #### Example:
         * ```js
         * $state.$current.name = 'contacts.details.item';
         *
         * // absolute name
         * $state.is('contact.details.item'); // returns true
         * $state.is(contactDetailItemStateObject); // returns true
         * ```
         *
         * // relative name (. and ^), typically from a template
         * // E.g. from the 'contacts.details' template
         * ```html
         * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
         * ```
         *
         * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
         * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
         * to test against the current active state.
         * @param options An options object. The options are:
         *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
         *     test relative to `options.relative` state (or name).
         *
         * @returns Returns true if it is the state.
         */
        StateService.prototype.is = function (stateOrName, params, options) {
            options = defaults(options, { relative: this.$current });
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state))
                return undefined;
            if (this.$current !== state)
                return false;
            if (!params)
                return true;
            var schema = state.parameters({ inherit: true, matchingKeys: params });
            return Param.equals(schema, Param.values(schema, params), this.params);
        };
        /**
         * Checks if the current state *includes* the provided state
         *
         * A method to determine if the current active state is equal to or is the child of the
         * state stateName. If any params are passed then they will be tested for a match as well.
         * Not all the parameters need to be passed, just the ones you'd like to test for equality.
         *
         * #### Example when `$state.$current.name === 'contacts.details.item'`
         * ```js
         * // Using partial names
         * $state.includes("contacts"); // returns true
         * $state.includes("contacts.details"); // returns true
         * $state.includes("contacts.details.item"); // returns true
         * $state.includes("contacts.list"); // returns false
         * $state.includes("about"); // returns false
         * ```
         *
         * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
         * ```js
         * $state.includes("*.details.*.*"); // returns true
         * $state.includes("*.details.**"); // returns true
         * $state.includes("**.item.**"); // returns true
         * $state.includes("*.details.item.url"); // returns true
         * $state.includes("*.details.*.url"); // returns true
         * $state.includes("*.details.*"); // returns false
         * $state.includes("item.**"); // returns false
         * ```
         *
         * @param stateOrName A partial name, relative name, glob pattern,
         *   or state object to be searched for within the current state name.
         * @param params A param object, e.g. `{sectionId: section.id}`,
         *   that you'd like to test against the current active state.
         * @param options An options object. The options are:
         *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
         *     test relative to `options.relative` state (or name).
         *
         * @returns {boolean} Returns true if it does include the state
         */
        StateService.prototype.includes = function (stateOrName, params, options) {
            options = defaults(options, { relative: this.$current });
            var glob = isString(stateOrName) && Glob.fromString(stateOrName);
            if (glob) {
                if (!glob.matches(this.$current.name))
                    return false;
                stateOrName = this.$current.name;
            }
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
            if (!isDefined(state))
                return undefined;
            if (!isDefined(include[state.name]))
                return false;
            if (!params)
                return true;
            var schema = state.parameters({ inherit: true, matchingKeys: params });
            return Param.equals(schema, Param.values(schema, params), this.params);
        };
        /**
         * Generates a URL for a state and parameters
         *
         * Returns the url for the given state populated with the given params.
         *
         * #### Example:
         * ```js
         * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
         * ```
         *
         * @param stateOrName The state name or state object you'd like to generate a url from.
         * @param params An object of parameter values to fill the state's required parameters.
         * @param options Options object. The options are:
         *
         * @returns {string} compiled state url
         */
        StateService.prototype.href = function (stateOrName, params, options) {
            var defaultHrefOpts = {
                lossy: true,
                inherit: true,
                absolute: false,
                relative: this.$current,
            };
            options = defaults(options, defaultHrefOpts);
            params = params || {};
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state))
                return null;
            if (options.inherit)
                params = this.params.$inherit(params, this.$current, state);
            var nav = state && options.lossy ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
                return null;
            }
            return this.router.urlRouter.href(nav.url, params, { absolute: options.absolute });
        };
        /**
         * Sets or gets the default [[transitionTo]] error handler.
         *
         * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
         * This includes errors caused by resolves and transition hooks.
         *
         * Note:
         * This handler does not receive certain Transition rejections.
         * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
         *
         * The built-in default error handler logs the error to the console.
         *
         * You can provide your own custom handler.
         *
         * #### Example:
         * ```js
         * stateService.defaultErrorHandler(function() {
         *   // Do not log transitionTo errors
         * });
         * ```
         *
         * @param handler a global error handler function
         * @returns the current global error handler
         */
        StateService.prototype.defaultErrorHandler = function (handler) {
            return (this._defaultErrorHandler = handler || this._defaultErrorHandler);
        };
        StateService.prototype.get = function (stateOrName, base) {
            var reg = this.router.stateRegistry;
            if (arguments.length === 0)
                return reg.get();
            return reg.get(stateOrName, base || this.$current);
        };
        /**
         * Lazy loads a state
         *
         * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
         *
         * @param stateOrName the state that should be lazy loaded
         * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
         * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
         * This noop transition is not actually run.
         *
         * @returns a promise to lazy load
         */
        StateService.prototype.lazyLoad = function (stateOrName, transition) {
            var state = this.get(stateOrName);
            if (!state || !state.lazyLoad)
                throw new Error('Can not lazy load ' + stateOrName);
            var currentPath = this.getCurrentPath();
            var target = PathUtils.makeTargetState(this.router.stateRegistry, currentPath);
            transition = transition || this.router.transitionService.create(currentPath, target);
            return lazyLoadState(transition, state);
        };
        return StateService;
    }());

    /** @internalapi @module vanilla */ /** */
    /**
     * An angular1-like promise api
     *
     * This object implements four methods similar to the
     * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)
     *
     * UI-Router evolved from an angular 1 library to a framework agnostic library.
     * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
     *
     * This API provides native ES6 promise support wrapped as a $q-like API.
     * Internally, UI-Router uses this $q object to perform promise operations.
     * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.
     *
     * $q-like promise api
     */
    var $q = {
        /** Normalizes a value as a promise */
        when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },
        /** Normalizes a value as a promise rejection */
        reject: function (val) {
            return new Promise(function (resolve, reject) {
                reject(val);
            });
        },
        /** @returns a deferred object, which has `resolve` and `reject` functions */
        defer: function () {
            var deferred = {};
            deferred.promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            return deferred;
        },
        /** Like Promise.all(), but also supports object key/promise notation like $q */
        all: function (promises) {
            if (isArray(promises)) {
                return Promise.all(promises);
            }
            if (isObject(promises)) {
                // Convert promises map to promises array.
                // When each promise resolves, map it to a tuple { key: key, val: val }
                var chain = Object.keys(promises).map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });
                // Then wait for all promises to resolve, and convert them back to an object
                return $q.all(chain).then(function (values) {
                    return values.reduce(function (acc, tuple) {
                        acc[tuple.key] = tuple.val;
                        return acc;
                    }, {});
                });
            }
        },
    };

    /** @internalapi @module vanilla */ /** */
    // globally available injectables
    var globals = {};
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var ARGUMENT_NAMES = /([^\s,]+)/g;
    /**
     * A basic angular1-like injector api
     *
     * This object implements four methods similar to the
     * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)
     *
     * UI-Router evolved from an angular 1 library to a framework agnostic library.
     * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
     *
     * This object provides a naive implementation of a globally scoped dependency injection system.
     * It supports the following DI approaches:
     *
     * ### Function parameter names
     *
     * A function's `.toString()` is called, and the parameter names are parsed.
     * This only works when the parameter names aren't "mangled" by a minifier such as UglifyJS.
     *
     * ```js
     * function injectedFunction(FooService, BarService) {
     *   // FooService and BarService are injected
     * }
     * ```
     *
     * ### Function annotation
     *
     * A function may be annotated with an array of dependency names as the `$inject` property.
     *
     * ```js
     * injectedFunction.$inject = [ 'FooService', 'BarService' ];
     * function injectedFunction(fs, bs) {
     *   // FooService and BarService are injected as fs and bs parameters
     * }
     * ```
     *
     * ### Array notation
     *
     * An array provides the names of the dependencies to inject (as strings).
     * The function is the last element of the array.
     *
     * ```js
     * [ 'FooService', 'BarService', function (fs, bs) {
     *   // FooService and BarService are injected as fs and bs parameters
     * }]
     * ```
     *
     * @type {$InjectorLike}
     */
    var $injector = {
        /** Gets an object from DI based on a string token */
        get: function (name) { return globals[name]; },
        /** Returns true if an object named `name` exists in global DI */
        has: function (name) { return $injector.get(name) != null; },
        /**
         * Injects a function
         *
         * @param fn the function to inject
         * @param context the function's `this` binding
         * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`
         */
        invoke: function (fn, context, locals) {
            var all = extend({}, globals, locals || {});
            var params = $injector.annotate(fn);
            var ensureExist = assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return "DI can't find injectable: '" + key + "'"; });
            var args = params.filter(ensureExist).map(function (x) { return all[x]; });
            if (isFunction(fn))
                return fn.apply(context, args);
            else
                return fn.slice(-1)[0].apply(context, args);
        },
        /**
         * Returns a function's dependencies
         *
         * Analyzes a function (or array) and returns an array of DI tokens that the function requires.
         * @return an array of `string`s
         */
        annotate: function (fn) {
            if (!isInjectable(fn))
                throw new Error("Not an injectable function: " + fn);
            if (fn && fn.$inject)
                return fn.$inject;
            if (isArray(fn))
                return fn.slice(0, -1);
            var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
            var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
            return result || [];
        },
    };

    /** @internalapi @module vanilla */ /** */
    var keyValsToObjectR = function (accum, _a) {
        var key = _a[0], val = _a[1];
        if (!accum.hasOwnProperty(key)) {
            accum[key] = val;
        }
        else if (isArray(accum[key])) {
            accum[key].push(val);
        }
        else {
            accum[key] = [accum[key], val];
        }
        return accum;
    };
    var getParams = function (queryString) {
        return queryString
            .split('&')
            .filter(identity)
            .map(splitEqual)
            .reduce(keyValsToObjectR, {});
    };
    function parseUrl$1(url) {
        var orEmptyString = function (x) { return x || ''; };
        var _a = splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
        var _b = splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
        return { path: path, search: search, hash: hash, url: url };
    }
    var buildUrl = function (loc) {
        var path = loc.path();
        var searchObject = loc.search();
        var hash = loc.hash();
        var search = Object.keys(searchObject)
            .map(function (key) {
            var param = searchObject[key];
            var vals = isArray(param) ? param : [param];
            return vals.map(function (val) { return key + '=' + val; });
        })
            .reduce(unnestR, [])
            .join('&');
        return path + (search ? '?' + search : '') + (hash ? '#' + hash : '');
    };
    function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
        return function (uiRouter) {
            var service = (uiRouter.locationService = new serviceClass(uiRouter));
            var configuration = (uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5));
            function dispose(router) {
                router.dispose(service);
                router.dispose(configuration);
            }
            return { name: name, service: service, configuration: configuration, dispose: dispose };
        };
    }

    /** @internalapi @module vanilla */ /** */
    /** A base `LocationServices` */
    var BaseLocationServices = /** @class */ (function () {
        function BaseLocationServices(router, fireAfterUpdate) {
            var _this = this;
            this.fireAfterUpdate = fireAfterUpdate;
            this._listeners = [];
            this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };
            this.hash = function () { return parseUrl$1(_this._get()).hash; };
            this.path = function () { return parseUrl$1(_this._get()).path; };
            this.search = function () { return getParams(parseUrl$1(_this._get()).search); };
            this._location = root.location;
            this._history = root.history;
        }
        BaseLocationServices.prototype.url = function (url, replace) {
            if (replace === void 0) { replace = true; }
            if (isDefined(url) && url !== this._get()) {
                this._set(null, null, url, replace);
                if (this.fireAfterUpdate) {
                    this._listeners.forEach(function (cb) { return cb({ url: url }); });
                }
            }
            return buildUrl(this);
        };
        BaseLocationServices.prototype.onChange = function (cb) {
            var _this = this;
            this._listeners.push(cb);
            return function () { return removeFrom(_this._listeners, cb); };
        };
        BaseLocationServices.prototype.dispose = function (router) {
            deregAll(this._listeners);
        };
        return BaseLocationServices;
    }());

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** A `LocationServices` that uses the browser hash "#" to get/set the current location */
    var HashLocationService = /** @class */ (function (_super) {
        __extends(HashLocationService, _super);
        function HashLocationService(router) {
            var _this = _super.call(this, router, false) || this;
            root.addEventListener('hashchange', _this._listener, false);
            return _this;
        }
        HashLocationService.prototype._get = function () {
            return trimHashVal(this._location.hash);
        };
        HashLocationService.prototype._set = function (state, title, url, replace) {
            this._location.hash = url;
        };
        HashLocationService.prototype.dispose = function (router) {
            _super.prototype.dispose.call(this, router);
            root.removeEventListener('hashchange', this._listener);
        };
        return HashLocationService;
    }(BaseLocationServices));

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** A `LocationServices` that gets/sets the current location from an in-memory object */
    var MemoryLocationService = /** @class */ (function (_super) {
        __extends$1(MemoryLocationService, _super);
        function MemoryLocationService(router) {
            return _super.call(this, router, true) || this;
        }
        MemoryLocationService.prototype._get = function () {
            return this._url;
        };
        MemoryLocationService.prototype._set = function (state, title, url, replace) {
            this._url = url;
        };
        return MemoryLocationService;
    }(BaseLocationServices));

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis
     *
     * Uses `history.pushState` and `history.replaceState`
     */
    var PushStateLocationService = /** @class */ (function (_super) {
        __extends$2(PushStateLocationService, _super);
        function PushStateLocationService(router) {
            var _this = _super.call(this, router, true) || this;
            _this._config = router.urlService.config;
            root.addEventListener('popstate', _this._listener, false);
            return _this;
        }
        /**
         * Gets the base prefix without:
         * - trailing slash
         * - trailing filename
         * - protocol and hostname
         *
         * If <base href='/base/'>, this returns '/base'.
         * If <base href='/foo/base/'>, this returns '/foo/base'.
         * If <base href='/base/index.html'>, this returns '/base'.
         * If <base href='http://localhost:8080/base/index.html'>, this returns '/base'.
         * If <base href='/base'>, this returns ''.
         * If <base href='http://localhost:8080'>, this returns ''.
         * If <base href='http://localhost:8080/'>, this returns ''.
         *
         * See: https://html.spec.whatwg.org/dev/semantics.html#the-base-element
         */
        PushStateLocationService.prototype._getBasePrefix = function () {
            return stripLastPathElement(this._config.baseHref());
        };
        PushStateLocationService.prototype._get = function () {
            var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
            search = splitQuery(search)[1]; // strip ? if found
            hash = splitHash(hash)[1]; // strip # if found
            var basePrefix = this._getBasePrefix();
            var exactBaseHrefMatch = pathname === this._config.baseHref();
            var startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;
            pathname = exactBaseHrefMatch ? '/' : startsWithBase ? pathname.substring(basePrefix.length) : pathname;
            return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');
        };
        PushStateLocationService.prototype._set = function (state, title, url, replace) {
            var basePrefix = this._getBasePrefix();
            var slash = url && url[0] !== '/' ? '/' : '';
            var fullUrl = url === '' || url === '/' ? this._config.baseHref() : basePrefix + slash + url;
            if (replace) {
                this._history.replaceState(state, title, fullUrl);
            }
            else {
                this._history.pushState(state, title, fullUrl);
            }
        };
        PushStateLocationService.prototype.dispose = function (router) {
            _super.prototype.dispose.call(this, router);
            root.removeEventListener('popstate', this._listener);
        };
        return PushStateLocationService;
    }(BaseLocationServices));

    /** A `LocationConfig` mock that gets/sets all config from an in-memory object */
    var MemoryLocationConfig = /** @class */ (function () {
        function MemoryLocationConfig() {
            var _this = this;
            this.dispose = noop;
            this._baseHref = '';
            this._port = 80;
            this._protocol = 'http';
            this._host = 'localhost';
            this._hashPrefix = '';
            this.port = function () { return _this._port; };
            this.protocol = function () { return _this._protocol; };
            this.host = function () { return _this._host; };
            this.baseHref = function () { return _this._baseHref; };
            this.html5Mode = function () { return false; };
            this.hashPrefix = function (newval) { return (isDefined(newval) ? (_this._hashPrefix = newval) : _this._hashPrefix); };
        }
        return MemoryLocationConfig;
    }());

    /** @internalapi @module vanilla */
    /** A `LocationConfig` that delegates to the browser's `location` object */
    var BrowserLocationConfig = /** @class */ (function () {
        function BrowserLocationConfig(router, _isHtml5) {
            if (_isHtml5 === void 0) { _isHtml5 = false; }
            this._isHtml5 = _isHtml5;
            this._baseHref = undefined;
            this._hashPrefix = '';
        }
        BrowserLocationConfig.prototype.port = function () {
            if (location.port) {
                return Number(location.port);
            }
            return this.protocol() === 'https' ? 443 : 80;
        };
        BrowserLocationConfig.prototype.protocol = function () {
            return location.protocol.replace(/:/g, '');
        };
        BrowserLocationConfig.prototype.host = function () {
            return location.hostname;
        };
        BrowserLocationConfig.prototype.html5Mode = function () {
            return this._isHtml5;
        };
        BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {
            return isDefined(newprefix) ? (this._hashPrefix = newprefix) : this._hashPrefix;
        };
        BrowserLocationConfig.prototype.baseHref = function (href) {
            if (isDefined(href))
                this._baseHref = href;
            if (isUndefined(this._baseHref))
                this._baseHref = this.getBaseHref();
            return this._baseHref;
        };
        BrowserLocationConfig.prototype.getBaseHref = function () {
            var baseTag = document.getElementsByTagName('base')[0];
            if (baseTag && baseTag.href) {
                return baseTag.href.replace(/^([^/:]*:)?\/\/[^/]*/, '');
            }
            return this._isHtml5 ? '/' : location.pathname || '/';
        };
        BrowserLocationConfig.prototype.dispose = function () { };
        return BrowserLocationConfig;
    }());

    /** @internalapi @module vanilla */ /** */
    function servicesPlugin(router) {
        services.$injector = $injector;
        services.$q = $q;
        return { name: 'vanilla.services', $q: $q, $injector: $injector, dispose: function () { return null; } };
    }
    /** A `UIRouterPlugin` uses the browser hash to get/set the current location */
    var hashLocationPlugin = locationPluginFactory('vanilla.hashBangLocation', false, HashLocationService, BrowserLocationConfig);
    /** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */
    var pushStateLocationPlugin = locationPluginFactory('vanilla.pushStateLocation', true, PushStateLocationService, BrowserLocationConfig);
    /** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */
    var memoryLocationPlugin = locationPluginFactory('vanilla.memoryLocation', false, MemoryLocationService, MemoryLocationConfig);

    /**
     * # Core classes and interfaces
     *
     * The classes and interfaces that are core to ui-router and do not belong
     * to a more specific subsystem (such as resolve).
     *
     * @preferred @publicapi @module core
     */ /** */
    /** @internalapi */
    var UIRouterPluginBase = /** @class */ (function () {
        function UIRouterPluginBase() {
        }
        UIRouterPluginBase.prototype.dispose = function (router) { };
        return UIRouterPluginBase;
    }());

    /** @publicapi @module common */ /** */

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        root: root,
        fromJson: fromJson,
        toJson: toJson,
        forEach: forEach,
        extend: extend,
        equals: equals,
        identity: identity,
        noop: noop,
        createProxyFunctions: createProxyFunctions,
        inherit: inherit,
        inArray: inArray,
        _inArray: _inArray,
        removeFrom: removeFrom,
        _removeFrom: _removeFrom,
        pushTo: pushTo,
        _pushTo: _pushTo,
        deregAll: deregAll,
        defaults: defaults,
        mergeR: mergeR,
        ancestors: ancestors,
        pick: pick,
        omit: omit,
        pluck: pluck,
        filter: filter,
        find: find,
        mapObj: mapObj,
        map: map,
        values: values,
        allTrueR: allTrueR,
        anyTrueR: anyTrueR,
        unnestR: unnestR,
        flattenR: flattenR,
        pushR: pushR,
        uniqR: uniqR,
        unnest: unnest,
        flatten: flatten,
        assertPredicate: assertPredicate,
        assertMap: assertMap,
        assertFn: assertFn,
        pairs: pairs,
        arrayTuples: arrayTuples,
        applyPairs: applyPairs,
        tail: tail,
        copy: copy,
        _extend: _extend,
        silenceUncaughtInPromise: silenceUncaughtInPromise,
        silentRejection: silentRejection,
        makeStub: makeStub,
        services: services,
        Glob: Glob,
        curry: curry,
        compose: compose,
        pipe: pipe,
        prop: prop,
        propEq: propEq,
        parse: parse,
        not: not,
        and: and,
        or: or,
        all: all,
        any: any,
        is: is,
        eq: eq,
        val: val,
        invoke: invoke,
        pattern: pattern,
        isUndefined: isUndefined,
        isDefined: isDefined,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isFunction: isFunction,
        isNumber: isNumber,
        isString: isString,
        isObject: isObject,
        isArray: isArray,
        isDate: isDate,
        isRegExp: isRegExp,
        isInjectable: isInjectable,
        isPromise: isPromise,
        Queue: Queue,
        maxLength: maxLength,
        padString: padString,
        kebobString: kebobString,
        functionToString: functionToString,
        fnToString: fnToString,
        stringify: stringify,
        beforeAfterSubstr: beforeAfterSubstr,
        hostRegex: hostRegex,
        stripLastPathElement: stripLastPathElement,
        splitHash: splitHash,
        splitQuery: splitQuery,
        splitEqual: splitEqual,
        trimHashVal: trimHashVal,
        splitOnDelim: splitOnDelim,
        joinNeighborsR: joinNeighborsR,
        get Category () { return exports.Category; },
        Trace: Trace,
        trace: trace,
        get DefType () { return exports.DefType; },
        Param: Param,
        ParamTypes: ParamTypes,
        StateParams: StateParams,
        ParamType: ParamType,
        PathNode: PathNode,
        PathUtils: PathUtils,
        resolvePolicies: resolvePolicies,
        defaultResolvePolicy: defaultResolvePolicy,
        Resolvable: Resolvable,
        NATIVE_INJECTOR_TOKEN: NATIVE_INJECTOR_TOKEN,
        ResolveContext: ResolveContext,
        resolvablesBuilder: resolvablesBuilder,
        StateBuilder: StateBuilder,
        StateObject: StateObject,
        StateMatcher: StateMatcher,
        StateQueueManager: StateQueueManager,
        StateRegistry: StateRegistry,
        StateService: StateService,
        TargetState: TargetState,
        get TransitionHookPhase () { return exports.TransitionHookPhase; },
        get TransitionHookScope () { return exports.TransitionHookScope; },
        HookBuilder: HookBuilder,
        matchState: matchState,
        RegisteredHook: RegisteredHook,
        makeEvent: makeEvent,
        get RejectType () { return exports.RejectType; },
        Rejection: Rejection,
        Transition: Transition,
        TransitionHook: TransitionHook,
        TransitionEventType: TransitionEventType,
        defaultTransOpts: defaultTransOpts,
        TransitionService: TransitionService,
        UrlRules: UrlRules,
        UrlConfig: UrlConfig,
        UrlMatcher: UrlMatcher,
        ParamFactory: ParamFactory,
        UrlMatcherFactory: UrlMatcherFactory,
        UrlRouter: UrlRouter,
        UrlRuleFactory: UrlRuleFactory,
        BaseUrlRule: BaseUrlRule,
        UrlService: UrlService,
        ViewService: ViewService,
        UIRouterGlobals: UIRouterGlobals,
        UIRouter: UIRouter,
        $q: $q,
        $injector: $injector,
        BaseLocationServices: BaseLocationServices,
        HashLocationService: HashLocationService,
        MemoryLocationService: MemoryLocationService,
        PushStateLocationService: PushStateLocationService,
        MemoryLocationConfig: MemoryLocationConfig,
        BrowserLocationConfig: BrowserLocationConfig,
        keyValsToObjectR: keyValsToObjectR,
        getParams: getParams,
        parseUrl: parseUrl$1,
        buildUrl: buildUrl,
        locationPluginFactory: locationPluginFactory,
        servicesPlugin: servicesPlugin,
        hashLocationPlugin: hashLocationPlugin,
        pushStateLocationPlugin: pushStateLocationPlugin,
        memoryLocationPlugin: memoryLocationPlugin,
        UIRouterPluginBase: UIRouterPluginBase
    });

    /** @internalapi */
    function getNg1ViewConfigFactory() {
        var templateFactory = null;
        return function (path, view) {
            templateFactory = templateFactory || services.$injector.get('$templateFactory');
            return [new Ng1ViewConfig(path, view, templateFactory)];
        };
    }
    /** @internalapi */
    var hasAnyKey = function (keys, obj) { return keys.reduce(function (acc, key) { return acc || isDefined(obj[key]); }, false); };
    /**
     * This is a [[StateBuilder.builder]] function for angular1 `views`.
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * handles the `views` property with logic specific to @uirouter/angularjs (ng1).
     *
     * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
     * and applies the state-level configuration to a view named `$default`.
     *
     * @internalapi
     */
    function ng1ViewsBuilder(state) {
        // Do not process root state
        if (!state.parent)
            return {};
        var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
        // Do not allow a state to have both state-level props and also a `views: {}` property.
        // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.
        // However, the `$default` approach should not be mixed with a separate `views: ` block.
        if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
            throw new Error("State '" + state.name + "' has a 'views' object. " +
                "It cannot also have \"view properties\" at the state level.  " +
                "Move the following properties into a view (in the 'views' object): " +
                (" " + allViewKeys.filter(function (key) { return isDefined(state[key]); }).join(', ')));
        }
        var views = {}, viewsObject = state.views || { $default: pick(state, allViewKeys) };
        forEach(viewsObject, function (config, name) {
            // Account for views: { "": { template... } }
            name = name || '$default';
            // Account for views: { header: "headerComponent" }
            if (isString(config))
                config = { component: config };
            // Make a shallow copy of the config object
            config = extend({}, config);
            // Do not allow a view to mix props for component-style view with props for template/controller-style view
            if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
                throw new Error("Cannot combine: " + compKeys.join('|') + " with: " + nonCompKeys.join('|') + " in stateview: '" + name + "@" + state.name + "'");
            }
            config.resolveAs = config.resolveAs || '$resolve';
            config.$type = 'ng1';
            config.$context = state;
            config.$name = name;
            var normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName;
            config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
            views[name] = config;
        });
        return views;
    }
    /** @hidden */
    var id$1 = 0;
    /** @internalapi */
    var Ng1ViewConfig = /** @class */ (function () {
        function Ng1ViewConfig(path, viewDecl, factory) {
            var _this = this;
            this.path = path;
            this.viewDecl = viewDecl;
            this.factory = factory;
            this.$id = id$1++;
            this.loaded = false;
            this.getTemplate = function (uiView, context) {
                return _this.component
                    ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings)
                    : _this.template;
            };
        }
        Ng1ViewConfig.prototype.load = function () {
            var _this = this;
            var $q = services.$q;
            var context = new ResolveContext(this.path);
            var params = this.path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {});
            var promises = {
                template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),
                controller: $q.when(this.getController(context)),
            };
            return $q.all(promises).then(function (results) {
                trace.traceViewServiceEvent('Loaded', _this);
                _this.controller = results.controller;
                extend(_this, results.template); // Either { template: "tpl" } or { component: "cmpName" }
                return _this;
            });
        };
        /**
         * Gets the controller for a view configuration.
         *
         * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
         */
        Ng1ViewConfig.prototype.getController = function (context) {
            var provider = this.viewDecl.controllerProvider;
            if (!isInjectable(provider))
                return this.viewDecl.controller;
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        return Ng1ViewConfig;
    }());

    /** @publicapi @module view */ /** */
    /**
     * Service which manages loading of templates from a ViewConfig.
     */
    var TemplateFactory = /** @class */ (function () {
        function TemplateFactory() {
            var _this = this;
            /** @hidden */ this._useHttp = ng.version.minor < 3;
            /** @hidden */ this.$get = [
                '$http',
                '$templateCache',
                '$injector',
                function ($http, $templateCache, $injector) {
                    _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');
                    _this.$http = $http;
                    _this.$templateCache = $templateCache;
                    return _this;
                },
            ];
        }
        /** @hidden */
        TemplateFactory.prototype.useHttpService = function (value) {
            this._useHttp = value;
        };
        /**
         * Creates a template from a configuration object.
         *
         * @param config Configuration object for which to load a template.
         * The following properties are search in the specified order, and the first one
         * that is defined is used to create the template:
         *
         * @param params  Parameters to pass to the template function.
         * @param context The resolve context associated with the template's view
         *
         * @return {string|object}  The template html as a string, or a promise for
         * that string,or `null` if no template is configured.
         */
        TemplateFactory.prototype.fromConfig = function (config, params, context) {
            var defaultTemplate = '<ui-view></ui-view>';
            var asTemplate = function (result) { return services.$q.when(result).then(function (str) { return ({ template: str }); }); };
            var asComponent = function (result) { return services.$q.when(result).then(function (str) { return ({ component: str }); }); };
            return isDefined(config.template)
                ? asTemplate(this.fromString(config.template, params))
                : isDefined(config.templateUrl)
                    ? asTemplate(this.fromUrl(config.templateUrl, params))
                    : isDefined(config.templateProvider)
                        ? asTemplate(this.fromProvider(config.templateProvider, params, context))
                        : isDefined(config.component)
                            ? asComponent(config.component)
                            : isDefined(config.componentProvider)
                                ? asComponent(this.fromComponentProvider(config.componentProvider, params, context))
                                : asTemplate(defaultTemplate);
        };
        /**
         * Creates a template from a string or a function returning a string.
         *
         * @param template html template as a string or function that returns an html template as a string.
         * @param params Parameters to pass to the template function.
         *
         * @return {string|object} The template html as a string, or a promise for that
         * string.
         */
        TemplateFactory.prototype.fromString = function (template, params) {
            return isFunction(template) ? template(params) : template;
        };
        /**
         * Loads a template from the a URL via `$http` and `$templateCache`.
         *
         * @param {string|Function} url url of the template to load, or a function
         * that returns a url.
         * @param {Object} params Parameters to pass to the url function.
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        TemplateFactory.prototype.fromUrl = function (url, params) {
            if (isFunction(url))
                url = url(params);
            if (url == null)
                return null;
            if (this._useHttp) {
                return this.$http
                    .get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })
                    .then(function (response) {
                    return response.data;
                });
            }
            return this.$templateRequest(url);
        };
        /**
         * Creates a template by invoking an injectable provider function.
         *
         * @param provider Function to invoke via `locals`
         * @param {Function} injectFn a function used to invoke the template provider
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        TemplateFactory.prototype.fromProvider = function (provider, params, context) {
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        /**
         * Creates a component's template by invoking an injectable provider function.
         *
         * @param provider Function to invoke via `locals`
         * @param {Function} injectFn a function used to invoke the template provider
         * @return {string} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        /**
         * Creates a template from a component's name
         *
         * This implements route-to-component.
         * It works by retrieving the component (directive) metadata from the injector.
         * It analyses the component's bindings, then constructs a template that instantiates the component.
         * The template wires input and output bindings to resolves or from the parent component.
         *
         * @param uiView {object} The parent ui-view (for binding outputs to callbacks)
         * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)
         * @param component {string} Component's name in camel case.
         * @param bindings An object defining the component's bindings: {foo: '<'}
         * @return {string} The template as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {
            bindings = bindings || {};
            // Bind once prefix
            var prefix = ng.version.minor >= 3 ? '::' : '';
            // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`
            var kebob = function (camelCase) {
                var kebobed = kebobString(camelCase);
                return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
            };
            var attributeTpl = function (input) {
                var name = input.name, type = input.type;
                var attrName = kebob(name);
                // If the ui-view has an attribute which matches a binding on the routed component
                // then pass that attribute through to the routed component template.
                // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`
                if (uiView.attr(attrName) && !bindings[name])
                    return attrName + "='" + uiView.attr(attrName) + "'";
                var resolveName = bindings[name] || name;
                // Pre-evaluate the expression for "@" bindings by enclosing in {{ }}
                // some-attr="{{ ::$resolve.someResolveName }}"
                if (type === '@')
                    return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                // Wire "&" callbacks to resolves that return a callback function
                // Get the result of the resolve (should be a function) and annotate it to get its arguments.
                // some-attr="$resolve.someResolveResultName(foo, bar)"
                if (type === '&') {
                    var res = context.getResolvable(resolveName);
                    var fn = res && res.data;
                    var args = (fn && services.$injector.annotate(fn)) || [];
                    // account for array style injection, i.e., ['foo', function(foo) {}]
                    var arrayIdxStr = isArray(fn) ? "[" + (fn.length - 1) + "]" : '';
                    return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(',') + ")'";
                }
                // some-attr="::$resolve.someResolveName"
                return attrName + "='" + prefix + "$resolve." + resolveName + "'";
            };
            var attrs = getComponentBindings(component)
                .map(attributeTpl)
                .join(' ');
            var kebobName = kebob(component);
            return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
        };
        return TemplateFactory;
    }());
    // Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')
    function getComponentBindings(name) {
        var cmpDefs = services.$injector.get(name + 'Directive'); // could be multiple
        if (!cmpDefs || !cmpDefs.length)
            throw new Error("Unable to find component named '" + name + "'");
        return cmpDefs.map(getBindings).reduce(unnestR, []);
    }
    // Given a directive definition, find its object input attributes
    // Use different properties, depending on the type of directive (component, bindToController, normal)
    var getBindings = function (def) {
        if (isObject(def.bindToController))
            return scopeBindings(def.bindToController);
        return scopeBindings(def.scope);
    };
    // for ng 1.2 style, process the scope: { input: "=foo" }
    // for ng 1.3 through ng 1.5, process the component's bindToController: { input: "=foo" } object
    var scopeBindings = function (bindingsObj) {
        return Object.keys(bindingsObj || {})
            // [ 'input', [ '=foo', '=', 'foo' ] ]
            .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })
            // skip malformed values
            .filter(function (tuple) { return isDefined(tuple) && isArray(tuple[1]); })
            // { name: ('foo' || 'input'), type: '=' }
            .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); });
    };

    /** @publicapi @module ng1 */ /** */
    /**
     * The Angular 1 `StateProvider`
     *
     * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely
     * on state.
     *
     * A state corresponds to a "place" in the application in terms of the overall UI and
     * navigation. A state describes (via the controller / template / view properties) what
     * the UI looks like and does at that place.
     *
     * States often have things in common, and the primary way of factoring out these
     * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
     * nested states.
     *
     * The `$stateProvider` provides interfaces to declare these states for your app.
     */
    var StateProvider = /** @class */ (function () {
        function StateProvider(stateRegistry, stateService) {
            this.stateRegistry = stateRegistry;
            this.stateService = stateService;
            createProxyFunctions(val(StateProvider.prototype), this, val(this));
        }
        /**
         * Decorates states when they are registered
         *
         * Allows you to extend (carefully) or override (at your own peril) the
         * `stateBuilder` object used internally by [[StateRegistry]].
         * This can be used to add custom functionality to ui-router,
         * for example inferring templateUrl based on the state name.
         *
         * When passing only a name, it returns the current (original or decorated) builder
         * function that matches `name`.
         *
         * The builder functions that can be decorated are listed below. Though not all
         * necessarily have a good use case for decoration, that is up to you to decide.
         *
         * In addition, users can attach custom decorators, which will generate new
         * properties within the state's internal definition. There is currently no clear
         * use-case for this beyond accessing internal states (i.e. $state.$current),
         * however, expect this to become increasingly relevant as we introduce additional
         * meta-programming features.
         *
         * **Warning**: Decorators should not be interdependent because the order of
         * execution of the builder functions in non-deterministic. Builder functions
         * should only be dependent on the state definition object and super function.
         *
         *
         * Existing builder functions and current return values:
         *
         * - **parent** `{object}` - returns the parent state object.
         * - **data** `{object}` - returns state data, including any inherited data that is not
         *   overridden by own values (if any).
         * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
         *   or `null`.
         * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
         *   navigable).
         * - **params** `{object}` - returns an array of state params that are ensured to
         *   be a super-set of parent's params.
         * - **views** `{object}` - returns a views object where each key is an absolute view
         *   name (i.e. "viewName@stateName") and each value is the config object
         *   (template, controller) for the view. Even when you don't use the views object
         *   explicitly on a state config, one is still created for you internally.
         *   So by decorating this builder function you have access to decorating template
         *   and controller properties.
         * - **ownParams** `{object}` - returns an array of params that belong to the state,
         *   not including any params defined by ancestor states.
         * - **path** `{string}` - returns the full path from the root down to this state.
         *   Needed for state activation.
         * - **includes** `{object}` - returns an object that includes every state that
         *   would pass a `$state.includes()` test.
         *
         * #### Example:
         * Override the internal 'views' builder with a function that takes the state
         * definition, and a reference to the internal function being overridden:
         * ```js
         * $stateProvider.decorator('views', function (state, parent) {
         *   let result = {},
         *       views = parent(state);
         *
         *   angular.forEach(views, function (config, name) {
         *     let autoName = (state.name + '.' + name).replace('.', '/');
         *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
         *     result[name] = config;
         *   });
         *   return result;
         * });
         *
         * $stateProvider.state('home', {
         *   views: {
         *     'contact.list': { controller: 'ListController' },
         *     'contact.item': { controller: 'ItemController' }
         *   }
         * });
         * ```
         *
         *
         * ```js
         * // Auto-populates list and item views with /partials/home/contact/list.html,
         * // and /partials/home/contact/item.html, respectively.
         * $state.go('home');
         * ```
         *
         * @param {string} name The name of the builder function to decorate.
         * @param {object} func A function that is responsible for decorating the original
         * builder function. The function receives two parameters:
         *
         *   - `{object}` - state - The state config object.
         *   - `{object}` - super - The original builder function.
         *
         * @return {object} $stateProvider - $stateProvider instance
         */
        StateProvider.prototype.decorator = function (name, func) {
            return this.stateRegistry.decorator(name, func) || this;
        };
        StateProvider.prototype.state = function (name, definition) {
            if (isObject(name)) {
                definition = name;
            }
            else {
                definition.name = name;
            }
            this.stateRegistry.register(definition);
            return this;
        };
        /**
         * Registers an invalid state handler
         *
         * This is a passthrough to [[StateService.onInvalid]] for ng1.
         */
        StateProvider.prototype.onInvalid = function (callback) {
            return this.stateService.onInvalid(callback);
        };
        return StateProvider;
    }());

    /** @publicapi @module ng1 */ /** */
    /**
     * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
     * `onRetain` callback hooks on a [[Ng1StateDeclaration]].
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
     *
     * @internalapi
     */
    var getStateHookBuilder = function (hookName) {
        return function stateHookBuilder(stateObject, parentFn) {
            var hook = stateObject[hookName];
            var pathname = hookName === 'onExit' ? 'from' : 'to';
            function decoratedNg1Hook(trans, state) {
                var resolveContext = new ResolveContext(trans.treeChanges(pathname));
                var subContext = resolveContext.subContext(state.$$state());
                var locals = extend(getLocals(subContext), { $state$: state, $transition$: trans });
                return services.$injector.invoke(hook, this, locals);
            }
            return hook ? decoratedNg1Hook : undefined;
        };
    };

    /** @publicapi @module ng1 */ /** */
    /**
     * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service
     * @internalapi
     */
    var Ng1LocationServices = /** @class */ (function () {
        function Ng1LocationServices($locationProvider) {
            // .onChange() registry
            this._urlListeners = [];
            this.$locationProvider = $locationProvider;
            var _lp = val($locationProvider);
            createProxyFunctions(_lp, this, _lp, ['hashPrefix']);
        }
        /**
         * Applys ng1-specific path parameter encoding
         *
         * The Angular 1 `$location` service is a bit weird.
         * It doesn't allow slashes to be encoded/decoded bi-directionally.
         *
         * See the writeup at https://github.com/angular-ui/ui-router/issues/2598
         *
         * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F
         *
         * @param router
         */
        Ng1LocationServices.monkeyPatchPathParameterType = function (router) {
            var pathType = router.urlMatcherFactory.type('path');
            pathType.encode = function (x) {
                return x != null ? x.toString().replace(/(~|\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : x;
            };
            pathType.decode = function (x) {
                return x != null ? x.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : x;
            };
        };
        Ng1LocationServices.prototype.dispose = function () { };
        Ng1LocationServices.prototype.onChange = function (callback) {
            var _this = this;
            this._urlListeners.push(callback);
            return function () { return removeFrom(_this._urlListeners)(callback); };
        };
        Ng1LocationServices.prototype.html5Mode = function () {
            var html5Mode = this.$locationProvider.html5Mode();
            html5Mode = isObject(html5Mode) ? html5Mode.enabled : html5Mode;
            return html5Mode && this.$sniffer.history;
        };
        Ng1LocationServices.prototype.baseHref = function () {
            return this._baseHref || (this._baseHref = this.$browser.baseHref() || this.$window.location.pathname);
        };
        Ng1LocationServices.prototype.url = function (newUrl, replace, state) {
            if (replace === void 0) { replace = false; }
            if (isDefined(newUrl))
                this.$location.url(newUrl);
            if (replace)
                this.$location.replace();
            if (state)
                this.$location.state(state);
            return this.$location.url();
        };
        Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser, $window) {
            var _this = this;
            this.$location = $location;
            this.$sniffer = $sniffer;
            this.$browser = $browser;
            this.$window = $window;
            // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange
            $rootScope.$on('$locationChangeSuccess', function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });
            var _loc = val($location);
            // Bind these LocationService functions to $location
            createProxyFunctions(_loc, this, _loc, ['replace', 'path', 'search', 'hash']);
            // Bind these LocationConfig functions to $location
            createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);
        };
        return Ng1LocationServices;
    }());

    /** @publicapi @module url */ /** */
    /**
     * Manages rules for client-side URL
     *
     * ### Deprecation warning:
     * This class is now considered to be an internal API
     * Use the [[UrlService]] instead.
     * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
     *
     * This class manages the router rules for what to do when the URL changes.
     *
     * This provider remains for backwards compatibility.
     *
     * @internalapi
     * @deprecated
     */
    var UrlRouterProvider = /** @class */ (function () {
        /** @hidden */
        function UrlRouterProvider(/** @hidden */ router) {
            this.router = router;
        }
        UrlRouterProvider.injectableHandler = function (router, handler) {
            return function (match) { return services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params }); };
        };
        /** @hidden */
        UrlRouterProvider.prototype.$get = function () {
            var urlService = this.router.urlService;
            this.router.urlRouter.update(true);
            if (!urlService.interceptDeferred)
                urlService.listen();
            return this.router.urlRouter;
        };
        /**
         * Registers a url handler function.
         *
         * Registers a low level url handler (a `rule`).
         * A rule detects specific URL patterns and returns a redirect, or performs some action.
         *
         * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Here's an example of how you might allow case insensitive urls
         *   $urlRouterProvider.rule(function ($injector, $location) {
         *     var path = $location.path(),
         *         normalized = path.toLowerCase();
         *
         *     if (path !== normalized) {
         *       return normalized;
         *     }
         *   });
         * });
         * ```
         *
         * @param ruleFn
         * Handler function that takes `$injector` and `$location` services as arguments.
         * You can use them to detect a url and return a different url as a string.
         *
         * @return [[UrlRouterProvider]] (`this`)
         */
        UrlRouterProvider.prototype.rule = function (ruleFn) {
            var _this = this;
            if (!isFunction(ruleFn))
                throw new Error("'rule' must be a function");
            var match = function () { return ruleFn(services.$injector, _this.router.locationService); };
            var rule = new BaseUrlRule(match, identity);
            this.router.urlService.rules.rule(rule);
            return this;
        };
        /**
         * Defines the path or behavior to use when no url can be matched.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // if the path doesn't match any of the urls you configured
         *   // otherwise will take care of routing the user to the
         *   // specified url
         *   $urlRouterProvider.otherwise('/index');
         *
         *   // Example of using function rule as param
         *   $urlRouterProvider.otherwise(function ($injector, $location) {
         *     return '/a/valid/url';
         *   });
         * });
         * ```
         *
         * @param rule
         * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.
         * The function version is passed two params: `$injector` and `$location` services, and should return a url string.
         *
         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
         */
        UrlRouterProvider.prototype.otherwise = function (rule) {
            var _this = this;
            var urlRules = this.router.urlService.rules;
            if (isString(rule)) {
                urlRules.otherwise(rule);
            }
            else if (isFunction(rule)) {
                urlRules.otherwise(function () { return rule(services.$injector, _this.router.locationService); });
            }
            else {
                throw new Error("'rule' must be a string or function");
            }
            return this;
        };
        /**
         * Registers a handler for a given url matching.
         *
         * If the handler is a string, it is
         * treated as a redirect, and is interpolated according to the syntax of match
         * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
         *
         * If the handler is a function, it is injectable.
         * It gets invoked if `$location` matches.
         * You have the option of inject the match object as `$match`.
         *
         * The handler can return
         *
         * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
         *   will continue trying to find another one that matches.
         * - **string** which is treated as a redirect and passed to `$location.url()`
         * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
         *     if ($state.$current.navigable !== state ||
         *         !equalForKeys($match, $stateParams) {
         *      $state.transitionTo(state, $match, false);
         *     }
         *   });
         * });
         * ```
         *
         * @param what A pattern string to match, compiled as a [[UrlMatcher]].
         * @param handler The path (or function that returns a path) that you want to redirect your user to.
         * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]
         *
         * Note: the handler may also invoke arbitrary code, such as `$state.go()`
         */
        UrlRouterProvider.prototype.when = function (what, handler) {
            if (isArray(handler) || isFunction(handler)) {
                handler = UrlRouterProvider.injectableHandler(this.router, handler);
            }
            this.router.urlService.rules.when(what, handler);
            return this;
        };
        /**
         * Disables monitoring of the URL.
         *
         * Call this method before UI-Router has bootstrapped.
         * It will stop UI-Router from performing the initial url sync.
         *
         * This can be useful to perform some asynchronous initialization before the router starts.
         * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Prevent $urlRouter from automatically intercepting URL changes;
         *   $urlRouterProvider.deferIntercept();
         * })
         *
         * app.run(function (MyService, $urlRouter, $http) {
         *   $http.get("/stuff").then(function(resp) {
         *     MyService.doStuff(resp.data);
         *     $urlRouter.listen();
         *     $urlRouter.sync();
         *   });
         * });
         * ```
         *
         * @param defer Indicates whether to defer location change interception.
         *        Passing no parameter is equivalent to `true`.
         */
        UrlRouterProvider.prototype.deferIntercept = function (defer) {
            this.router.urlService.deferIntercept(defer);
        };
        return UrlRouterProvider;
    }());

    /**
     * # Angular 1 types
     *
     * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.
     * The customizations to the core types for Angular UI-Router are documented here.
     *
     * The optional [[$resolve]] service is also documented here.
     *
     * @preferred @publicapi @module ng1
     */ /** */
    ng.module('ui.router.angular1', []);
    var mod_init = ng.module('ui.router.init', ['ng']);
    var mod_util = ng.module('ui.router.util', ['ui.router.init']);
    var mod_rtr = ng.module('ui.router.router', ['ui.router.util']);
    var mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
    var mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
    var mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line
    var router = null;
    $uiRouterProvider.$inject = ['$locationProvider'];
    /** This angular 1 provider instantiates a Router and exposes its services via the angular injector */
    function $uiRouterProvider($locationProvider) {
        // Create a new instance of the Router when the $uiRouterProvider is initialized
        router = this.router = new UIRouter();
        router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);
        // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties
        router.stateRegistry.decorator('views', ng1ViewsBuilder);
        router.stateRegistry.decorator('onExit', getStateHookBuilder('onExit'));
        router.stateRegistry.decorator('onRetain', getStateHookBuilder('onRetain'));
        router.stateRegistry.decorator('onEnter', getStateHookBuilder('onEnter'));
        router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());
        var ng1LocationService = (router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider));
        Ng1LocationServices.monkeyPatchPathParameterType(router);
        // backwards compat: also expose router instance as $uiRouterProvider.router
        router['router'] = router;
        router['$get'] = $get;
        $get.$inject = ['$location', '$browser', '$window', '$sniffer', '$rootScope', '$http', '$templateCache'];
        function $get($location, $browser, $window, $sniffer, $rootScope, $http, $templateCache) {
            ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser, $window);
            delete router['router'];
            delete router['$get'];
            return router;
        }
        return router;
    }
    var getProviderFor = function (serviceName) { return [
        '$uiRouterProvider',
        function ($urp) {
            var service = $urp.router[serviceName];
            service['$get'] = function () { return service; };
            return service;
        },
    ]; };
    // This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)
    runBlock.$inject = ['$injector', '$q', '$uiRouter'];
    function runBlock($injector, $q, $uiRouter) {
        services.$injector = $injector;
        services.$q = $q;
        // https://github.com/angular-ui/ui-router/issues/3678
        if (!$injector.hasOwnProperty('strictDi')) {
            try {
                $injector.invoke(function (checkStrictDi) { });
            }
            catch (error) {
                $injector.strictDi = !!/strict mode/.exec(error && error.toString());
            }
        }
        // The $injector is now available.
        // Find any resolvables that had dependency annotation deferred
        $uiRouter.stateRegistry
            .get()
            .map(function (x) { return x.$$state().resolvables; })
            .reduce(unnestR, [])
            .filter(function (x) { return x.deps === 'deferred'; })
            .forEach(function (resolvable) { return (resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi)); });
    }
    // $urlRouter service and $urlRouterProvider
    var getUrlRouterProvider = function (uiRouter) { return (uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter)); };
    // $state service and $stateProvider
    // $urlRouter service and $urlRouterProvider
    var getStateProvider = function () { return extend(router.stateProvider, { $get: function () { return router.stateService; } }); };
    watchDigests.$inject = ['$rootScope'];
    function watchDigests($rootScope) {
        $rootScope.$watch(function () {
            trace.approximateDigests++;
        });
    }
    mod_init.provider('$uiRouter', $uiRouterProvider);
    mod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);
    mod_util.provider('$urlService', getProviderFor('urlService'));
    mod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);
    mod_util.provider('$templateFactory', function () { return new TemplateFactory(); });
    mod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));
    mod_state.provider('$uiRouterGlobals', getProviderFor('globals'));
    mod_state.provider('$transitions', getProviderFor('transitionService'));
    mod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);
    mod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);
    mod_main.factory('$view', function () { return router.viewService; });
    mod_main.service('$trace', function () { return trace; });
    mod_main.run(watchDigests);
    mod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);
    mod_state.run(['$state', function ($state) { }]);
    mod_rtr.run(['$urlRouter', function ($urlRouter) { }]);
    mod_init.run(runBlock);
    /** @hidden TODO: find a place to move this */
    var getLocals = function (ctx) {
        var tokens = ctx.getTokens().filter(isString);
        var tuples = tokens.map(function (key) {
            var resolvable = ctx.getResolvable(key);
            var waitPolicy = ctx.getPolicy(resolvable).async;
            return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];
        });
        return tuples.reduce(applyPairs, {});
    };

    /**
     * # Angular 1 Directives
     *
     * These are the directives included in UI-Router for Angular 1.
     * These directives are used in templates to create viewports and link/navigate to states.
     *
     * @preferred @publicapi @module directives
     */ /** */
    /** @hidden */
    function parseStateRef(ref) {
        var parsed;
        var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        if (paramsOnly)
            ref = '(' + paramsOnly[1] + ')';
        parsed = ref.replace(/\n/g, ' ').match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
        if (!parsed || parsed.length !== 4)
            throw new Error("Invalid state ref '" + ref + "'");
        return { state: parsed[1] || null, paramExpr: parsed[3] || null };
    }
    /** @hidden */
    function stateContext(el) {
        var $uiView = el.parent().inheritedData('$uiView');
        var path = parse('$cfg.path')($uiView);
        return path ? tail(path).state.name : undefined;
    }
    /** @hidden */
    function processedDef($state, $element, def) {
        var uiState = def.uiState || $state.current.name;
        var uiStateOpts = extend(defaultOpts($element, $state), def.uiStateOpts || {});
        var href = $state.href(uiState, def.uiStateParams, uiStateOpts);
        return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };
    }
    /** @hidden */
    function getTypeInfo(el) {
        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === 'FORM';
        return {
            attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',
            isAnchor: el.prop('tagName').toUpperCase() === 'A',
            clickable: !isForm,
        };
    }
    /** @hidden */
    function clickHook(el, $state, $timeout, type, getDef) {
        return function (e) {
            var button = e.which || e.button, target = getDef();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
                // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
                var transition_1 = $timeout(function () {
                    if (!el.attr('disabled')) {
                        $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
                    }
                });
                e.preventDefault();
                // if the state has no URL, ignore one preventDefault from the <a> directive.
                var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function () {
                    if (ignorePreventDefaultCount_1-- <= 0)
                        $timeout.cancel(transition_1);
                };
            }
        };
    }
    /** @hidden */
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: true,
            source: 'sref',
        };
    }
    /** @hidden */
    function bindEvents(element, scope, hookFn, uiStateOpts) {
        var events;
        if (uiStateOpts) {
            events = uiStateOpts.events;
        }
        if (!isArray(events)) {
            events = ['click'];
        }
        var on = element.on ? 'on' : 'bind';
        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var event_1 = events_1[_i];
            element[on](event_1, hookFn);
        }
        scope.$on('$destroy', function () {
            var off = element.off ? 'off' : 'unbind';
            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {
                var event_2 = events_2[_i];
                element[off](event_2, hookFn);
            }
        });
    }
    /**
     * `ui-sref`: A directive for linking to a state
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * ### Linked State
     * The attribute value of the `ui-sref` is the name of the state to link to.
     *
     * #### Example:
     * This will activate the `home` state when the link is clicked.
     * ```html
     * <a ui-sref="home">Home</a>
     * ```
     *
     * ### Relative Links
     * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).
     * You just need to be aware that the path is relative to the state that *created* the link.
     * This allows a state to create a relative `ui-sref` which always targets the same destination.
     *
     * #### Example:
     * Both these links are relative to the parent state, even when a child state is currently active.
     * ```html
     * <a ui-sref=".child1">child 1 state</a>
     * <a ui-sref=".child2">child 2 state</a>
     * ```
     *
     * This link activates the parent state.
     * ```html
     * <a ui-sref="^">Return</a>
     * ```
     *
     * ### hrefs
     * If the linked state has a URL, the directive will automatically generate and
     * update the `href` attribute (using the [[StateService.href]]  method).
     *
     * #### Example:
     * Assuming the `users` state has a url of `/users/`
     * ```html
     * <a ui-sref="users" href="/users/">Users</a>
     * ```
     *
     * ### Parameter Values
     * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.
     * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.
     * The content inside the parentheses is an expression, evaluated to the parameter values.
     *
     * #### Example:
     * This example renders a list of links to users.
     * The state's `userId` parameter value comes from each user's `user.id` property.
     * ```html
     * <li ng-repeat="user in users">
     *   <a ui-sref="users.detail({ userId: user.id })">{{ user.displayName }}</a>
     * </li>
     * ```
     *
     * Note:
     * The parameter values expression is `$watch`ed for updates.
     *
     * ### Transition Options
     * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.
     * Options are restricted to `location`, `inherit`, and `reload`.
     *
     * #### Example:
     * ```html
     * <a ui-sref="home" ui-sref-opts="{ reload: true }">Home</a>
     * ```
     *
     * ### Other DOM Events
     *
     * You can also customize which DOM events to respond to (instead of `click`) by
     * providing an `events` array in the `ui-sref-opts` attribute.
     *
     * #### Example:
     * ```html
     * <input type="text" ui-sref="contacts" ui-sref-opts="{ events: ['change', 'blur'] }">
     * ```
     *
     * ### Highlighting the active link
     * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
     *
     * ### Examples
     * If you have the following template:
     *
     * ```html
     * <a ui-sref="home">Home</a>
     * <a ui-sref="about">About</a>
     * <a ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
     *     </li>
     * </ul>
     * ```
     *
     * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:
     *
     * ```html
     * <a href="#/home" ui-sref="home">Home</a>
     * <a href="#/about" ui-sref="about">About</a>
     * <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
     *     </li>
     * </ul>
     *
     * <a href="#/home" ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
     * ```
     *
     * ### Notes
     *
     * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.
     * #### Example:
     * Sets the `lang` parameter to `en` and remains on the same state.
     *
     * ```html
     * <a ui-sref="{ lang: 'en' }">English</a>
     * ```
     *
     * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
     *
     * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).
     * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.
     */
    var uiSrefDirective;
    uiSrefDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var ref = parseStateRef(attrs.uiSref);
                    rawDef.uiState = ref.state;
                    rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    if (ref.paramExpr) {
                        scope.$watch(ref.paramExpr, function (val) {
                            rawDef.uiStateParams = extend({}, val);
                            update();
                        }, true);
                        rawDef.uiStateParams = extend({}, scope.$eval(ref.paramExpr));
                    }
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    /**
     * `ui-state`: A fully dynamic directive for linking to a state
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * ### Linked State
     * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.
     * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**
     *
     * #### Example:
     * Create a list of links.
     * ```html
     * <li ng-repeat="link in navlinks">
     *   <a ui-state="link.state">{{ link.displayName }}</a>
     * </li>
     * ```
     *
     * ### Relative Links
     * If the expression evaluates to a relative path, it is processed like [[uiSref]].
     * You just need to be aware that the path is relative to the state that *created* the link.
     * This allows a state to create relative `ui-state` which always targets the same destination.
     *
     * ### hrefs
     * If the linked state has a URL, the directive will automatically generate and
     * update the `href` attribute (using the [[StateService.href]]  method).
     *
     * ### Parameter Values
     * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.
     * Param values should be provided using the `ui-state-params` attribute.
     * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.
     *
     * #### Example:
     * This example renders a list of links with param values.
     * The state's `userId` parameter value comes from each user's `user.id` property.
     * ```html
     * <li ng-repeat="link in navlinks">
     *   <a ui-state="link.state" ui-state-params="link.params">{{ link.displayName }}</a>
     * </li>
     * ```
     *
     * ### Transition Options
     * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.
     * Options are restricted to `location`, `inherit`, and `reload`.
     * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.
     *
     * #### Example:
     * ```html
     * <a ui-state="returnto.state" ui-state-opts="{ reload: true }">Home</a>
     * ```
     *
     * ### Other DOM Events
     *
     * You can also customize which DOM events to respond to (instead of `click`) by
     * providing an `events` array in the `ui-state-opts` attribute.
     *
     * #### Example:
     * ```html
     * <input type="text" ui-state="contacts" ui-state-opts="{ events: ['change', 'blur'] }">
     * ```
     *
     * ### Highlighting the active link
     * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
     *
     * ### Notes
     *
     * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.
     *   However, it might be simpler to use [[uiSref]] parameter-only links.
     *
     * #### Example:
     * Sets the `lang` parameter to `en` and remains on the same state.
     *
     * ```html
     * <a ui-state="" ui-state-params="{ lang: 'en' }">English</a>
     * ```
     *
     * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
     * ```
     */
    var uiStateDirective;
    uiStateDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDynamicDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];
                    var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return ((acc[attr] = noop), acc); }, {});
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    inputAttrs.forEach(function (field) {
                        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
                        attrs.$observe(field, function (expr) {
                            watchDeregFns[field]();
                            watchDeregFns[field] = scope.$watch(expr, function (newval) {
                                rawDef[field] = newval;
                                update();
                            }, true);
                        });
                    });
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    /**
     * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active
     *
     * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the
     * related directive's state is active (and remove them when it is inactive).
     *
     * The primary use-case is to highlight the active link in navigation menus,
     * distinguishing it from the inactive menu items.
     *
     * ### Linking to a `ui-sref` or `ui-state`
     * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.
     * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.
     *
     * ### Matching
     *
     * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.
     * This is a "fuzzy match" which uses [[StateService.includes]].
     *
     * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).
     * This is an "exact match" which uses [[StateService.is]].
     *
     * ### Parameter values
     * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.
     * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.
     *
     * #### Example:
     * ```html
     * <li ng-repeat="user in users" ui-sref-active="active">
     *   <a ui-sref="user.details({ userId: user.id })">{{ user.lastName }}</a>
     * </li>
     * ```
     *
     * ### Examples
     *
     * Given the following template:
     * #### Example:
     * ```html
     * <ul>
     *   <li ui-sref-active="active" class="item">
     *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
     *   </li>
     * </ul>
     * ```
     *
     * When the app state is `app.user` (or any child state),
     * and contains the state parameter "user" with value "bilbobaggins",
     * the resulting HTML will appear as (note the 'active' class):
     *
     * ```html
     * <ul>
     *   <li ui-sref-active="active" class="item active">
     *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
     *   </li>
     * </ul>
     * ```
     *
     * ### Glob mode
     *
     * It is possible to pass `ui-sref-active` an expression that evaluates to an object.
     * The objects keys represent active class names and values represent the respective state names/globs.
     * `ui-sref-active` will match if the current active state **includes** any of
     * the specified state names/globs, even the abstract ones.
     *
     * #### Example:
     * Given the following template, with "admin" being an abstract state:
     * ```html
     * <div ui-sref-active="{'active': 'admin.**'}">
     *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
     * </div>
     * ```
     *
     * Arrays are also supported as values in the `ngClass`-like interface.
     * This allows multiple states to add `active` class.
     *
     * #### Example:
     * Given the following template, with "admin.roles" being the current state, the class will be added too:
     * ```html
     * <div ui-sref-active="{'active': ['owner.**', 'admin.**']}">
     *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
     * </div>
     * ```
     *
     * When the current state is "admin.roles" the "active" class will be applied to both the `<div>` and `<a>` elements.
     * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.
     *
     * ### Notes:
     *
     * - The class name is interpolated **once** during the directives link time (any further changes to the
     * interpolated value are ignored).
     *
     * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`
     */
    var uiSrefActiveDirective;
    uiSrefActiveDirective = [
        '$state',
        '$stateParams',
        '$interpolate',
        '$uiRouter',
        function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$element',
                    '$attrs',
                    function ($scope, $element, $attrs) {
                        var states = [];
                        var activeEqClass;
                        var uiSrefActive;
                        // There probably isn't much point in $observing this
                        // uiSrefActive and uiSrefActiveEq share the same directive object with some
                        // slight difference in logic routing
                        activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                        try {
                            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                        }
                        catch (e) {
                            // Do nothing. uiSrefActive is not a valid expression.
                            // Fall back to using $interpolate below
                        }
                        uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                        setStatesFromDefinitionObject(uiSrefActive);
                        // Allow uiSref to communicate with uiSrefActive[Equals]
                        this.$$addStateInfo = function (newState, newParams) {
                            // we already got an explicit state provided by ui-sref-active, so we
                            // shadow the one that comes from ui-sref
                            if (isObject(uiSrefActive) && states.length > 0) {
                                return;
                            }
                            var deregister = addState(newState, newParams, uiSrefActive);
                            update();
                            return deregister;
                        };
                        function updateAfterTransition(trans) {
                            trans.promise.then(update, noop);
                        }
                        $scope.$on('$destroy', setupEventListeners());
                        if ($uiRouter.globals.transition) {
                            updateAfterTransition($uiRouter.globals.transition);
                        }
                        function setupEventListeners() {
                            var deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged);
                            var deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition);
                            var deregisterStateChangeSuccessListener = $scope.$on('$stateChangeSuccess', update);
                            return function cleanUp() {
                                deregisterStatesChangedListener();
                                deregisterOnStartListener();
                                deregisterStateChangeSuccessListener();
                            };
                        }
                        function handleStatesChanged() {
                            setStatesFromDefinitionObject(uiSrefActive);
                        }
                        function setStatesFromDefinitionObject(statesDefinition) {
                            if (isObject(statesDefinition)) {
                                states = [];
                                forEach(statesDefinition, function (stateOrName, activeClass) {
                                    // Helper function to abstract adding state.
                                    var addStateForClass = function (stateOrName, activeClass) {
                                        var ref = parseStateRef(stateOrName);
                                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                    };
                                    if (isString(stateOrName)) {
                                        // If state is string, just add it.
                                        addStateForClass(stateOrName, activeClass);
                                    }
                                    else if (isArray(stateOrName)) {
                                        // If state is an array, iterate over it and add each array item individually.
                                        forEach(stateOrName, function (stateOrName) {
                                            addStateForClass(stateOrName, activeClass);
                                        });
                                    }
                                });
                            }
                        }
                        function addState(stateName, stateParams, activeClass) {
                            var state = $state.get(stateName, stateContext($element));
                            var stateInfo = {
                                state: state || { name: stateName },
                                params: stateParams,
                                activeClass: activeClass,
                            };
                            states.push(stateInfo);
                            return function removeState() {
                                removeFrom(states)(stateInfo);
                            };
                        }
                        // Update route state
                        function update() {
                            var splitClasses = function (str) { return str.split(/\s/).filter(identity); };
                            var getClasses = function (stateList) {
                                return stateList
                                    .map(function (x) { return x.activeClass; })
                                    .map(splitClasses)
                                    .reduce(unnestR, []);
                            };
                            var allClasses = getClasses(states)
                                .concat(splitClasses(activeEqClass))
                                .reduce(uniqR, []);
                            var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));
                            var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;
                            var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
                            var addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);
                            var removeClasses = allClasses.filter(function (cls) { return !inArray(addClasses, cls); });
                            $scope.$evalAsync(function () {
                                addClasses.forEach(function (className) { return $element.addClass(className); });
                                removeClasses.forEach(function (className) { return $element.removeClass(className); });
                            });
                        }
                        update();
                    },
                ],
            };
        },
    ];
    ng
        .module('ui.router.state')
        .directive('uiSref', uiSrefDirective)
        .directive('uiSrefActive', uiSrefActiveDirective)
        .directive('uiSrefActiveEq', uiSrefActiveDirective)
        .directive('uiState', uiStateDirective);

    /** @publicapi @module ng1 */ /** */
    /**
     * `isState` Filter: truthy if the current state is the parameter
     *
     * Translates to [[StateService.is]] `$state.is("stateName")`.
     *
     * #### Example:
     * ```html
     * <div ng-if="'stateName' | isState">show if state is 'stateName'</div>
     * ```
     */
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
        var isFilter = function (state, params, options) {
            return $state.is(state, params, options);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    /**
     * `includedByState` Filter: truthy if the current state includes the parameter
     *
     * Translates to [[StateService.includes]]` $state.is("fullOrPartialStateName")`.
     *
     * #### Example:
     * ```html
     * <div ng-if="'fullOrPartialStateName' | includedByState">show if state includes 'fullOrPartialStateName'</div>
     * ```
     */
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
        var includesFilter = function (state, params, options) {
            return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    ng
        .module('ui.router.state')
        .filter('isState', $IsStateFilter)
        .filter('includedByState', $IncludedByStateFilter);

    /** @publicapi @module directives */ /** */
    /**
     * `ui-view`: A viewport directive which is filled in by a view from the active state.
     *
     * ### Attributes
     *
     * - `name`: (Optional) A view name.
     *   The name should be unique amongst the other views in the same state.
     *   You can have views of the same name that live in different states.
     *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).
     *
     * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.
     *   Uses [[$uiViewScroll]] to do the scrolling.
     *
     * - `onload`: Expression to evaluate whenever the view updates.
     *
     * #### Example:
     * A view can be unnamed or named.
     * ```html
     * <!-- Unnamed -->
     * <div ui-view></div>
     *
     * <!-- Named -->
     * <div ui-view="viewName"></div>
     *
     * <!-- Named (different style) -->
     * <ui-view name="viewName"></ui-view>
     * ```
     *
     * You can only have one unnamed view within any template (or root html). If you are only using a
     * single view and it is unnamed then you can populate it like so:
     *
     * ```html
     * <div ui-view></div>
     * $stateProvider.state("home", {
     *   template: "<h1>HELLO!</h1>"
     * })
     * ```
     *
     * The above is a convenient shortcut equivalent to specifying your view explicitly with the
     * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * ```
     *
     * But typically you'll only use the views property if you name your view or have more than one view
     * in the same template. There's not really a compelling reason to name a view if its the only one,
     * but you could if you wanted, like so:
     *
     * ```html
     * <div ui-view="main"></div>
     * ```
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "main": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * ```
     *
     * Really though, you'll use views to set up multiple views:
     *
     * ```html
     * <div ui-view></div>
     * <div ui-view="chart"></div>
     * <div ui-view="data"></div>
     * ```
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     },
     *     "chart": {
     *       template: "<chart_thing/>"
     *     },
     *     "data": {
     *       template: "<data_thing/>"
     *     }
     *   }
     * })
     * ```
     *
     * #### Examples for `autoscroll`:
     * ```html
     * <!-- If autoscroll present with no expression,
     *      then scroll ui-view into view -->
     * <ui-view autoscroll/>
     *
     * <!-- If autoscroll present with valid expression,
     *      then scroll ui-view into view if expression evaluates to true -->
     * <ui-view autoscroll='true'/>
     * <ui-view autoscroll='false'/>
     * <ui-view autoscroll='scopeVariable'/>
     * ```
     *
     * Resolve data:
     *
     * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
     * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
     *
     * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
     * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
     * depends on `$resolve` data.
     *
     * #### Example:
     * ```js
     * $stateProvider.state('home', {
     *   template: '<my-component user="$resolve.user"></my-component>',
     *   resolve: {
     *     user: function(UserService) { return UserService.fetchUser(); }
     *   }
     * });
     * ```
     */
    var uiView;
    uiView = [
        '$view',
        '$animate',
        '$uiViewScroll',
        '$interpolate',
        '$q',
        function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {
            function getRenderer(attrs, scope) {
                return {
                    enter: function (element, target, cb) {
                        if (ng.version.minor > 2) {
                            $animate.enter(element, null, target).then(cb);
                        }
                        else {
                            $animate.enter(element, null, target, cb);
                        }
                    },
                    leave: function (element, cb) {
                        if (ng.version.minor > 2) {
                            $animate.leave(element).then(cb);
                        }
                        else {
                            $animate.leave(element, cb);
                        }
                    },
                };
            }
            function configsEqual(config1, config2) {
                return config1 === config2;
            }
            var rootData = {
                $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },
                $uiView: {},
            };
            var directive = {
                count: 0,
                restrict: 'ECA',
                terminal: true,
                priority: 400,
                transclude: 'element',
                compile: function (tElement, tAttrs, $transclude) {
                    return function (scope, $element, attrs) {
                        var onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(), inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';
                        var previousEl, currentEl, currentScope, viewConfig, unregister;
                        var activeUIView = {
                            $type: 'ng1',
                            id: directive.count++,
                            name: name,
                            fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,
                            config: null,
                            configUpdated: configUpdatedCallback,
                            get creationContext() {
                                // The context in which this ui-view "tag" was created
                                var fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited);
                                // Allow <ui-view name="foo"><ui-view name="bar"></ui-view></ui-view>
                                // See https://github.com/angular-ui/ui-router/issues/3355
                                var fromParentTag = parse('$uiView.creationContext')(inherited);
                                return fromParentTagConfig || fromParentTag;
                            },
                        };
                        trace.traceUIViewEvent('Linking', activeUIView);
                        function configUpdatedCallback(config) {
                            if (config && !(config instanceof Ng1ViewConfig))
                                return;
                            if (configsEqual(viewConfig, config))
                                return;
                            trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);
                            viewConfig = config;
                            updateView(config);
                        }
                        $element.data('$uiView', { $uiView: activeUIView });
                        updateView();
                        unregister = $view.registerUIView(activeUIView);
                        scope.$on('$destroy', function () {
                            trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);
                            unregister();
                        });
                        function cleanupLastView() {
                            if (previousEl) {
                                trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));
                                previousEl.remove();
                                previousEl = null;
                            }
                            if (currentScope) {
                                trace.traceUIViewEvent('Destroying scope', activeUIView);
                                currentScope.$destroy();
                                currentScope = null;
                            }
                            if (currentEl) {
                                var _viewData_1 = currentEl.data('$uiViewAnim');
                                trace.traceUIViewEvent('Animate out', _viewData_1);
                                renderer.leave(currentEl, function () {
                                    _viewData_1.$$animLeave.resolve();
                                    previousEl = null;
                                });
                                previousEl = currentEl;
                                currentEl = null;
                            }
                        }
                        function updateView(config) {
                            var newScope = scope.$new();
                            var animEnter = $q.defer(), animLeave = $q.defer();
                            var $uiViewData = {
                                $cfg: config,
                                $uiView: activeUIView,
                            };
                            var $uiViewAnim = {
                                $animEnter: animEnter.promise,
                                $animLeave: animLeave.promise,
                                $$animLeave: animLeave,
                            };
                            /**
                             * @ngdoc event
                             * @name ui.router.state.directive:ui-view#$viewContentLoading
                             * @eventOf ui.router.state.directive:ui-view
                             * @eventType emits on ui-view directive scope
                             * @description
                             *
                             * Fired once the view **begins loading**, *before* the DOM is rendered.
                             *
                             * @param {Object} event Event object.
                             * @param {string} viewName Name of the view.
                             */
                            newScope.$emit('$viewContentLoading', name);
                            var cloned = $transclude(newScope, function (clone) {
                                clone.data('$uiViewAnim', $uiViewAnim);
                                clone.data('$uiView', $uiViewData);
                                renderer.enter(clone, $element, function onUIViewEnter() {
                                    animEnter.resolve();
                                    if (currentScope)
                                        currentScope.$emit('$viewContentAnimationEnded');
                                    if ((isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {
                                        $uiViewScroll(clone);
                                    }
                                });
                                cleanupLastView();
                            });
                            currentEl = cloned;
                            currentScope = newScope;
                            /**
                             * @ngdoc event
                             * @name ui.router.state.directive:ui-view#$viewContentLoaded
                             * @eventOf ui.router.state.directive:ui-view
                             * @eventType emits on ui-view directive scope
                             * @description           *
                             * Fired once the view is **loaded**, *after* the DOM is rendered.
                             *
                             * @param {Object} event Event object.
                             */
                            currentScope.$emit('$viewContentLoaded', config || viewConfig);
                            currentScope.$eval(onloadExp);
                        }
                    };
                },
            };
            return directive;
        },
    ];
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];
    /** @hidden */
    function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {
        var getControllerAs = parse('viewDecl.controllerAs');
        var getResolveAs = parse('viewDecl.resolveAs');
        return {
            restrict: 'ECA',
            priority: -400,
            compile: function (tElement) {
                var initial = tElement.html();
                tElement.empty();
                return function (scope, $element) {
                    var data = $element.data('$uiView');
                    if (!data) {
                        $element.html(initial);
                        $compile($element.contents())(scope);
                        return;
                    }
                    var cfg = data.$cfg || { viewDecl: {}, getTemplate: noop };
                    var resolveCtx = cfg.path && new ResolveContext(cfg.path);
                    $element.html(cfg.getTemplate($element, resolveCtx) || initial);
                    trace.traceUIViewFill(data.$uiView, $element.html());
                    var link = $compile($element.contents());
                    var controller = cfg.controller;
                    var controllerAs = getControllerAs(cfg);
                    var resolveAs = getResolveAs(cfg);
                    var locals = resolveCtx && getLocals(resolveCtx);
                    scope[resolveAs] = locals;
                    if (controller) {
                        var controllerInstance = ($controller(controller, extend({}, locals, { $scope: scope, $element: $element })));
                        if (controllerAs) {
                            scope[controllerAs] = controllerInstance;
                            scope[controllerAs][resolveAs] = locals;
                        }
                        // TODO: Use $view service as a central point for registering component-level hooks
                        // Then, when a component is created, tell the $view service, so it can invoke hooks
                        // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
                        // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
                        $element.data('$ngControllerController', controllerInstance);
                        $element.children().data('$ngControllerController', controllerInstance);
                        registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);
                    }
                    // Wait for the component to appear in the DOM
                    if (isString(cfg.component)) {
                        var kebobName = kebobString(cfg.component);
                        var tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", 'i');
                        var getComponentController = function () {
                            var directiveEl = [].slice
                                .call($element[0].children)
                                .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });
                            return directiveEl && ng.element(directiveEl).data("$" + cfg.component + "Controller");
                        };
                        var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {
                            if (!ctrlInstance)
                                return;
                            registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);
                            deregisterWatch_1();
                        });
                    }
                    link(scope);
                };
            },
        };
    }
    /** @hidden */
    var hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';
    /** @hidden incrementing id */
    var _uiCanExitId = 0;
    /** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */
    function registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {
        // Call $onInit() ASAP
        if (isFunction(controllerInstance.$onInit) && !((cfg.viewDecl.component || cfg.viewDecl.componentProvider) && hasComponentImpl)) {
            controllerInstance.$onInit();
        }
        var viewState = tail(cfg.path).state.self;
        var hookOptions = { bind: controllerInstance };
        // Add component-level hook for onUiParamsChanged
        if (isFunction(controllerInstance.uiOnParamsChanged)) {
            var resolveContext = new ResolveContext(cfg.path);
            var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;
            // Fire callback on any successful transition
            var paramsUpdated = function ($transition$) {
                // Exit early if the $transition$ is the same as the view was created within.
                // Exit early if the $transition$ will exit the state the view is for.
                if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)
                    return;
                var toParams = $transition$.params('to');
                var fromParams = $transition$.params('from');
                var getNodeSchema = function (node) { return node.paramSchema; };
                var toSchema = $transition$
                    .treeChanges('to')
                    .map(getNodeSchema)
                    .reduce(unnestR, []);
                var fromSchema = $transition$
                    .treeChanges('from')
                    .map(getNodeSchema)
                    .reduce(unnestR, []);
                // Find the to params that have different values than the from params
                var changedToParams = toSchema.filter(function (param) {
                    var idx = fromSchema.indexOf(param);
                    return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
                });
                // Only trigger callback if a to param has changed or is new
                if (changedToParams.length) {
                    var changedKeys_1 = changedToParams.map(function (x) { return x.id; });
                    // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
                    var newValues = filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });
                    controllerInstance.uiOnParamsChanged(newValues, $transition$);
                }
            };
            $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));
        }
        // Add component-level hook for uiCanExit
        if (isFunction(controllerInstance.uiCanExit)) {
            var id_1 = _uiCanExitId++;
            var cacheProp_1 = '_uiCanExitIds';
            // Returns true if a redirect transition already answered truthy
            var prevTruthyAnswer_1 = function (trans) {
                return !!trans && ((trans[cacheProp_1] && trans[cacheProp_1][id_1] === true) || prevTruthyAnswer_1(trans.redirectedFrom()));
            };
            // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition
            var wrappedHook = function (trans) {
                var promise;
                var ids = (trans[cacheProp_1] = trans[cacheProp_1] || {});
                if (!prevTruthyAnswer_1(trans)) {
                    promise = $q.when(controllerInstance.uiCanExit(trans));
                    promise.then(function (val) { return (ids[id_1] = val !== false); });
                }
                return promise;
            };
            var criteria = { exiting: viewState.name };
            $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));
        }
    }
    ng.module('ui.router.state').directive('uiView', uiView);
    ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

    /** @publicapi @module ng1 */ /** */
    /** @hidden */
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function () {
            useAnchorScroll = true;
        };
        this.$get = [
            '$anchorScroll',
            '$timeout',
            function ($anchorScroll, $timeout) {
                if (useAnchorScroll) {
                    return $anchorScroll;
                }
                return function ($element) {
                    return $timeout(function () {
                        $element[0].scrollIntoView();
                    }, 0, false);
                };
            },
        ];
    }
    ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

    var index$1 = 'ui.router';

    exports.$injector = $injector;
    exports.$q = $q;
    exports.BaseLocationServices = BaseLocationServices;
    exports.BaseUrlRule = BaseUrlRule;
    exports.BrowserLocationConfig = BrowserLocationConfig;
    exports.Glob = Glob;
    exports.HashLocationService = HashLocationService;
    exports.HookBuilder = HookBuilder;
    exports.MemoryLocationConfig = MemoryLocationConfig;
    exports.MemoryLocationService = MemoryLocationService;
    exports.NATIVE_INJECTOR_TOKEN = NATIVE_INJECTOR_TOKEN;
    exports.Ng1ViewConfig = Ng1ViewConfig;
    exports.Param = Param;
    exports.ParamFactory = ParamFactory;
    exports.ParamType = ParamType;
    exports.ParamTypes = ParamTypes;
    exports.PathNode = PathNode;
    exports.PathUtils = PathUtils;
    exports.PushStateLocationService = PushStateLocationService;
    exports.Queue = Queue;
    exports.RegisteredHook = RegisteredHook;
    exports.Rejection = Rejection;
    exports.Resolvable = Resolvable;
    exports.ResolveContext = ResolveContext;
    exports.StateBuilder = StateBuilder;
    exports.StateMatcher = StateMatcher;
    exports.StateObject = StateObject;
    exports.StateParams = StateParams;
    exports.StateProvider = StateProvider;
    exports.StateQueueManager = StateQueueManager;
    exports.StateRegistry = StateRegistry;
    exports.StateService = StateService;
    exports.TargetState = TargetState;
    exports.Trace = Trace;
    exports.Transition = Transition;
    exports.TransitionEventType = TransitionEventType;
    exports.TransitionHook = TransitionHook;
    exports.TransitionService = TransitionService;
    exports.UIRouter = UIRouter;
    exports.UIRouterGlobals = UIRouterGlobals;
    exports.UIRouterPluginBase = UIRouterPluginBase;
    exports.UrlConfig = UrlConfig;
    exports.UrlMatcher = UrlMatcher;
    exports.UrlMatcherFactory = UrlMatcherFactory;
    exports.UrlRouter = UrlRouter;
    exports.UrlRouterProvider = UrlRouterProvider;
    exports.UrlRuleFactory = UrlRuleFactory;
    exports.UrlRules = UrlRules;
    exports.UrlService = UrlService;
    exports.ViewService = ViewService;
    exports._extend = _extend;
    exports._inArray = _inArray;
    exports._pushTo = _pushTo;
    exports._removeFrom = _removeFrom;
    exports.all = all;
    exports.allTrueR = allTrueR;
    exports.ancestors = ancestors;
    exports.and = and;
    exports.any = any;
    exports.anyTrueR = anyTrueR;
    exports.applyPairs = applyPairs;
    exports.arrayTuples = arrayTuples;
    exports.assertFn = assertFn;
    exports.assertMap = assertMap;
    exports.assertPredicate = assertPredicate;
    exports.beforeAfterSubstr = beforeAfterSubstr;
    exports.buildUrl = buildUrl;
    exports.compose = compose;
    exports.copy = copy;
    exports.core = index;
    exports.createProxyFunctions = createProxyFunctions;
    exports.curry = curry;
    exports.default = index$1;
    exports.defaultResolvePolicy = defaultResolvePolicy;
    exports.defaultTransOpts = defaultTransOpts;
    exports.defaults = defaults;
    exports.deregAll = deregAll;
    exports.eq = eq;
    exports.equals = equals;
    exports.extend = extend;
    exports.filter = filter;
    exports.find = find;
    exports.flatten = flatten;
    exports.flattenR = flattenR;
    exports.fnToString = fnToString;
    exports.forEach = forEach;
    exports.fromJson = fromJson;
    exports.functionToString = functionToString;
    exports.getLocals = getLocals;
    exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;
    exports.getParams = getParams;
    exports.hashLocationPlugin = hashLocationPlugin;
    exports.hostRegex = hostRegex;
    exports.identity = identity;
    exports.inArray = inArray;
    exports.inherit = inherit;
    exports.invoke = invoke;
    exports.is = is;
    exports.isArray = isArray;
    exports.isDate = isDate;
    exports.isDefined = isDefined;
    exports.isFunction = isFunction;
    exports.isInjectable = isInjectable;
    exports.isNull = isNull;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isPromise = isPromise;
    exports.isRegExp = isRegExp;
    exports.isString = isString;
    exports.isUndefined = isUndefined;
    exports.joinNeighborsR = joinNeighborsR;
    exports.kebobString = kebobString;
    exports.keyValsToObjectR = keyValsToObjectR;
    exports.locationPluginFactory = locationPluginFactory;
    exports.makeEvent = makeEvent;
    exports.makeStub = makeStub;
    exports.map = map;
    exports.mapObj = mapObj;
    exports.matchState = matchState;
    exports.maxLength = maxLength;
    exports.memoryLocationPlugin = memoryLocationPlugin;
    exports.mergeR = mergeR;
    exports.ng1ViewsBuilder = ng1ViewsBuilder;
    exports.noop = noop;
    exports.not = not;
    exports.omit = omit;
    exports.or = or;
    exports.padString = padString;
    exports.pairs = pairs;
    exports.parse = parse;
    exports.parseUrl = parseUrl$1;
    exports.pattern = pattern;
    exports.pick = pick;
    exports.pipe = pipe;
    exports.pluck = pluck;
    exports.prop = prop;
    exports.propEq = propEq;
    exports.pushR = pushR;
    exports.pushStateLocationPlugin = pushStateLocationPlugin;
    exports.pushTo = pushTo;
    exports.removeFrom = removeFrom;
    exports.resolvablesBuilder = resolvablesBuilder;
    exports.resolvePolicies = resolvePolicies;
    exports.root = root;
    exports.services = services;
    exports.servicesPlugin = servicesPlugin;
    exports.silenceUncaughtInPromise = silenceUncaughtInPromise;
    exports.silentRejection = silentRejection;
    exports.splitEqual = splitEqual;
    exports.splitHash = splitHash;
    exports.splitOnDelim = splitOnDelim;
    exports.splitQuery = splitQuery;
    exports.stringify = stringify;
    exports.stripLastPathElement = stripLastPathElement;
    exports.tail = tail;
    exports.toJson = toJson;
    exports.trace = trace;
    exports.trimHashVal = trimHashVal;
    exports.uniqR = uniqR;
    exports.unnest = unnest;
    exports.unnestR = unnestR;
    exports.val = val;
    exports.values = values;
    exports.watchDigests = watchDigests;

    Object.defineProperty(exports, '__esModule', { value: true });

})));


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL2FuZ3VsYXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2NvbW1vbi9AdWlyb3V0ZXIvY29yZS9jb21tb24vaG9mLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL3ByZWRpY2F0ZXMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2NvbW1vbi9AdWlyb3V0ZXIvY29yZS9jb21tb24vY29yZXNlcnZpY2VzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL2NvbW1vbi50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi9nbG9iLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL3F1ZXVlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi9zdHJpbmdzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL3NhZmVDb25zb2xlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL3RyYWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9wYXJhbXMvQHVpcm91dGVyL2NvcmUvcGFyYW1zL3BhcmFtVHlwZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcGFyYW1zL0B1aXJvdXRlci9jb3JlL3BhcmFtcy9wYXJhbS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcGFyYW1zL0B1aXJvdXRlci9jb3JlL3BhcmFtcy9wYXJhbVR5cGVzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9wYXJhbXMvQHVpcm91dGVyL2NvcmUvcGFyYW1zL3N0YXRlUGFyYW1zLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9wYXRoL0B1aXJvdXRlci9jb3JlL3BhdGgvcGF0aE5vZGUudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3N0YXRlL0B1aXJvdXRlci9jb3JlL3N0YXRlL3RhcmdldFN0YXRlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9wYXRoL0B1aXJvdXRlci9jb3JlL3BhdGgvcGF0aFV0aWxzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9yZXNvbHZlL0B1aXJvdXRlci9jb3JlL3Jlc29sdmUvaW50ZXJmYWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9yZXNvbHZlL0B1aXJvdXRlci9jb3JlL3Jlc29sdmUvcmVzb2x2YWJsZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcmVzb2x2ZS9AdWlyb3V0ZXIvY29yZS9yZXNvbHZlL3Jlc29sdmVDb250ZXh0LnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9zdGF0ZS9AdWlyb3V0ZXIvY29yZS9zdGF0ZS9zdGF0ZUJ1aWxkZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3N0YXRlL0B1aXJvdXRlci9jb3JlL3N0YXRlL3N0YXRlT2JqZWN0LnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9zdGF0ZS9AdWlyb3V0ZXIvY29yZS9zdGF0ZS9zdGF0ZU1hdGNoZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3N0YXRlL0B1aXJvdXRlci9jb3JlL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9zdGF0ZS9AdWlyb3V0ZXIvY29yZS9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5LnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vaW50ZXJmYWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2sudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3RyYW5zaXRpb24vQHVpcm91dGVyL2NvcmUvdHJhbnNpdGlvbi9ob29rUmVnaXN0cnkudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3RyYW5zaXRpb24vQHVpcm91dGVyL2NvcmUvdHJhbnNpdGlvbi9ob29rQnVpbGRlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdHJhbnNpdGlvbi9AdWlyb3V0ZXIvY29yZS90cmFuc2l0aW9uL3RyYW5zaXRpb24udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3VybC9AdWlyb3V0ZXIvY29yZS91cmwvdXJsTWF0Y2hlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdXJsL0B1aXJvdXRlci9jb3JlL3VybC91cmxNYXRjaGVyRmFjdG9yeS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdXJsL0B1aXJvdXRlci9jb3JlL3VybC91cmxSdWxlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS91cmwvQHVpcm91dGVyL2NvcmUvdXJsL3VybFJvdXRlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmlldy9AdWlyb3V0ZXIvY29yZS92aWV3L3ZpZXcudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL0B1aXJvdXRlci9jb3JlL2dsb2JhbHMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3VybC9AdWlyb3V0ZXIvY29yZS91cmwvdXJsUnVsZXMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3VybC9AdWlyb3V0ZXIvY29yZS91cmwvdXJsQ29uZmlnLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS91cmwvQHVpcm91dGVyL2NvcmUvdXJsL3VybFNlcnZpY2UudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL0B1aXJvdXRlci9jb3JlL3JvdXRlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3MvY29yZVJlc29sdmFibGVzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9ob29rcy9AdWlyb3V0ZXIvY29yZS9ob29rcy9yZWRpcmVjdFRvLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9ob29rcy9AdWlyb3V0ZXIvY29yZS9ob29rcy9vbkVudGVyRXhpdFJldGFpbi50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3MvcmVzb2x2ZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3Mvdmlld3MudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL3VwZGF0ZUdsb2JhbHMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL3VybC50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3MvbGF6eUxvYWQudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3RyYW5zaXRpb24vQHVpcm91dGVyL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uRXZlbnRUeXBlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9ob29rcy9AdWlyb3V0ZXIvY29yZS9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3MvaW52YWxpZFRyYW5zaXRpb24udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3RyYW5zaXRpb24vQHVpcm91dGVyL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vc3RhdGUvQHVpcm91dGVyL2NvcmUvc3RhdGUvc3RhdGVTZXJ2aWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS92YW5pbGxhL0B1aXJvdXRlci9jb3JlL3ZhbmlsbGEvcS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL2luamVjdG9yLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS92YW5pbGxhL0B1aXJvdXRlci9jb3JlL3ZhbmlsbGEvdXRpbHMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3ZhbmlsbGEvQHVpcm91dGVyL2NvcmUvdmFuaWxsYS9iYXNlTG9jYXRpb25TZXJ2aWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS92YW5pbGxhL0B1aXJvdXRlci9jb3JlL3ZhbmlsbGEvaGFzaExvY2F0aW9uU2VydmljZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL21lbW9yeUxvY2F0aW9uU2VydmljZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL21lbW9yeUxvY2F0aW9uQ29uZmlnLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS92YW5pbGxhL0B1aXJvdXRlci9jb3JlL3ZhbmlsbGEvYnJvd3NlckxvY2F0aW9uQ29uZmlnLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS92YW5pbGxhL0B1aXJvdXRlci9jb3JlL3ZhbmlsbGEvcGx1Z2lucy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vQHVpcm91dGVyL2NvcmUvaW50ZXJmYWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9AdWlyb3V0ZXIvY29yZS9pbmRleC50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL3N0YXRlYnVpbGRlcnMvdmlld3MudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy90ZW1wbGF0ZUZhY3RvcnkudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9zdGF0ZVByb3ZpZGVyLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvc3RhdGVidWlsZGVycy9vbkVudGVyRXhpdFJldGFpbi50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL2xvY2F0aW9uU2VydmljZXMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy91cmxSb3V0ZXJQcm92aWRlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL3NlcnZpY2VzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvZGlyZWN0aXZlcy9zdGF0ZURpcmVjdGl2ZXMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9zdGF0ZUZpbHRlcnMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9kaXJlY3RpdmVzL3ZpZXdEaXJlY3RpdmUudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy92aWV3U2Nyb2xsLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvaW5kZXgudHMiXSwibmFtZXMiOlsibmdfZnJvbV9pbXBvcnQubW9kdWxlIiwidGhpcyIsImFuZ3VsYXIiLCJSZWplY3RUeXBlIiwiQ2F0ZWdvcnkiLCJEZWZUeXBlIiwiVHJhbnNpdGlvbkhvb2tQaGFzZSIsIlRyYW5zaXRpb25Ib29rU2NvcGUiLCJwYXJzZVVybCIsIl9fZXh0ZW5kcyIsImlkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7QUFDQSxJQUVBLGVBQWUsSUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDO0lBQzlDLGVBQWUsQUFBTyxJQUFNLEVBQUUsR0FBRyxjQUFjLElBQUlBLHFCQUFxQixHQUFHLGNBQWMsR0FBRyxjQUFjLENBQUM7O0lDSjNHOzs7Ozs7Ozs7Ozs7OztJQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDQSxhQUFnQixLQUFLLENBQUMsRUFBWTtRQUNoQyxPQUFPLFNBQVMsT0FBTztZQUNyQixJQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRTtnQkFDakMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzthQUNsQztZQUNELElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNuRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLE9BQVosT0FBTyxrQkFBTSxJQUFJLEdBQUssSUFBSSxHQUFFO1NBQ3BDLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7OztBQU1BLGFBQWdCLE9BQU87UUFDckIsSUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDO1FBQ3ZCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLE9BQU87WUFDTCxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQ1gsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzlDLE9BQU8sQ0FB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QyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFPLE1BQU0sQ0FBQyxDQUFDO0FBQ25FQSxNQUFPLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBTyxrQkFBa0IsQ0FBQyxDQUFDOztJQzloQi9FO0FBQ0EsSUFlQTtJQUNBLFNBQVMsbUJBQW1CO1FBQzFCLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztRQUU1QixJQUFJLENBQUMsZUFBZSxHQUFHO1lBQ3JCLGVBQWUsR0FBRyxJQUFJLENBQUM7U0FDeEIsQ0FBQztRQUVGLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDVixlQUFlO1lBQ2YsVUFBVTtZQUNWLFVBQVMsYUFBbUMsRUFBRSxRQUF5QjtnQkFDckUsSUFBSSxlQUFlLEVBQUU7b0JBQ25CLE9BQU8sYUFBYSxDQUFDO2lCQUN0QjtnQkFFRCxPQUFPLFVBQVMsUUFBZ0I7b0JBQzlCLE9BQU8sUUFBUSxDQUNiO3dCQUNFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztxQkFDOUIsRUFDRCxDQUFDLEVBQ0QsS0FBSyxDQUNOLENBQUM7aUJBQ0gsQ0FBQzthQUNIO1NBQ0YsQ0FBQztJQUNKLENBQUM7QUFFREEsTUFBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQTJCLG1CQUFtQixDQUFDLENBQUM7O0FDN0IxRyxrQkFBZSxXQUFXLENBQUMiLCJmaWxlIjoidmVuZG9yLTE1ODI0Nzc0NjIxMTQubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5pbXBvcnQgKiBhcyBuZ19mcm9tX2ltcG9ydCBmcm9tICdhbmd1bGFyJztcbi8qKiBAaGlkZGVuICovIGRlY2xhcmUgdmFyIGFuZ3VsYXI7XG4vKiogQGhpZGRlbiAqLyBjb25zdCBuZ19mcm9tX2dsb2JhbCA9IGFuZ3VsYXI7XG4vKiogQGhpZGRlbiAqLyBleHBvcnQgY29uc3QgbmcgPSBuZ19mcm9tX2ltcG9ydCAmJiBuZ19mcm9tX2ltcG9ydC5tb2R1bGUgPyBuZ19mcm9tX2ltcG9ydCA6IG5nX2Zyb21fZ2xvYmFsO1xuIiwiLyoqXG4gKiBIaWdoZXIgb3JkZXIgZnVuY3Rpb25zXG4gKlxuICogVGhlc2UgdXRpbGl0eSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCBidXQgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBtb2R1bGUgY29tbW9uX2hvZlxuICovIC8qKiAqL1xuXG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuL2NvbW1vbic7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gZm9yIFtQYXJ0aWFsIEFwcGxpY2F0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJ0aWFsX2FwcGxpY2F0aW9uKSBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gKlxuICogR2l2ZW4gYSBmdW5jdGlvbiB3aXRoIE4gcGFyYW1ldGVycywgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHN1cHBvcnRzIHBhcnRpYWwgYXBwbGljYXRpb24uXG4gKiBUaGUgbmV3IGZ1bmN0aW9uIGFjY2VwdHMgYW55d2hlcmUgZnJvbSAxIHRvIE4gcGFyYW1ldGVycy4gIFdoZW4gdGhhdCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBNIHBhcmFtZXRlcnMsXG4gKiB3aGVyZSBNIGlzIGxlc3MgdGhhbiBOLCBpdCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIHBhcmFtZXRlcnMuICBJdCBjb250aW51ZXMgdG9cbiAqIGFjY2VwdCBtb3JlIHBhcmFtZXRlcnMgdW50aWwgYWxsIE4gcGFyYW1ldGVycyBoYXZlIGJlZW4gc3VwcGxpZWQuXG4gKlxuICpcbiAqIFRoaXMgY29udHJpdmVkIGV4YW1wbGUgdXNlcyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uIGFzIGFuIHByZWRpY2F0ZSwgd2hpY2ggcmV0dXJucyB0cnVlXG4gKiBpZiBhbiBvYmplY3QgaXMgZm91bmQgaW4gYm90aCBhcnJheXMuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiAvLyByZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGlzIGluIGJvdGggb2YgdGhlIHR3byBhcnJheXNcbiAqIGZ1bmN0aW9uIGluQm90aChhcnJheTEsIGFycmF5Miwgb2JqZWN0KSB7XG4gKiAgIHJldHVybiBhcnJheTEuaW5kZXhPZihvYmplY3QpICE9PSAtMSAmJlxuICogICAgICAgICAgYXJyYXkyLmluZGV4T2Yob2JqZWN0KSAhPT0gMTtcbiAqIH1cbiAqIGxldCBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3XG4gKiBsZXQgZm9vcyA9IFtvYmoxLCBvYmozXVxuICogbGV0IGJhcnMgPSBbb2JqMywgb2JqNCwgb2JqNV1cbiAqXG4gKiAvLyBBIGN1cnJpZWQgXCJjb3B5XCIgb2YgaW5Cb3RoXG4gKiBsZXQgY3VycmllZEluQm90aCA9IGN1cnJ5KGluQm90aCk7XG4gKiAvLyBQYXJ0aWFsbHkgYXBwbHkgYm90aCB0aGUgYXJyYXkxIGFuZCBhcnJheTJcbiAqIGxldCBpbkZvb3NBbmRCYXJzID0gY3VycmllZEluQm90aChmb29zLCBiYXJzKTtcbiAqXG4gKiAvLyBTdXBwbHkgdGhlIGZpbmFsIGFyZ3VtZW50OyBzaW5jZSBhbGwgYXJndW1lbnRzIGFyZVxuICogLy8gc3VwcGxpZWQsIHRoZSBvcmlnaW5hbCBpbkJvdGggZnVuY3Rpb24gaXMgdGhlbiBjYWxsZWQuXG4gKiBsZXQgb2JqMUluQm90aCA9IGluRm9vc0FuZEJhcnMob2JqMSk7IC8vIGZhbHNlXG4gKlxuICogLy8gVXNlIHRoZSBpbkZvb3NBbmRCYXJzIGFzIGEgcHJlZGljYXRlLlxuICogLy8gRmlsdGVyLCBvbiBlYWNoIGl0ZXJhdGlvbiwgc3VwcGxpZXMgdGhlIGZpbmFsIGFyZ3VtZW50XG4gKiBsZXQgYWxsT2JqcyA9IFsgb2JqMSwgb2JqMiwgb2JqMywgb2JqNCwgb2JqNSwgb2JqNiwgb2JqNyBdO1xuICogbGV0IGZvdW5kSW5Cb3RoID0gYWxsT2Jqcy5maWx0ZXIoaW5Gb29zQW5kQmFycyk7IC8vIFsgb2JqMyBdXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIGZuXG4gKiBAcmV0dXJucyB7KnxmdW5jdGlvbigpOiAoKnxhbnkpfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VycnkoZm46IEZ1bmN0aW9uKTogRnVuY3Rpb24ge1xuICByZXR1cm4gZnVuY3Rpb24gY3VycmllZCgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSBmbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gY3VycmllZC5iaW5kKHRoaXMsIC4uLmFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgcmlnaHQtdG8tbGVmdFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBjb21wb3NlZCA9IGNvbXBvc2UoZixnLGgpXG4gKiB0aGVuLCBjb21wb3NlZCBpczogZihnKGgoeCkpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgY29uc3Qgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgaSA9IHN0YXJ0LFxuICAgICAgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgbGVmdC10by1yaWdodFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBwaXBlZCA9IHBpcGUoZixnLGgpO1xuICogdGhlbiwgcGlwZWQgaXM6IGgoZyhmKHgpKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcGUoLi4uZnVuY3M6IEZ1bmN0aW9uW10pOiAob2JqOiBhbnkpID0+IGFueSB7XG4gIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5yZXZlcnNlKCkpO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGF0IHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG4gKiBsZXQgb2JqID0geyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9wID0gKG5hbWU6IHN0cmluZykgPT4gKG9iajogYW55KSA9PiBvYmogJiYgb2JqW25hbWVdO1xuXG4vKipcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSBhbmQgYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gYmFzZWQgb24gd2hldGhlclxuICogdGhlIHBhc3NlZCBvYmplY3QgaGFzIGEgcHJvcGVydHkgdGhhdCBtYXRjaGVzIHRoZSB2YWx1ZVxuICogbGV0IG9iaiA9IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfTtcbiAqIGxldCBnZXROYW1lID0gcHJvcEVxKFwibmFtZVwiLCBcImJsYXJnXCIpO1xuICogZ2V0TmFtZShvYmopID09PSB0cnVlXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9wRXEgPSBjdXJyeSgobmFtZTogc3RyaW5nLCBfdmFsOiBhbnksIG9iajogYW55KSA9PiBvYmogJiYgb2JqW25hbWVdID09PSBfdmFsKTtcblxuLyoqXG4gKiBHaXZlbiBhIGRvdHRlZCBwcm9wZXJ0eSBuYW1lLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbmVzdGVkIHByb3BlcnR5IGZyb20gYW4gb2JqZWN0LCBvciB1bmRlZmluZWRcbiAqIGxldCBvYmogPSB7IGlkOiAxLCBuZXN0ZWRPYmo6IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfSwgfTtcbiAqIGxldCBnZXROYW1lID0gcHJvcChcIm5lc3RlZE9iai5uYW1lXCIpO1xuICogZ2V0TmFtZShvYmopID09PSBcImJsYXJnXCJcbiAqIGxldCBwcm9wTm90Rm91bmQgPSBwcm9wKFwidGhpcy5wcm9wZXJ0eS5kb2VzbnQuZXhpc3RcIik7XG4gKiBwcm9wTm90Rm91bmQob2JqKSA9PT0gdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZSA9IChuYW1lOiBzdHJpbmcpID0+IHBpcGUuYXBwbHkobnVsbCwgbmFtZS5zcGxpdCgnLicpLm1hcChwcm9wKSk7XG5cbi8qKlxuICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlLCByZXR1cm5zIGFcbiAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb3Bwb3NpdGUgKGZhbHNleSBvciB0cnV0aHkpIHZhbHVlIGdpdmVuIHRoZSBzYW1lIGlucHV0c1xuICovXG5leHBvcnQgY29uc3Qgbm90OiAoZm46IFByZWRpY2F0ZTxhbnk+KSA9PiBQcmVkaWNhdGU8YW55PiA9IChmbjogUHJlZGljYXRlPGFueT4pID0+ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgIWZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4vKipcbiAqIEdpdmVuIHR3byBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZXMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1dGh5XG4gKiBpZiBib3RoIGZ1bmN0aW9ucyByZXR1cm4gdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmQoZm4xOiBQcmVkaWNhdGU8YW55PiwgZm4yOiBQcmVkaWNhdGU8YW55Pik6IFByZWRpY2F0ZTxhbnk+IHtcbiAgcmV0dXJuICguLi5hcmdzOiBhbnlbXSkgPT4gZm4xLmFwcGx5KG51bGwsIGFyZ3MpICYmIGZuMi5hcHBseShudWxsLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxuICogaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBmdW5jdGlvbnMgcmV0dXJucyB0cnV0aHkgZm9yIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yKGZuMTogUHJlZGljYXRlPGFueT4sIGZuMjogUHJlZGljYXRlPGFueT4pOiBQcmVkaWNhdGU8YW55PiB7XG4gIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IGZuMS5hcHBseShudWxsLCBhcmdzKSB8fCBmbjIuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYWxsIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBtYXRjaCBhIHByZWRpY2F0ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmbjEgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYGZuMWBcbiAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJyYXkgYW5kIHJldHVybnMgdHJ1ZSBpZiBgZm4xYCBpcyB0cnVlIGZvciBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSAoZm4xOiBQcmVkaWNhdGU8YW55PikgPT4gKGFycjogYW55W10pID0+IGFyci5yZWR1Y2UoKGIsIHgpID0+IGIgJiYgISFmbjEoeCksIHRydWUpIGFzIGJvb2xlYW47XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG5leHBvcnQgY29uc3QgYW55ID0gKGZuMTogUHJlZGljYXRlPGFueT4pID0+IChhcnI6IGFueVtdKSA9PiBhcnIucmVkdWNlKChiLCB4KSA9PiBiIHx8ICEhZm4xKHgpLCBmYWxzZSkgYXMgYm9vbGVhbjtcblxuLyoqIEdpdmVuIGEgY2xhc3MsIHJldHVybnMgYSBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBvZiB0aGF0IGNsYXNzICovXG5leHBvcnQgY29uc3QgaXMgPSA8VD4oY3RvcjogeyBuZXcgKC4uLmFyZ3MpOiBUIH0pID0+IChvYmo6IGFueSk6IG9iaiBpcyBUID0+XG4gIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgPT09IGN0b3IpIHx8IG9iaiBpbnN0YW5jZW9mIGN0b3I7XG5cbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFub3RoZXIgdmFsdWUgaXMgPT09IGVxdWFsIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSAqL1xuZXhwb3J0IGNvbnN0IGVxOiAoY29tcDogYW55KSA9PiBQcmVkaWNhdGU8YW55PiA9ICh2YWx1ZTogYW55KSA9PiAob3RoZXI6IGFueSkgPT4gdmFsdWUgPT09IG90aGVyO1xuXG4vKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnQgY29uc3QgdmFsID0gPFQ+KHY6IFQpID0+ICgpID0+IHY7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2UoZm5OYW1lOiBzdHJpbmcpOiBGdW5jdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBpbnZva2UoZm5OYW1lOiBzdHJpbmcsIGFyZ3M6IGFueVtdKTogRnVuY3Rpb247XG5leHBvcnQgZnVuY3Rpb24gaW52b2tlKGZuTmFtZTogc3RyaW5nLCBhcmdzPzogYW55W10pOiBGdW5jdGlvbiB7XG4gIHJldHVybiAob2JqOiBhbnkpID0+IG9ialtmbk5hbWVdLmFwcGx5KG9iaiwgYXJncyk7XG59XG5cbi8qKlxuICogU29ydGEgbGlrZSBQYXR0ZXJuIE1hdGNoaW5nIChhIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgY29uZGl0aW9uYWwgY29uc3RydWN0KVxuICpcbiAqIFNlZSBodHRwOi8vYzIuY29tL2NnaS93aWtpP1BhdHRlcm5NYXRjaGluZ1xuICpcbiAqIFRoaXMgaXMgYSBjb25kaXRpb25hbCBjb25zdHJ1Y3Qgd2hpY2ggYWxsb3dzIGEgc2VyaWVzIG9mIHByZWRpY2F0ZXMgYW5kIG91dHB1dCBmdW5jdGlvbnNcbiAqIHRvIGJlIGNoZWNrZWQgYW5kIHRoZW4gYXBwbGllZC4gIEVhY2ggcHJlZGljYXRlIHJlY2VpdmVzIHRoZSBpbnB1dC4gIElmIHRoZSBwcmVkaWNhdGVcbiAqIHJldHVybnMgdHJ1dGh5LCB0aGVuIGl0cyBtYXRjaGluZyBvdXRwdXQgZnVuY3Rpb24gKG1hcHBpbmcgZnVuY3Rpb24pIGlzIHByb3ZpZGVkIHdpdGhcbiAqIHRoZSBpbnB1dCBhbmQsIHRoZW4gdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBFYWNoIGNvbWJpbmF0aW9uICgyLXR1cGxlKSBvZiBwcmVkaWNhdGUgKyBvdXRwdXQgZnVuY3Rpb24gc2hvdWxkIGJlIHBsYWNlZCBpbiBhbiBhcnJheVxuICogb2Ygc2l6ZSAyOiBbIHByZWRpY2F0ZSwgbWFwRm4gXVxuICpcbiAqIFRoZXNlIDItdHVwbGVzIHNob3VsZCBiZSBwdXQgaW4gYW4gb3V0ZXIgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIC8vIEhlcmUncyBhIDItdHVwbGUgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGlzU3RyaW5nIHByZWRpY2F0ZVxuICogLy8gYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnB1dFxuICogbGV0IGZpcnN0VHVwbGUgPSBbIGFuZ3VsYXIuaXNTdHJpbmcsIChpbnB1dCkgPT4gYEhlcmVzIHlvdXIgc3RyaW5nICR7aW5wdXR9YCBdO1xuICpcbiAqIC8vIFNlY29uZCB0dXBsZTogcHJlZGljYXRlIFwiaXNOdW1iZXJcIiwgbWFwZm4gcmV0dXJucyBhIGRlc2NyaXB0aW9uXG4gKiBsZXQgc2Vjb25kVHVwbGUgPSBbIGFuZ3VsYXIuaXNOdW1iZXIsIChpbnB1dCkgPT4gYCgke2lucHV0fSkgVGhhdCdzIGEgbnVtYmVyIWAgXTtcbiAqXG4gKiBsZXQgdGhpcmQgPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IG51bGwsICAoaW5wdXQpID0+IGBPaCwgbnVsbC4uLmAgXTtcbiAqXG4gKiBsZXQgZm91cnRoID0gWyAoaW5wdXQpID0+IGlucHV0ID09PSB1bmRlZmluZWQsICAoaW5wdXQpID0+IGBub3RkZWZpbmVkYCBdO1xuICpcbiAqIGxldCBkZXNjcmlwdGlvbk9mID0gcGF0dGVybihbIGZpcnN0VHVwbGUsIHNlY29uZFR1cGxlLCB0aGlyZCwgZm91cnRoIF0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YodW5kZWZpbmVkKSk7IC8vICdub3RkZWZpbmVkJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZig1NSkpOyAvLyAnKDU1KSBUaGF0J3MgYSBudW1iZXIhJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZihcImZvb1wiKSk7IC8vICdIZXJlJ3MgeW91ciBzdHJpbmcgZm9vJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cnVjdCBBIDJEIGFycmF5LiAgRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBzaG91bGQgYmUgYW4gYXJyYXksIGEgMi10dXBsZSxcbiAqIHdpdGggYSBQcmVkaWNhdGUgYW5kIGEgbWFwcGluZy9vdXRwdXQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihhbnkpOiAqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3Q6IEZ1bmN0aW9uW11bXSk6IEZ1bmN0aW9uIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHg6IGFueSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RydWN0W2ldWzBdKHgpKSByZXR1cm4gc3RydWN0W2ldWzFdKHgpO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKiBQcmVkaWNhdGVzXG4gKlxuICogVGhlc2UgcHJlZGljYXRlcyByZXR1cm4gdHJ1ZS9mYWxzZSBiYXNlZCBvbiB0aGUgaW5wdXQuXG4gKiBBbHRob3VnaCB0aGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCB0aGV5IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9wcmVkaWNhdGVzXG4gKi8gLyoqICovXG5pbXBvcnQgeyBhbmQsIG5vdCwgcGlwZSwgcHJvcCwgb3IgfSBmcm9tICcuL2hvZic7XG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuL2NvbW1vbic7IC8vIGhhcyBvciBpcyB1c2luZ1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5cbmNvbnN0IHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRpcyA9ICh0OiBzdHJpbmcpID0+ICh4OiBhbnkpID0+IHR5cGVvZiB4ID09PSB0O1xuZXhwb3J0IGNvbnN0IGlzVW5kZWZpbmVkID0gdGlzKCd1bmRlZmluZWQnKTtcbmV4cG9ydCBjb25zdCBpc0RlZmluZWQgPSBub3QoaXNVbmRlZmluZWQpO1xuZXhwb3J0IGNvbnN0IGlzTnVsbCA9IChvOiBhbnkpID0+IG8gPT09IG51bGw7XG5leHBvcnQgY29uc3QgaXNOdWxsT3JVbmRlZmluZWQgPSBvcihpc051bGwsIGlzVW5kZWZpbmVkKTtcbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uOiAoeDogYW55KSA9PiB4IGlzIEZ1bmN0aW9uID0gPGFueT50aXMoJ2Z1bmN0aW9uJyk7XG5leHBvcnQgY29uc3QgaXNOdW1iZXI6ICh4OiBhbnkpID0+IHggaXMgbnVtYmVyID0gPGFueT50aXMoJ251bWJlcicpO1xuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gPCh4OiBhbnkpID0+IHggaXMgc3RyaW5nPnRpcygnc3RyaW5nJyk7XG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAoeDogYW55KSA9PiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JztcbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydCBjb25zdCBpc0RhdGU6ICh4OiBhbnkpID0+IHggaXMgRGF0ZSA9IDxhbnk+KCh4OiBhbnkpID0+IHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IERhdGVdJyk7XG5leHBvcnQgY29uc3QgaXNSZWdFeHA6ICh4OiBhbnkpID0+IHggaXMgUmVnRXhwID0gPGFueT4oKHg6IGFueSkgPT4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xuXG4vKipcbiAqIFByZWRpY2F0ZSB3aGljaCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBpbmplY3RhYmxlXG4gKlxuICogQSB2YWx1ZSBpcyBcImluamVjdGFibGVcIiBpZiBpdCBpcyBhIGZ1bmN0aW9uLCBvciBpZiBpdCBpcyBhbiBuZzEgYXJyYXktbm90YXRpb24tc3R5bGUgYXJyYXlcbiAqIHdoZXJlIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIGFycmF5IGFyZSBTdHJpbmdzLCBleGNlcHQgdGhlIGxhc3Qgb25lLCB3aGljaCBpcyBhIEZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0luamVjdGFibGUodmFsOiBhbnkpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoKSB7XG4gICAgY29uc3QgaGVhZCA9IHZhbC5zbGljZSgwLCAtMSksXG4gICAgICB0YWlsID0gdmFsLnNsaWNlKC0xKTtcbiAgICByZXR1cm4gIShoZWFkLmZpbHRlcihub3QoaXNTdHJpbmcpKS5sZW5ndGggfHwgdGFpbC5maWx0ZXIobm90KGlzRnVuY3Rpb24pKS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbCk7XG59XG5cbi8qKlxuICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGxvb2tzIGxpa2UgYSBQcm9taXNlXG4gKlxuICogSXQgaXMgcHJvYmFibHkgYSBQcm9taXNlIGlmIGl0J3MgYW4gb2JqZWN0LCBhbmQgaXQgaGFzIGEgYHRoZW5gIHByb3BlcnR5IHdoaWNoIGlzIGEgRnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZSA9IDwoeDogYW55KSA9PiB4IGlzIFByb21pc2U8YW55Pj5hbmQoXG4gIGlzT2JqZWN0LFxuICBwaXBlKFxuICAgIHByb3AoJ3RoZW4nKSxcbiAgICBpc0Z1bmN0aW9uXG4gIClcbik7XG4iLCIvKipcbiAqIFRoaXMgbW9kdWxlIGlzIGEgc3R1YiBmb3IgY29yZSBzZXJ2aWNlcyBzdWNoIGFzIERlcGVuZGVuY3kgSW5qZWN0aW9uIG9yIEJyb3dzZXIgTG9jYXRpb24uXG4gKiBDb3JlIHNlcnZpY2VzIG1heSBiZSBpbXBsZW1lbnRlZCBieSBhIHNwZWNpZmljIGZyYW1ld29yaywgc3VjaCBhcyBuZzEgb3IgbmcyLCBvciBiZSBwdXJlIGphdmFzY3JpcHQuXG4gKlxuICogQHB1YmxpY2FwaSBAbW9kdWxlIGNvbW1vblxuICovIC8qKiAqL1xuaW1wb3J0IHsgSUluamVjdGFibGUsIE9iaiB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVXJsQ29uZmlnLCBVcmxTZXJ2aWNlIH0gZnJvbSAnLi4vdXJsJztcblxuY29uc3Qgbm9JbXBsID0gKGZubmFtZTogc3RyaW5nKSA9PiAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgTm8gaW1wbGVtZW50YXRpb24gZm9yICR7Zm5uYW1lfS4gVGhlIGZyYW1ld29yayBzcGVjaWZpYyBjb2RlIGRpZCBub3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kLmApO1xufTtcblxuZXhwb3J0IGNvbnN0IG1ha2VTdHViID0gPFQ+KHNlcnZpY2U6IHN0cmluZywgbWV0aG9kczogKGtleW9mIFQpW10pOiBUID0+XG4gIG1ldGhvZHMucmVkdWNlKChhY2MsIGtleSkgPT4gKChhY2Nba2V5XSA9IG5vSW1wbChgJHtzZXJ2aWNlfS4ke2tleX0oKWApIGFzIGFueSksIGFjYyksIHt9IGFzIFQpO1xuXG5jb25zdCBzZXJ2aWNlczogQ29yZVNlcnZpY2VzID0ge1xuICAkcTogdW5kZWZpbmVkLFxuICAkaW5qZWN0b3I6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgJFFMaWtlRGVmZXJyZWQge1xuICByZXNvbHZlOiAodmFsPzogYW55KSA9PiB2b2lkO1xuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG4gIHByb21pc2U6IFByb21pc2U8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSAkUUxpa2Uge1xuICB3aGVuPFQ+KHZhbHVlPzogVCB8IFByb21pc2VMaWtlPFQ+KTogUHJvbWlzZTxUPjtcbiAgcmVqZWN0PFQ+KHJlYXNvbjogYW55KTogUHJvbWlzZTxUPjtcbiAgZGVmZXIoKTogJFFMaWtlRGVmZXJyZWQ7XG4gIGFsbChwcm9taXNlczogeyBba2V5OiBzdHJpbmddOiBQcm9taXNlPGFueT4gfSk6IFByb21pc2U8YW55PjtcbiAgYWxsKHByb21pc2VzOiBQcm9taXNlPGFueT5bXSk6IFByb21pc2U8YW55W10+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlICRJbmplY3Rvckxpa2Uge1xuICBzdHJpY3REaT86IGJvb2xlYW47XG4gIGdldCh0b2tlbjogYW55KTogYW55O1xuICBnZXQ8VD4odG9rZW46IGFueSk6IFQ7XG4gIGhhcyh0b2tlbjogYW55KTogYm9vbGVhbjtcbiAgaW52b2tlKGZuOiBJSW5qZWN0YWJsZSwgY29udGV4dD86IGFueSwgbG9jYWxzPzogT2JqKTogYW55O1xuICBhbm5vdGF0ZShmbjogSUluamVjdGFibGUsIHN0cmljdERpPzogYm9vbGVhbik6IGFueVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvcmVTZXJ2aWNlcyB7XG4gICRxOiAkUUxpa2U7XG4gICRpbmplY3RvcjogJEluamVjdG9yTGlrZTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGxvdyBsZXZlbCBVUkwgcmVhZC93cml0ZVxuICpcbiAqIFRoaXMgc2VydmljZSBoYW5kbGVzIGxvdyBsZXZlbCByZWFkcyBhbmQgdXBkYXRlcyBvZiB0aGUgVVJMIGFuZCBsaXN0ZW5zIGZvciB1cmwgY2hhbmdlcy5cbiAqIEltcGxlbWVudG9ycyBzaG91bGQgcGFzcyB0aGVzZSB0aHJvdWdoIHRvIHRoZSB1bmRlcmx5aW5nIFVSTCBtZWNoYW5pc20uXG4gKiBUaGUgdW5kZXJseWluZyBVUkwgbWVjaGFuaXNtIG1pZ2h0IGJlIGJyb3dzZXIgQVBJcywgZnJhbWV3b3JrIEFQSXMsIG9yIHNvbWUgM3JkIHBhcnR5IFVSTCBtYW5hZ2VtZW50IGxpYnJhcnkuXG4gKlxuICogVUktUm91dGVyIENvcmUgaW5jbHVkZXMgdGhyZWUgYmFzaWMgaW1wbGVtZW50YXRpb25zOlxuICpcbiAqIC0gW1tQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VdXVxuICogLSBbW0hhc2hMb2NhdGlvblNlcnZpY2VdXVxuICogLSBbW01lbW9yeUxvY2F0aW9uU2VydmljZV1dXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb25TZXJ2aWNlcyBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKiogU2VlOiBbW1VybFNlcnZpY2UudXJsXV0gKi8gdXJsOiBVcmxTZXJ2aWNlWyd1cmwnXTtcbiAgLyoqIFNlZTogW1tVcmxTZXJ2aWNlLnBhdGhdXSAqLyBwYXRoOiBVcmxTZXJ2aWNlWydwYXRoJ107XG4gIC8qKiBTZWU6IFtbVXJsU2VydmljZS5zZWFyY2hdXSAqLyBzZWFyY2g6IFVybFNlcnZpY2VbJ3NlYXJjaCddO1xuICAvKiogU2VlOiBbW1VybFNlcnZpY2UuaGFzaF1dICovIGhhc2g6IFVybFNlcnZpY2VbJ2hhc2gnXTtcbiAgLyoqIFNlZTogW1tVcmxTZXJ2aWNlLm9uQ2hhbmdlXV0gKi8gb25DaGFuZ2U6IFVybFNlcnZpY2VbJ29uQ2hhbmdlJ107XG59XG5cbi8qKlxuICogUmV0dXJucyBsb3cgbGV2ZWwgVVJMIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGFkYXRhXG4gKlxuICogVGhpcyBzZXJ2aWNlIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvY2F0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKiBUaGlzIHNlcnZpY2UgaXMgcHJpbWFyaWx5IHVzZWQgd2hlbiBidWlsZGluZyBVUkxzIChlLmcuLCBmb3IgYGhyZWZzYClcbiAqXG4gKiBJbXBsZW1lbnRvcnMgc2hvdWxkIHBhc3MgdGhlc2UgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBVUkwgQVBJcy5cbiAqIFRoZSB1bmRlcmx5aW5nIFVSTCBtZWNoYW5pc20gbWlnaHQgYmUgYnJvd3NlciBBUElzLCBmcmFtZXdvcmsgQVBJcywgb3Igc29tZSAzcmQgcGFydHkgVVJMIG1hbmFnZW1lbnQgbGlicmFyeS5cbiAqXG4gKiBVSS1Sb3V0ZXIgQ29yZSBpbmNsdWRlcyB0d28gYmFzaWMgaW1wbGVtZW50YXRpb25zOlxuICpcbiAqIC0gW1tCcm93c2VyTG9jYXRpb25Db25maWddXVxuICogLSBbW01lbW9yeUxvY2F0aW9uQ29uZmlnXV1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NhdGlvbkNvbmZpZyBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKiogU2VlOiBbW1VybENvbmZpZy5wb3J0XV0gKi8gcG9ydDogVXJsQ29uZmlnWydwb3J0J107XG4gIC8qKiBTZWU6IFtbVXJsQ29uZmlnLnByb3RvY29sXV0gKi8gcHJvdG9jb2w6IFVybENvbmZpZ1sncHJvdG9jb2wnXTtcbiAgLyoqIFNlZTogW1tVcmxDb25maWcuaG9zdF1dICovIGhvc3Q6IFVybENvbmZpZ1snaG9zdCddO1xuICAvKiogU2VlOiBbW1VybENvbmZpZy5iYXNlSHJlZl1dICovIGJhc2VIcmVmOiBVcmxDb25maWdbJ2Jhc2VIcmVmJ107XG4gIC8qKiBTZWU6IFtbVXJsQ29uZmlnLmh0bWw1TW9kZV1dICovIGh0bWw1TW9kZTogVXJsQ29uZmlnWydodG1sNU1vZGUnXTtcbiAgLyoqIFNlZTogW1tVcmxDb25maWcuaGFzaFByZWZpeF1dICovIGhhc2hQcmVmaXg6IFVybENvbmZpZ1snaGFzaFByZWZpeCddO1xufVxuXG5leHBvcnQgeyBzZXJ2aWNlcyB9O1xuIiwiLyoqXG4gKiBSYW5kb20gdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBpbiB0aGUgVUktUm91dGVyIGNvZGVcbiAqXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCBidXQgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBwcmVmZXJyZWQgQHB1YmxpY2FwaSBAbW9kdWxlIGNvbW1vblxuICovIC8qKiAqL1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzQXJyYXksIGlzUmVnRXhwLCBpc0RhdGUgfSBmcm9tICcuL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgYWxsLCBhbnksIHByb3AsIGN1cnJ5LCBub3QgfSBmcm9tICcuL2hvZic7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuXG5kZWNsYXJlIGNvbnN0IGdsb2JhbDtcbmV4cG9ydCBjb25zdCByb290OiBhbnkgPVxuICAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmKSB8fFxuICAodHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCkgfHxcbiAgdGhpcztcbmNvbnN0IGFuZ3VsYXIgPSByb290LmFuZ3VsYXIgfHwge307XG5cbmV4cG9ydCBjb25zdCBmcm9tSnNvbiA9IGFuZ3VsYXIuZnJvbUpzb24gfHwgSlNPTi5wYXJzZS5iaW5kKEpTT04pO1xuZXhwb3J0IGNvbnN0IHRvSnNvbiA9IGFuZ3VsYXIudG9Kc29uIHx8IEpTT04uc3RyaW5naWZ5LmJpbmQoSlNPTik7XG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaCB8fCBfZm9yRWFjaDtcbmV4cG9ydCBjb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduIHx8IF9leHRlbmQ7XG5leHBvcnQgY29uc3QgZXF1YWxzID0gYW5ndWxhci5lcXVhbHMgfHwgX2VxdWFscztcbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eSh4OiBhbnkpIHtcbiAgcmV0dXJuIHg7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpOiBhbnkge31cblxuZXhwb3J0IHR5cGUgTWFwcGVyPFgsIFQ+ID0gKHg6IFgsIGtleT86IHN0cmluZyB8IG51bWJlcikgPT4gVDtcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRNYXA8VD4ge1xuICBba2V5OiBzdHJpbmddOiBUO1xufVxuZXhwb3J0IHR5cGUgUHJlZGljYXRlPFg+ID0gKHg/OiBYKSA9PiBib29sZWFuO1xuZXhwb3J0IHR5cGUgUHJlZGljYXRlQmluYXJ5PFgsIFk+ID0gKHg/OiBYLCB5PzogWSkgPT4gYm9vbGVhbjtcbi8qKlxuICogQW4gbmcxLXN0eWxlIGluamVjdGFibGVcbiAqXG4gKiBUaGlzIGNvdWxkIGJlIGEgKG5vbi1taW5pZmllZCkgZnVuY3Rpb24gc3VjaCBhczpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBpbmplY3RhYmxlRnVuY3Rpb24oU29tZURlcGVuZGVuY3kpIHtcbiAqXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBvciBhbiBleHBsaWNpdGx5IGFubm90YXRlZCBmdW5jdGlvbiAobWluaWZ5IHNhZmUpXG4gKiBgYGBqc1xuICogaW5qZWN0YWJsZUZ1bmN0aW9uLiRpbmplY3QgPSBbICdTb21lRGVwZW5kZW5jeScgXTtcbiAqIGZ1bmN0aW9uIGluamVjdGFibGVGdW5jdGlvbihTb21lRGVwZW5kZW5jeSkge1xuICpcbiAqIH1cbiAqIGBgYFxuICpcbiAqIG9yIGFuIGFycmF5IHN0eWxlIGFubm90YXRlZCBmdW5jdGlvbiAobWluaWZ5IHNhZmUpXG4gKiBgYGBqc1xuICogWydTb21lRGVwZW5kZW5jeScsIGZ1bmN0aW9uIGluamVjdGFibGVGdW5jdGlvbihTb21lRGVwZW5kZW5jeSkge1xuICpcbiAqIH1dO1xuICogYGBgXG4gKlxuICogQHB1YmxpY2FwaVxuICovXG5leHBvcnQgdHlwZSBJSW5qZWN0YWJsZSA9IEZ1bmN0aW9uIHwgYW55W107XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JqIGV4dGVuZHMgT2JqZWN0IHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG4vKipcbiAqIEJ1aWxkcyBwcm94eSBmdW5jdGlvbnMgb24gdGhlIGB0b2Agb2JqZWN0IHdoaWNoIHBhc3MgdGhyb3VnaCB0byB0aGUgYGZyb21gIG9iamVjdC5cbiAqXG4gKiBGb3IgZWFjaCBrZXkgaW4gYGZuTmFtZXNgLCBjcmVhdGVzIGEgcHJveHkgZnVuY3Rpb24gb24gdGhlIGB0b2Agb2JqZWN0LlxuICogVGhlIHByb3h5IGZ1bmN0aW9uIGNhbGxzIHRoZSByZWFsIGZ1bmN0aW9uIG9uIHRoZSBgZnJvbWAgb2JqZWN0LlxuICpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhbiBuZXcgY2xhc3MgaW5zdGFuY2Ugd2hvc2UgZnVuY3Rpb25zIGFyZSBwcmVib3VuZCB0byB0aGUgbmV3J2Qgb2JqZWN0LlxuICogYGBganNcbiAqIGNsYXNzIEZvbyB7XG4gKiAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAqICAgICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gRm9vLnByb3RvdHlwZSB0byAndGhpcycsXG4gKiAgICAgLy8gdGhlbiBjb3BpZXMgdGhlbSB0byAndGhpcydcbiAqICAgICBiaW5kRnVuY3Rpb25zKEZvby5wcm90b3R5cGUsIHRoaXMsIHRoaXMpO1xuICogICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gKiAgIH1cbiAqXG4gKiAgIGxvZygpIHtcbiAqICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpO1xuICogICB9XG4gKiB9XG4gKlxuICogbGV0IG15Rm9vID0gbmV3IEZvbyhbMSwyLDNdKTtcbiAqIHZhciBsb2dpdCA9IG15Rm9vLmxvZztcbiAqIGxvZ2l0KCk7IC8vIGxvZ3MgWzEsIDIsIDNdIGZyb20gdGhlIG15Rm9vICd0aGlzJyBpbnN0YW5jZVxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBib3VuZCB2ZXJzaW9uIG9mIGEgc2VydmljZSBmdW5jdGlvbiwgYW5kIGNvcGllcyBpdCB0byBhbm90aGVyIG9iamVjdFxuICogYGBgXG4gKlxuICogdmFyIFNvbWVTZXJ2aWNlID0ge1xuICogICB0aGlzLmRhdGEgPSBbMywgNCwgNV07XG4gKiAgIHRoaXMubG9nID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2codGhpcy5kYXRhKTtcbiAqICAgfVxuICogfVxuICpcbiAqIC8vIENvbnN0cnVjdG9yIGZuXG4gKiBmdW5jdGlvbiBPdGhlclRoaW5nKCkge1xuICogICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gU29tZVNlcnZpY2UgdG8gU29tZVNlcnZpY2UsXG4gKiAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXG4gKiAgIGJpbmRGdW5jdGlvbnMoU29tZVNlcnZpY2UsIHRoaXMsIFNvbWVTZXJ2aWNlKTtcbiAqIH1cbiAqXG4gKiBsZXQgbXlPdGhlclRoaW5nID0gbmV3IE90aGVyVGhpbmcoKTtcbiAqIG15T3RoZXJUaGluZy5sb2coKTsgLy8gbG9ncyBbMywgNCwgNV0gZnJvbSBTb21lU2VydmljZSdzICd0aGlzJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNvdXJjZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc291cmNlIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25zIHRvIGJlIGJvdW5kXG4gKiBAcGFyYW0gdGFyZ2V0IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgYm91bmQgZnVuY3Rpb25zXG4gKiBAcGFyYW0gYmluZCBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb2JqZWN0IHdoaWNoIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBib3VuZCB0b1xuICogQHBhcmFtIGZuTmFtZXMgVGhlIGZ1bmN0aW9uIG5hbWVzIHdoaWNoIHdpbGwgYmUgYm91bmQgKERlZmF1bHRzIHRvIGFsbCB0aGUgZnVuY3Rpb25zIGZvdW5kIG9uIHRoZSAnZnJvbScgb2JqZWN0KVxuICogQHBhcmFtIGxhdGViaW5kIElmIHRydWUsIHRoZSBiaW5kaW5nIG9mIHRoZSBmdW5jdGlvbiBpcyBkZWxheWVkIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgaW52b2tlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbnMoXG4gIHNvdXJjZTogRnVuY3Rpb24sXG4gIHRhcmdldDogT2JqLFxuICBiaW5kOiBGdW5jdGlvbixcbiAgZm5OYW1lcz86IHN0cmluZ1tdLFxuICBsYXRlYmluZCA9IGZhbHNlXG4pOiBPYmoge1xuICBjb25zdCBiaW5kRnVuY3Rpb24gPSBmbk5hbWUgPT4gc291cmNlKClbZm5OYW1lXS5iaW5kKGJpbmQoKSk7XG5cbiAgY29uc3QgbWFrZUxhdGVSZWJpbmRGbiA9IGZuTmFtZSA9PlxuICAgIGZ1bmN0aW9uIGxhdGVSZWJpbmRGdW5jdGlvbigpIHtcbiAgICAgIHRhcmdldFtmbk5hbWVdID0gYmluZEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgICByZXR1cm4gdGFyZ2V0W2ZuTmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gIGZuTmFtZXMgPSBmbk5hbWVzIHx8IE9iamVjdC5rZXlzKHNvdXJjZSgpKTtcblxuICByZXR1cm4gZm5OYW1lcy5yZWR1Y2UoKGFjYywgbmFtZSkgPT4ge1xuICAgIGFjY1tuYW1lXSA9IGxhdGViaW5kID8gbWFrZUxhdGVSZWJpbmRGbihuYW1lKSA6IGJpbmRGdW5jdGlvbihuYW1lKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgaGVscGVyLlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2hpY2ggaGFzIGBwYXJlbnRgIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLCBhbmQgdGhlbiBjb3BpZXMgdGhlIHByb3BlcnRpZXMgZnJvbSBgZXh0cmFgIG9udG8gaXRcbiAqL1xuZXhwb3J0IGNvbnN0IGluaGVyaXQgPSAocGFyZW50OiBPYmosIGV4dHJhPzogT2JqKSA9PiBleHRlbmQoT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCBleHRyYSk7XG5cbi8qKiBHaXZlbiBhbiBhcnJheSwgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgZm91bmQgaW4gdGhlIGFycmF5LCAodXNpbmcgaW5kZXhPZikgKi9cbmV4cG9ydCBjb25zdCBpbkFycmF5OiB0eXBlb2YgX2luQXJyYXkgPSBjdXJyeShfaW5BcnJheSkgYXMgYW55O1xuZXhwb3J0IGZ1bmN0aW9uIF9pbkFycmF5KGFycmF5OiBhbnlbXSwgb2JqOiBhbnkpOiBib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIF9pbkFycmF5KGFycmF5OiBhbnlbXSk6IChvYmo6IGFueSkgPT4gYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBfaW5BcnJheShhcnJheSwgb2JqPyk6IGFueSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKG9iaikgIT09IC0xO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5LCBhbmQgYW4gaXRlbSwgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGFycmF5LCBpdCByZW1vdmVzIGl0IChpbi1wbGFjZSkuXG4gKiBUaGUgc2FtZSBhcnJheSBpcyByZXR1cm5lZFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRnJvbTogdHlwZW9mIF9yZW1vdmVGcm9tID0gY3VycnkoX3JlbW92ZUZyb20pIGFzIGFueTtcbmV4cG9ydCBmdW5jdGlvbiBfcmVtb3ZlRnJvbTxUPihhcnJheTogVFtdLCBvYmo6IFQpOiBUW107XG5leHBvcnQgZnVuY3Rpb24gX3JlbW92ZUZyb208VD4oYXJyYXk6IFRbXSk6IChvYmo6IFQpID0+IFRbXTtcbmV4cG9ydCBmdW5jdGlvbiBfcmVtb3ZlRnJvbShhcnJheSwgb2JqPykge1xuICBjb25zdCBpZHggPSBhcnJheS5pbmRleE9mKG9iaik7XG4gIGlmIChpZHggPj0gMCkgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqIHB1c2hlcyBhIHZhbHVlcyB0byBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgdmFsdWUgKi9cbmV4cG9ydCBjb25zdCBwdXNoVG86IHR5cGVvZiBfcHVzaFRvID0gY3VycnkoX3B1c2hUbykgYXMgYW55O1xuZXhwb3J0IGZ1bmN0aW9uIF9wdXNoVG88VD4oYXJyOiBUW10sIHZhbDogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gX3B1c2hUbzxUPihhcnI6IFRbXSk6ICh2YWw6IFQpID0+IFQ7XG5leHBvcnQgZnVuY3Rpb24gX3B1c2hUbyhhcnIsIHZhbD8pOiBhbnkge1xuICByZXR1cm4gYXJyLnB1c2godmFsKSwgdmFsO1xufVxuXG4vKiogR2l2ZW4gYW4gYXJyYXkgb2YgKGRlcmVnaXN0cmF0aW9uKSBmdW5jdGlvbnMsIGNhbGxzIGFsbCBmdW5jdGlvbnMgYW5kIHJlbW92ZXMgZWFjaCBvbmUgZnJvbSB0aGUgc291cmNlIGFycmF5ICovXG5leHBvcnQgY29uc3QgZGVyZWdBbGwgPSAoZnVuY3Rpb25zOiBGdW5jdGlvbltdKSA9PlxuICBmdW5jdGlvbnMuc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgZm4oKTtcbiAgICByZW1vdmVGcm9tKGZ1bmN0aW9ucywgZm4pO1xuICB9KTtcbi8qKlxuICogQXBwbGllcyBhIHNldCBvZiBkZWZhdWx0cyB0byBhbiBvcHRpb25zIG9iamVjdC4gIFRoZSBvcHRpb25zIG9iamVjdCBpcyBmaWx0ZXJlZFxuICogdG8gb25seSB0aG9zZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QuXG4gKiBFYXJsaWVyIG9iamVjdHMgaW4gdGhlIGRlZmF1bHRzTGlzdCB0YWtlIHByZWNlZGVuY2Ugd2hlbiBhcHBseWluZyBkZWZhdWx0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKG9wdHMsIC4uLmRlZmF1bHRzTGlzdDogT2JqW10pIHtcbiAgY29uc3QgZGVmYXVsdFZhbHMgPSBleHRlbmQoe30sIC4uLmRlZmF1bHRzTGlzdC5yZXZlcnNlKCkpO1xuICByZXR1cm4gZXh0ZW5kKGRlZmF1bHRWYWxzLCBwaWNrKG9wdHMgfHwge30sIE9iamVjdC5rZXlzKGRlZmF1bHRWYWxzKSkpO1xufVxuXG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGVhY2ggZWxlbWVudCBvZiB0aGUgbGlzdCBpbnRvIGEgc2luZ2xlIG9iamVjdCwgdXNpbmcgZXh0ZW5kICovXG5leHBvcnQgY29uc3QgbWVyZ2VSID0gKG1lbW86IE9iaiwgaXRlbTogT2JqKSA9PiBleHRlbmQobWVtbywgaXRlbSk7XG5cbi8qKlxuICogRmluZHMgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgVGhlIGZpcnN0IHN0YXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCBUaGUgc2Vjb25kIHN0YXRlLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgbmFtZXMgaW4gZGVzY2VuZGluZyBvcmRlciwgbm90IGluY2x1ZGluZyB0aGUgcm9vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuY2VzdG9ycyhmaXJzdDogU3RhdGVPYmplY3QsIHNlY29uZDogU3RhdGVPYmplY3QpIHtcbiAgY29uc3QgcGF0aDogU3RhdGVPYmplY3RbXSA9IFtdO1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxuICBmb3IgKGNvbnN0IG4gaW4gZmlyc3QucGF0aCkge1xuICAgIGlmIChmaXJzdC5wYXRoW25dICE9PSBzZWNvbmQucGF0aFtuXSkgYnJlYWs7XG4gICAgcGF0aC5wdXNoKGZpcnN0LnBhdGhbbl0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBwaWNrKGZvbywgWydhJywgJ2InXSk7IC8vIHsgYTogMSwgYjogMiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmo6IE9iaiwgcHJvcE5hbWVzOiBzdHJpbmdbXSk6IE9iaiB7XG4gIGNvbnN0IG9iakNvcHkgPSB7fTtcbiAgZm9yIChjb25zdCBfcHJvcCBpbiBvYmopIHtcbiAgICBpZiAocHJvcE5hbWVzLmluZGV4T2YoX3Byb3ApICE9PSAtMSkge1xuICAgICAgb2JqQ29weVtfcHJvcF0gPSBvYmpbX3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqQ29weTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb21pdHRpbmcgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIHZhciBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfTtcbiAqIHZhciBhYiA9IG9taXQoZm9vLCBbJ2EnLCAnYiddKTsgLy8geyBjOiAzIH1cbiAqIGBgYFxuICogQHBhcmFtIG9iaiB0aGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtIHByb3BOYW1lcyBhbiBBcnJheSBvZiBzdHJpbmdzLCB3aGljaCBhcmUgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnR5IG5hbWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0KG9iajogT2JqLCBwcm9wTmFtZXM6IHN0cmluZ1tdKTogT2JqIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAuZmlsdGVyKG5vdChpbkFycmF5KHByb3BOYW1lcykpKVxuICAgIC5yZWR1Y2UoKGFjYywga2V5KSA9PiAoKGFjY1trZXldID0gb2JqW2tleV0pLCBhY2MpLCB7fSk7XG59XG5cbi8qKiBHaXZlbiBhbiBhcnJheSBvZiBvYmplY3RzLCBtYXBzIGVhY2ggZWxlbWVudCB0byBhIG5hbWVkIHByb3BlcnR5IG9mIHRoZSBlbGVtZW50LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsdWNrPFQ+KGNvbGxlY3Rpb246IE9ialtdLCBwcm9wTmFtZTogc3RyaW5nKTogVFtdO1xuLyoqIEdpdmVuIGFuIG9iamVjdCwgbWFwcyBlYWNoIHByb3BlcnR5IG9mIHRoZSBvYmplY3QgdG8gYSBuYW1lZCBwcm9wZXJ0eSBvZiB0aGUgcHJvcGVydHkuICovXG5leHBvcnQgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSwgcHJvcE5hbWU6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4vKipcbiAqIE1hcHMgYW4gYXJyYXksIG9yIG9iamVjdCB0byBhIHByb3BlcnR5IChieSBuYW1lKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbjogYW55LCBwcm9wTmFtZTogc3RyaW5nKTogYW55IHtcbiAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCA8TWFwcGVyPGFueSwgc3RyaW5nPj5wcm9wKHByb3BOYW1lKSk7XG59XG5cbi8qKiBHaXZlbiBhbiBhcnJheSBvZiBvYmplY3RzLCByZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgb25seSB0aGUgZWxlbWVudHMgd2hpY2ggcGFzc2VkIHRoZSBjYWxsYmFjayBwcmVkaWNhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXI8VD4oY29sbGVjdGlvbjogVFtdLCBjYWxsYmFjazogKHQ6IFQsIGtleT86IG51bWJlcikgPT4gYm9vbGVhbik6IFRbXTtcbi8qKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggb25seSB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBwcmVkaWNhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXI8VD4oY29sbGVjdGlvbjogVHlwZWRNYXA8VD4sIGNhbGxiYWNrOiAodDogVCwga2V5Pzogc3RyaW5nKSA9PiBib29sZWFuKTogVHlwZWRNYXA8VD47XG4vKiogRmlsdGVycyBhbiBBcnJheSBvciBhbiBPYmplY3QncyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQ+KGNvbGxlY3Rpb246IGFueSwgY2FsbGJhY2s6IEZ1bmN0aW9uKTogVCB7XG4gIGNvbnN0IGFyciA9IGlzQXJyYXkoY29sbGVjdGlvbiksXG4gICAgcmVzdWx0OiBhbnkgPSBhcnIgPyBbXSA6IHt9O1xuICBjb25zdCBhY2NlcHQgPSBhcnIgPyB4ID0+IHJlc3VsdC5wdXNoKHgpIDogKHgsIGtleSkgPT4gKHJlc3VsdFtrZXldID0geCk7XG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSkgYWNjZXB0KGl0ZW0sIGkpO1xuICB9KTtcbiAgcmV0dXJuIDxUPnJlc3VsdDtcbn1cblxuLyoqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJuIHRoZSBmaXJzdCBwcm9wZXJ0eSBvZiB0aGF0IG9iamVjdCB3aGljaCBwYXNzZWQgdGhlIGNhbGxiYWNrIHByZWRpY2F0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4oY29sbGVjdGlvbjogVHlwZWRNYXA8VD4sIGNhbGxiYWNrOiBQcmVkaWNhdGU8VD4pOiBUO1xuLyoqIEdpdmVuIGFuIGFycmF5IG9mIG9iamVjdHMsIHJldHVybnMgdGhlIGZpcnN0IG9iamVjdCB3aGljaCBwYXNzZWQgdGhlIGNhbGxiYWNrIHByZWRpY2F0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4oY29sbGVjdGlvbjogVFtdLCBjYWxsYmFjazogUHJlZGljYXRlPFQ+KTogVDtcbi8qKiBGaW5kcyBhbiBvYmplY3QgZnJvbSBhbiBhcnJheSwgb3IgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIHRoYXQgbWF0Y2hlcyBhIHByZWRpY2F0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbjogYW55LCBjYWxsYmFjazogYW55KSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuO1xuICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSkgcmVzdWx0ID0gaXRlbTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdHJhbnNmb3JtZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5leHBvcnQgbGV0IG1hcE9iajogPFQsIFU+KFxuICBjb2xsZWN0aW9uOiB7IFtrZXk6IHN0cmluZ106IFQgfSxcbiAgY2FsbGJhY2s6IE1hcHBlcjxULCBVPixcbiAgdGFyZ2V0PzogdHlwZW9mIGNvbGxlY3Rpb25cbikgPT4geyBba2V5OiBzdHJpbmddOiBVIH0gPSBtYXA7XG4vKiogR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgYSBuZXcgYXJyYXksIHdoZXJlIGVhY2ggZWxlbWVudCBpcyB0cmFuc2Zvcm1lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4oY29sbGVjdGlvbjogVFtdLCBjYWxsYmFjazogTWFwcGVyPFQsIFU+LCB0YXJnZXQ/OiB0eXBlb2YgY29sbGVjdGlvbik6IFVbXTtcbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4oXG4gIGNvbGxlY3Rpb246IHsgW2tleTogc3RyaW5nXTogVCB9LFxuICBjYWxsYmFjazogTWFwcGVyPFQsIFU+LFxuICB0YXJnZXQ/OiB0eXBlb2YgY29sbGVjdGlvblxuKTogeyBba2V5OiBzdHJpbmddOiBVIH07XG4vKiogTWFwcyBhbiBhcnJheSBvciBvYmplY3QgcHJvcGVydGllcyB1c2luZyBhIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb246IGFueSwgY2FsbGJhY2s6IGFueSwgdGFyZ2V0OiB0eXBlb2YgY29sbGVjdGlvbik6IGFueSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCAoaXNBcnJheShjb2xsZWN0aW9uKSA/IFtdIDoge30pO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIChpdGVtLCBpKSA9PiAodGFyZ2V0W2ldID0gY2FsbGJhY2soaXRlbSwgaSkpKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBpdHMgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4gKiBsZXQgdmFscyA9IHZhbHVlcyhmb28pOyAvLyBbIDEsIDIsIDMgXVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB2YWx1ZXM6ICg8VD4ob2JqOiBUeXBlZE1hcDxUPikgPT4gVFtdKSA9IChvYmo6IE9iaikgPT4gT2JqZWN0LmtleXMob2JqKS5tYXAoa2V5ID0+IG9ialtrZXldKTtcblxuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDEsIHRydWUsIHt9LCBcImhlbGxvIHdvcmxkXCJdO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKlxuICogdmFscy5wdXNoKDApO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBhbGxUcnVlUiA9IChtZW1vOiBib29sZWFuLCBlbGVtOiBhbnkpID0+IG1lbW8gJiYgZWxlbTtcblxuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiAgKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDAsIG51bGwsIHVuZGVmaW5lZCBdO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICpcbiAqIHZhbHMucHVzaChcImhlbGxvIHdvcmxkXCIpO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGFueVRydWVSID0gKG1lbW86IGJvb2xlYW4sIGVsZW06IGFueSkgPT4gbWVtbyB8fCBlbGVtO1xuXG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCB1bi1uZXN0cyBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXNcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1bm5lc3RSID0gKG1lbW86IGFueVtdLCBlbGVtOiBhbnlbXSkgPT4gbWVtby5jb25jYXQoZWxlbSk7XG5cbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIHJlY3Vyc2l2ZWx5IHVuLW5lc3RzIGFsbCBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJkb3VibGUsIFwibmVzdGVkXCIgXVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuUiA9IChtZW1vOiBhbnlbXSwgZWxlbTogYW55KSA9PlxuICBpc0FycmF5KGVsZW0pID8gbWVtby5jb25jYXQoZWxlbS5yZWR1Y2UoZmxhdHRlblIsIFtdKSkgOiBwdXNoUihtZW1vLCBlbGVtKTtcblxuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCBwdXNoZXMgYW4gb2JqZWN0IHRvIGFuIGFycmF5LCB0aGVuIHJldHVybnMgdGhlIGFycmF5LlxuICogTW9zdGx5IGp1c3QgZm9yIFtbZmxhdHRlblJdXSBhbmQgW1t1bmlxUl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoUihhcnI6IGFueVtdLCBvYmo6IGFueSkge1xuICBhcnIucHVzaChvYmopO1xuICByZXR1cm4gYXJyO1xufVxuXG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgZmlsdGVycyBvdXQgZHVwbGljYXRlcyAqL1xuZXhwb3J0IGNvbnN0IHVuaXFSID0gPFQ+KGFjYzogVFtdLCB0b2tlbjogVCk6IFRbXSA9PiAoaW5BcnJheShhY2MsIHRva2VuKSA/IGFjYyA6IHB1c2hSKGFjYywgdG9rZW4pKTtcblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXMgdW5uZXN0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG4gKiB1bm5lc3QoaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFsgXCJkb3VibGUsIFwibmVzdGVkXCIgXSBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHVubmVzdCA9IChhcnI6IGFueVtdKSA9PiBhcnIucmVkdWNlKHVubmVzdFIsIFtdKTtcbi8qKlxuICogUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGZsYXR0ZW4oaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IChhcnI6IGFueVtdKSA9PiBhcnIucmVkdWNlKGZsYXR0ZW5SLCBbXSk7XG5cbi8qKlxuICogR2l2ZW4gYSAuZmlsdGVyIFByZWRpY2F0ZSwgYnVpbGRzIGEgLmZpbHRlciBQcmVkaWNhdGUgd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBlbGVtZW50cyBkbyBub3QgcGFzcy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaXNOdW1iZXIgPSAob2JqKSA9PiB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcic7XG4gKiBsZXQgYWxsTnVtYmVycyA9IFsgMSwgMiwgMywgNCwgNSBdO1xuICogYWxsTnVtYmVycy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyKSk7IC8vT0tcbiAqXG4gKiBsZXQgb25lU3RyaW5nID0gWyAxLCAyLCAzLCA0LCBcIjVcIiBdO1xuICogb25lU3RyaW5nLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIsIFwiTm90IGFsbCBudW1iZXJzXCIpKTsgLy8gdGhyb3dzIEVycm9yKFwiXCJOb3QgYWxsIG51bWJlcnNcIlwiKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYXNzZXJ0UHJlZGljYXRlOiA8VD4ocHJlZGljYXRlOiBQcmVkaWNhdGU8VD4sIGVyck1zZzogc3RyaW5nIHwgRnVuY3Rpb24pID0+IFByZWRpY2F0ZTxUPiA9IGFzc2VydEZuO1xuLyoqXG4gKiBHaXZlbiBhIC5tYXAgZnVuY3Rpb24sIGJ1aWxkcyBhIC5tYXAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBtYXBwZWQgZWxlbWVudHMgZG8gbm90IHBhc3MgYSB0cnV0aHluZXNzIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIGRhdGEgPSB7IGZvbzogMSwgYmFyOiAyIH07XG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJyBdXG4gKiBsZXQgdmFsdWVzID0ga2V5cy5tYXAoYXNzZXJ0TWFwKGtleSA9PiBkYXRhW2tleV0sIFwiS2V5IG5vdCBmb3VuZFwiKSk7XG4gKiAvLyB2YWx1ZXMgaXMgWzEsIDJdXG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJywgJ2JheicgXVxuICogbGV0IHZhbHVlcyA9IGtleXMubWFwKGFzc2VydE1hcChrZXkgPT4gZGF0YVtrZXldLCBcIktleSBub3QgZm91bmRcIikpO1xuICogLy8gdGhyb3dzIEVycm9yKFwiS2V5IG5vdCBmb3VuZFwiKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBhc3NlcnRNYXA6IDxULCBVPihtYXBGbjogKHQ6IFQpID0+IFUsIGVyck1zZzogc3RyaW5nIHwgRnVuY3Rpb24pID0+ICh0OiBUKSA9PiBVID0gYXNzZXJ0Rm47XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Rm4ocHJlZGljYXRlT3JNYXA6IEZ1bmN0aW9uLCBlcnJNc2c6IHN0cmluZyB8IEZ1bmN0aW9uID0gJ2Fzc2VydCBmYWlsdXJlJyk6IGFueSB7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHByZWRpY2F0ZU9yTWFwKG9iaik7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihpc0Z1bmN0aW9uKGVyck1zZykgPyAoPEZ1bmN0aW9uPmVyck1zZykob2JqKSA6IGVyck1zZyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogTGlrZSBfLnBhaXJzOiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYW4gYXJyYXkgb2Yga2V5L3ZhbHVlIHBhaXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIHBhaXJzKHsgZm9vOiBcIkZPT1wiLCBiYXI6IFwiQkFSIH0pIC8vIFsgWyBcImZvb1wiLCBcIkZPT1wiIF0sIFsgXCJiYXJcIjogXCJCQVJcIiBdIF1cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgcGFpcnMgPSAob2JqOiBPYmopID0+IE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiBba2V5LCBvYmpba2V5XV0pO1xuXG4vKipcbiAqIEdpdmVuIHR3byBvciBtb3JlIHBhcmFsbGVsIGFycmF5cywgcmV0dXJucyBhbiBhcnJheSBvZiB0dXBsZXMgd2hlcmVcbiAqIGVhY2ggdHVwbGUgaXMgY29tcG9zZWQgb2YgWyBhW2ldLCBiW2ldLCAuLi4geltpXSBdXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBmb28gPSBbIDAsIDIsIDQsIDYgXTtcbiAqIGxldCBiYXIgPSBbIDEsIDMsIDUsIDcgXTtcbiAqIGxldCBiYXogPSBbIDEwLCAzMCwgNTAsIDcwIF07XG4gKiBhcnJheVR1cGxlcyhmb28sIGJhcik7ICAgICAgIC8vIFsgWzAsIDFdLCBbMiwgM10sIFs0LCA1XSwgWzYsIDddIF1cbiAqIGFycmF5VHVwbGVzKGZvbywgYmFyLCBiYXopOyAgLy8gWyBbMCwgMSwgMTBdLCBbMiwgMywgMzBdLCBbNCwgNSwgNTBdLCBbNiwgNywgNzBdIF1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUdXBsZXMoLi4uYXJnczogYW55W10pOiBhbnlbXSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBjb25zdCBtYXhBcnJheUxlbiA9IGFyZ3MucmVkdWNlKChtaW4sIGFycikgPT4gTWF0aC5taW4oYXJyLmxlbmd0aCwgbWluKSwgOTAwNzE5OTI1NDc0MDk5MSk7IC8vIGFrYSAyXjUzIOKIkiAxIGFrYSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEFycmF5TGVuOyBpKyspIHtcbiAgICAvLyBUaGlzIGlzIGEgaG90IGZ1bmN0aW9uXG4gICAgLy8gVW5yb2xsIHdoZW4gdGhlcmUgYXJlIDEtNCBhcmd1bWVudHNcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV0sIGFyZ3NbMl1baV1dKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldLCBhcmdzWzJdW2ldLCBhcmdzWzNdW2ldXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzdWx0LnB1c2goYXJncy5tYXAoYXJyYXkgPT4gYXJyYXlbaV0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggYnVpbGRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIFtrZXksIHZhbHVlXSBwYWlycy5cbiAqXG4gKiBFYWNoIGl0ZXJhdGlvbiBzZXRzIHRoZSBrZXkvdmFsIHBhaXIgb24gdGhlIG1lbW8gb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG1lbW8gZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAqXG4gKiBFYWNoIGtleVZhbHVlVHVwbGUgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdmFsdWVzIFsga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkgXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgcGFpcnMgPSBbIFtcImZvb2tleVwiLCBcImZvb3ZhbFwiXSwgW1wiYmFya2V5XCIsIFwiYmFydmFsXCJdIF1cbiAqXG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZSgobWVtbywgcGFpcikgPT4gYXBwbHlQYWlycyhtZW1vLCBwYWlyKSwge30pXG4gKiAvLyBwYWlyc1RvT2JqID09IHsgZm9va2V5OiBcImZvb3ZhbFwiLCBiYXJrZXk6IFwiYmFydmFsXCIgfVxuICpcbiAqIC8vIE9yLCBtb3JlIHNpbXBseTpcbiAqIHZhciBwYWlyc1RvT2JqID0gcGFpcnMucmVkdWNlKGFwcGx5UGFpcnMsIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYWlycyhtZW1vOiBUeXBlZE1hcDxhbnk+LCBrZXlWYWxUdXBsZTogYW55W10pIHtcbiAgbGV0IGtleTogc3RyaW5nLCB2YWx1ZTogYW55O1xuICBpZiAoaXNBcnJheShrZXlWYWxUdXBsZSkpIFtrZXksIHZhbHVlXSA9IGtleVZhbFR1cGxlO1xuICBpZiAoIWlzU3RyaW5nKGtleSkpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXJhbWV0ZXJzIHRvIGFwcGx5UGFpcnMnKTtcbiAgbWVtb1trZXldID0gdmFsdWU7XG4gIHJldHVybiBtZW1vO1xufVxuXG4vKiogR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWlsPFQ+KGFycjogVFtdKTogVCB7XG4gIHJldHVybiAoYXJyLmxlbmd0aCAmJiBhcnJbYXJyLmxlbmd0aCAtIDFdKSB8fCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogc2hhbGxvdyBjb3B5IGZyb20gc3JjIHRvIGRlc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc3JjOiBPYmosIGRlc3Q/OiBPYmopIHtcbiAgaWYgKGRlc3QpIE9iamVjdC5rZXlzKGRlc3QpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBkZXN0W2tleV0pO1xuICBpZiAoIWRlc3QpIGRlc3QgPSB7fTtcbiAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMpO1xufVxuXG4vKiogTmFpdmUgZm9yRWFjaCBpbXBsZW1lbnRhdGlvbiB3b3JrcyB3aXRoIE9iamVjdHMgb3IgQXJyYXlzICovXG5mdW5jdGlvbiBfZm9yRWFjaChvYmo6IGFueVtdIHwgYW55LCBjYjogKGVsLCBpZHg/KSA9PiB2b2lkLCBfdGhpczogT2JqKSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHJldHVybiBvYmouZm9yRWFjaChjYiwgX3RoaXMpO1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IGNiKG9ialtrZXldLCBrZXkpKTtcbn1cblxuLyoqIExpa2UgT2JqZWN0LmFzc2lnbigpICovXG5leHBvcnQgZnVuY3Rpb24gX2V4dGVuZCh0b09iajogT2JqLCAuLi5mcm9tT2JqczogT2JqW10pOiBhbnk7XG5leHBvcnQgZnVuY3Rpb24gX2V4dGVuZCh0b09iajogT2JqKTogYW55IHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKCFvYmopIGNvbnRpbnVlO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b09ialtrZXlzW2pdXSA9IG9ialtrZXlzW2pdXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9PYmo7XG59XG5cbmZ1bmN0aW9uIF9lcXVhbHMobzE6IGFueSwgbzI6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAobzEgPT09IG8yKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvMSAhPT0gbzEgJiYgbzIgIT09IG8yKSByZXR1cm4gdHJ1ZTsgLy8gTmFOID09PSBOYU5cbiAgY29uc3QgdDEgPSB0eXBlb2YgbzEsXG4gICAgdDIgPSB0eXBlb2YgbzI7XG4gIGlmICh0MSAhPT0gdDIgfHwgdDEgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgdHVwID0gW28xLCBvMl07XG4gIGlmIChhbGwoaXNBcnJheSkodHVwKSkgcmV0dXJuIF9hcnJheXNFcShvMSwgbzIpO1xuICBpZiAoYWxsKGlzRGF0ZSkodHVwKSkgcmV0dXJuIG8xLmdldFRpbWUoKSA9PT0gbzIuZ2V0VGltZSgpO1xuICBpZiAoYWxsKGlzUmVnRXhwKSh0dXApKSByZXR1cm4gbzEudG9TdHJpbmcoKSA9PT0gbzIudG9TdHJpbmcoKTtcbiAgaWYgKGFsbChpc0Z1bmN0aW9uKSh0dXApKSByZXR1cm4gdHJ1ZTsgLy8gbWVoXG5cbiAgY29uc3QgcHJlZGljYXRlcyA9IFtpc0Z1bmN0aW9uLCBpc0FycmF5LCBpc0RhdGUsIGlzUmVnRXhwXTtcbiAgaWYgKHByZWRpY2F0ZXMubWFwKGFueSkucmVkdWNlKChiLCBmbikgPT4gYiB8fCAhIWZuKHR1cCksIGZhbHNlKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGtleXM6IHsgW2k6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgZm9yIChjb25zdCBrZXkgaW4gbzEpIHtcbiAgICBpZiAoIV9lcXVhbHMobzFba2V5XSwgbzJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICBrZXlzW2tleV0gPSB0cnVlO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG8yKSB7XG4gICAgaWYgKCFrZXlzW2tleV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlzRXEoYTE6IGFueVtdLCBhMjogYW55W10pIHtcbiAgaWYgKGExLmxlbmd0aCAhPT0gYTIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBhcnJheVR1cGxlcyhhMSwgYTIpLnJlZHVjZSgoYiwgdCkgPT4gYiAmJiBfZXF1YWxzKHRbMF0sIHRbMV0pLCB0cnVlKTtcbn1cblxuLy8gaXNzdWUgIzI2NzZcbmV4cG9ydCBjb25zdCBzaWxlbmNlVW5jYXVnaHRJblByb21pc2UgPSAocHJvbWlzZTogUHJvbWlzZTxhbnk+KSA9PiBwcm9taXNlLmNhdGNoKGUgPT4gMCkgJiYgcHJvbWlzZTtcbmV4cG9ydCBjb25zdCBzaWxlbnRSZWplY3Rpb24gPSAoZXJyb3I6IGFueSkgPT4gc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKHNlcnZpY2VzLiRxLnJlamVjdChlcnJvcikpO1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBjb3JlICovXG4vKipcbiAqIE1hdGNoZXMgc3RhdGUgbmFtZXMgdXNpbmcgZ2xvYi1saWtlIHBhdHRlcm4gc3RyaW5ncy5cbiAqXG4gKiBHbG9icyBjYW4gYmUgdXNlZCBpbiBzcGVjaWZpYyBBUElzIGluY2x1ZGluZzpcbiAqXG4gKiAtIFtbU3RhdGVTZXJ2aWNlLmlzXV1cbiAqIC0gW1tTdGF0ZVNlcnZpY2UuaW5jbHVkZXNdXVxuICogLSBUaGUgZmlyc3QgYXJndW1lbnQgdG8gSG9vayBSZWdpc3RyYXRpb24gZnVuY3Rpb25zIGxpa2UgW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV1cbiAqICAgIC0gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGFuZCBbW0hvb2tNYXRjaENyaXRlcmlvbl1dXG4gKlxuICogQSBgR2xvYmAgc3RyaW5nIGlzIGEgcGF0dGVybiB3aGljaCBtYXRjaGVzIHN0YXRlIG5hbWVzLlxuICogTmVzdGVkIHN0YXRlIG5hbWVzIGFyZSBzcGxpdCBpbnRvIHNlZ21lbnRzIChzZXBhcmF0ZWQgYnkgYSBkb3QpIHdoZW4gcHJvY2Vzc2luZy5cbiAqIFRoZSBzdGF0ZSBuYW1lZCBgZm9vLmJhci5iYXpgIGlzIHNwbGl0IGludG8gdGhyZWUgc2VnbWVudHMgWydmb28nLCAnYmFyJywgJ2JheiddXG4gKlxuICogR2xvYnMgd29yayBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBydWxlczpcbiAqXG4gKiAjIyMgRXhhY3QgbWF0Y2g6XG4gKlxuICogVGhlIGdsb2IgYCdBLkInYCBtYXRjaGVzIHRoZSBzdGF0ZSBuYW1lZCBleGFjdGx5IGAnQS5CJ2AuXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWR8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWR8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCdBJ2AgICAgICAgfCBgJ0EnYCAgICAgICAgICAgICAgIHwgYCdCJ2AgLCBgJ0EuQydgICAgICAgfFxuICogfCBgJ0EuQidgICAgICB8IGAnQS5CJ2AgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICB8XG4gKiB8IGAnZm9vJ2AgICAgIHwgYCdmb28nYCAgICAgICAgICAgICB8IGAnRk9PJ2AgLCBgJ2Zvby5iYXInYHxcbiAqXG4gKiAjIyMgU2luZ2xlIHN0YXIgKGAqYClcbiAqXG4gKiBBIHNpbmdsZSBzdGFyIChgKmApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzIGV4YWN0bHkgb25lIHNlZ21lbnQuXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWQgIHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZCB8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCcqJ2AgICAgICAgfCBgJ0EnYCAsIGAnWidgICAgICAgICB8IGAnQS5CJ2AgLCBgJ1ouWS5YJ2AgICAgICAgfFxuICogfCBgJ0EuKidgICAgICB8IGAnQS5CJ2AgLCBgJ0EuQydgICAgIHwgYCdBJ2AgLCBgJ0EuQi5DJ2AgICAgICAgICB8XG4gKiB8IGAnQS4qLionYCAgIHwgYCdBLkIuQydgICwgYCdBLlguWSdgfCBgJ0EnYCwgYCdBLkInYCAsIGAnWi5ZLlgnYHxcbiAqXG4gKiAjIyMgRG91YmxlIHN0YXIgKGAqKmApXG4gKlxuICogQSBkb3VibGUgc3RhciAoYCcqKidgKSBpcyBhIHdpbGRjYXJkIHRoYXQgbWF0Y2hlcyAqemVybyBvciBtb3JlIHNlZ21lbnRzKlxuICpcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkICAgICAgICAgICAgICAgICAgICAgICAgICAgfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkICAgICAgICAgfFxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IGAnKionYCAgICAgIHwgYCdBJ2AgLCBgJ0EuQidgLCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgIHwgKG1hdGNoZXMgYWxsIHN0YXRlcykgICAgICAgICAgICAgIHxcbiAqIHwgYCdBLioqJ2AgICAgfCBgJ0EnYCAsIGAnQS5CJ2AgLCBgJ0EuQy5YJ2AgICAgICAgICAgICAgICAgICAgfCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgJyoqLlgnYCAgICB8IGAnWCdgICwgYCdBLlgnYCAsIGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLmxvZ2luLlonYCAgICAgICAgICAgICB8XG4gKiB8IGAnQS4qKi5YJ2AgIHwgYCdBLlgnYCAsIGAnQS5CLlgnYCAsIGAnQS5CLkMuWCdgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EuQi5DJ2AgICAgICAgICAgICAgICAgIHxcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBHbG9iIHtcbiAgdGV4dDogc3RyaW5nO1xuICBnbG9iOiBBcnJheTxzdHJpbmc+O1xuICByZWdleHA6IFJlZ0V4cDtcblxuICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaGFzIGdsb2ItbGlrZSBjaGFyYWN0ZXJzIGluIGl0ICovXG4gIHN0YXRpYyBpcyh0ZXh0OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gISEvWyEsKl0rLy5leGVjKHRleHQpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBnbG9iIGZyb20gdGhlIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgc3RyaW5nIGlzbid0IEdsb2ItbGlrZSAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gR2xvYi5pcyh0ZXh0KSA/IG5ldyBHbG9iKHRleHQpIDogbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHRleHQ6IHN0cmluZykge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5nbG9iID0gdGV4dC5zcGxpdCgnLicpO1xuXG4gICAgY29uc3QgcmVnZXhwU3RyaW5nID0gdGhpcy50ZXh0XG4gICAgICAuc3BsaXQoJy4nKVxuICAgICAgLm1hcChzZWcgPT4ge1xuICAgICAgICBpZiAoc2VnID09PSAnKionKSByZXR1cm4gJyg/OnwoPzpcXFxcLlteLl0qKSopJztcbiAgICAgICAgaWYgKHNlZyA9PT0gJyonKSByZXR1cm4gJ1xcXFwuW14uXSonO1xuICAgICAgICByZXR1cm4gJ1xcXFwuJyArIHNlZztcbiAgICAgIH0pXG4gICAgICAuam9pbignJyk7XG5cbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcmVnZXhwU3RyaW5nICsgJyQnKTtcbiAgfVxuXG4gIG1hdGNoZXMobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwLnRlc3QoJy4nICsgbmFtZSk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgY29tbW9uICovIC8qKiAqL1xuaW1wb3J0IHsgcHVzaFRvIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgY2xhc3MgUXVldWU8VD4ge1xuICBwcml2YXRlIF9ldmljdExpc3RlbmVyczogKChpdGVtOiBUKSA9PiB2b2lkKVtdID0gW107XG4gIHB1YmxpYyBvbkV2aWN0ID0gcHVzaFRvKHRoaXMuX2V2aWN0TGlzdGVuZXJzKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pdGVtczogVFtdID0gW10sIHByaXZhdGUgX2xpbWl0OiBudW1iZXIgPSBudWxsKSB7fVxuXG4gIGVucXVldWUoaXRlbTogVCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG4gICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICBpZiAodGhpcy5fbGltaXQgJiYgaXRlbXMubGVuZ3RoID4gdGhpcy5fbGltaXQpIHRoaXMuZXZpY3QoKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIGV2aWN0KCk6IFQge1xuICAgIGNvbnN0IGl0ZW06IFQgPSB0aGlzLl9pdGVtcy5zaGlmdCgpO1xuICAgIHRoaXMuX2V2aWN0TGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oaXRlbSkpO1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgZGVxdWV1ZSgpOiBUIHtcbiAgICBpZiAodGhpcy5zaXplKCkpIHJldHVybiB0aGlzLl9pdGVtcy5zcGxpY2UoMCwgMSlbMF07XG4gIH1cblxuICBjbGVhcigpOiBBcnJheTxUPiB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2l0ZW1zO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIHJlbW92ZShpdGVtOiBUKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICByZXR1cm4gaWR4ID4gLTEgJiYgdGhpcy5faXRlbXMuc3BsaWNlKGlkeCwgMSlbMF07XG4gIH1cblxuICBwZWVrVGFpbCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBwZWVrSGVhZCgpOiBUIHtcbiAgICBpZiAodGhpcy5zaXplKCkpIHJldHVybiB0aGlzLl9pdGVtc1swXTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgZXh0ZW5kLCBzaWxlbnRSZWplY3Rpb24gfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmdzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5cbmVudW0gUmVqZWN0VHlwZSB7XG4gIC8qKlxuICAgKiBBIG5ldyB0cmFuc2l0aW9uIHN1cGVyc2VkZWQgdGhpcyBvbmUuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgdHJhbnNpdGlvbiB3YXMgcnVubmluZywgYSBuZXcgdHJhbnNpdGlvbiBzdGFydGVkLlxuICAgKiBUaGlzIHRyYW5zaXRpb24gaXMgY2FuY2VsbGVkIGJlY2F1c2UgaXQgd2FzIHN1cGVyc2VkZWQgYnkgbmV3IHRyYW5zaXRpb24uXG4gICAqL1xuICBTVVBFUlNFREVEID0gMixcblxuICAvKipcbiAgICogVGhlIHRyYW5zaXRpb24gd2FzIGFib3J0ZWRcbiAgICpcbiAgICogVGhlIHRyYW5zaXRpb24gd2FzIGFib3J0ZWQgYnkgYSBob29rIHdoaWNoIHJldHVybmVkIGBmYWxzZWBcbiAgICovXG4gIEFCT1JURUQgPSAzLFxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNpdGlvbiB3YXMgaW52YWxpZFxuICAgKlxuICAgKiBUaGUgdHJhbnNpdGlvbiB3YXMgbmV2ZXIgc3RhcnRlZCBiZWNhdXNlIGl0IHdhcyBpbnZhbGlkXG4gICAqL1xuICBJTlZBTElEID0gNCxcblxuICAvKipcbiAgICogVGhlIHRyYW5zaXRpb24gd2FzIGlnbm9yZWRcbiAgICpcbiAgICogVGhlIHRyYW5zaXRpb24gd2FzIGlnbm9yZWQgYmVjYXVzZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdC5cbiAgICpcbiAgICogRWl0aGVyOlxuICAgKlxuICAgKiAtIFRoZSB0cmFuc2l0aW9uIGlzIHRhcmdldGluZyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgcGFyYW1ldGVyIHZhbHVlc1xuICAgKiAtIFRoZSB0cmFuc2l0aW9uIGlzIHRhcmdldGluZyB0aGUgc2FtZSBzdGF0ZSBhbmQgcGFyYW1ldGVyIHZhbHVlcyBhcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdHJhbnNpdGlvbi5cbiAgICovXG4gIElHTk9SRUQgPSA1LFxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNpdGlvbiBlcnJvcmVkLlxuICAgKlxuICAgKiBUaGlzIGdlbmVyYWxseSBtZWFucyBhIGhvb2sgdGhyZXcgYW4gZXJyb3Igb3IgcmV0dXJuZWQgYSByZWplY3RlZCBwcm9taXNlXG4gICAqL1xuICBFUlJPUiA9IDYsXG59XG5cbmV4cG9ydCB7IFJlamVjdFR5cGUgfTtcblxuLyoqIEBoaWRkZW4gKi9cbmxldCBpZCA9IDA7XG5cbmV4cG9ydCBjbGFzcyBSZWplY3Rpb24ge1xuICAvKiogQGhpZGRlbiAqL1xuICAkaWQgPSBpZCsrO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHJlamVjdGlvbi5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBpcyBhbiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRyYW5zaXRpb24gcmVqZWN0aW9uLlxuICAgKiBJZiB1c2luZyBUeXBlc2NyaXB0LCB0aGlzIGlzIGEgVHlwZXNjcmlwdCBlbnVtLlxuICAgKlxuICAgKiAtIFtbUmVqZWN0VHlwZS5TVVBFUlNFREVEXV0gKGAyYClcbiAgICogLSBbW1JlamVjdFR5cGUuQUJPUlRFRF1dIChgM2ApXG4gICAqIC0gW1tSZWplY3RUeXBlLklOVkFMSURdXSAoYDRgKVxuICAgKiAtIFtbUmVqZWN0VHlwZS5JR05PUkVEXV0gKGA1YClcbiAgICogLSBbW1JlamVjdFR5cGUuRVJST1JdXSAoYDZgKVxuICAgKlxuICAgKi9cbiAgdHlwZTogUmVqZWN0VHlwZTtcblxuICAvKipcbiAgICogQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIHJlamVjdGlvblxuICAgKi9cbiAgbWVzc2FnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGRldGFpbCBvYmplY3RcbiAgICpcbiAgICogVGhpcyB2YWx1ZSB2YXJpZXMgYmFzZWQgb24gdGhlIG1lY2hhbmlzbSBmb3IgcmVqZWN0aW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYW4gZXJyb3Igd2FzIHRocm93biBmcm9tIGEgaG9vaywgdGhlIGBkZXRhaWxgIHdpbGwgYmUgdGhlIGBFcnJvcmAgb2JqZWN0LlxuICAgKiBJZiBhIGhvb2sgcmV0dXJuZWQgYSByZWplY3RlZCBwcm9taXNlLCB0aGUgYGRldGFpbGAgd2lsbCBiZSB0aGUgcmVqZWN0ZWQgdmFsdWUuXG4gICAqL1xuICBkZXRhaWw6IGFueTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxuICAgKlxuICAgKiBXaGVuIGEgdHJhbnNpdGlvbiBpcyByZWRpcmVjdGVkLCB0aGUgcmVqZWN0aW9uIFtbdHlwZV1dIHdpbGwgYmUgW1tSZWplY3RUeXBlLlNVUEVSU0VERURdXSBhbmQgdGhpcyBmbGFnIHdpbGwgYmUgdHJ1ZS5cbiAgICovXG4gIHJlZGlyZWN0ZWQ6IGJvb2xlYW47XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqIGlzIGEgcmVqZWN0ZWQgcHJvbWlzZSBjcmVhdGVkIGZyb20gdGhlIGBhc1Byb21pc2VgIGZhY3RvcnkgKi9cbiAgc3RhdGljIGlzUmVqZWN0aW9uUHJvbWlzZShvYmo6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIGlzKFJlamVjdGlvbikob2JqLl90cmFuc2l0aW9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byB0cmFuc2l0aW9uIHN1cGVyc2VkZWQgKi9cbiAgc3RhdGljIHN1cGVyc2VkZWQoZGV0YWlsPzogYW55LCBvcHRpb25zPzogYW55KTogUmVqZWN0aW9uIHtcbiAgICBjb25zdCBtZXNzYWdlID0gJ1RoZSB0cmFuc2l0aW9uIGhhcyBiZWVuIHN1cGVyc2VkZWQgYnkgYSBkaWZmZXJlbnQgdHJhbnNpdGlvbic7XG4gICAgY29uc3QgcmVqZWN0aW9uID0gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLlNVUEVSU0VERUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWRpcmVjdGVkKSB7XG4gICAgICByZWplY3Rpb24ucmVkaXJlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZWplY3Rpb247XG4gIH1cblxuICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gcmVkaXJlY3RlZCB0cmFuc2l0aW9uICovXG4gIHN0YXRpYyByZWRpcmVjdGVkKGRldGFpbD86IGFueSk6IFJlamVjdGlvbiB7XG4gICAgcmV0dXJuIFJlamVjdGlvbi5zdXBlcnNlZGVkKGRldGFpbCwgeyByZWRpcmVjdGVkOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGludmFsaWQgdHJhbnNpdGlvbiAqL1xuICBzdGF0aWMgaW52YWxpZChkZXRhaWw/OiBhbnkpOiBSZWplY3Rpb24ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnVGhpcyB0cmFuc2l0aW9uIGlzIGludmFsaWQnO1xuICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuSU5WQUxJRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBpZ25vcmVkIHRyYW5zaXRpb24gKi9cbiAgc3RhdGljIGlnbm9yZWQoZGV0YWlsPzogYW55KTogUmVqZWN0aW9uIHtcbiAgICBjb25zdCBtZXNzYWdlID0gJ1RoZSB0cmFuc2l0aW9uIHdhcyBpZ25vcmVkJztcbiAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLklHTk9SRUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gIH1cblxuICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gYWJvcnRlZCB0cmFuc2l0aW9uICovXG4gIHN0YXRpYyBhYm9ydGVkKGRldGFpbD86IGFueSk6IFJlamVjdGlvbiB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBhYm9ydGVkJztcbiAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLkFCT1JURUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gIH1cblxuICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gYWJvcnRlZCB0cmFuc2l0aW9uICovXG4gIHN0YXRpYyBlcnJvcmVkKGRldGFpbD86IGFueSk6IFJlamVjdGlvbiB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiBlcnJvcmVkJztcbiAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLkVSUk9SLCBtZXNzYWdlLCBkZXRhaWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBSZWplY3Rpb25cbiAgICpcbiAgICogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgUmVqZWN0aW9uLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBhIFJlamVjdGlvbiwgcmV0dXJucyBpdC5cbiAgICogT3RoZXJ3aXNlLCB3cmFwcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgYXMgYSBSZWplY3Rpb24gKFJlamVjdGlvbiB0eXBlOiBFUlJPUikuXG4gICAqXG4gICAqIEByZXR1cm5zIGBkZXRhaWxgIGlmIGl0IGlzIGFscmVhZHkgYSBgUmVqZWN0aW9uYCwgZWxzZSByZXR1cm5zIGFuIEVSUk9SIFJlamVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemUoZGV0YWlsPzogUmVqZWN0aW9uIHwgRXJyb3IgfCBhbnkpOiBSZWplY3Rpb24ge1xuICAgIHJldHVybiBpcyhSZWplY3Rpb24pKGRldGFpbCkgPyBkZXRhaWwgOiBSZWplY3Rpb24uZXJyb3JlZChkZXRhaWwpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodHlwZTogbnVtYmVyLCBtZXNzYWdlPzogc3RyaW5nLCBkZXRhaWw/OiBhbnkpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kZXRhaWwgPSBkZXRhaWw7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBkZXRhaWxTdHJpbmcgPSAoZDogYW55KSA9PiAoZCAmJiBkLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID8gZC50b1N0cmluZygpIDogc3RyaW5naWZ5KGQpKTtcbiAgICBjb25zdCBkZXRhaWwgPSBkZXRhaWxTdHJpbmcodGhpcy5kZXRhaWwpO1xuICAgIGNvbnN0IHsgJGlkLCB0eXBlLCBtZXNzYWdlIH0gPSB0aGlzO1xuICAgIHJldHVybiBgVHJhbnNpdGlvbiBSZWplY3Rpb24oJGlkOiAkeyRpZH0gdHlwZTogJHt0eXBlfSwgbWVzc2FnZTogJHttZXNzYWdlfSwgZGV0YWlsOiAke2RldGFpbH0pYDtcbiAgfVxuXG4gIHRvUHJvbWlzZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBleHRlbmQoc2lsZW50UmVqZWN0aW9uKHRoaXMpLCB7IF90cmFuc2l0aW9uUmVqZWN0aW9uOiB0aGlzIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEZ1bmN0aW9ucyB0aGF0IG1hbmlwdWxhdGUgc3RyaW5nc1xuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIHRoZXkgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBtb2R1bGUgY29tbW9uX3N0cmluZ3NcbiAqLyAvKiogKi9cblxuaW1wb3J0IHsgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNJbmplY3RhYmxlLCBpc051bGwsIGlzT2JqZWN0LCBpc1Byb21pc2UsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCB9IGZyb20gJy4vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBSZWplY3Rpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnknO1xuaW1wb3J0IHsgaWRlbnRpdHksIElJbmplY3RhYmxlLCBwdXNoUiwgdGFpbCB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IHBhdHRlcm4sIHZhbCB9IGZyb20gJy4vaG9mJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHNob3J0ZW5lZCB0byBhIG1heGltdW0gbGVuZ3RoXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxlc3MgdGhhbiB0aGUgYG1heGAgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cbiAqIEVsc2UgcmV0dXJuIHRoZSBzdHJpbmcsIHNob3J0ZW5lZCB0byBgbWF4IC0gM2AgYW5kIGFwcGVuZCB0aHJlZSBkb3RzIChcIi4uLlwiKS5cbiAqXG4gKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxuICogQHBhcmFtIHN0ciB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhMZW5ndGgobWF4OiBudW1iZXIsIHN0cjogc3RyaW5nKSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IG1heCkgcmV0dXJuIHN0cjtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4IC0gMykgKyAnLi4uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nLCB3aXRoIHNwYWNlcyBhZGRlZCB0byB0aGUgZW5kLCB1cCB0byBhIGRlc2lyZWQgc3RyIGxlbmd0aFxuICpcbiAqIElmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBsb25nZXIgdGhhbiB0aGUgZGVzaXJlZCBsZW5ndGgsIHJldHVybiB0aGUgc3RyaW5nLlxuICogRWxzZSByZXR1cm5zIHRoZSBzdHJpbmcsIHdpdGggZXh0cmEgc3BhY2VzIG9uIHRoZSBlbmQsIHN1Y2ggdGhhdCBpdCByZWFjaGVzIGBsZW5ndGhgIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGxlbmd0aCB0aGUgZGVzaXJlZCBsZW5ndGggb2YgdGhlIHN0cmluZyB0byByZXR1cm5cbiAqIEBwYXJhbSBzdHIgdGhlIGlucHV0IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RyaW5nKGxlbmd0aDogbnVtYmVyLCBzdHI6IHN0cmluZykge1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkgc3RyICs9ICcgJztcbiAgcmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGtlYm9iU3RyaW5nKGNhbWVsQ2FzZTogc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbENhc2VcbiAgICAucmVwbGFjZSgvXihbQS1aXSkvLCAkMSA9PiAkMS50b0xvd2VyQ2FzZSgpKSAvLyByZXBsYWNlIGZpcnN0IGNoYXJcbiAgICAucmVwbGFjZSgvKFtBLVpdKS9nLCAkMSA9PiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpKTsgLy8gcmVwbGFjZSByZXN0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblRvU3RyaW5nKGZuOiBGdW5jdGlvbikge1xuICBjb25zdCBmblN0ciA9IGZuVG9TdHJpbmcoZm4pO1xuICBjb25zdCBuYW1lZEZ1bmN0aW9uTWF0Y2ggPSBmblN0ci5tYXRjaCgvXihmdW5jdGlvbiBbXiBdK1xcKFteKV0qXFwpKS8pO1xuICBjb25zdCB0b1N0ciA9IG5hbWVkRnVuY3Rpb25NYXRjaCA/IG5hbWVkRnVuY3Rpb25NYXRjaFsxXSA6IGZuU3RyO1xuXG4gIGNvbnN0IGZuTmFtZSA9IGZuWyduYW1lJ10gfHwgJyc7XG4gIGlmIChmbk5hbWUgJiYgdG9TdHIubWF0Y2goL2Z1bmN0aW9uIFxcKC8pKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbiAnICsgZm5OYW1lICsgdG9TdHIuc3Vic3RyKDkpO1xuICB9XG4gIHJldHVybiB0b1N0cjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZuVG9TdHJpbmcoZm46IElJbmplY3RhYmxlKSB7XG4gIGNvbnN0IF9mbiA9IGlzQXJyYXkoZm4pID8gZm4uc2xpY2UoLTEpWzBdIDogZm47XG4gIHJldHVybiAoX2ZuICYmIF9mbi50b1N0cmluZygpKSB8fCAndW5kZWZpbmVkJztcbn1cblxuY29uc3QgaXNSZWplY3Rpb24gPSBSZWplY3Rpb24uaXNSZWplY3Rpb25Qcm9taXNlO1xuY29uc3QgaGFzVG9TdHJpbmcgPSAob2JqOiBhbnkpID0+XG4gIGlzT2JqZWN0KG9iaikgJiYgIWlzQXJyYXkob2JqKSAmJiBvYmouY29uc3RydWN0b3IgIT09IE9iamVjdCAmJiBpc0Z1bmN0aW9uKG9iai50b1N0cmluZyk7XG5cbmNvbnN0IHN0cmluZ2lmeVBhdHRlcm4gPSBwYXR0ZXJuKFtcbiAgW2lzVW5kZWZpbmVkLCB2YWwoJ3VuZGVmaW5lZCcpXSxcbiAgW2lzTnVsbCwgdmFsKCdudWxsJyldLFxuICBbaXNQcm9taXNlLCB2YWwoJ1tQcm9taXNlXScpXSxcbiAgW2lzUmVqZWN0aW9uLCAoeDogYW55KSA9PiB4Ll90cmFuc2l0aW9uUmVqZWN0aW9uLnRvU3RyaW5nKCldLFxuICBbaGFzVG9TdHJpbmcsICh4OiBvYmplY3QpID0+IHgudG9TdHJpbmcoKV0sXG4gIFtpc0luamVjdGFibGUsIGZ1bmN0aW9uVG9TdHJpbmddLFxuICBbdmFsKHRydWUpLCBpZGVudGl0eV0sXG5dKSBhcyAodmFsOiBhbnkpID0+IHN0cmluZztcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShvOiBhbnkpIHtcbiAgY29uc3Qgc2VlbjogYW55W10gPSBbXTtcblxuICBmdW5jdGlvbiBmb3JtYXQodmFsdWU6IGFueSkge1xuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsdWUpICE9PSAtMSkgcmV0dXJuICdbY2lyY3VsYXIgcmVmXSc7XG4gICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5UGF0dGVybih2YWx1ZSk7XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQobykpIHtcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBJRSAmIEVkZ2UgU3BlYyBpbmNvbXBhdGliaWxpdHkgd2hlcmUgcmVwbGFjZXIgZnVuY3Rpb24gd291bGQgbm90IGJlIGNhbGxlZCB3aGVuIEpTT04uc3RyaW5naWZ5XG4gICAgLy8gaXMgZ2l2ZW4gYHVuZGVmaW5lZGAgYXMgdmFsdWUuIFRvIHdvcmsgYXJvdW5kIHRoYXQsIHdlIHNpbXBseSBkZXRlY3QgYHVuZGVmaW5lZGAgYW5kIGJhaWwgb3V0IGVhcmx5IGJ5XG4gICAgLy8gbWFudWFsbHkgc3RyaW5naWZ5aW5nIGl0LlxuICAgIHJldHVybiBmb3JtYXQobyk7XG4gIH1cblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobywgKGtleSwgdmFsdWUpID0+IGZvcm1hdCh2YWx1ZSkpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtcbn1cblxuLyoqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHNwbGl0cyBhIHN0cmluZyBvbiBhIGNoYXJhY3RlciBvciBzdWJzdHJpbmcgKi9cbmV4cG9ydCBjb25zdCBiZWZvcmVBZnRlclN1YnN0ciA9IChjaGFyOiBzdHJpbmcpID0+IChzdHI6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgaWYgKCFzdHIpIHJldHVybiBbJycsICcnXTtcbiAgY29uc3QgaWR4ID0gc3RyLmluZGV4T2YoY2hhcik7XG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gW3N0ciwgJyddO1xuICByZXR1cm4gW3N0ci5zdWJzdHIoMCwgaWR4KSwgc3RyLnN1YnN0cihpZHggKyAxKV07XG59O1xuXG5leHBvcnQgY29uc3QgaG9zdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OlthLXpdKzopPy8vW14vXSsvJyk7XG5leHBvcnQgY29uc3Qgc3RyaXBMYXN0UGF0aEVsZW1lbnQgPSAoc3RyOiBzdHJpbmcpID0+IHN0ci5yZXBsYWNlKC9cXC9bXi9dKiQvLCAnJyk7XG5leHBvcnQgY29uc3Qgc3BsaXRIYXNoID0gYmVmb3JlQWZ0ZXJTdWJzdHIoJyMnKTtcbmV4cG9ydCBjb25zdCBzcGxpdFF1ZXJ5ID0gYmVmb3JlQWZ0ZXJTdWJzdHIoJz8nKTtcbmV4cG9ydCBjb25zdCBzcGxpdEVxdWFsID0gYmVmb3JlQWZ0ZXJTdWJzdHIoJz0nKTtcbmV4cG9ydCBjb25zdCB0cmltSGFzaFZhbCA9IChzdHI6IHN0cmluZykgPT4gKHN0ciA/IHN0ci5yZXBsYWNlKC9eIy8sICcnKSA6ICcnKTtcblxuLyoqXG4gKiBTcGxpdHMgb24gYSBkZWxpbWl0ZXIsIGJ1dCByZXR1cm5zIHRoZSBkZWxpbWl0ZXJzIGluIHRoZSBhcnJheVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgc3BsaXRPblNsYXNoZXMgPSBzcGxpdE9uRGVsaW0oJy8nKTtcbiAqIHNwbGl0T25TbGFzaGVzKFwiL2Zvb1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiXVxuICogc3BsaXRPblNsYXNoZXMoXCIvZm9vL1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiLCBcIi9cIl1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRPbkRlbGltKGRlbGltOiBzdHJpbmcpIHtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKCcoJyArIGRlbGltICsgJyknLCAnZycpO1xuICByZXR1cm4gKHN0cjogc3RyaW5nKSA9PiBzdHIuc3BsaXQocmUpLmZpbHRlcihpZGVudGl0eSk7XG59XG5cbi8qKlxuICogUmVkdWNlIGZuIHRoYXQgam9pbnMgbmVpZ2hib3Jpbmcgc3RyaW5nc1xuICpcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybnMgYSBuZXcgYXJyYXlcbiAqIHdoZXJlIGFsbCBuZWlnaGJvcmluZyBzdHJpbmdzIGhhdmUgYmVlbiBqb2luZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIGxldCBhcnIgPSBbXCJmb29cIiwgXCJiYXJcIiwgMSwgXCJiYXpcIiwgXCJcIiwgXCJxdXhcIiBdO1xuICogYXJyLnJlZHVjZShqb2luTmVpZ2hib3JzUiwgW10pIC8vIFtcImZvb2JhclwiLCAxLCBcImJhenF1eFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gam9pbk5laWdoYm9yc1IoYWNjOiBhbnlbXSwgeDogYW55KSB7XG4gIGlmIChpc1N0cmluZyh0YWlsKGFjYykpICYmIGlzU3RyaW5nKHgpKSByZXR1cm4gYWNjLnNsaWNlKDAsIC0xKS5jb25jYXQodGFpbChhY2MpICsgeCk7XG4gIHJldHVybiBwdXNoUihhY2MsIHgpO1xufVxuIiwiLyoqIHdvcmthcm91bmQgZm9yIG1pc3NpbmcgY29uc29sZSBvYmplY3QgaW4gSUU5IHdoZW4gZGV2IHRvb2xzIGhhdmVuJ3QgYmVlbiBvcGVuZWQgb19PICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBub29wQ29uc29sZVN0dWIgPSB7IGxvZzogbm9vcCwgZXJyb3I6IG5vb3AsIHRhYmxlOiBub29wIH07XG5cbmZ1bmN0aW9uIGllOUNvbnNvbGUoY29uc29sZSkge1xuICBjb25zdCBib3VuZCA9IChmbjogRnVuY3Rpb24pID0+IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoZm4sIGNvbnNvbGUpO1xuICByZXR1cm4ge1xuICAgIGxvZzogYm91bmQoY29uc29sZS5sb2cpLFxuICAgIGVycm9yOiBib3VuZChjb25zb2xlLmxvZyksXG4gICAgdGFibGU6IGJvdW5kKGNvbnNvbGUubG9nKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmFsbGJhY2tDb25zb2xlKGNvbnNvbGUpIHtcbiAgY29uc3QgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgY29uc3QgZXJyb3IgPSBjb25zb2xlLmVycm9yID8gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpIDogbG9nO1xuICBjb25zdCB0YWJsZSA9IGNvbnNvbGUudGFibGUgPyBjb25zb2xlLnRhYmxlLmJpbmQoY29uc29sZSkgOiBsb2c7XG4gIHJldHVybiB7IGxvZywgZXJyb3IsIHRhYmxlIH07XG59XG5cbmZ1bmN0aW9uIGdldFNhZmVDb25zb2xlKCkge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IGlzSUU5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSA5O1xuICBpZiAoaXNJRTkpIHtcbiAgICByZXR1cm4gd2luZG93ICYmIHdpbmRvdy5jb25zb2xlID8gaWU5Q29uc29sZSh3aW5kb3cuY29uc29sZSkgOiBub29wQ29uc29sZVN0dWI7XG4gIH0gZWxzZSBpZiAoIWNvbnNvbGUudGFibGUgfHwgIWNvbnNvbGUuZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsbGJhY2tDb25zb2xlKGNvbnNvbGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb25zb2xlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzYWZlQ29uc29sZSA9IGdldFNhZmVDb25zb2xlKCk7XG4iLCIvKipcbiAqICMgVHJhbnNpdGlvbiB0cmFjaW5nIChkZWJ1ZylcbiAqXG4gKiBFbmFibGUgdHJhbnNpdGlvbiB0cmFjaW5nIHRvIHByaW50IHRyYW5zaXRpb24gaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUsXG4gKiBpbiBvcmRlciB0byBoZWxwIGRlYnVnIHlvdXIgYXBwbGljYXRpb24uXG4gKiBUcmFjaW5nIGxvZ3MgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBUcmFuc2l0aW9uIHRvIHlvdXIgY29uc29sZS5cbiAqXG4gKiBUbyBlbmFibGUgdHJhY2luZywgaW1wb3J0IHRoZSBbW1RyYWNlXV0gc2luZ2xldG9uIGFuZCBlbmFibGUgb25lIG9yIG1vcmUgY2F0ZWdvcmllcy5cbiAqXG4gKiAjIyMgRVM2XG4gKiBgYGBqc1xuICogaW1wb3J0IHt0cmFjZX0gZnJvbSBcIkB1aXJvdXRlci9jb3JlXCI7XG4gKiB0cmFjZS5lbmFibGUoMSwgNSk7IC8vIFRSQU5TSVRJT04gYW5kIFZJRVdDT05GSUdcbiAqIGBgYFxuICpcbiAqICMjIyBDSlNcbiAqIGBgYGpzXG4gKiBsZXQgdHJhY2UgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIikudHJhY2U7XG4gKiB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIsIFwiVklFV0NPTkZJR1wiKTtcbiAqIGBgYFxuICpcbiAqICMjIyBHbG9iYWxzXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gd2luZG93W1wiQHVpcm91dGVyL2NvcmVcIl0udHJhY2U7XG4gKiB0cmFjZS5lbmFibGUoKTsgLy8gVHJhY2UgZXZlcnl0aGluZyAodmVyeSB2ZXJib3NlKVxuICogYGBgXG4gKlxuICogIyMjIEFuZ3VsYXIgMTpcbiAqIGBgYGpzXG4gKiBhcHAucnVuKCR0cmFjZSA9PiAkdHJhY2UuZW5hYmxlKCkpO1xuICogYGBgXG4gKlxuICogQHB1YmxpY2FwaSBAbW9kdWxlIHRyYWNlXG4gKi9cbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc051bWJlciB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVmlld1R1cGxlIH0gZnJvbSAnLi4vdmlldyc7XG5pbXBvcnQgeyBBY3RpdmVVSVZpZXcsIFZpZXdDb25maWcsIFZpZXdDb250ZXh0IH0gZnJvbSAnLi4vdmlldy9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgc3RyaW5naWZ5LCBmdW5jdGlvblRvU3RyaW5nLCBtYXhMZW5ndGgsIHBhZFN0cmluZyB9IGZyb20gJy4vc3RyaW5ncyc7XG5pbXBvcnQgeyBzYWZlQ29uc29sZSB9IGZyb20gJy4vc2FmZUNvbnNvbGUnO1xuaW1wb3J0IHsgUmVzb2x2YWJsZSB9IGZyb20gJy4uL3Jlc29sdmUvcmVzb2x2YWJsZSc7XG5pbXBvcnQgeyBQYXRoTm9kZSB9IGZyb20gJy4uL3BhdGgvcGF0aE5vZGUnO1xuaW1wb3J0IHsgUG9saWN5V2hlbiB9IGZyb20gJy4uL3Jlc29sdmUvaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uSG9vayc7XG5pbXBvcnQgeyBIb29rUmVzdWx0IH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB1aVZpZXdTdHJpbmcodWl2aWV3OiBBY3RpdmVVSVZpZXcpIHtcbiAgaWYgKCF1aXZpZXcpIHJldHVybiAndWktdmlldyAoZGVmdW5jdCknO1xuICBjb25zdCBzdGF0ZSA9IHVpdmlldy5jcmVhdGlvbkNvbnRleHQgPyB1aXZpZXcuY3JlYXRpb25Db250ZXh0Lm5hbWUgfHwgJyhyb290KScgOiAnKG5vbmUpJztcbiAgcmV0dXJuIGBbdWktdmlldyMke3Vpdmlldy5pZH0gJHt1aXZpZXcuJHR5cGV9OiR7dWl2aWV3LmZxbn0gKCR7dWl2aWV3Lm5hbWV9QCR7c3RhdGV9KV1gO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3Qgdmlld0NvbmZpZ1N0cmluZyA9ICh2aWV3Q29uZmlnOiBWaWV3Q29uZmlnKSA9PiB7XG4gIGNvbnN0IHZpZXcgPSB2aWV3Q29uZmlnLnZpZXdEZWNsO1xuICBjb25zdCBzdGF0ZSA9IHZpZXcuJGNvbnRleHQubmFtZSB8fCAnKHJvb3QpJztcbiAgcmV0dXJuIGBbVmlldyMke3ZpZXdDb25maWcuJGlkfSBmcm9tICcke3N0YXRlfScgc3RhdGVdOiB0YXJnZXQgdWktdmlldzogJyR7dmlldy4kdWlWaWV3TmFtZX1AJHt2aWV3LiR1aVZpZXdDb250ZXh0QW5jaG9yfSdgO1xufTtcblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRDYXQoaW5wdXQ6IENhdGVnb3J5IHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGlzTnVtYmVyKGlucHV0KSA/IENhdGVnb3J5W2lucHV0XSA6IENhdGVnb3J5W0NhdGVnb3J5W2lucHV0XV07XG59XG5cbi8qKlxuICogVHJhY2UgY2F0ZWdvcmllcyBFbnVtXG4gKlxuICogRW5hYmxlIG9yIGRpc2FibGUgYSBjYXRlZ29yeSB1c2luZyBbW1RyYWNlLmVuYWJsZV1dIG9yIFtbVHJhY2UuZGlzYWJsZV1dXG4gKlxuICogYHRyYWNlLmVuYWJsZShDYXRlZ29yeS5UUkFOU0lUSU9OKWBcbiAqXG4gKiBUaGVzZSBjYW4gYWxzbyBiZSBwcm92aWRlZCB1c2luZyBhIG1hdGNoaW5nIHN0cmluZywgb3IgcG9zaXRpb24gb3JkaW5hbFxuICpcbiAqIGB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIpYFxuICpcbiAqIGB0cmFjZS5lbmFibGUoMSlgXG4gKi9cbmVudW0gQ2F0ZWdvcnkge1xuICBSRVNPTFZFLFxuICBUUkFOU0lUSU9OLFxuICBIT09LLFxuICBVSVZJRVcsXG4gIFZJRVdDT05GSUcsXG59XG5cbmV4cG9ydCB7IENhdGVnb3J5IH07XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBfdGlkID0gcGFyc2UoJyRpZCcpO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgX3JpZCA9IHBhcnNlKCdyb3V0ZXIuJGlkJyk7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCB0cmFuc0xibCA9IHRyYW5zID0+IGBUcmFuc2l0aW9uICMke190aWQodHJhbnMpfS0ke19yaWQodHJhbnMpfWA7XG5cbi8qKlxuICogUHJpbnRzIFVJLVJvdXRlciBUcmFuc2l0aW9uIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICovXG5leHBvcnQgY2xhc3MgVHJhY2Uge1xuICAvKiogQGhpZGRlbiAqL1xuICBhcHByb3hpbWF0ZURpZ2VzdHM6IG51bWJlcjtcblxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9lbmFibGVkOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXBwcm94aW1hdGVEaWdlc3RzID0gMDtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX3NldChlbmFibGVkOiBib29sZWFuLCBjYXRlZ29yaWVzOiBDYXRlZ29yeVtdKSB7XG4gICAgaWYgKCFjYXRlZ29yaWVzLmxlbmd0aCkge1xuICAgICAgY2F0ZWdvcmllcyA9IDxhbnk+T2JqZWN0LmtleXMoQ2F0ZWdvcnkpXG4gICAgICAgIC5tYXAoayA9PiBwYXJzZUludChrLCAxMCkpXG4gICAgICAgIC5maWx0ZXIoayA9PiAhaXNOYU4oaykpXG4gICAgICAgIC5tYXAoa2V5ID0+IENhdGVnb3J5W2tleV0pO1xuICAgIH1cbiAgICBjYXRlZ29yaWVzLm1hcChub3JtYWxpemVkQ2F0KS5mb3JFYWNoKGNhdGVnb3J5ID0+ICh0aGlzLl9lbmFibGVkW2NhdGVnb3J5XSA9IGVuYWJsZWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIGEgdHJhY2UgW1tDYXRlZ29yeV1dXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHRyYWNlLmVuYWJsZShcIlRSQU5TSVRJT05cIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzIHRvIGVuYWJsZS4gSWYgYGNhdGVnb3JpZXNgIGlzIG9taXR0ZWQsIGFsbCBjYXRlZ29yaWVzIGFyZSBlbmFibGVkLlxuICAgKiAgICAgICAgQWxzbyB0YWtlcyBzdHJpbmdzIChjYXRlZ29yeSBuYW1lKSBvciBvcmRpbmFsIChjYXRlZ29yeSBwb3NpdGlvbilcbiAgICovXG4gIGVuYWJsZSguLi5jYXRlZ29yaWVzOiAoQ2F0ZWdvcnkgfCBzdHJpbmcgfCBudW1iZXIpW10pO1xuICBlbmFibGUoLi4uY2F0ZWdvcmllczogYW55W10pIHtcbiAgICB0aGlzLl9zZXQodHJ1ZSwgY2F0ZWdvcmllcyk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIGEgdHJhY2UgW1tDYXRlZ29yeV1dXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHRyYWNlLmRpc2FibGUoXCJWSUVXQ09ORklHXCIpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNhdGVnb3JpZXMgY2F0ZWdvcmllcyB0byBkaXNhYmxlLiBJZiBgY2F0ZWdvcmllc2AgaXMgb21pdHRlZCwgYWxsIGNhdGVnb3JpZXMgYXJlIGRpc2FibGVkLlxuICAgKiAgICAgICAgQWxzbyB0YWtlcyBzdHJpbmdzIChjYXRlZ29yeSBuYW1lKSBvciBvcmRpbmFsIChjYXRlZ29yeSBwb3NpdGlvbilcbiAgICovXG4gIGRpc2FibGUoLi4uY2F0ZWdvcmllczogKENhdGVnb3J5IHwgc3RyaW5nIHwgbnVtYmVyKVtdKTtcbiAgZGlzYWJsZSguLi5jYXRlZ29yaWVzOiBhbnlbXSkge1xuICAgIHRoaXMuX3NldChmYWxzZSwgY2F0ZWdvcmllcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBlbmFibGVkIHN0YXRldXMgb2YgYSBbW0NhdGVnb3J5XV1cbiAgICpcbiAgICogYGBganNcbiAgICogdHJhY2UuZW5hYmxlZChcIlZJRVdDT05GSUdcIik7IC8vIHRydWUgb3IgZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIGJvb2xlYW4gdHJ1ZSBpZiB0aGUgY2F0ZWdvcnkgaXMgZW5hYmxlZFxuICAgKi9cbiAgZW5hYmxlZChjYXRlZ29yeTogQ2F0ZWdvcnkgfCBzdHJpbmcgfCBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9lbmFibGVkW25vcm1hbGl6ZWRDYXQoY2F0ZWdvcnkpXTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlVHJhbnNpdGlvblN0YXJ0KHRyYW5zOiBUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYCR7dHJhbnNMYmwodHJhbnMpfTogU3RhcnRlZCAgLT4gJHtzdHJpbmdpZnkodHJhbnMpfWApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VUcmFuc2l0aW9uSWdub3JlZCh0cmFuczogVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGAke3RyYW5zTGJsKHRyYW5zKX06IElnbm9yZWQgIDw+ICR7c3RyaW5naWZ5KHRyYW5zKX1gKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlSG9va0ludm9jYXRpb24oc3RlcDogVHJhbnNpdGlvbkhvb2ssIHRyYW5zOiBUcmFuc2l0aW9uLCBvcHRpb25zOiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5IT09LKSkgcmV0dXJuO1xuICAgIGNvbnN0IGV2ZW50ID0gcGFyc2UoJ3RyYWNlRGF0YS5ob29rVHlwZScpKG9wdGlvbnMpIHx8ICdpbnRlcm5hbCcsXG4gICAgICBjb250ZXh0ID0gcGFyc2UoJ3RyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWUnKShvcHRpb25zKSB8fCBwYXJzZSgndHJhY2VEYXRhLmNvbnRleHQnKShvcHRpb25zKSB8fCAndW5rbm93bicsXG4gICAgICBuYW1lID0gZnVuY3Rpb25Ub1N0cmluZygoc3RlcCBhcyBhbnkpLnJlZ2lzdGVyZWRIb29rLmNhbGxiYWNrKTtcbiAgICBzYWZlQ29uc29sZS5sb2coYCR7dHJhbnNMYmwodHJhbnMpfTogICBIb29rIC0+ICR7ZXZlbnR9IGNvbnRleHQ6ICR7Y29udGV4dH0sICR7bWF4TGVuZ3RoKDIwMCwgbmFtZSl9YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZUhvb2tSZXN1bHQoaG9va1Jlc3VsdDogSG9va1Jlc3VsdCwgdHJhbnM6IFRyYW5zaXRpb24sIHRyYW5zaXRpb25PcHRpb25zOiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5IT09LKSkgcmV0dXJuO1xuICAgIHNhZmVDb25zb2xlLmxvZyhgJHt0cmFuc0xibCh0cmFucyl9OiAgIDwtIEhvb2sgcmV0dXJuZWQ6ICR7bWF4TGVuZ3RoKDIwMCwgc3RyaW5naWZ5KGhvb2tSZXN1bHQpKX1gKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlUmVzb2x2ZVBhdGgocGF0aDogUGF0aE5vZGVbXSwgd2hlbjogUG9saWN5V2hlbiwgdHJhbnM/OiBUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuUkVTT0xWRSkpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYCR7dHJhbnNMYmwodHJhbnMpfTogICAgICAgICBSZXNvbHZpbmcgJHtwYXRofSAoJHt3aGVufSlgKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlUmVzb2x2YWJsZVJlc29sdmVkKHJlc29sdmFibGU6IFJlc29sdmFibGUsIHRyYW5zPzogVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKFxuICAgICAgYCR7dHJhbnNMYmwodHJhbnMpfTogICAgICAgICAgICAgICA8LSBSZXNvbHZlZCAgJHtyZXNvbHZhYmxlfSB0bzogJHttYXhMZW5ndGgoMjAwLCBzdHJpbmdpZnkocmVzb2x2YWJsZS5kYXRhKSl9YFxuICAgICk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZUVycm9yKHJlYXNvbjogYW55LCB0cmFuczogVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGAke3RyYW5zTGJsKHRyYW5zKX06IDwtIFJlamVjdGVkICR7c3RyaW5naWZ5KHRyYW5zKX0sIHJlYXNvbjogJHtyZWFzb259YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVN1Y2Nlc3MoZmluYWxTdGF0ZTogU3RhdGVPYmplY3QsIHRyYW5zOiBUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYCR7dHJhbnNMYmwodHJhbnMpfTogPC0gU3VjY2VzcyAgJHtzdHJpbmdpZnkodHJhbnMpfSwgZmluYWwgc3RhdGU6ICR7ZmluYWxTdGF0ZS5uYW1lfWApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VVSVZpZXdFdmVudChldmVudDogc3RyaW5nLCB2aWV3RGF0YTogQWN0aXZlVUlWaWV3LCBleHRyYSA9ICcnKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSkgcmV0dXJuO1xuICAgIHNhZmVDb25zb2xlLmxvZyhgdWktdmlldzogJHtwYWRTdHJpbmcoMzAsIGV2ZW50KX0gJHt1aVZpZXdTdHJpbmcodmlld0RhdGEpfSR7ZXh0cmF9YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQodmlld0RhdGE6IEFjdGl2ZVVJVmlldywgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKSByZXR1cm47XG4gICAgdGhpcy50cmFjZVVJVmlld0V2ZW50KCdVcGRhdGluZycsIHZpZXdEYXRhLCBgIHdpdGggVmlld0NvbmZpZyBmcm9tIGNvbnRleHQ9JyR7Y29udGV4dH0nYCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVVJVmlld0ZpbGwodmlld0RhdGE6IEFjdGl2ZVVJVmlldywgaHRtbDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSkgcmV0dXJuO1xuICAgIHRoaXMudHJhY2VVSVZpZXdFdmVudCgnRmlsbCcsIHZpZXdEYXRhLCBgIHdpdGg6ICR7bWF4TGVuZ3RoKDIwMCwgaHRtbCl9YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVZpZXdTeW5jKHBhaXJzOiBWaWV3VHVwbGVbXSkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKSByZXR1cm47XG4gICAgY29uc3QgdWl2aGVhZGVyID0gJ3VpdmlldyBjb21wb25lbnQgZnFuJztcbiAgICBjb25zdCBjZmdoZWFkZXIgPSAndmlldyBjb25maWcgc3RhdGUgKHZpZXcgbmFtZSknO1xuICAgIGNvbnN0IG1hcHBpbmcgPSBwYWlyc1xuICAgICAgLm1hcCgoeyB1aVZpZXcsIHZpZXdDb25maWcgfSkgPT4ge1xuICAgICAgICBjb25zdCB1aXYgPSB1aVZpZXcgJiYgdWlWaWV3LmZxbjtcbiAgICAgICAgY29uc3QgY2ZnID0gdmlld0NvbmZpZyAmJiBgJHt2aWV3Q29uZmlnLnZpZXdEZWNsLiRjb250ZXh0Lm5hbWV9OiAoJHt2aWV3Q29uZmlnLnZpZXdEZWNsLiRuYW1lfSlgO1xuICAgICAgICByZXR1cm4geyBbdWl2aGVhZGVyXTogdWl2LCBbY2ZnaGVhZGVyXTogY2ZnIH07XG4gICAgICB9KVxuICAgICAgLnNvcnQoKGEsIGIpID0+IChhW3VpdmhlYWRlcl0gfHwgJycpLmxvY2FsZUNvbXBhcmUoYlt1aXZoZWFkZXJdIHx8ICcnKSk7XG5cbiAgICBzYWZlQ29uc29sZS50YWJsZShtYXBwaW5nKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlVmlld1NlcnZpY2VFdmVudChldmVudDogc3RyaW5nLCB2aWV3Q29uZmlnOiBWaWV3Q29uZmlnKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYFZJRVdDT05GSUc6ICR7ZXZlbnR9ICR7dmlld0NvbmZpZ1N0cmluZyh2aWV3Q29uZmlnKX1gKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChldmVudDogc3RyaW5nLCB2aWV3RGF0YTogQWN0aXZlVUlWaWV3KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYFZJRVdDT05GSUc6ICR7ZXZlbnR9ICR7dWlWaWV3U3RyaW5nKHZpZXdEYXRhKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBbW1RyYWNlXV0gc2luZ2xldG9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJAdWlyb3V0ZXIvY29yZVwiO1xuICogdHJhY2UuZW5hYmxlKDEsIDUpO1xuICogYGBgXG4gKi9cbmNvbnN0IHRyYWNlID0gbmV3IFRyYWNlKCk7XG5leHBvcnQgeyB0cmFjZSB9O1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBwYXJhbXMgKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIGZpbHRlciwgbWFwIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBpc0FycmF5LCBpc0RlZmluZWQgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBQYXJhbVR5cGVEZWZpbml0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEFuIGludGVybmFsIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0uXG4gKlxuICogQSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBpcyBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IHVzZWQgdG8gcmVnaXN0ZXIgY3VzdG9tIHBhcmFtZXRlciB0eXBlcy5cbiAqIFdoZW4gYSBwYXJhbSB0eXBlIGRlZmluaXRpb24gaXMgcmVnaXN0ZXJlZCwgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gKlxuICogVGhpcyBjbGFzcyBoYXMgbmFpdmUgaW1wbGVtZW50YXRpb25zIGZvciBhbGwgdGhlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIG1ldGhvZHMuXG4gKlxuICogVXNlZCBieSBbW1VybE1hdGNoZXJdXSB3aGVuIG1hdGNoaW5nIG9yIGZvcm1hdHRpbmcgVVJMcywgb3IgY29tcGFyaW5nIGFuZCB2YWxpZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIHZhciBwYXJhbVR5cGVEZWYgPSB7XG4gKiAgIGRlY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcbiAqICAgZW5jb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbCAmJiB2YWwudG9TdHJpbmcoKTsgfSxcbiAqICAgZXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLmlzKGEpICYmIGEgPT09IGI7IH0sXG4gKiAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIGFuZ3VsYXIuaXNOdW1iZXIodmFsKSAmJiBpc0Zpbml0ZSh2YWwpICYmIHZhbCAlIDEgPT09IDA7IH0sXG4gKiAgIHBhdHRlcm46IC9cXGQrL1xuICogfVxuICpcbiAqIHZhciBwYXJhbVR5cGUgPSBuZXcgUGFyYW1UeXBlKHBhcmFtVHlwZURlZik7XG4gKiBgYGBcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIGltcGxlbWVudHMgUGFyYW1UeXBlRGVmaW5pdGlvbiB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwYXR0ZXJuOiBSZWdFeHAgPSAvLiovO1xuICAvKiogVGhlIG5hbWUvaWQgb2YgdGhlIHBhcmFtZXRlciB0eXBlICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJhdzogYm9vbGVhbjtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGR5bmFtaWM6IGJvb2xlYW47XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpbmhlcml0ID0gdHJ1ZTtcblxuICAvKipcbiAgICogQHBhcmFtIGRlZiAgQSBjb25maWd1cmF0aW9uIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgY3VzdG9tIHR5cGUgZGVmaW5pdGlvbi4gIFRoZSBvYmplY3Qnc1xuICAgKiAgICAgICAgcHJvcGVydGllcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZHMgYW5kL29yIHBhdHRlcm4gaW4gYFBhcmFtVHlwZWAncyBwdWJsaWMgaW50ZXJmYWNlLlxuICAgKiBAcmV0dXJucyBhIG5ldyBQYXJhbVR5cGUgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWY6IFBhcmFtVHlwZURlZmluaXRpb24pIHtcbiAgICBleHRlbmQodGhpcywgZGVmKTtcbiAgfVxuXG4gIC8vIGNvbnNpZGVyIHRoZXNlIGZvdXIgbWV0aG9kcyB0byBiZSBcImFic3RyYWN0IG1ldGhvZHNcIiB0aGF0IHNob3VsZCBiZSBvdmVycmlkZGVuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpcyh2YWw6IGFueSwga2V5Pzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGVuY29kZSh2YWw6IGFueSwga2V5Pzogc3RyaW5nKTogc3RyaW5nIHwgc3RyaW5nW10ge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGRlY29kZSh2YWw6IHN0cmluZywga2V5Pzogc3RyaW5nKTogYW55IHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBlcXVhbHMoYTogYW55LCBiOiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgIHJldHVybiBhID09IGI7XG4gIH1cblxuICAkc3ViUGF0dGVybigpIHtcbiAgICBjb25zdCBzdWIgPSB0aGlzLnBhdHRlcm4udG9TdHJpbmcoKTtcbiAgICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYHtQYXJhbVR5cGU6JHt0aGlzLm5hbWV9fWA7XG4gIH1cblxuICAvKiogR2l2ZW4gYW4gZW5jb2RlZCBzdHJpbmcsIG9yIGEgZGVjb2RlZCBvYmplY3QsIHJldHVybnMgYSBkZWNvZGVkIG9iamVjdCAqL1xuICAkbm9ybWFsaXplKHZhbDogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuaXModmFsKSA/IHZhbCA6IHRoaXMuZGVjb2RlKHZhbCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYW4gZXhpc3RpbmcgY3VzdG9tIFBhcmFtVHlwZSBhcyBhbiBhcnJheSBvZiBQYXJhbVR5cGUsIGRlcGVuZGluZyBvbiAnbW9kZScuXG4gICAqIGUuZy46XG4gICAqIC0gdXJsbWF0Y2hlciBwYXR0ZXJuIFwiL3BhdGg/e3F1ZXJ5UGFyYW1bXTppbnR9XCJcbiAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xJnF1ZXJ5UGFyYW09MlxuICAgKiAtICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtIHdpbGwgYmUgWzEsIDJdXG4gICAqIGlmIGBtb2RlYCBpcyBcImF1dG9cIiwgdGhlblxuICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IDFcbiAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xJnF1ZXJ5UGFyYW09MiB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogWzEsIDJdXG4gICAqL1xuICAkYXNBcnJheShtb2RlOiBib29sZWFuIHwgJ2F1dG8nLCBpc1NlYXJjaDogYm9vbGVhbikge1xuICAgIGlmICghbW9kZSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG1vZGUgPT09ICdhdXRvJyAmJiAhaXNTZWFyY2gpIHRocm93IG5ldyBFcnJvcihcIidhdXRvJyBhcnJheSBtb2RlIGlzIGZvciBxdWVyeSBwYXJhbWV0ZXJzIG9ubHlcIik7XG4gICAgcmV0dXJuIG5ldyAoPGFueT5BcnJheVR5cGUpKHRoaXMsIG1vZGUpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgdXAgYSBgUGFyYW1UeXBlYCBvYmplY3QgdG8gaGFuZGxlIGFycmF5IHZhbHVlcy5cbiAqIEBpbnRlcm5hbGFwaVxuICovXG5mdW5jdGlvbiBBcnJheVR5cGUodHlwZTogUGFyYW1UeXBlLCBtb2RlOiBib29sZWFuIHwgJ2F1dG8nKSB7XG4gIC8vIFdyYXAgbm9uLWFycmF5IHZhbHVlIGFzIGFycmF5XG4gIGZ1bmN0aW9uIGFycmF5V3JhcCh2YWw6IGFueSk6IGFueVtdIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWwpID8gdmFsIDogaXNEZWZpbmVkKHZhbCkgPyBbdmFsXSA6IFtdO1xuICB9XG5cbiAgLy8gVW53cmFwIGFycmF5IHZhbHVlIGZvciBcImF1dG9cIiBtb2RlLiBSZXR1cm4gdW5kZWZpbmVkIGZvciBlbXB0eSBhcnJheS5cbiAgZnVuY3Rpb24gYXJyYXlVbndyYXAodmFsOiBhbnkpIHtcbiAgICBzd2l0Y2ggKHZhbC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdhdXRvJyA/IHZhbFswXSA6IHZhbDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcHMgdHlwZSAoLmlzLy5lbmNvZGUvLmRlY29kZSkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICBmdW5jdGlvbiBhcnJheUhhbmRsZXIoY2FsbGJhY2s6ICh4OiBhbnkpID0+IGFueSwgYWxsVHJ1dGh5TW9kZT86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsOiBhbnkpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZhbDtcbiAgICAgIGNvbnN0IGFyciA9IGFycmF5V3JhcCh2YWwpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gbWFwKGFyciwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIGFsbFRydXRoeU1vZGUgPT09IHRydWUgPyBmaWx0ZXIocmVzdWx0LCB4ID0+ICF4KS5sZW5ndGggPT09IDAgOiBhcnJheVVud3JhcChyZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICAvLyBXcmFwcyB0eXBlICguZXF1YWxzKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG4gIGZ1bmN0aW9uIGFycmF5RXF1YWxzSGFuZGxlcihjYWxsYmFjazogKGw6IGFueSwgcjogYW55KSA9PiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbDE6IGFueSwgdmFsMjogYW55KSB7XG4gICAgICBjb25zdCBsZWZ0ID0gYXJyYXlXcmFwKHZhbDEpLFxuICAgICAgICByaWdodCA9IGFycmF5V3JhcCh2YWwyKTtcbiAgICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayhsZWZ0W2ldLCByaWdodFtpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICBbJ2VuY29kZScsICdkZWNvZGUnLCAnZXF1YWxzJywgJyRub3JtYWxpemUnXS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IHBhcmFtVHlwZUZuID0gdHlwZVtuYW1lXS5iaW5kKHR5cGUpO1xuICAgIGNvbnN0IHdyYXBwZXJGbjogRnVuY3Rpb24gPSBuYW1lID09PSAnZXF1YWxzJyA/IGFycmF5RXF1YWxzSGFuZGxlciA6IGFycmF5SGFuZGxlcjtcbiAgICB0aGlzW25hbWVdID0gd3JhcHBlckZuKHBhcmFtVHlwZUZuKTtcbiAgfSk7XG5cbiAgZXh0ZW5kKHRoaXMsIHtcbiAgICBkeW5hbWljOiB0eXBlLmR5bmFtaWMsXG4gICAgbmFtZTogdHlwZS5uYW1lLFxuICAgIHBhdHRlcm46IHR5cGUucGF0dGVybixcbiAgICBpbmhlcml0OiB0eXBlLmluaGVyaXQsXG4gICAgcmF3OiB0eXBlLnJhdyxcbiAgICBpczogYXJyYXlIYW5kbGVyKHR5cGUuaXMuYmluZCh0eXBlKSwgdHJ1ZSksXG4gICAgJGFycmF5TW9kZTogbW9kZSxcbiAgfSk7XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHBhcmFtcyAqLyAvKiogKi9cbmltcG9ydCB7IGV4dGVuZCwgZmlsdGVyLCBtYXAsIGFsbFRydWVSLCBmaW5kIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBwcm9wIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBpc0luamVjdGFibGUsIGlzRGVmaW5lZCwgaXNTdHJpbmcsIGlzQXJyYXksIGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgUmF3UGFyYW1zLCBQYXJhbURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vcGFyYW1zL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgUGFyYW1UeXBlIH0gZnJvbSAnLi9wYXJhbVR5cGUnO1xuaW1wb3J0IHsgUGFyYW1UeXBlcyB9IGZyb20gJy4vcGFyYW1UeXBlcyc7XG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgVXJsQ29uZmlnIH0gZnJvbSAnLi4vdXJsJztcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBpc1Nob3J0aGFuZCA9IChjZmc6IFBhcmFtRGVjbGFyYXRpb24pID0+XG4gIFsndmFsdWUnLCAndHlwZScsICdzcXVhc2gnLCAnYXJyYXknLCAnZHluYW1pYyddLmZpbHRlcihoYXNPd24uYmluZChjZmcgfHwge30pKS5sZW5ndGggPT09IDA7XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmVudW0gRGVmVHlwZSB7XG4gIFBBVEgsXG4gIFNFQVJDSCxcbiAgQ09ORklHLFxufVxuZXhwb3J0IHsgRGVmVHlwZSB9O1xuXG4vKiogQGludGVybmFsYXBpICovXG5mdW5jdGlvbiBnZXRQYXJhbURlY2xhcmF0aW9uKHBhcmFtTmFtZTogc3RyaW5nLCBsb2NhdGlvbjogRGVmVHlwZSwgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pOiBQYXJhbURlY2xhcmF0aW9uIHtcbiAgY29uc3Qgbm9SZWxvYWRPblNlYXJjaCA9IChzdGF0ZS5yZWxvYWRPblNlYXJjaCA9PT0gZmFsc2UgJiYgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIKSB8fCB1bmRlZmluZWQ7XG4gIGNvbnN0IGR5bmFtaWMgPSBmaW5kKFtzdGF0ZS5keW5hbWljLCBub1JlbG9hZE9uU2VhcmNoXSwgaXNEZWZpbmVkKTtcbiAgY29uc3QgZGVmYXVsdENvbmZpZyA9IGlzRGVmaW5lZChkeW5hbWljKSA/IHsgZHluYW1pYyB9IDoge307XG4gIGNvbnN0IHBhcmFtQ29uZmlnID0gdW53cmFwU2hvcnRoYW5kKHN0YXRlICYmIHN0YXRlLnBhcmFtcyAmJiBzdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXSk7XG4gIHJldHVybiBleHRlbmQoZGVmYXVsdENvbmZpZywgcGFyYW1Db25maWcpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdW53cmFwU2hvcnRoYW5kKGNmZzogUGFyYW1EZWNsYXJhdGlvbik6IFBhcmFtRGVjbGFyYXRpb24ge1xuICBjZmcgPSBpc1Nob3J0aGFuZChjZmcpID8gKHsgdmFsdWU6IGNmZyB9IGFzIFBhcmFtRGVjbGFyYXRpb24pIDogY2ZnO1xuXG4gIGdldFN0YXRpY0RlZmF1bHRWYWx1ZVsnX19jYWNoZWFibGUnXSA9IHRydWU7XG4gIGZ1bmN0aW9uIGdldFN0YXRpY0RlZmF1bHRWYWx1ZSgpIHtcbiAgICByZXR1cm4gY2ZnLnZhbHVlO1xuICB9XG5cbiAgY29uc3QgJCRmbiA9IGlzSW5qZWN0YWJsZShjZmcudmFsdWUpID8gY2ZnLnZhbHVlIDogZ2V0U3RhdGljRGVmYXVsdFZhbHVlO1xuICByZXR1cm4gZXh0ZW5kKGNmZywgeyAkJGZuIH0pO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZShjZmc6IFBhcmFtRGVjbGFyYXRpb24sIHVybFR5cGU6IFBhcmFtVHlwZSwgbG9jYXRpb246IERlZlR5cGUsIGlkOiBzdHJpbmcsIHBhcmFtVHlwZXM6IFBhcmFtVHlwZXMpIHtcbiAgaWYgKGNmZy50eXBlICYmIHVybFR5cGUgJiYgdXJsVHlwZS5uYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKGBQYXJhbSAnJHtpZH0nIGhhcyB0d28gdHlwZSBjb25maWd1cmF0aW9ucy5gKTtcbiAgaWYgKGNmZy50eXBlICYmIHVybFR5cGUgJiYgdXJsVHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUgYXMgc3RyaW5nKSlcbiAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlIGFzIHN0cmluZyk7XG4gIGlmICh1cmxUeXBlKSByZXR1cm4gdXJsVHlwZTtcbiAgaWYgKCFjZmcudHlwZSkge1xuICAgIGNvbnN0IHR5cGUgPVxuICAgICAgbG9jYXRpb24gPT09IERlZlR5cGUuQ09ORklHXG4gICAgICAgID8gJ2FueSdcbiAgICAgICAgOiBsb2NhdGlvbiA9PT0gRGVmVHlwZS5QQVRIXG4gICAgICAgID8gJ3BhdGgnXG4gICAgICAgIDogbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIXG4gICAgICAgID8gJ3F1ZXJ5J1xuICAgICAgICA6ICdzdHJpbmcnO1xuICAgIHJldHVybiBwYXJhbVR5cGVzLnR5cGUodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGNmZy50eXBlIGluc3RhbmNlb2YgUGFyYW1UeXBlID8gY2ZnLnR5cGUgOiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUgYXMgc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIHJldHVybnMgZmFsc2UsIHRydWUsIG9yIHRoZSBzcXVhc2ggdmFsdWUgdG8gaW5kaWNhdGUgdGhlIFwiZGVmYXVsdCBwYXJhbWV0ZXIgdXJsIHNxdWFzaCBwb2xpY3lcIi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZzogUGFyYW1EZWNsYXJhdGlvbiwgaXNPcHRpb25hbDogYm9vbGVhbiwgZGVmYXVsdFBvbGljeTogYm9vbGVhbiB8IHN0cmluZykge1xuICBjb25zdCBzcXVhc2ggPSBjb25maWcuc3F1YXNoO1xuICBpZiAoIWlzT3B0aW9uYWwgfHwgc3F1YXNoID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzRGVmaW5lZChzcXVhc2gpIHx8IHNxdWFzaCA9PSBudWxsKSByZXR1cm4gZGVmYXVsdFBvbGljeTtcbiAgaWYgKHNxdWFzaCA9PT0gdHJ1ZSB8fCBpc1N0cmluZyhzcXVhc2gpKSByZXR1cm4gc3F1YXNoO1xuICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3F1YXNoIHBvbGljeTogJyR7c3F1YXNofScuIFZhbGlkIHBvbGljaWVzOiBmYWxzZSwgdHJ1ZSwgb3IgYXJiaXRyYXJ5IHN0cmluZ2ApO1xufVxuXG4vKiogQGludGVybmFsYXBpICovXG5mdW5jdGlvbiBnZXRSZXBsYWNlKGNvbmZpZzogUGFyYW1EZWNsYXJhdGlvbiwgYXJyYXlNb2RlOiBib29sZWFuLCBpc09wdGlvbmFsOiBib29sZWFuLCBzcXVhc2g6IHN0cmluZyB8IGJvb2xlYW4pIHtcbiAgY29uc3QgZGVmYXVsdFBvbGljeSA9IFtcbiAgICB7IGZyb206ICcnLCB0bzogaXNPcHRpb25hbCB8fCBhcnJheU1vZGUgPyB1bmRlZmluZWQgOiAnJyB9LFxuICAgIHsgZnJvbTogbnVsbCwgdG86IGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogJycgfSxcbiAgXTtcblxuICBjb25zdCByZXBsYWNlID0gaXNBcnJheShjb25maWcucmVwbGFjZSkgPyBjb25maWcucmVwbGFjZSA6IFtdO1xuICBpZiAoaXNTdHJpbmcoc3F1YXNoKSkgcmVwbGFjZS5wdXNoKHsgZnJvbTogc3F1YXNoLCB0bzogdW5kZWZpbmVkIH0pO1xuXG4gIGNvbnN0IGNvbmZpZ3VyZWRLZXlzID0gbWFwKHJlcGxhY2UsIHByb3AoJ2Zyb20nKSk7XG4gIHJldHVybiBmaWx0ZXIoZGVmYXVsdFBvbGljeSwgaXRlbSA9PiBjb25maWd1cmVkS2V5cy5pbmRleE9mKGl0ZW0uZnJvbSkgPT09IC0xKS5jb25jYXQocmVwbGFjZSk7XG59XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBjbGFzcyBQYXJhbSB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6IFBhcmFtVHlwZTtcbiAgbG9jYXRpb246IERlZlR5cGU7XG4gIGlzT3B0aW9uYWw6IGJvb2xlYW47XG4gIGR5bmFtaWM6IGJvb2xlYW47XG4gIHJhdzogYm9vbGVhbjtcbiAgc3F1YXNoOiBib29sZWFuIHwgc3RyaW5nO1xuICByZXBsYWNlOiBbeyB0bzogYW55OyBmcm9tOiBhbnkgfV07XG4gIGluaGVyaXQ6IGJvb2xlYW47XG4gIGFycmF5OiBib29sZWFuO1xuICBjb25maWc6IGFueTtcbiAgLyoqIENhY2hlIHRoZSBkZWZhdWx0IHZhbHVlIGlmIGl0IGlzIGEgc3RhdGljIHZhbHVlICovXG4gIF9kZWZhdWx0VmFsdWVDYWNoZToge1xuICAgIGRlZmF1bHRWYWx1ZTogYW55O1xuICB9O1xuXG4gIHN0YXRpYyB2YWx1ZXMocGFyYW1zOiBQYXJhbVtdLCB2YWx1ZXM6IFJhd1BhcmFtcyA9IHt9KTogUmF3UGFyYW1zIHtcbiAgICBjb25zdCBwYXJhbVZhbHVlcyA9IHt9IGFzIFJhd1BhcmFtcztcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgcGFyYW1WYWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWVzW3BhcmFtLmlkXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbVZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBbW1BhcmFtXV0gb2JqZWN0cyB3aGljaCBoYXZlIGRpZmZlcmVudCBwYXJhbSB2YWx1ZXNcbiAgICpcbiAgICogRmlsdGVycyBhIGxpc3Qgb2YgW1tQYXJhbV1dIG9iamVjdHMgdG8gb25seSB0aG9zZSB3aG9zZSBwYXJhbWV0ZXIgdmFsdWVzIGRpZmZlciBpbiB0d28gcGFyYW0gdmFsdWUgb2JqZWN0c1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zOiBUaGUgbGlzdCBvZiBQYXJhbSBvYmplY3RzIHRvIGZpbHRlclxuICAgKiBAcGFyYW0gdmFsdWVzMTogVGhlIGZpcnN0IHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZXMyOiB0aGUgc2Vjb25kIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIGFueSBQYXJhbSBvYmplY3RzIHdob3NlIHZhbHVlcyB3ZXJlIGRpZmZlcmVudCBiZXR3ZWVuIHZhbHVlczEgYW5kIHZhbHVlczJcbiAgICovXG4gIHN0YXRpYyBjaGFuZ2VkKHBhcmFtczogUGFyYW1bXSwgdmFsdWVzMTogUmF3UGFyYW1zID0ge30sIHZhbHVlczI6IFJhd1BhcmFtcyA9IHt9KTogUGFyYW1bXSB7XG4gICAgcmV0dXJuIHBhcmFtcy5maWx0ZXIocGFyYW0gPT4gIXBhcmFtLnR5cGUuZXF1YWxzKHZhbHVlczFbcGFyYW0uaWRdLCB2YWx1ZXMyW3BhcmFtLmlkXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcGFyYW0gdmFsdWUgb2JqZWN0cyBhcmUgZXF1YWwgKGZvciBhIHNldCBvZiBbW1BhcmFtXV0gb2JqZWN0cylcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyBUaGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyB0byBjaGVja1xuICAgKiBAcGFyYW0gdmFsdWVzMSBUaGUgZmlyc3Qgc2V0IG9mIHBhcmFtIHZhbHVlc1xuICAgKiBAcGFyYW0gdmFsdWVzMiBUaGUgc2Vjb25kIHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyYW0gdmFsdWVzIGluIHZhbHVlczEgYW5kIHZhbHVlczIgYXJlIGVxdWFsXG4gICAqL1xuICBzdGF0aWMgZXF1YWxzKHBhcmFtczogUGFyYW1bXSwgdmFsdWVzMSA9IHt9LCB2YWx1ZXMyID0ge30pOiBib29sZWFuIHtcbiAgICByZXR1cm4gUGFyYW0uY2hhbmdlZChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYSB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhcmUgdmFsaWQsIGFjY29yZGluZyB0byB0aGUgUGFyYW0gZGVmaW5pdGlvbnMgKi9cbiAgc3RhdGljIHZhbGlkYXRlcyhwYXJhbXM6IFBhcmFtW10sIHZhbHVlczogUmF3UGFyYW1zID0ge30pOiBib29sZWFuIHtcbiAgICByZXR1cm4gcGFyYW1zLm1hcChwYXJhbSA9PiBwYXJhbS52YWxpZGF0ZXModmFsdWVzW3BhcmFtLmlkXSkpLnJlZHVjZShhbGxUcnVlUiwgdHJ1ZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihpZDogc3RyaW5nLCB0eXBlOiBQYXJhbVR5cGUsIGxvY2F0aW9uOiBEZWZUeXBlLCB1cmxDb25maWc6IFVybENvbmZpZywgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pIHtcbiAgICBjb25zdCBjb25maWc6IFBhcmFtRGVjbGFyYXRpb24gPSBnZXRQYXJhbURlY2xhcmF0aW9uKGlkLCBsb2NhdGlvbiwgc3RhdGUpO1xuICAgIHR5cGUgPSBnZXRUeXBlKGNvbmZpZywgdHlwZSwgbG9jYXRpb24sIGlkLCB1cmxDb25maWcucGFyYW1UeXBlcyk7XG4gICAgY29uc3QgYXJyYXlNb2RlID0gZ2V0QXJyYXlNb2RlKCk7XG4gICAgdHlwZSA9IGFycmF5TW9kZSA/IHR5cGUuJGFzQXJyYXkoYXJyYXlNb2RlLCBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0gpIDogdHlwZTtcbiAgICBjb25zdCBpc09wdGlvbmFsID0gY29uZmlnLnZhbHVlICE9PSB1bmRlZmluZWQgfHwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBpc0RlZmluZWQoY29uZmlnLmR5bmFtaWMpID8gISFjb25maWcuZHluYW1pYyA6ICEhdHlwZS5keW5hbWljO1xuICAgIGNvbnN0IHJhdyA9IGlzRGVmaW5lZChjb25maWcucmF3KSA/ICEhY29uZmlnLnJhdyA6ICEhdHlwZS5yYXc7XG4gICAgY29uc3Qgc3F1YXNoID0gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgdXJsQ29uZmlnLmRlZmF1bHRTcXVhc2hQb2xpY3koKSk7XG4gICAgY29uc3QgcmVwbGFjZSA9IGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCk7XG4gICAgY29uc3QgaW5oZXJpdCA9IGlzRGVmaW5lZChjb25maWcuaW5oZXJpdCkgPyAhIWNvbmZpZy5pbmhlcml0IDogISF0eXBlLmluaGVyaXQ7XG5cbiAgICAvLyBhcnJheSBjb25maWc6IHBhcmFtIG5hbWUgKHBhcmFtW10pIG92ZXJyaWRlcyBkZWZhdWx0IHNldHRpbmdzLiAgZXhwbGljaXQgY29uZmlnIG92ZXJyaWRlcyBwYXJhbSBuYW1lLlxuICAgIGZ1bmN0aW9uIGdldEFycmF5TW9kZSgpIHtcbiAgICAgIGNvbnN0IGFycmF5RGVmYXVsdHMgPSB7IGFycmF5OiBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0ggPyAnYXV0bycgOiBmYWxzZSB9O1xuICAgICAgY29uc3QgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSA9IGlkLm1hdGNoKC9cXFtcXF0kLykgPyB7IGFycmF5OiB0cnVlIH0gOiB7fTtcbiAgICAgIHJldHVybiBleHRlbmQoYXJyYXlEZWZhdWx0cywgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSwgY29uZmlnKS5hcnJheTtcbiAgICB9XG5cbiAgICBleHRlbmQodGhpcywgeyBpZCwgdHlwZSwgbG9jYXRpb24sIGlzT3B0aW9uYWwsIGR5bmFtaWMsIHJhdywgc3F1YXNoLCByZXBsYWNlLCBpbmhlcml0LCBhcnJheTogYXJyYXlNb2RlLCBjb25maWcgfSk7XG4gIH1cblxuICBpc0RlZmF1bHRWYWx1ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcHRpb25hbCAmJiB0aGlzLnR5cGUuZXF1YWxzKHRoaXMudmFsdWUoKSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtJbnRlcm5hbF0gR2V0cyB0aGUgZGVjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlIGlmIHRoZSB2YWx1ZSBpcyBkZWZpbmVkLCBvdGhlcndpc2UsIHJldHVybnMgdGhlXG4gICAqIGRlZmF1bHQgdmFsdWUsIHdoaWNoIG1heSBiZSB0aGUgcmVzdWx0IG9mIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAqL1xuICB2YWx1ZSh2YWx1ZT86IGFueSk6IGFueSB7XG4gICAgLyoqXG4gICAgICogW0ludGVybmFsXSBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwYXJhbWV0ZXIsIHdoaWNoIG1heSBiZSBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0IGdldERlZmF1bHRWYWx1ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSkgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlLmRlZmF1bHRWYWx1ZTtcblxuICAgICAgaWYgKCFzZXJ2aWNlcy4kaW5qZWN0b3IpIHRocm93IG5ldyBFcnJvcignSW5qZWN0YWJsZSBmdW5jdGlvbnMgY2Fubm90IGJlIGNhbGxlZCBhdCBjb25maWd1cmF0aW9uIHRpbWUnKTtcblxuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gc2VydmljZXMuJGluamVjdG9yLmludm9rZSh0aGlzLmNvbmZpZy4kJGZuKTtcblxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy50eXBlLmlzKGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRGVmYXVsdCB2YWx1ZSAoJHtkZWZhdWx0VmFsdWV9KSBmb3IgcGFyYW1ldGVyICcke3RoaXMuaWR9JyBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgUGFyYW1UeXBlICgke1xuICAgICAgICAgICAgdGhpcy50eXBlLm5hbWVcbiAgICAgICAgICB9KWBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLiQkZm5bJ19fY2FjaGVhYmxlJ10pIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUgPSB7IGRlZmF1bHRWYWx1ZSB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH07XG5cbiAgICBjb25zdCByZXBsYWNlU3BlY2lhbFZhbHVlcyA9ICh2YWw6IGFueSkgPT4ge1xuICAgICAgZm9yIChjb25zdCB0dXBsZSBvZiB0aGlzLnJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHR1cGxlLmZyb20gPT09IHZhbCkgcmV0dXJuIHR1cGxlLnRvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdmFsdWUgPSByZXBsYWNlU3BlY2lhbFZhbHVlcyh2YWx1ZSk7XG5cbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpID8gZ2V0RGVmYXVsdFZhbHVlKCkgOiB0aGlzLnR5cGUuJG5vcm1hbGl6ZSh2YWx1ZSk7XG4gIH1cblxuICBpc1NlYXJjaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0g7XG4gIH1cblxuICB2YWxpZGF0ZXModmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIC8vIFRoZXJlIHdhcyBubyBwYXJhbWV0ZXIgdmFsdWUsIGJ1dCB0aGUgcGFyYW0gaXMgb3B0aW9uYWxcbiAgICBpZiAoKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgdGhpcy5pc09wdGlvbmFsKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFRoZSB2YWx1ZSB3YXMgbm90IG9mIHRoZSBjb3JyZWN0IFBhcmFtVHlwZSwgYW5kIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBjb3JyZWN0IFBhcmFtVHlwZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB0aGlzLnR5cGUuJG5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgaWYgKCF0aGlzLnR5cGUuaXMobm9ybWFsaXplZCkpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFRoZSB2YWx1ZSB3YXMgb2YgdGhlIGNvcnJlY3QgdHlwZSwgYnV0IHdoZW4gZW5jb2RlZCwgZGlkIG5vdCBtYXRjaCB0aGUgUGFyYW1UeXBlJ3MgcmVnZXhwXG4gICAgY29uc3QgZW5jb2RlZCA9IHRoaXMudHlwZS5lbmNvZGUobm9ybWFsaXplZCk7XG4gICAgcmV0dXJuICEoaXNTdHJpbmcoZW5jb2RlZCkgJiYgIXRoaXMudHlwZS5wYXR0ZXJuLmV4ZWMoPHN0cmluZz5lbmNvZGVkKSk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYHtQYXJhbToke3RoaXMuaWR9ICR7dGhpcy50eXBlfSBzcXVhc2g6ICcke3RoaXMuc3F1YXNofScgb3B0aW9uYWw6ICR7dGhpcy5pc09wdGlvbmFsfX1gO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHBhcmFtcyAqLyAvKiogKi9cbmltcG9ydCB7IGZyb21Kc29uLCB0b0pzb24sIGlkZW50aXR5LCBlcXVhbHMsIGluaGVyaXQsIG1hcCwgZXh0ZW5kLCBwaWNrIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBpc0RlZmluZWQsIGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tICcuL3BhcmFtVHlwZSc7XG5pbXBvcnQgeyBQYXJhbVR5cGVEZWZpbml0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEEgcmVnaXN0cnkgZm9yIHBhcmFtZXRlciB0eXBlcy5cbiAqXG4gKiBUaGlzIHJlZ2lzdHJ5IG1hbmFnZXMgdGhlIGJ1aWx0LWluIChhbmQgY3VzdG9tKSBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhlIGJ1aWx0LWluIHBhcmFtZXRlciB0eXBlcyBhcmU6XG4gKlxuICogLSBbW3N0cmluZ11dXG4gKiAtIFtbcGF0aF1dXG4gKiAtIFtbcXVlcnldXVxuICogLSBbW2hhc2hdXVxuICogLSBbW2ludF1dXG4gKiAtIFtbYm9vbF1dXG4gKiAtIFtbZGF0ZV1dXG4gKiAtIFtbanNvbl1dXG4gKiAtIFtbYW55XV1cbiAqXG4gKiBUbyByZWdpc3RlciBjdXN0b20gcGFyYW1ldGVyIHR5cGVzLCB1c2UgW1tVcmxDb25maWcudHlwZV1dLCBpLmUuLFxuICpcbiAqIGBgYGpzXG4gKiByb3V0ZXIudXJsU2VydmljZS5jb25maWcudHlwZShjdXN0b21UeXBlKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGVzIHtcbiAgLyoqXG4gICAqIEJ1aWx0LWluIHBhcmFtZXRlciB0eXBlOiBgc3RyaW5nYFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MuXG4gICAqIEl0IG1hdGNoZXMgYW55dGhpbmcgKGBuZXcgUmVnRXhwKFwiLipcIilgKSBpbiB0aGUgVVJMXG4gICAqL1xuICBzdGF0aWMgc3RyaW5nOiBQYXJhbVR5cGVEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBCdWlsdC1pbiBwYXJhbWV0ZXIgdHlwZTogYHBhdGhgXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIHR5cGUgaXMgdGhlIGRlZmF1bHQgdHlwZSBmb3IgcGF0aCBwYXJhbWV0ZXJzLlxuICAgKiBBIHBhdGggcGFyYW1ldGVyIGlzIGFueSBwYXJhbWV0ZXIgZGVjbGFyZWQgaW4gdGhlIHBhdGggcG9ydGlvbiBvZiBhIHVybFxuICAgKlxuICAgKiAtIGAvZm9vLzpwYXJhbTEvOnBhcmFtMmA6IHR3byBwYXRoIHBhcmFtZXRlcnNcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBiZWhhdmVzIGV4YWN0bHkgbGlrZSB0aGUgW1tzdHJpbmddXSB0eXBlIHdpdGggb25lIGV4Y2VwdGlvbi5cbiAgICogV2hlbiBtYXRjaGluZyBwYXJhbWV0ZXIgdmFsdWVzIGluIHRoZSBVUkwsIHRoZSBgcGF0aGAgdHlwZSBkb2VzIG5vdCBtYXRjaCBmb3J3YXJkIHNsYXNoZXMgYC9gLlxuICAgKlxuICAgKiAjIyMjIEFuZ3VsYXIgMSBub3RlOlxuICAgKiBJbiBuZzEsIHRoaXMgdHlwZSBpcyBvdmVycmlkZGVuIHdpdGggb25lIHRoYXQgcHJlLWVuY29kZXMgc2xhc2hlcyBhcyBgfjJGYCBpbnN0ZWFkIG9mIGAlMkZgLlxuICAgKiBGb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRoaXMgYW5ndWxhciAxIGJlaGF2aW9yLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlci9pc3N1ZXMvMjU5OFxuICAgKi9cbiAgc3RhdGljIHBhdGg6IFBhcmFtVHlwZURlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIEJ1aWx0LWluIHBhcmFtZXRlciB0eXBlOiBgcXVlcnlgXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIHR5cGUgaXMgdGhlIGRlZmF1bHQgdHlwZSBmb3IgcXVlcnkvc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAqIEl0IGJlaGF2ZXMgdGhlIHNhbWUgYXMgdGhlIFtbc3RyaW5nXV0gcGFyYW1ldGVyIHR5cGUuXG4gICAqXG4gICAqIEEgcXVlcnkgcGFyYW1ldGVyIGlzIGFueSBwYXJhbWV0ZXIgZGVjbGFyZWQgaW4gdGhlIHF1ZXJ5L3NlYXJjaCBwb3J0aW9uIG9mIGEgdXJsXG4gICAqXG4gICAqIC0gYC9iYXI/cGFyYW0yYDogYSBxdWVyeSBwYXJhbWV0ZXJcbiAgICovXG4gIHN0YXRpYyBxdWVyeTogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQnVpbHQtaW4gcGFyYW1ldGVyIHR5cGU6IGBoYXNoYFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGlzIHVzZWQgZm9yIHRoZSBgI2AgcGFyYW1ldGVyICh0aGUgaGFzaClcbiAgICogSXQgYmVoYXZlcyB0aGUgc2FtZSBhcyB0aGUgW1tzdHJpbmddXSBwYXJhbWV0ZXIgdHlwZS5cbiAgICovXG4gIHN0YXRpYyBoYXNoOiBQYXJhbVR5cGVEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBCdWlsdC1pbiBwYXJhbWV0ZXIgdHlwZTogYGludGBcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBzZXJpYWxpemVzIGphdmFzY3JpcHQgaW50ZWdlcnMgKGBudW1iZXJgcyB3aGljaCByZXByZXNlbnQgYW4gaW50ZWdlcikgdG8gdGhlIFVSTC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAuc3RhdGUoe1xuICAgKiAgIG5hbWU6ICd1c2VyJyxcbiAgICogICB1cmw6ICcvdXNlci97aWQ6aW50fSdcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUuZ28oJ3VzZXInLCB7IGlkOiAxMjk4NTQ3IH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIFVSTCB3aWxsIHNlcmlhbGl6ZSB0bzogYC91c2VyLzEyOTg1NDdgLlxuICAgKlxuICAgKiBXaGVuIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgcmVhZCwgaXQgd2lsbCBiZSB0aGUgYG51bWJlcmAgYDEyOTg1NDdgLCBub3QgdGhlIHN0cmluZyBgXCIxMjk4NTQ3XCJgLlxuICAgKi9cbiAgc3RhdGljIGludDogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQnVpbHQtaW4gcGFyYW1ldGVyIHR5cGU6IGBib29sYFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIHNlcmlhbGl6ZXMgYHRydWVgL2BmYWxzZWAgYXMgYDFgL2AwYFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC5zdGF0ZSh7XG4gICAqICAgbmFtZTogJ2luYm94JyxcbiAgICogICB1cmw6ICcvaW5ib3g/e3VucmVhZDpib29sfSdcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUuZ28oJ2luYm94JywgeyB1bnJlYWQ6IHRydWUgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgVVJMIHdpbGwgc2VyaWFsaXplIHRvOiBgL2luYm94P3VucmVhZD0xYC5cbiAgICpcbiAgICogQ29udmVyc2VseSwgaWYgdGhlIHVybCBpcyBgL2luYm94P3VucmVhZD0wYCwgdGhlIHZhbHVlIG9mIHRoZSBgdW5yZWFkYCBwYXJhbWV0ZXIgd2lsbCBiZSBhIGBmYWxzZWAuXG4gICAqL1xuICBzdGF0aWMgYm9vbDogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQnVpbHQtaW4gcGFyYW1ldGVyIHR5cGU6IGBkYXRlYFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGNhbiBiZSB1c2VkIHRvIHNlcmlhbGl6ZSBKYXZhc2NyaXB0IGRhdGVzIGFzIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLnN0YXRlKHtcbiAgICogICBuYW1lOiAnc2VhcmNoJyxcbiAgICogICB1cmw6ICcvc2VhcmNoP3tzdGFydDpkYXRlfSdcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUuZ28oJ3NlYXJjaCcsIHsgc3RhcnQ6IG5ldyBEYXRlKDIwMDAsIDAsIDEpIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIFVSTCB3aWxsIHNlcmlhbGl6ZSB0bzogYC9zZWFyY2g/c3RhcnQ9MjAwMC0wMS0wMWAuXG4gICAqXG4gICAqIENvbnZlcnNlbHksIGlmIHRoZSB1cmwgaXMgYC9zZWFyY2g/c3RhcnQ9MjAxNi0xMi0yNWAsIHRoZSB2YWx1ZSBvZiB0aGUgYHN0YXJ0YCBwYXJhbWV0ZXIgd2lsbCBiZSBhIGBEYXRlYCBvYmplY3Qgd2hlcmU6XG4gICAqXG4gICAqIC0gYGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gMjAxNmBcbiAgICogLSBgZGF0ZS5nZXRNb250aCgpID09PSAxMWAgKG1vbnRoIGlzIDAtYmFzZWQpXG4gICAqIC0gYGRhdGUuZ2V0RGF0ZSgpID09PSAyNWBcbiAgICovXG4gIHN0YXRpYyBkYXRlOiBQYXJhbVR5cGVEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBCdWlsdC1pbiBwYXJhbWV0ZXIgdHlwZTogYGpzb25gXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIHR5cGUgY2FuIGJlIHVzZWQgdG8gc2VyaWFsaXplIGphdmFzY3JpcHQgb2JqZWN0cyBpbnRvIHRoZSBVUkwgdXNpbmcgSlNPTiBzZXJpYWxpemF0aW9uLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFRoaXMgZXhhbXBsZSBzZXJpYWxpemVzIGFuIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IHRvIHRoZSBVUkxcbiAgICogYGBganNcbiAgICogLnN0YXRlKHtcbiAgICogICBuYW1lOiAnbWFwJyxcbiAgICogICB1cmw6ICcvbWFwL3tjb29yZHM6anNvbn0nXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGBganNcbiAgICogJHN0YXRlLmdvKCdtYXAnLCB7IGNvb3JkczogeyB4OiAxMDM5OS4yLCB5OiA0OTA3MSB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBVUkwgd2lsbCBzZXJpYWxpemUgdG86IGAvbWFwLyU3QiUyMnglMjIlM0ExMDM5OS4yJTJDJTIyeSUyMiUzQTQ5MDcxJTdEYFxuICAgKi9cbiAgc3RhdGljIGpzb246IFBhcmFtVHlwZURlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIEJ1aWx0LWluIHBhcmFtZXRlciB0eXBlOiBgYW55YFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGlzIHVzZWQgYnkgZGVmYXVsdCBmb3IgdXJsLWxlc3MgcGFyYW1ldGVycyAocGFyYW1ldGVycyB0aGF0IGRvIG5vdCBhcHBlYXIgaW4gdGhlIFVSTCkuXG4gICAqIFRoaXMgdHlwZSBkb2VzIG5vdCBlbmNvZGUgb3IgZGVjb2RlLlxuICAgKiBJdCBpcyBjb21wYXJlZCB1c2luZyBhIGRlZXAgYGVxdWFsc2AgY29tcGFyaXNvbi5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBUaGlzIGV4YW1wbGUgZGVmaW5lcyBhIG5vbi11cmwgcGFyYW1ldGVyIG9uIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0uXG4gICAqIGBgYGpzXG4gICAqIC5zdGF0ZSh7XG4gICAqICAgbmFtZTogJ25ldycsXG4gICAqICAgdXJsOiAnL25ldycsXG4gICAqICAgcGFyYW1zOiB7XG4gICAqICAgICBpbnJlcHl0bzogbnVsbFxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUuZ28oJ25ldycsIHsgaW5yZXBseXRvOiBjdXJyZW50TWVzc2FnZSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgYW55OiBQYXJhbVR5cGVEZWZpbml0aW9uO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIHR5cGVzOiBhbnk7XG4gIC8qKiBAaGlkZGVuICovXG4gIGVucXVldWUgPSB0cnVlO1xuICAvKiogQGhpZGRlbiAqL1xuICB0eXBlUXVldWU6IGFueVtdID0gW107XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBwcml2YXRlIGRlZmF1bHRUeXBlczogYW55ID0gcGljayhQYXJhbVR5cGVzLnByb3RvdHlwZSwgW1xuICAgICdoYXNoJyxcbiAgICAnc3RyaW5nJyxcbiAgICAncXVlcnknLFxuICAgICdwYXRoJyxcbiAgICAnaW50JyxcbiAgICAnYm9vbCcsXG4gICAgJ2RhdGUnLFxuICAgICdqc29uJyxcbiAgICAnYW55JyxcbiAgXSk7XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBSZWdpc3RlciBkZWZhdWx0IHR5cGVzLiBTdG9yZSB0aGVtIGluIHRoZSBwcm90b3R5cGUgb2YgdGhpcy50eXBlcy5cbiAgICBjb25zdCBtYWtlVHlwZSA9IChkZWZpbml0aW9uOiBQYXJhbVR5cGVEZWZpbml0aW9uLCBuYW1lOiBzdHJpbmcpID0+IG5ldyBQYXJhbVR5cGUoZXh0ZW5kKHsgbmFtZSB9LCBkZWZpbml0aW9uKSk7XG4gICAgdGhpcy50eXBlcyA9IGluaGVyaXQobWFwKHRoaXMuZGVmYXVsdFR5cGVzLCBtYWtlVHlwZSksIHt9KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnR5cGVzID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgcGFyYW1ldGVyIHR5cGVcbiAgICpcbiAgICogRW5kIHVzZXJzIHNob3VsZCBjYWxsIFtbVXJsTWF0Y2hlckZhY3RvcnkudHlwZV1dLCB3aGljaCBkZWxlZ2F0ZXMgdG8gdGhpcyBtZXRob2QuXG4gICAqL1xuICB0eXBlKG5hbWU6IHN0cmluZywgZGVmaW5pdGlvbj86IFBhcmFtVHlwZURlZmluaXRpb24sIGRlZmluaXRpb25Gbj86ICgpID0+IFBhcmFtVHlwZURlZmluaXRpb24pIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkZWZpbml0aW9uKSkgcmV0dXJuIHRoaXMudHlwZXNbbmFtZV07XG4gICAgaWYgKHRoaXMudHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHRocm93IG5ldyBFcnJvcihgQSB0eXBlIG5hbWVkICcke25hbWV9JyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuYCk7XG5cbiAgICB0aGlzLnR5cGVzW25hbWVdID0gbmV3IFBhcmFtVHlwZShleHRlbmQoeyBuYW1lIH0sIGRlZmluaXRpb24pKTtcblxuICAgIGlmIChkZWZpbml0aW9uRm4pIHtcbiAgICAgIHRoaXMudHlwZVF1ZXVlLnB1c2goeyBuYW1lLCBkZWY6IGRlZmluaXRpb25GbiB9KTtcbiAgICAgIGlmICghdGhpcy5lbnF1ZXVlKSB0aGlzLl9mbHVzaFR5cGVRdWV1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBfZmx1c2hUeXBlUXVldWUoKSB7XG4gICAgd2hpbGUgKHRoaXMudHlwZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAodHlwZS5wYXR0ZXJuKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IG92ZXJyaWRlIGEgdHlwZSdzIC5wYXR0ZXJuIGF0IHJ1bnRpbWUuXCIpO1xuICAgICAgZXh0ZW5kKHRoaXMudHlwZXNbdHlwZS5uYW1lXSwgc2VydmljZXMuJGluamVjdG9yLmludm9rZSh0eXBlLmRlZikpO1xuICAgIH1cbiAgfVxufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gaW5pdERlZmF1bHRUeXBlcygpIHtcbiAgY29uc3QgbWFrZURlZmF1bHRUeXBlID0gZGVmID0+IHtcbiAgICBjb25zdCB2YWxUb1N0cmluZyA9ICh2YWw6IGFueSkgPT4gKHZhbCAhPSBudWxsID8gdmFsLnRvU3RyaW5nKCkgOiB2YWwpO1xuXG4gICAgY29uc3QgZGVmYXVsdFR5cGVCYXNlID0ge1xuICAgICAgZW5jb2RlOiB2YWxUb1N0cmluZyxcbiAgICAgIGRlY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICBpczogaXMoU3RyaW5nKSxcbiAgICAgIHBhdHRlcm46IC8uKi8sXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgICAgZXF1YWxzOiAoYTogYW55LCBiOiBhbnkpID0+IGEgPT0gYiwgLy8gYWxsb3cgY29lcnNpb24gZm9yIG51bGwvdW5kZWZpbmVkL1wiXCJcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZGVmYXVsdFR5cGVCYXNlLCBkZWYpIGFzIFBhcmFtVHlwZURlZmluaXRpb247XG4gIH07XG5cbiAgLy8gRGVmYXVsdCBQYXJhbWV0ZXIgVHlwZSBEZWZpbml0aW9uc1xuICBleHRlbmQoUGFyYW1UeXBlcy5wcm90b3R5cGUsIHtcbiAgICBzdHJpbmc6IG1ha2VEZWZhdWx0VHlwZSh7fSksXG5cbiAgICBwYXRoOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgcGF0dGVybjogL1teL10qLyxcbiAgICB9KSxcblxuICAgIHF1ZXJ5OiBtYWtlRGVmYXVsdFR5cGUoe30pLFxuXG4gICAgaGFzaDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIH0pLFxuXG4gICAgaW50OiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgZGVjb2RlOiAodmFsOiBzdHJpbmcpID0+IHBhcnNlSW50KHZhbCwgMTApLFxuICAgICAgaXM6IGZ1bmN0aW9uKHZhbDogYW55KSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsT3JVbmRlZmluZWQodmFsKSAmJiB0aGlzLmRlY29kZSh2YWwudG9TdHJpbmcoKSkgPT09IHZhbDtcbiAgICAgIH0sXG4gICAgICBwYXR0ZXJuOiAvLT9cXGQrLyxcbiAgICB9KSxcblxuICAgIGJvb2w6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICBlbmNvZGU6ICh2YWw6IGFueSkgPT4gKHZhbCAmJiAxKSB8fCAwLFxuICAgICAgZGVjb2RlOiAodmFsOiBzdHJpbmcpID0+IHBhcnNlSW50KHZhbCwgMTApICE9PSAwLFxuICAgICAgaXM6IGlzKEJvb2xlYW4pLFxuICAgICAgcGF0dGVybjogLzB8MS8sXG4gICAgfSksXG5cbiAgICBkYXRlOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgZW5jb2RlOiBmdW5jdGlvbih2YWw6IGFueSkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXModmFsKVxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBbdmFsLmdldEZ1bGxZZWFyKCksICgnMCcgKyAodmFsLmdldE1vbnRoKCkgKyAxKSkuc2xpY2UoLTIpLCAoJzAnICsgdmFsLmdldERhdGUoKSkuc2xpY2UoLTIpXS5qb2luKCctJyk7XG4gICAgICB9LFxuICAgICAgZGVjb2RlOiBmdW5jdGlvbih2YWw6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5pcyh2YWwpKSByZXR1cm4gKDxhbnk+dmFsKSBhcyBEYXRlO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuY2FwdHVyZS5leGVjKHZhbCk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG5ldyBEYXRlKG1hdGNoWzFdLCBtYXRjaFsyXSAtIDEsIG1hdGNoWzNdKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBpczogKHZhbDogYW55KSA9PiB2YWwgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWwudmFsdWVPZigpKSxcbiAgICAgIGVxdWFscyhsOiBhbnksIHI6IGFueSkge1xuICAgICAgICByZXR1cm4gWydnZXRGdWxsWWVhcicsICdnZXRNb250aCcsICdnZXREYXRlJ10ucmVkdWNlKChhY2MsIGZuKSA9PiBhY2MgJiYgbFtmbl0oKSA9PT0gcltmbl0oKSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcGF0dGVybjogL1swLTldezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXxbMS0yXVswLTldfDNbMC0xXSkvLFxuICAgICAgY2FwdHVyZTogLyhbMC05XXs0fSktKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcbiAgICB9KSxcblxuICAgIGpzb246IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICBlbmNvZGU6IHRvSnNvbixcbiAgICAgIGRlY29kZTogZnJvbUpzb24sXG4gICAgICBpczogaXMoT2JqZWN0KSxcbiAgICAgIGVxdWFsczogZXF1YWxzLFxuICAgICAgcGF0dGVybjogL1teL10qLyxcbiAgICB9KSxcblxuICAgIC8vIGRvZXMgbm90IGVuY29kZS9kZWNvZGVcbiAgICBhbnk6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICBlbmNvZGU6IGlkZW50aXR5LFxuICAgICAgZGVjb2RlOiBpZGVudGl0eSxcbiAgICAgIGlzOiAoKSA9PiB0cnVlLFxuICAgICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgfSksXG4gIH0pO1xufVxuXG5pbml0RGVmYXVsdFR5cGVzKCk7XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHBhcmFtcyAqLyAvKiogKi9cbmltcG9ydCB7IGV4dGVuZCwgYW5jZXN0b3JzLCBPYmogfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgY2xhc3MgU3RhdGVQYXJhbXMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zOiBPYmogPSB7fSkge1xuICAgIGV4dGVuZCh0aGlzLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhIHNldCBvZiBwYXJhbWV0ZXJzIHdpdGggYWxsIHBhcmFtZXRlcnMgaW5oZXJpdGVkIGJldHdlZW4gdGhlIGNvbW1vbiBwYXJlbnRzIG9mIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3UGFyYW1zIFRoZSBzZXQgb2YgcGFyYW1ldGVycyB3aGljaCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCBpbmhlcml0ZWQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gJHRvIEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLlxuICAgKi9cbiAgJGluaGVyaXQobmV3UGFyYW1zOiBPYmosICRjdXJyZW50OiBTdGF0ZU9iamVjdCwgJHRvOiBTdGF0ZU9iamVjdCkge1xuICAgIGxldCBwYXJlbnRQYXJhbXM6IHN0cmluZ1tdO1xuICAgIGNvbnN0IHBhcmVudHMgPSBhbmNlc3RvcnMoJGN1cnJlbnQsICR0byksXG4gICAgICBpbmhlcml0ZWQ6IE9iaiA9IHt9LFxuICAgICAgaW5oZXJpdExpc3Q6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gcGFyZW50cykge1xuICAgICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcykgY29udGludWU7XG4gICAgICBwYXJlbnRQYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzW2ldLnBhcmFtcyk7XG4gICAgICBpZiAoIXBhcmVudFBhcmFtcy5sZW5ndGgpIGNvbnRpbnVlO1xuXG4gICAgICBmb3IgKGNvbnN0IGogaW4gcGFyZW50UGFyYW1zKSB7XG4gICAgICAgIGlmIChpbmhlcml0TGlzdC5pbmRleE9mKHBhcmVudFBhcmFtc1tqXSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIGluaGVyaXRMaXN0LnB1c2gocGFyZW50UGFyYW1zW2pdKTtcbiAgICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSB0aGlzW3BhcmVudFBhcmFtc1tqXV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoe30sIGluaGVyaXRlZCwgbmV3UGFyYW1zKTtcbiAgfVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHBhdGggKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIGFwcGx5UGFpcnMsIGZpbmQsIGFsbFRydWVSLCBwYWlycywgYXJyYXlUdXBsZXMgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHByb3BFcSB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMvaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhcmFtIH0gZnJvbSAnLi4vcGFyYW1zL3BhcmFtJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuLi9yZXNvbHZlL3Jlc29sdmFibGUnO1xuaW1wb3J0IHsgVmlld0NvbmZpZyB9IGZyb20gJy4uL3ZpZXcvaW50ZXJmYWNlJztcblxuLyoqXG4gKiBBIG5vZGUgaW4gYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aFxuICpcbiAqIEZvciBhIFtbVHJlZUNoYW5nZXNdXSBwYXRoLCB0aGlzIGNsYXNzIGhvbGRzIHRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBmb3IgYSBzaW5nbGUgbm9kZSBpbiB0aGUgcGF0aC5cbiAqIEVhY2ggUGF0aE5vZGUgY29ycmVzcG9uZHMgdG8gYSBzdGF0ZSBiZWluZyBlbnRlcmVkLCBleGl0ZWQsIG9yIHJldGFpbmVkLlxuICogVGhlIHN0YXRlZnVsIGluZm9ybWF0aW9uIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHJlc29sdmUgZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhOb2RlIHtcbiAgLyoqIFRoZSBzdGF0ZSBiZWluZyBlbnRlcmVkLCBleGl0ZWQsIG9yIHJldGFpbmVkICovXG4gIHB1YmxpYyBzdGF0ZTogU3RhdGVPYmplY3Q7XG4gIC8qKiBUaGUgcGFyYW1ldGVycyBkZWNsYXJlZCBvbiB0aGUgc3RhdGUgKi9cbiAgcHVibGljIHBhcmFtU2NoZW1hOiBQYXJhbVtdO1xuICAvKiogVGhlIHBhcmFtZXRlciB2YWx1ZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHN0YXRlICovXG4gIHB1YmxpYyBwYXJhbVZhbHVlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqIFRoZSBpbmRpdmlkdWFsIChzdGF0ZWZ1bCkgcmVzb2x2YWJsZSBvYmplY3RzIHRoYXQgYmVsb25nIHRvIHRoZSBzdGF0ZSAqL1xuICBwdWJsaWMgcmVzb2x2YWJsZXM6IFJlc29sdmFibGVbXTtcbiAgLyoqIFRoZSBzdGF0ZSdzIGRlY2xhcmVkIHZpZXcgY29uZmlndXJhdGlvbiBvYmplY3RzICovXG4gIHB1YmxpYyB2aWV3czogVmlld0NvbmZpZ1tdO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBhdGhOb2RlXG4gICAqIEBkZXByZWNhdGVkIHVzZSBpbnN0YW5jZSBtZXRob2QgYG5vZGUuY2xvbmUoKWBcbiAgICovXG4gIHN0YXRpYyBjbG9uZSA9IChub2RlOiBQYXRoTm9kZSkgPT4gbm9kZS5jbG9uZSgpO1xuXG4gIC8qKiBDcmVhdGVzIGEgY29weSBvZiBhIFBhdGhOb2RlICovXG4gIGNvbnN0cnVjdG9yKG5vZGU6IFBhdGhOb2RlKTtcbiAgLyoqIENyZWF0ZXMgYSBuZXcgKGVtcHR5KSBQYXRoTm9kZSBmb3IgYSBTdGF0ZSAqL1xuICBjb25zdHJ1Y3RvcihzdGF0ZTogU3RhdGVPYmplY3QpO1xuICBjb25zdHJ1Y3RvcihzdGF0ZU9yTm9kZTogYW55KSB7XG4gICAgaWYgKHN0YXRlT3JOb2RlIGluc3RhbmNlb2YgUGF0aE5vZGUpIHtcbiAgICAgIGNvbnN0IG5vZGU6IFBhdGhOb2RlID0gc3RhdGVPck5vZGU7XG4gICAgICB0aGlzLnN0YXRlID0gbm9kZS5zdGF0ZTtcbiAgICAgIHRoaXMucGFyYW1TY2hlbWEgPSBub2RlLnBhcmFtU2NoZW1hLnNsaWNlKCk7XG4gICAgICB0aGlzLnBhcmFtVmFsdWVzID0gZXh0ZW5kKHt9LCBub2RlLnBhcmFtVmFsdWVzKTtcbiAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLnNsaWNlKCk7XG4gICAgICB0aGlzLnZpZXdzID0gbm9kZS52aWV3cyAmJiBub2RlLnZpZXdzLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlOiBTdGF0ZU9iamVjdCA9IHN0YXRlT3JOb2RlO1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KTtcbiAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB7fTtcbiAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBzdGF0ZS5yZXNvbHZhYmxlcy5tYXAocmVzID0+IHJlcy5jbG9uZSgpKTtcbiAgICB9XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBhdGhOb2RlKHRoaXMpO1xuICB9XG5cbiAgLyoqIFNldHMgW1twYXJhbVZhbHVlc11dIGZvciB0aGUgbm9kZSwgZnJvbSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCBoYXNoICovXG4gIGFwcGx5UmF3UGFyYW1zKHBhcmFtczogUmF3UGFyYW1zKTogUGF0aE5vZGUge1xuICAgIGNvbnN0IGdldFBhcmFtVmFsID0gKHBhcmFtRGVmOiBQYXJhbSkgPT4gW3BhcmFtRGVmLmlkLCBwYXJhbURlZi52YWx1ZShwYXJhbXNbcGFyYW1EZWYuaWRdKV07XG4gICAgdGhpcy5wYXJhbVZhbHVlcyA9IHRoaXMucGFyYW1TY2hlbWEucmVkdWNlKChtZW1vLCBwRGVmKSA9PiBhcHBseVBhaXJzKG1lbW8sIGdldFBhcmFtVmFsKHBEZWYpKSwge30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEdldHMgYSBzcGVjaWZpYyBbW1BhcmFtXV0gbWV0YWRhdGEgdGhhdCBiZWxvbmdzIHRvIHRoZSBub2RlICovXG4gIHBhcmFtZXRlcihuYW1lOiBzdHJpbmcpOiBQYXJhbSB7XG4gICAgcmV0dXJuIGZpbmQodGhpcy5wYXJhbVNjaGVtYSwgcHJvcEVxKCdpZCcsIG5hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzdGF0ZSBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYW5vdGhlciBQYXRoTm9kZSBhcmVcbiAgICogZXF1YWwgdG8gdGhlIHN0YXRlIGFuZCBwYXJhbSB2YWx1ZXMgZm9yIHRoaXMgUGF0aE5vZGVcbiAgICovXG4gIGVxdWFscyhub2RlOiBQYXRoTm9kZSwgcGFyYW1zRm4/OiBHZXRQYXJhbXNGbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRpZmYgPSB0aGlzLmRpZmYobm9kZSwgcGFyYW1zRm4pO1xuICAgIHJldHVybiBkaWZmICYmIGRpZmYubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIFBhcmFtcyB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXIgdmFsdWVzIG9uIGFub3RoZXIgUGF0aE5vZGUuXG4gICAqXG4gICAqIEdpdmVuIGFub3RoZXIgbm9kZSAob2YgdGhlIHNhbWUgc3RhdGUpLCBmaW5kcyB0aGUgcGFyYW1ldGVyIHZhbHVlcyB3aGljaCBkaWZmZXIuXG4gICAqIFJldHVybnMgdGhlIFtbUGFyYW1dXSAoc2NoZW1hIG9iamVjdHMpIHdob3NlIHBhcmFtZXRlciB2YWx1ZXMgZGlmZmVyLlxuICAgKlxuICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgZm9yIGEgZGlmZmVyZW50IHN0YXRlLCByZXR1cm5zIGBmYWxzZWBcbiAgICpcbiAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gY29tcGFyZSB0b1xuICAgKiBAcGFyYW0gcGFyYW1zRm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hpY2ggcGFyYW1ldGVycyBzaG91bGQgYmUgY29tcGFyZWQuXG4gICAqIEByZXR1cm5zIFRoZSBbW1BhcmFtXV1zIHdoaWNoIGRpZmZlciwgb3IgbnVsbCBpZiB0aGUgdHdvIG5vZGVzIGFyZSBmb3IgZGlmZmVyZW50IHN0YXRlc1xuICAgKi9cbiAgZGlmZihub2RlOiBQYXRoTm9kZSwgcGFyYW1zRm4/OiBHZXRQYXJhbXNGbik6IFBhcmFtW10gfCBmYWxzZSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5vZGUuc3RhdGUpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IHBhcmFtczogUGFyYW1bXSA9IHBhcmFtc0ZuID8gcGFyYW1zRm4odGhpcykgOiB0aGlzLnBhcmFtU2NoZW1hO1xuICAgIHJldHVybiBQYXJhbS5jaGFuZ2VkKHBhcmFtcywgdGhpcy5wYXJhbVZhbHVlcywgbm9kZS5wYXJhbVZhbHVlcyk7XG4gIH1cbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCB0eXBlIEdldFBhcmFtc0ZuID0gKHBhdGhOb2RlOiBQYXRoTm9kZSkgPT4gUGFyYW1bXTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgc3RhdGUgKi8gLyoqICovXG5cbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24sIFN0YXRlT3JOYW1lLCBUYXJnZXRTdGF0ZURlZiB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25PcHRpb25zIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZ3MnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IFN0YXRlUmVnaXN0cnkgfSBmcm9tICcuL3N0YXRlUmVnaXN0cnknO1xuaW1wb3J0IHsgUmF3UGFyYW1zIH0gZnJvbSAnLi4vcGFyYW1zJztcblxuLyoqXG4gKiBFbmNhcHN1bGF0ZSB0aGUgdGFyZ2V0IChkZXN0aW5hdGlvbikgc3RhdGUvcGFyYW1zL29wdGlvbnMgb2YgYSBbW1RyYW5zaXRpb25dXS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGZyZXF1ZW50bHkgdXNlZCB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgZGVzdGluYXRpb24uXG4gKlxuICogU2VlOlxuICpcbiAqIC0gW1tIb29rUmVzdWx0XV1cbiAqIC0gW1tUcmFuc2l0aW9uSG9va0ZuXV1cbiAqIC0gW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV1cbiAqXG4gKiBUbyBjcmVhdGUgYSBgVGFyZ2V0U3RhdGVgLCB1c2UgW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0uXG4gKlxuICogLS0tXG4gKlxuICogVGhpcyBjbGFzcyB3cmFwczpcbiAqXG4gKiAxKSBhbiBpZGVudGlmaWVyIGZvciBhIHN0YXRlXG4gKiAyKSBhIHNldCBvZiBwYXJhbWV0ZXJzXG4gKiAzKSBhbmQgdHJhbnNpdGlvbiBvcHRpb25zXG4gKiA0KSB0aGUgcmVnaXN0ZXJlZCBzdGF0ZSBvYmplY3QgKHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSlcbiAqXG4gKiBNYW55IFVJLVJvdXRlciBBUElzIHN1Y2ggYXMgW1tTdGF0ZVNlcnZpY2UuZ29dXSB0YWtlIGEgW1tTdGF0ZU9yTmFtZV1dIGFyZ3VtZW50IHdoaWNoIGNhblxuICogZWl0aGVyIGJlIGEgKnN0YXRlIG9iamVjdCogKGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgW1tTdGF0ZU9iamVjdF1dKSBvciBhICpzdGF0ZSBuYW1lKiAoYSBzdHJpbmcpLlxuICogVGhlIGBUYXJnZXRTdGF0ZWAgY2xhc3Mgbm9ybWFsaXplcyB0aG9zZSBvcHRpb25zLlxuICpcbiAqIEEgYFRhcmdldFN0YXRlYCBtYXkgYmUgdmFsaWQgKHRoZSBzdGF0ZSBiZWluZyB0YXJnZXRlZCBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5KVxuICogb3IgaW52YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGlzIG5vdCByZWdpc3RlcmVkKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhcmdldFN0YXRlIHtcbiAgcHJpdmF0ZSBfZGVmaW5pdGlvbjogU3RhdGVPYmplY3Q7XG4gIHByaXZhdGUgX3BhcmFtczogUmF3UGFyYW1zO1xuICBwcml2YXRlIF9vcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucztcblxuICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaGFzIGEgc3RhdGUgcHJvcGVydHkgdGhhdCBtaWdodCBiZSBhIHN0YXRlIG9yIHN0YXRlIG5hbWUgKi9cbiAgc3RhdGljIGlzRGVmID0gKG9iaik6IG9iaiBpcyBUYXJnZXRTdGF0ZURlZiA9PiBvYmogJiYgb2JqLnN0YXRlICYmIChpc1N0cmluZyhvYmouc3RhdGUpIHx8IGlzU3RyaW5nKG9iai5zdGF0ZS5uYW1lKSk7XG5cbiAgLyoqXG4gICAqIFRoZSBUYXJnZXRTdGF0ZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBOb3RlOiBEbyBub3QgY29uc3RydWN0IGEgYFRhcmdldFN0YXRlYCBtYW51YWxseS5cbiAgICogVG8gY3JlYXRlIGEgYFRhcmdldFN0YXRlYCwgdXNlIHRoZSBbW1N0YXRlU2VydmljZS50YXJnZXRdXSBmYWN0b3J5IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIF9zdGF0ZVJlZ2lzdHJ5IFRoZSBTdGF0ZVJlZ2lzdHJ5IHRvIHVzZSB0byBsb29rIHVwIHRoZSBfZGVmaW5pdGlvblxuICAgKiBAcGFyYW0gX2lkZW50aWZpZXIgQW4gaWRlbnRpZmllciBmb3IgYSBzdGF0ZS5cbiAgICogICAgRWl0aGVyIGEgZnVsbHktcXVhbGlmaWVkIHN0YXRlIG5hbWUsIG9yIHRoZSBvYmplY3QgdXNlZCB0byBkZWZpbmUgdGhlIHN0YXRlLlxuICAgKiBAcGFyYW0gX3BhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGFyZ2V0IHN0YXRlXG4gICAqIEBwYXJhbSBfb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc3RhdGVSZWdpc3RyeTogU3RhdGVSZWdpc3RyeSxcbiAgICBwcml2YXRlIF9pZGVudGlmaWVyOiBTdGF0ZU9yTmFtZSxcbiAgICBfcGFyYW1zPzogUmF3UGFyYW1zLFxuICAgIF9vcHRpb25zPzogVHJhbnNpdGlvbk9wdGlvbnNcbiAgKSB7XG4gICAgdGhpcy5faWRlbnRpZmllciA9IF9pZGVudGlmaWVyO1xuICAgIHRoaXMuX3BhcmFtcyA9IGV4dGVuZCh7fSwgX3BhcmFtcyB8fCB7fSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IGV4dGVuZCh7fSwgX29wdGlvbnMgfHwge30pO1xuICAgIHRoaXMuX2RlZmluaXRpb24gPSBfc3RhdGVSZWdpc3RyeS5tYXRjaGVyLmZpbmQoX2lkZW50aWZpZXIsIHRoaXMuX29wdGlvbnMucmVsYXRpdmUpO1xuICB9XG5cbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0aGlzIG9iamVjdCB0YXJnZXRzICovXG4gIG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5uYW1lKSB8fCA8c3RyaW5nPnRoaXMuX2lkZW50aWZpZXI7XG4gIH1cblxuICAvKiogVGhlIGlkZW50aWZpZXIgdXNlZCB3aGVuIGNyZWF0aW5nIHRoaXMgVGFyZ2V0U3RhdGUgKi9cbiAgaWRlbnRpZmllcigpOiBTdGF0ZU9yTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkZW50aWZpZXI7XG4gIH1cblxuICAvKiogVGhlIHRhcmdldCBwYXJhbWV0ZXIgdmFsdWVzICovXG4gIHBhcmFtcygpOiBSYXdQYXJhbXMge1xuICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvKiogVGhlIGludGVybmFsIHN0YXRlIG9iamVjdCAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAkc3RhdGUoKTogU3RhdGVPYmplY3Qge1xuICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICB9XG5cbiAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBkZWNsYXJhdGlvbiAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICBzdGF0ZSgpOiBTdGF0ZURlY2xhcmF0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbiAmJiB0aGlzLl9kZWZpbml0aW9uLnNlbGY7XG4gIH1cblxuICAvKiogVGhlIHRhcmdldCBvcHRpb25zICovXG4gIG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICAvKiogVHJ1ZSBpZiB0aGUgdGFyZ2V0IHN0YXRlIHdhcyBmb3VuZCAqL1xuICBleGlzdHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmKTtcbiAgfVxuXG4gIC8qKiBUcnVlIGlmIHRoZSBvYmplY3QgaXMgdmFsaWQgKi9cbiAgdmFsaWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmVycm9yKCk7XG4gIH1cblxuICAvKiogSWYgdGhlIG9iamVjdCBpcyBpbnZhbGlkLCByZXR1cm5zIHRoZSByZWFzb24gd2h5ICovXG4gIGVycm9yKCk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZSA9IDxhbnk+dGhpcy5vcHRpb25zKCkucmVsYXRpdmU7XG4gICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uICYmICEhYmFzZSkge1xuICAgICAgY29uc3Qgc3RhdGVOYW1lID0gYmFzZS5uYW1lID8gYmFzZS5uYW1lIDogYmFzZTtcbiAgICAgIHJldHVybiBgQ291bGQgbm90IHJlc29sdmUgJyR7dGhpcy5uYW1lKCl9JyBmcm9tIHN0YXRlICcke3N0YXRlTmFtZX0nYDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uKSByZXR1cm4gYE5vIHN1Y2ggc3RhdGUgJyR7dGhpcy5uYW1lKCl9J2A7XG4gICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uLnNlbGYpIHJldHVybiBgU3RhdGUgJyR7dGhpcy5uYW1lKCl9JyBoYXMgYW4gaW52YWxpZCBkZWZpbml0aW9uYDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJyR7dGhpcy5uYW1lKCl9JyR7c3RyaW5naWZ5KHRoaXMucGFyYW1zKCkpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSB3aGljaCB0YXJnZXRzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgKiBUaGUgbmV3IFRhcmdldFN0YXRlIGhhcyB0aGUgc2FtZSBwYXJhbWV0ZXIgdmFsdWVzIGFuZCB0cmFuc2l0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgbmV3IHN0YXRlIHRoYXQgc2hvdWxkIGJlIHRhcmdldGVkXG4gICAqL1xuICB3aXRoU3RhdGUoc3RhdGU6IFN0YXRlT3JOYW1lKTogVGFyZ2V0U3RhdGUge1xuICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgc3RhdGUsIHRoaXMuX3BhcmFtcywgdGhpcy5fb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIHRoZSBuZXcgcGFyYW1ldGVyIHZhbHVlcyB0byB1c2VcbiAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiBmYWxzZSAoZGVmYXVsdCkgdGhlIG5ldyBwYXJhbWV0ZXIgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVzLlxuICAgKiAgICAgICAgICAgICAgICBXaGVuIHRydWUgdGhlIHBhcmFtZXRlciB2YWx1ZXMgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgdmFsdWVzLlxuICAgKi9cbiAgd2l0aFBhcmFtcyhwYXJhbXM6IFJhd1BhcmFtcywgcmVwbGFjZSA9IGZhbHNlKTogVGFyZ2V0U3RhdGUge1xuICAgIGNvbnN0IG5ld1BhcmFtczogUmF3UGFyYW1zID0gcmVwbGFjZSA/IHBhcmFtcyA6IGV4dGVuZCh7fSwgdGhpcy5fcGFyYW1zLCBwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgbmV3UGFyYW1zLCB0aGlzLl9vcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIFRhcmdldFN0YXRlLCB1c2luZyB0aGUgc3BlY2lmaWVkIFRyYW5zaXRpb24gT3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5ldyBvcHRpb25zIHRvIHVzZVxuICAgKiBAcGFyYW0gcmVwbGFjZSBXaGVuIGZhbHNlIChkZWZhdWx0KSB0aGUgbmV3IG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgY3VycmVudCBvcHRpb25zLlxuICAgKiAgICAgICAgICAgICAgICBXaGVuIHRydWUgdGhlIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb3B0aW9ucy5cbiAgICovXG4gIHdpdGhPcHRpb25zKG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zLCByZXBsYWNlID0gZmFsc2UpOiBUYXJnZXRTdGF0ZSB7XG4gICAgY29uc3QgbmV3T3B0cyA9IHJlcGxhY2UgPyBvcHRpb25zIDogZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHRoaXMuX2lkZW50aWZpZXIsIHRoaXMuX3BhcmFtcywgbmV3T3B0cyk7XG4gIH1cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBwYXRoICovIC8qKiAqL1xuXG5pbXBvcnQge1xuICBleHRlbmQsXG4gIGZpbmQsXG4gIHBpY2ssXG4gIG9taXQsXG4gIHRhaWwsXG4gIG1lcmdlUixcbiAgdmFsdWVzLFxuICB1bm5lc3RSLFxuICBQcmVkaWNhdGUsXG4gIGluQXJyYXksXG4gIGFycmF5VHVwbGVzLFxufSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHByb3AsIHByb3BFcSwgbm90IH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5cbmltcG9ydCB7IFJhd1BhcmFtcyB9IGZyb20gJy4uL3BhcmFtcy9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVHJlZUNoYW5nZXMgfSBmcm9tICcuLi90cmFuc2l0aW9uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBWaWV3Q29uZmlnIH0gZnJvbSAnLi4vdmlldy9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgX1ZpZXdEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlL2ludGVyZmFjZSc7XG5cbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUgfSBmcm9tICcuLi9zdGF0ZS90YXJnZXRTdGF0ZSc7XG5pbXBvcnQgeyBHZXRQYXJhbXNGbiwgUGF0aE5vZGUgfSBmcm9tICcuL3BhdGhOb2RlJztcbmltcG9ydCB7IFZpZXdTZXJ2aWNlIH0gZnJvbSAnLi4vdmlldy92aWV3JztcbmltcG9ydCB7IFBhcmFtIH0gZnJvbSAnLi4vcGFyYW1zL3BhcmFtJztcbmltcG9ydCB7IFN0YXRlUmVnaXN0cnkgfSBmcm9tICcuLi9zdGF0ZSc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggY29udmVydCBUYXJnZXRTdGF0ZXMsIE5vZGVzIGFuZCBwYXRocyBmcm9tIG9uZSB0eXBlIHRvIGFub3RoZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoVXRpbHMge1xuICAvKiogR2l2ZW4gYSBQYXRoTm9kZVtdLCBjcmVhdGUgYW4gVGFyZ2V0U3RhdGUgKi9cbiAgc3RhdGljIG1ha2VUYXJnZXRTdGF0ZShyZWdpc3RyeTogU3RhdGVSZWdpc3RyeSwgcGF0aDogUGF0aE5vZGVbXSk6IFRhcmdldFN0YXRlIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRhaWwocGF0aCkuc3RhdGU7XG4gICAgcmV0dXJuIG5ldyBUYXJnZXRTdGF0ZShyZWdpc3RyeSwgc3RhdGUsIHBhdGgubWFwKHByb3AoJ3BhcmFtVmFsdWVzJykpLnJlZHVjZShtZXJnZVIsIHt9KSwge30pO1xuICB9XG5cbiAgc3RhdGljIGJ1aWxkUGF0aCh0YXJnZXRTdGF0ZTogVGFyZ2V0U3RhdGUpIHtcbiAgICBjb25zdCB0b1BhcmFtcyA9IHRhcmdldFN0YXRlLnBhcmFtcygpO1xuICAgIHJldHVybiB0YXJnZXRTdGF0ZS4kc3RhdGUoKS5wYXRoLm1hcChzdGF0ZSA9PiBuZXcgUGF0aE5vZGUoc3RhdGUpLmFwcGx5UmF3UGFyYW1zKHRvUGFyYW1zKSk7XG4gIH1cblxuICAvKiogR2l2ZW4gYSBmcm9tUGF0aDogUGF0aE5vZGVbXSBhbmQgYSBUYXJnZXRTdGF0ZSwgYnVpbGRzIGEgdG9QYXRoOiBQYXRoTm9kZVtdICovXG4gIHN0YXRpYyBidWlsZFRvUGF0aChmcm9tUGF0aDogUGF0aE5vZGVbXSwgdGFyZ2V0U3RhdGU6IFRhcmdldFN0YXRlKTogUGF0aE5vZGVbXSB7XG4gICAgY29uc3QgdG9QYXRoOiBQYXRoTm9kZVtdID0gUGF0aFV0aWxzLmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XG4gICAgaWYgKHRhcmdldFN0YXRlLm9wdGlvbnMoKS5pbmhlcml0KSB7XG4gICAgICByZXR1cm4gUGF0aFV0aWxzLmluaGVyaXRQYXJhbXMoZnJvbVBhdGgsIHRvUGF0aCwgT2JqZWN0LmtleXModGFyZ2V0U3RhdGUucGFyYW1zKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFZpZXdDb25maWcgb2JqZWN0cyBhbmQgYWRkcyB0byBub2Rlcy5cbiAgICpcbiAgICogT24gZWFjaCBbW1BhdGhOb2RlXV0sIGNyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGZyb20gdGhlIHZpZXdzOiBwcm9wZXJ0eSBvZiB0aGUgbm9kZSdzIHN0YXRlXG4gICAqL1xuICBzdGF0aWMgYXBwbHlWaWV3Q29uZmlncygkdmlldzogVmlld1NlcnZpY2UsIHBhdGg6IFBhdGhOb2RlW10sIHN0YXRlczogU3RhdGVPYmplY3RbXSkge1xuICAgIC8vIE9ubHkgYXBwbHkgdGhlIHZpZXdDb25maWdzIHRvIHRoZSBub2RlcyBmb3IgdGhlIGdpdmVuIHN0YXRlc1xuICAgIHBhdGhcbiAgICAgIC5maWx0ZXIobm9kZSA9PiBpbkFycmF5KHN0YXRlcywgbm9kZS5zdGF0ZSkpXG4gICAgICAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgY29uc3Qgdmlld0RlY2xzOiBfVmlld0RlY2xhcmF0aW9uW10gPSB2YWx1ZXMobm9kZS5zdGF0ZS52aWV3cyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHN1YlBhdGggPSBQYXRoVXRpbHMuc3ViUGF0aChwYXRoLCBuID0+IG4gPT09IG5vZGUpO1xuICAgICAgICBjb25zdCB2aWV3Q29uZmlnczogVmlld0NvbmZpZ1tdW10gPSB2aWV3RGVjbHMubWFwKHZpZXcgPT4gJHZpZXcuY3JlYXRlVmlld0NvbmZpZyhzdWJQYXRoLCB2aWV3KSk7XG4gICAgICAgIG5vZGUudmlld3MgPSB2aWV3Q29uZmlncy5yZWR1Y2UodW5uZXN0UiwgW10pO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBmcm9tUGF0aCBhbmQgYSB0b1BhdGgsIHJldHVybnMgYSBuZXcgdG8gcGF0aCB3aGljaCBpbmhlcml0cyBwYXJhbWV0ZXJzIGZyb20gdGhlIGZyb21QYXRoXG4gICAqXG4gICAqIEZvciBhIHBhcmFtZXRlciBpbiBhIG5vZGUgdG8gYmUgaW5oZXJpdGVkIGZyb20gdGhlIGZyb20gcGF0aDpcbiAgICogLSBUaGUgdG9QYXRoJ3Mgbm9kZSBtdXN0IGhhdmUgYSBtYXRjaGluZyBub2RlIGluIHRoZSBmcm9tUGF0aCAoYnkgc3RhdGUpLlxuICAgKiAtIFRoZSBwYXJhbWV0ZXIgbmFtZSBtdXN0IG5vdCBiZSBmb3VuZCBpbiB0aGUgdG9LZXlzIHBhcmFtZXRlciBhcnJheS5cbiAgICpcbiAgICogTm90ZTogdGhlIGtleXMgcHJvdmlkZWQgaW4gdG9LZXlzIGFyZSBpbnRlbmRlZCB0byBiZSB0aG9zZSBwYXJhbSBrZXlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGJ5IHNvbWVcbiAgICogY2FsbGVyLCBmb3IgaW5zdGFuY2UsICRzdGF0ZS50cmFuc2l0aW9uVG8oLi4uLCB0b1BhcmFtcykuICBJZiBhIGtleSB3YXMgZm91bmQgaW4gdG9QYXJhbXMsXG4gICAqIGl0IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbVBhdGguXG4gICAqL1xuICBzdGF0aWMgaW5oZXJpdFBhcmFtcyhmcm9tUGF0aDogUGF0aE5vZGVbXSwgdG9QYXRoOiBQYXRoTm9kZVtdLCB0b0tleXM6IHN0cmluZ1tdID0gW10pOiBQYXRoTm9kZVtdIHtcbiAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGg6IFBhdGhOb2RlW10sIHN0YXRlOiBTdGF0ZU9iamVjdCk6IFJhd1BhcmFtcyB7XG4gICAgICBjb25zdCBub2RlOiBQYXRoTm9kZSA9IGZpbmQocGF0aCwgcHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHt9LCBub2RlICYmIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vSW5oZXJpdCA9IGZyb21QYXRoXG4gICAgICAubWFwKG5vZGUgPT4gbm9kZS5wYXJhbVNjaGVtYSlcbiAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgICAuZmlsdGVyKHBhcmFtID0+ICFwYXJhbS5pbmhlcml0KVxuICAgICAgLm1hcChwcm9wKCdpZCcpKTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIFtbUGF0aE5vZGVdXSBcInRvTm9kZVwiLCByZXR1cm4gYSBuZXcgW1tQYXRoTm9kZV1dIHdpdGggcGFyYW0gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHRoZVxuICAgICAqIG1hdGNoaW5nIG5vZGUgaW4gZnJvbVBhdGguICBPbmx5IGluaGVyaXQga2V5cyB0aGF0IGFyZW4ndCBmb3VuZCBpbiBcInRvS2V5c1wiIGZyb20gdGhlIG5vZGUgaW4gXCJmcm9tUGF0aFwiXCJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlSW5oZXJpdGVkUGFyYW1zTm9kZSh0b05vZGU6IFBhdGhOb2RlKTogUGF0aE5vZGUge1xuICAgICAgLy8gQWxsIHBhcmFtIHZhbHVlcyBmb3IgdGhlIG5vZGUgKG1heSBpbmNsdWRlIGRlZmF1bHQga2V5L3ZhbHMsIHdoZW4ga2V5IHdhcyBub3QgZm91bmQgaW4gdG9QYXJhbXMpXG4gICAgICBsZXQgdG9QYXJhbVZhbHMgPSBleHRlbmQoe30sIHRvTm9kZSAmJiB0b05vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgLy8gbGltaXRlZCB0byBvbmx5IHRob3NlIGtleXMgZm91bmQgaW4gdG9QYXJhbXNcbiAgICAgIGNvbnN0IGluY29taW5nUGFyYW1WYWxzID0gcGljayh0b1BhcmFtVmFscywgdG9LZXlzKTtcbiAgICAgIHRvUGFyYW1WYWxzID0gb21pdCh0b1BhcmFtVmFscywgdG9LZXlzKTtcbiAgICAgIGNvbnN0IGZyb21QYXJhbVZhbHMgPSBvbWl0KG5vZGVQYXJhbVZhbHMoZnJvbVBhdGgsIHRvTm9kZS5zdGF0ZSkgfHwge30sIG5vSW5oZXJpdCk7XG4gICAgICAvLyBleHRlbmQgdG9QYXJhbVZhbHMgd2l0aCBhbnkgZnJvbVBhcmFtVmFscywgdGhlbiBvdmVycmlkZSBhbnkgb2YgdGhvc2UgdGhvc2Ugd2l0aCBpbmNvbWluZ1BhcmFtVmFsc1xuICAgICAgY29uc3Qgb3duUGFyYW1WYWxzOiBSYXdQYXJhbXMgPSBleHRlbmQodG9QYXJhbVZhbHMsIGZyb21QYXJhbVZhbHMsIGluY29taW5nUGFyYW1WYWxzKTtcbiAgICAgIHJldHVybiBuZXcgUGF0aE5vZGUodG9Ob2RlLnN0YXRlKS5hcHBseVJhd1BhcmFtcyhvd25QYXJhbVZhbHMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBwYXJhbSBrZXlzIHNwZWNpZmllZCBieSB0aGUgaW5jb21pbmcgdG9QYXJhbXNcbiAgICByZXR1cm4gPFBhdGhOb2RlW10+dG9QYXRoLm1hcChtYWtlSW5oZXJpdGVkUGFyYW1zTm9kZSk7XG4gIH1cblxuICBzdGF0aWMgbm9uRHluYW1pY1BhcmFtcyA9IChub2RlOiBQYXRoTm9kZSk6IFBhcmFtW10gPT5cbiAgICBub2RlLnN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KS5maWx0ZXIocGFyYW0gPT4gIXBhcmFtLmR5bmFtaWMpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgdHJlZSBjaGFuZ2VzIChlbnRlcmluZywgZXhpdGluZykgYmV0d2VlbiBhIGZyb21QYXRoIGFuZCB0b1BhdGguXG4gICAqL1xuICBzdGF0aWMgdHJlZUNoYW5nZXMoZnJvbVBhdGg6IFBhdGhOb2RlW10sIHRvUGF0aDogUGF0aE5vZGVbXSwgcmVsb2FkU3RhdGU6IFN0YXRlT2JqZWN0KTogVHJlZUNoYW5nZXMge1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWluKGZyb21QYXRoLmxlbmd0aCwgdG9QYXRoLmxlbmd0aCk7XG4gICAgbGV0IGtlZXAgPSAwO1xuXG4gICAgY29uc3Qgbm9kZXNNYXRjaCA9IChub2RlMTogUGF0aE5vZGUsIG5vZGUyOiBQYXRoTm9kZSkgPT4gbm9kZTEuZXF1YWxzKG5vZGUyLCBQYXRoVXRpbHMubm9uRHluYW1pY1BhcmFtcyk7XG5cbiAgICB3aGlsZSAoa2VlcCA8IG1heCAmJiBmcm9tUGF0aFtrZWVwXS5zdGF0ZSAhPT0gcmVsb2FkU3RhdGUgJiYgbm9kZXNNYXRjaChmcm9tUGF0aFtrZWVwXSwgdG9QYXRoW2tlZXBdKSkge1xuICAgICAga2VlcCsrO1xuICAgIH1cblxuICAgIC8qKiBHaXZlbiBhIHJldGFpbmVkIG5vZGUsIHJldHVybiBhIG5ldyBub2RlIHdoaWNoIHVzZXMgdGhlIHRvIG5vZGUncyBwYXJhbSB2YWx1ZXMgKi9cbiAgICBmdW5jdGlvbiBhcHBseVRvUGFyYW1zKHJldGFpbmVkTm9kZTogUGF0aE5vZGUsIGlkeDogbnVtYmVyKTogUGF0aE5vZGUge1xuICAgICAgY29uc3QgY2xvbmVkID0gcmV0YWluZWROb2RlLmNsb25lKCk7XG4gICAgICBjbG9uZWQucGFyYW1WYWx1ZXMgPSB0b1BhdGhbaWR4XS5wYXJhbVZhbHVlcztcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuXG4gICAgbGV0IGZyb206IFBhdGhOb2RlW10sIHJldGFpbmVkOiBQYXRoTm9kZVtdLCBleGl0aW5nOiBQYXRoTm9kZVtdLCBlbnRlcmluZzogUGF0aE5vZGVbXSwgdG86IFBhdGhOb2RlW107XG5cbiAgICBmcm9tID0gZnJvbVBhdGg7XG4gICAgcmV0YWluZWQgPSBmcm9tLnNsaWNlKDAsIGtlZXApO1xuICAgIGV4aXRpbmcgPSBmcm9tLnNsaWNlKGtlZXApO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHJldGFpbmVkIHBhdGggKHdpdGggc2hhbGxvdyBjb3BpZXMgb2Ygbm9kZXMpIHdoaWNoIGhhdmUgdGhlIHBhcmFtcyBvZiB0aGUgdG9QYXRoIG1hcHBlZFxuICAgIGNvbnN0IHJldGFpbmVkV2l0aFRvUGFyYW1zID0gcmV0YWluZWQubWFwKGFwcGx5VG9QYXJhbXMpO1xuICAgIGVudGVyaW5nID0gdG9QYXRoLnNsaWNlKGtlZXApO1xuICAgIHRvID0gcmV0YWluZWRXaXRoVG9QYXJhbXMuY29uY2F0KGVudGVyaW5nKTtcblxuICAgIHJldHVybiB7IGZyb20sIHRvLCByZXRhaW5lZCwgcmV0YWluZWRXaXRoVG9QYXJhbXMsIGV4aXRpbmcsIGVudGVyaW5nIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBwYXRoIHdoaWNoIGlzOiB0aGUgc3VicGF0aCBvZiB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaGVzIHRoZSBzZWNvbmQgcGF0aC5cbiAgICpcbiAgICogVGhlIG5ldyBwYXRoIHN0YXJ0cyBmcm9tIHJvb3QgYW5kIGNvbnRhaW5zIGFueSBub2RlcyB0aGF0IG1hdGNoIHRoZSBub2RlcyBpbiB0aGUgc2Vjb25kIHBhdGguXG4gICAqIEl0IHN0b3BzIGJlZm9yZSB0aGUgZmlyc3Qgbm9uLW1hdGNoaW5nIG5vZGUuXG4gICAqXG4gICAqIE5vZGVzIGFyZSBjb21wYXJlZCB1c2luZyB0aGVpciBzdGF0ZSBwcm9wZXJ0eSBhbmQgdGhlaXIgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICogSWYgYSBgcGFyYW1zRm5gIGlzIHByb3ZpZGVkLCBvbmx5IHRoZSBbW1BhcmFtXV0gcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZCB3aGVuIGNvbXBhcmluZyBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHBhdGhBIHRoZSBmaXJzdCBwYXRoXG4gICAqIEBwYXJhbSBwYXRoQiB0aGUgc2Vjb25kIHBhdGhcbiAgICogQHBhcmFtIHBhcmFtc0ZuIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcGFyYW1ldGVycyB0byBjb25zaWRlciB3aGVuIGNvbXBhcmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBQYXRoTm9kZXMgZnJvbSB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoXG4gICAqL1xuICBzdGF0aWMgbWF0Y2hpbmcocGF0aEE6IFBhdGhOb2RlW10sIHBhdGhCOiBQYXRoTm9kZVtdLCBwYXJhbXNGbj86IEdldFBhcmFtc0ZuKTogUGF0aE5vZGVbXSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCB0dXBsZXM6IFBhdGhOb2RlW11bXSA9IGFycmF5VHVwbGVzKHBhdGhBLCBwYXRoQik7XG4gICAgcmV0dXJuIHR1cGxlcy5yZWR1Y2UoKG1hdGNoaW5nLCBbbm9kZUEsIG5vZGVCXSkgPT4ge1xuICAgICAgZG9uZSA9IGRvbmUgfHwgIW5vZGVBLmVxdWFscyhub2RlQiwgcGFyYW1zRm4pO1xuICAgICAgcmV0dXJuIGRvbmUgPyBtYXRjaGluZyA6IG1hdGNoaW5nLmNvbmNhdChub2RlQSk7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0d28gcGF0aHMgYXJlIGlkZW50aWNhbC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGhBXG4gICAqIEBwYXJhbSBwYXRoQlxuICAgKiBAcGFyYW0gcGFyYW1zRm4gYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnNpZGVyIHdoZW4gY29tcGFyaW5nXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHRoZSBzdGF0ZXMgYW5kIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGJvdGggcGF0aHMgYXJlIGlkZW50aWNhbFxuICAgKi9cbiAgc3RhdGljIGVxdWFscyhwYXRoQTogUGF0aE5vZGVbXSwgcGF0aEI6IFBhdGhOb2RlW10sIHBhcmFtc0ZuPzogR2V0UGFyYW1zRm4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gcGF0aEEubGVuZ3RoID09PSBwYXRoQi5sZW5ndGggJiYgUGF0aFV0aWxzLm1hdGNoaW5nKHBhdGhBLCBwYXRoQiwgcGFyYW1zRm4pLmxlbmd0aCA9PT0gcGF0aEEubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHN1YnBhdGggb2YgYSBwYXRoLCB3aGljaCBzdG9wcyBhdCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZVxuICAgKlxuICAgKiBHaXZlbiBhbiBhcnJheSBvZiBub2RlcywgcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3Qgbm9kZSxcbiAgICogc3RvcHBpbmcgd2hlbiB0aGUgZmlyc3Qgbm9kZSBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgYSBbW1ByZWRpY2F0ZV1dIGZuIHRoYXQgbWF0Y2hlcyBbW1BhdGhOb2RlXV1zXG4gICAqIEByZXR1cm5zIGEgc3VicGF0aCB1cCB0byB0aGUgbWF0Y2hpbmcgbm9kZSwgb3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgc3ViUGF0aChwYXRoOiBQYXRoTm9kZVtdLCBwcmVkaWNhdGU6IFByZWRpY2F0ZTxQYXRoTm9kZT4pOiBQYXRoTm9kZVtdIHtcbiAgICBjb25zdCBub2RlID0gZmluZChwYXRoLCBwcmVkaWNhdGUpO1xuICAgIGNvbnN0IGVsZW1lbnRJZHggPSBwYXRoLmluZGV4T2Yobm9kZSk7XG4gICAgcmV0dXJuIGVsZW1lbnRJZHggPT09IC0xID8gdW5kZWZpbmVkIDogcGF0aC5zbGljZSgwLCBlbGVtZW50SWR4ICsgMSk7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgcmF3IHBhcmFtZXRlciB2YWx1ZXMgZnJvbSBhIHBhdGggKi9cbiAgc3RhdGljIHBhcmFtVmFsdWVzID0gKHBhdGg6IFBhdGhOb2RlW10pID0+IHBhdGgucmVkdWNlKChhY2MsIG5vZGUpID0+IGV4dGVuZChhY2MsIG5vZGUucGFyYW1WYWx1ZXMpLCB7fSk7XG59XG4iLCIvKipcbiAqICMgVGhlIFJlc29sdmUgc3Vic3lzdGVtXG4gKlxuICogVGhpcyBzdWJzeXN0ZW0gaXMgYW4gYXN5bmNocm9ub3VzLCBoaWVyYXJjaGljYWwgRGVwZW5kZW5jeSBJbmplY3Rpb24gc3lzdGVtLlxuICpcbiAqIFR5cGljYWxseSwgcmVzb2x2ZSBpcyBjb25maWd1cmVkIG9uIGEgc3RhdGUgdXNpbmcgYSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dIGRlY2xhcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNhcGkgQG1vZHVsZSByZXNvbHZlXG4gKi8gLyoqICovXG5pbXBvcnQgeyBSZXNvbHZhYmxlIH0gZnJvbSAnLi9yZXNvbHZhYmxlJztcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2Ugd2hpY2ggaXMgc2ltaWxhciB0byBhbiBBbmd1bGFyIDIgYFByb3ZpZGVyYFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb3ZpZGVyTGlrZSB7XG4gIHByb3ZpZGU6IGFueTtcbiAgdXNlQ2xhc3M/OiBhbnk7XG4gIHVzZUZhY3Rvcnk/OiBGdW5jdGlvbjtcbiAgdXNlVmFsdWU/OiBhbnk7XG4gIHVzZUV4aXN0aW5nPzogYW55O1xuICBkZXBzPzogYW55W107XG59XG5cbi8qKlxuICogQSBwbGFpbiBvYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIFtbUmVzb2x2YWJsZV1dXG4gKlxuICogVGhlc2Ugb2JqZWN0cyBtYXkgYmUgdXNlZCBpbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBhcnJheSB0byBkZWNsYXJlXG4gKiBhc3luYyBkYXRhIHRoYXQgdGhlIHN0YXRlIG9yIHN1YnN0YXRlcyByZXF1aXJlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKlxuICogdmFyIHN0YXRlID0ge1xuICogICBuYW1lOiAnbWFpbicsXG4gKiAgIHJlc29sdmU6IFtcbiAqICAgICB7IHRva2VuOiAnbXlEYXRhJywgZGVwczogW015RGF0YUFwaV0sIHJlc29sdmVGbjogKG15RGF0YUFwaSkgPT4gbXlEYXRhQXBpLmdldERhdGEoKSB9LFxuICogICBdLFxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2YWJsZUxpdGVyYWwge1xuICAvKipcbiAgICogQSBEZXBlbmRlbmN5IEluamVjdGlvbiB0b2tlblxuICAgKlxuICAgKiBUaGlzIFJlc29sdmFibGUncyBESSB0b2tlbi5cbiAgICogVGhlIFJlc29sdmFibGUgd2lsbCBiZSBpbmplY3RhYmxlIGVsc2V3aGVyZSB1c2luZyB0aGUgdG9rZW4uXG4gICAqL1xuICB0b2tlbjogYW55O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGZldGNoZXMgdGhlIFJlc29sdmFibGUncyBkYXRhXG4gICAqXG4gICAqIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBvbmUgb2Y6XG4gICAqXG4gICAqIC0gVGhlIHJlc29sdmVkIHZhbHVlIChzeW5jaHJvbm91c2x5KVxuICAgKiAtIEEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdmVkIHZhbHVlXG4gICAqIC0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgcmVzb2x2ZWQgdmFsdWUocylcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHByb3ZpZGVkIHRoZSBkZXBlbmRlbmNpZXMgbGlzdGVkIGluIFtbZGVwc11dIGFzIGl0cyBhcmd1bWVudHMuXG4gICAqIFRoZSByZXNvbHZlIHN5c3RlbSB3aWxsIGFzeW5jaHJvbm91c2x5IGZldGNoIHRoZSBkZXBlbmRlbmNpZXMgYmVmb3JlIGludm9raW5nIHRoaXMgZnVuY3Rpb24uXG4gICAqL1xuICByZXNvbHZlRm46IEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBSZXNvbHZlIFBvbGljeVxuICAgKlxuICAgKiBBIHBvbGljeSB0aGF0IGRlZmluZXMgd2hlbiB0byBpbnZva2UgdGhlIHJlc29sdmUsXG4gICAqIGFuZCB3aGV0aGVyIHRvIHdhaXQgZm9yIGFzeW5jIGFuZCB1bndyYXAgdGhlIGRhdGFcbiAgICovXG4gIHBvbGljeT86IFJlc29sdmVQb2xpY3k7XG5cbiAgLyoqXG4gICAqIFRoZSBEZXBlbmRlbmN5IEluamVjdGlvbiB0b2tlbnNcbiAgICpcbiAgICogVGhpcyBpcyBhbiBhcnJheSBvZiBEZXBlbmRlbmN5IEluamVjdGlvbiB0b2tlbnMgZm9yIHRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIFtbcmVzb2x2ZUZuXV0uXG4gICAqXG4gICAqIFRoZSBESSB0b2tlbnMgYXJlIHJlZmVyZW5jZXMgdG8gb3RoZXIgYFJlc29sdmFibGVzYCwgb3IgdG8gb3RoZXJcbiAgICogc2VydmljZXMgZnJvbSB0aGUgbmF0aXZlIERJIHN5c3RlbS5cbiAgICovXG4gIGRlcHM/OiBhbnlbXTtcblxuICAvKiogUHJlLXJlc29sdmVkIGRhdGEuICovXG4gIGRhdGE/OiBhbnk7XG59XG5cbi8qKlxuICogRGVmaW5lcyBob3cgYSByZXNvbHZlIGlzIHByb2Nlc3NlZCBkdXJpbmcgYSB0cmFuc2l0aW9uXG4gKlxuICogVGhpcyBvYmplY3QgaXMgdGhlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlUG9saWN5XV0gcHJvcGVydHkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIEZldGNoZWQgd2hlbiB0aGUgcmVzb2x2ZSdzIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gKiAvLyBXYWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlLlxuICogdmFyIHBvbGljeTEgPSB7IHdoZW46IFwiTEFaWVwiLCBhc3luYzogXCJXQUlUXCIgfVxuICpcbiAqIC8vIEZldGNoZWQgd2hlbiB0aGUgVHJhbnNpdGlvbiBpcyBzdGFydGluZy5cbiAqIC8vIERvIG5vdCB3YWl0IGZvciB0aGUgcmV0dXJuZWQgcHJvbWlzZSB0byByZXNvbHZlLlxuICogLy8gSW5qZWN0IHRoZSByYXcgcHJvbWlzZS92YWx1ZVxuICogdmFyIHBvbGljeTIgPSB7IHdoZW46IFwiRUFHRVJcIiwgYXN5bmM6IFwiTk9XQUlUXCIgfVxuICogYGBgXG4gKlxuICogVGhlIHBvbGljeSBmb3IgYSBnaXZlbiBSZXNvbHZhYmxlIGlzIG1lcmdlZCBmcm9tIHRocmVlIHNvdXJjZXMgKGhpZ2hlc3QgcHJpb3JpdHkgZmlyc3QpOlxuICpcbiAqIC0gMSkgSW5kaXZpZHVhbCByZXNvbHZlIGRlZmluaXRpb25cbiAqIC0gMikgU3RhdGUgZGVmaW5pdGlvblxuICogLSAzKSBHbG9iYWwgZGVmYXVsdFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBXYWl0IGZvciBhbiBPYnNlcnZhYmxlIHRvIGVtaXQgb25lIGl0ZW0uXG4gKiAvLyBTaW5jZSBgd2FpdGAgaXMgbm90IHNwZWNpZmllZCwgaXQgdXNlcyB0aGUgYHdhaXRgXG4gKiAvLyBwb2xpY3kgZGVmaW5lZCBvbiB0aGUgc3RhdGUsIG9yIHRoZSBnbG9iYWwgZGVmYXVsdFxuICogLy8gaWYgbm8gYHdhaXRgIHBvbGljeSBpcyBkZWZpbmVkIG9uIHRoZSBzdGF0ZVxuICogaW1wb3J0IHsgUlhXQUlUIH0gZnJvbSAnQHVpcm91dGVyL3J4JztcbiAqXG4gKiB2YXIgbXlSZXNvbHZhYmxlUG9saWN5ID0geyBhc3luYzogUlhXQUlUIH1cbiAqIGBgYFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc29sdmVQb2xpY3kge1xuICAvKipcbiAgICogRGVmaW5lcyB3aGVuIGEgUmVzb2x2YWJsZSBpcyByZXNvbHZlZCAoZmV0Y2hlZCkgZHVyaW5nIGEgdHJhbnNpdGlvblxuICAgKlxuICAgKiAtIGBMQVpZYCAoZGVmYXVsdClcbiAgICogICAtIFJlc29sdmVkIGFzIHRoZSByZXNvbHZlJ3Mgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZFxuICAgKiAtIGBFQUdFUmBcbiAgICogICAtIFJlc29sdmVkIGFzIHRoZSB0cmFuc2l0aW9uIGlzIHN0YXJ0aW5nXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogUmVzb2x2ZXMgZm9yIGBtYWluYCBhbmQgYG1haW4uaG9tZWAgYXJlIGZldGNoZWQgd2hlbiBlYWNoIHN0YXRlIGlzIGVudGVyZWQuXG4gICAqIEFsbCBvZiBgbWFpbmAgcmVzb2x2ZXMgYXJlIHByb2Nlc3NlZCBiZWZvcmUgZmV0Y2hpbmcgYG1haW4uaG9tZWAgcmVzb2x2ZXMuXG4gICAqIGBgYGpzXG4gICAqIHZhciBzdGF0ZSA9IHtcbiAgICogICBuYW1lOiAnbWFpbicsXG4gICAqICAgcmVzb2x2ZTogbWFpblJlc29sdmVzLCAvLyBkZWZpbmVkIGVsc2V3aGVyZVxuICAgKiAgIHJlc29sdmVQb2xpY3k6IHsgd2hlbjogJ0xBWlknIH0sIC8vIGRlZmF1bHRcbiAgICogfVxuICAgKlxuICAgKiB2YXIgc3RhdGUgPSB7XG4gICAqICAgbmFtZTogJ21haW4uaG9tZScsXG4gICAqICAgcmVzb2x2ZTogaG9tZVJlc29sdmVzLCAvLyBkZWZpbmVkIGVsc2V3aGVyZVxuICAgKiAgIHJlc29sdmVQb2xpY3k6IHsgd2hlbjogJ0xBWlknIH0sIC8vIGRlZmF1bHRcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBSZXNvbHZlcyBmb3IgYG1haW5gIGFuZCBgbWFpbi5ob21lYCBhcmUgZmV0Y2hlZCBhdCB0aGUgc2FtZSB0aW1lIHdoZW4gdGhlIHRyYW5zaXRpb24gc3RhcnRzLlxuICAgKiBUaGlzIGhhcHBlbnMgZWFybGllciBpbiB0aGUgbGlmZWN5Y2xlIHRoYW4gd2hlbiBzdGF0ZXMgYXJlIGVudGVyZWQuXG4gICAqIEFsbCBvZiB0aGUgYG1haW5gIGFuZCBgbWFpbi5ob21lYCByZXNvbHZlcyBhcmUgZmV0Y2hlZCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFpblN0YXRlID0ge1xuICAgKiAgIG5hbWU6ICdtYWluJyxcbiAgICogICByZXNvbHZlOiBtYWluUmVzb2x2ZXMsIC8vIGRlZmluZWQgZWxzZXdoZXJlXG4gICAqICAgcmVzb2x2ZVBvbGljeTogeyB3aGVuOiAnRUFHRVInIH0sXG4gICAqIH1cbiAgICpcbiAgICogdmFyIGhvbWVTdGF0ZSA9IHtcbiAgICogICBuYW1lOiAnbWFpbi5ob21lJyxcbiAgICogICByZXNvbHZlOiBob21lUmVzb2x2ZXMsIC8vIGRlZmluZWQgZWxzZXdoZXJlXG4gICAqICAgcmVzb2x2ZVBvbGljeTogeyB3aGVuOiAnRUFHRVInIH0sXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICB3aGVuPzogUG9saWN5V2hlbjtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdW53cmFwcGluZyBiZWhhdmlvciBvZiBhc3luY2hyb25vdXMgcmVzb2x2ZSB2YWx1ZXMuXG4gICAqXG4gICAqIC0gYFdBSVRgIChkZWZhdWx0KVxuICAgKiAgIC0gSWYgYSBwcm9taXNlIGlzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVGbiwgd2FpdCBmb3IgdGhlIHByb21pc2UgYmVmb3JlIHByb2NlZWRpbmdcbiAgICogICAtIFRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSB0aGUgcHJvbWlzZVxuICAgKiAtIGBOT1dBSVRgXG4gICAqICAgLSBJZiBhIHByb21pc2UgaXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZSwgZG8gbm90IHdhaXQgZm9yIHRoZSBwcm9taXNlLlxuICAgKiAgIC0gQW55IG90aGVyIHZhbHVlIHJldHVybmVkIGlzIHdyYXBwZWQgaW4gYSBwcm9taXNlLlxuICAgKiAgIC0gVGhlIHByb21pc2Ugd2lsbCBub3QgYmUgdW53cmFwcGVkLlxuICAgKiAgIC0gVGhlIHByb21pc2UgaXRzZWxmIHdpbGwgYmUgcHJvdmlkZWQgd2hlbiB0aGUgcmVzb2x2ZSBpcyBpbmplY3RlZCBvciBib3VuZCBlbHNld2hlcmUuXG4gICAqIC0ge0BsaW5rIEN1c3RvbUFzeW5jUG9saWN5fVxuICAgKiAgIC0gWW91IGNhbiBkZWZpbmUgYSBjdXN0b20gZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSByZXNvbHZlRm4gdmFsdWUuXG4gICAqICAgLSBUaGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgcHJvbWlzZS5cbiAgICogICAtIFRoZSB0cmFuc2l0aW9uIHdpbGwgd2FpdCBmb3IgdGhpcyBwcm9taXNlIGJlZm9yZSBwcm9jZWVkaW5nXG4gICAqXG4gICAqICAgTk9URTogVGhlIHByZXZpb3VzIGBSWFdBSVRgIHBvbGljeSBoYXMgYmVjb21lIGEgQ3VzdG9tQXN5bmNQb2xpY3kgZnVuY3Rpb24gZXhwb3J0ZWQgaW4gYEB1aXJvdXRlci9yeGAgcGFja2FnZS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBUaGUgYFRyYW5zaXRpb25gIHdpbGwgbm90IHdhaXQgZm9yIHRoZSByZXNvbHZlIHByb21pc2UocykgZnJvbSBgbWFpbmAgdG8gc2V0dGxlIGJlZm9yZSBjb250aW51aW5nLlxuICAgKiBSZXNvbHZlcyBmb3IgYG1haW5gIHdpbGwgYmUgcHJvdmlkZWQgdG8gY29tcG9uZW50cyB3cmFwcGVkIGluIGEgYFByb21pc2VgLlxuICAgKlxuICAgKiBUaGUgYFRyYW5zaXRpb25gIHdpbGwgd2FpdCBmb3IgdGhlIGBtYWluLmhvbWVgIHJlc29sdmUgcHJvbWlzZXMuXG4gICAqIFJlc29sdmVkIHZhbHVlcyB3aWxsIGJlIHVud3JhcHBlZCBiZWZvcmUgYmVpbmcgcHJvdmlkZWQgdG8gY29tcG9uZW50cy5cbiAgICogYGBganNcbiAgICogdmFyIG1haW5TdGF0ZSA9IHtcbiAgICogICBuYW1lOiAnbWFpbicsXG4gICAqICAgcmVzb2x2ZTogbWFpblJlc29sdmVzLCAvLyBkZWZpbmVkIGVsc2V3aGVyZVxuICAgKiAgIHJlc29sdmVQb2xpY3k6IHsgYXN5bmM6ICdOT1dBSVQnIH0sXG4gICAqIH1cbiAgICogdmFyIGhvbWVTdGF0ZSA9IHtcbiAgICogICBuYW1lOiAnbWFpbi5ob21lJyxcbiAgICogICByZXNvbHZlOiBob21lUmVzb2x2ZXMsIC8vIGRlZmluZWQgZWxzZXdoZXJlXG4gICAqICAgcmVzb2x2ZVBvbGljeTogeyBhc3luYzogJ1dBSVQnIH0sIC8vIGRlZmF1bHRcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jPzogUG9saWN5QXN5bmM7XG59XG5cbmV4cG9ydCB0eXBlIFBvbGljeVdoZW4gPSAnTEFaWScgfCAnRUFHRVInO1xuZXhwb3J0IHR5cGUgUG9saWN5QXN5bmMgPSAnV0FJVCcgfCAnTk9XQUlUJyB8IEN1c3RvbUFzeW5jUG9saWN5O1xuZXhwb3J0IGludGVyZmFjZSBDdXN0b21Bc3luY1BvbGljeSB7XG4gIChkYXRhOiBhbnkpOiBQcm9taXNlPGFueT47XG59XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBsZXQgcmVzb2x2ZVBvbGljaWVzID0ge1xuICB3aGVuOiB7XG4gICAgTEFaWTogJ0xBWlknLFxuICAgIEVBR0VSOiAnRUFHRVInLFxuICB9LFxuICBhc3luYzoge1xuICAgIFdBSVQ6ICdXQUlUJyxcbiAgICBOT1dBSVQ6ICdOT1dBSVQnLFxuICB9LFxufTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgcmVzb2x2ZSAqLyAvKiogKi9cbmltcG9ydCB7IGV4dGVuZCwgaWRlbnRpdHkgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gJy4uL2NvbW1vbi90cmFjZSc7XG5pbXBvcnQgeyBSZXNvbHZlUG9saWN5LCBSZXNvbHZhYmxlTGl0ZXJhbCwgUG9saWN5QXN5bmMgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbmltcG9ydCB7IFJlc29sdmVDb250ZXh0IH0gZnJvbSAnLi9yZXNvbHZlQ29udGV4dCc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9jb21tb24vc3RyaW5ncyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBQYXRoTm9kZSB9IGZyb20gJy4uL3BhdGgvcGF0aE5vZGUnO1xuaW1wb3J0IHsgaXNOdWxsT3JVbmRlZmluZWQgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5cbi8vIFRPRE86IGV4cGxpY2l0bHkgbWFrZSB0aGlzIHVzZXIgY29uZmlndXJhYmxlXG5leHBvcnQgbGV0IGRlZmF1bHRSZXNvbHZlUG9saWN5OiBSZXNvbHZlUG9saWN5ID0ge1xuICB3aGVuOiAnTEFaWScsXG4gIGFzeW5jOiAnV0FJVCcsXG59O1xuXG4vKipcbiAqIFRoZSBiYXNpYyBidWlsZGluZyBibG9jayBmb3IgdGhlIHJlc29sdmUgc3lzdGVtLlxuICpcbiAqIFJlc29sdmFibGVzIGVuY2Fwc3VsYXRlIGEgc3RhdGUncyByZXNvbHZlJ3MgcmVzb2x2ZUZuLCB0aGUgcmVzb2x2ZUZuJ3MgZGVjbGFyZWQgZGVwZW5kZW5jaWVzLCB0aGUgd3JhcHBlZCAoLnByb21pc2UpLFxuICogYW5kIHRoZSB1bndyYXBwZWQtd2hlbi1jb21wbGV0ZSAoLmRhdGEpIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZUZuLlxuICpcbiAqIFJlc29sdmFibGUuZ2V0KCkgZWl0aGVyIHJldHJpZXZlcyB0aGUgUmVzb2x2YWJsZSdzIGV4aXN0aW5nIHByb21pc2UsIG9yIGVsc2UgaW52b2tlcyByZXNvbHZlKCkgKHdoaWNoIGludm9rZXMgdGhlXG4gKiByZXNvbHZlRm4pIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgcHJvbWlzZS5cbiAqXG4gKiBSZXNvbHZhYmxlLmdldCgpIGFuZCBSZXNvbHZhYmxlLnJlc29sdmUoKSBib3RoIGV4ZWN1dGUgd2l0aGluIGEgY29udGV4dCBwYXRoLCB3aGljaCBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0XG4gKiBwYXJhbWV0ZXIgdG8gdGhvc2UgZm5zLlxuICovXG5leHBvcnQgY2xhc3MgUmVzb2x2YWJsZSBpbXBsZW1lbnRzIFJlc29sdmFibGVMaXRlcmFsIHtcbiAgdG9rZW46IGFueTtcbiAgcG9saWN5OiBSZXNvbHZlUG9saWN5O1xuICByZXNvbHZlRm46IEZ1bmN0aW9uO1xuICBkZXBzOiBhbnlbXTtcblxuICBkYXRhOiBhbnk7XG4gIHJlc29sdmVkID0gZmFsc2U7XG4gIHByb21pc2U6IFByb21pc2U8YW55PiA9IHVuZGVmaW5lZDtcblxuICBzdGF0aWMgZnJvbURhdGEgPSAodG9rZW46IGFueSwgZGF0YTogYW55KSA9PiBuZXcgUmVzb2x2YWJsZSh0b2tlbiwgKCkgPT4gZGF0YSwgbnVsbCwgbnVsbCwgZGF0YSk7XG5cbiAgLyoqIFRoaXMgY29uc3RydWN0b3IgY3JlYXRlcyBhIFJlc29sdmFibGUgY29weSAqL1xuICBjb25zdHJ1Y3RvcihyZXNvbHZhYmxlOiBSZXNvbHZhYmxlKTtcblxuICAvKiogVGhpcyBjb25zdHJ1Y3RvciBjcmVhdGVzIGEgbmV3IFJlc29sdmFibGUgZnJvbSB0aGUgcGxhaW4gb2xkIFtbUmVzb2x2YWJsZUxpdGVyYWxdXSBqYXZhc2NyaXB0IG9iamVjdCAqL1xuICBjb25zdHJ1Y3RvcihyZXNvbHZhYmxlOiBSZXNvbHZhYmxlTGl0ZXJhbCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgY29uc3RydWN0b3IgY3JlYXRlcyBhIG5ldyBgUmVzb2x2YWJsZWBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgcmVzb2x2YWJsZTEgPSBuZXcgUmVzb2x2YWJsZSgnbXl0b2tlbicsIGh0dHAgPT4gaHR0cC5nZXQoJ2Zvby5qc29uJykudG9Qcm9taXNlKCksIFtIdHRwXSk7XG4gICAqXG4gICAqIHZhciByZXNvbHZhYmxlMiA9IG5ldyBSZXNvbHZhYmxlKFVzZXJTZXJ2aWNlLCBkZXAgPT4gbmV3IFVzZXJTZXJ2aWNlKGRlcC5kYXRhKSwgW1NvbWVEZXBlbmRlbmN5XSk7XG4gICAqXG4gICAqIHZhciByZXNvbHZhYmxlMUNsb25lID0gbmV3IFJlc29sdmFibGUocmVzb2x2YWJsZTEpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRva2VuIFRoZSBuZXcgcmVzb2x2YWJsZSdzIGluamVjdGlvbiB0b2tlbiwgc3VjaCBhcyBgXCJ1c2VyTGlzdFwiYCAoYSBzdHJpbmcpIG9yIGBVc2VyU2VydmljZWAgKGEgY2xhc3MpLlxuICAgKiAgICAgICAgICAgICAgV2hlbiB0aGlzIHRva2VuIGlzIHVzZWQgZHVyaW5nIGluamVjdGlvbiwgdGhlIHJlc29sdmVkIHZhbHVlIHdpbGwgYmUgaW5qZWN0ZWQuXG4gICAqIEBwYXJhbSByZXNvbHZlRm4gVGhlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUsIG9yIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdmVkIHZhbHVlXG4gICAqIEBwYXJhbSBkZXBzIEFuIGFycmF5IG9mIGRlcGVuZGVuY2llcywgd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBpbnRvIHRoZSBgcmVzb2x2ZUZuYFxuICAgKiBAcGFyYW0gcG9saWN5IHRoZSBbW1Jlc29sdmVQb2xpY3ldXSBkZWZpbmVzIHdoZW4gYW5kIGhvdyB0aGUgUmVzb2x2YWJsZSBpcyBwcm9jZXNzZWRcbiAgICogQHBhcmFtIGRhdGEgUHJlLXJlc29sdmVkIGRhdGEuIElmIHRoZSByZXNvbHZlIHZhbHVlIGlzIGFscmVhZHkga25vd24sIGl0IG1heSBiZSBwcm92aWRlZCBoZXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodG9rZW46IGFueSwgcmVzb2x2ZUZuOiBGdW5jdGlvbiwgZGVwcz86IGFueVtdLCBwb2xpY3k/OiBSZXNvbHZlUG9saWN5LCBkYXRhPzogYW55KTtcbiAgY29uc3RydWN0b3IoYXJnMTogYW55LCByZXNvbHZlRm4/OiBGdW5jdGlvbiwgZGVwcz86IGFueVtdLCBwb2xpY3k/OiBSZXNvbHZlUG9saWN5LCBkYXRhPzogYW55KSB7XG4gICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBSZXNvbHZhYmxlKSB7XG4gICAgICBleHRlbmQodGhpcywgYXJnMSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJlc29sdmVGbikpIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChhcmcxKSkgdGhyb3cgbmV3IEVycm9yKCduZXcgUmVzb2x2YWJsZSgpOiB0b2tlbiBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJlc29sdmVGbikpIHRocm93IG5ldyBFcnJvcignbmV3IFJlc29sdmFibGUoKTogcmVzb2x2ZUZuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICB0aGlzLnRva2VuID0gYXJnMTtcbiAgICAgIHRoaXMucG9saWN5ID0gcG9saWN5O1xuICAgICAgdGhpcy5yZXNvbHZlRm4gPSByZXNvbHZlRm47XG4gICAgICB0aGlzLmRlcHMgPSBkZXBzIHx8IFtdO1xuXG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5yZXNvbHZlZCA9IGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucmVzb2x2ZWQgPyBzZXJ2aWNlcy4kcS53aGVuKHRoaXMuZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChhcmcxKSAmJiBhcmcxLnRva2VuICYmIChhcmcxLmhhc093blByb3BlcnR5KCdyZXNvbHZlRm4nKSB8fCBhcmcxLmhhc093blByb3BlcnR5KCdkYXRhJykpKSB7XG4gICAgICBjb25zdCBsaXRlcmFsID0gPFJlc29sdmFibGVMaXRlcmFsPmFyZzE7XG4gICAgICByZXR1cm4gbmV3IFJlc29sdmFibGUobGl0ZXJhbC50b2tlbiwgbGl0ZXJhbC5yZXNvbHZlRm4sIGxpdGVyYWwuZGVwcywgbGl0ZXJhbC5wb2xpY3ksIGxpdGVyYWwuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9saWN5KHN0YXRlOiBTdGF0ZU9iamVjdCk6IFJlc29sdmVQb2xpY3kge1xuICAgIGNvbnN0IHRoaXNQb2xpY3kgPSB0aGlzLnBvbGljeSB8fCB7fTtcbiAgICBjb25zdCBzdGF0ZVBvbGljeSA9IChzdGF0ZSAmJiBzdGF0ZS5yZXNvbHZlUG9saWN5KSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgd2hlbjogdGhpc1BvbGljeS53aGVuIHx8IHN0YXRlUG9saWN5LndoZW4gfHwgZGVmYXVsdFJlc29sdmVQb2xpY3kud2hlbixcbiAgICAgIGFzeW5jOiB0aGlzUG9saWN5LmFzeW5jIHx8IHN0YXRlUG9saWN5LmFzeW5jIHx8IGRlZmF1bHRSZXNvbHZlUG9saWN5LmFzeW5jLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgcmVzb2x2ZSB0aGlzIFJlc29sdmFibGUncyBkYXRhXG4gICAqXG4gICAqIEdpdmVuIGEgUmVzb2x2ZUNvbnRleHQgdGhhdCB0aGlzIFJlc29sdmFibGUgaXMgZm91bmQgaW46XG4gICAqIFdhaXQgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRlcGVuZGVuY2llcywgdGhlbiBpbnZva2UgdGhpcyBSZXNvbHZhYmxlJ3MgZnVuY3Rpb25cbiAgICogYW5kIHVwZGF0ZSB0aGUgUmVzb2x2YWJsZSdzIHN0YXRlXG4gICAqL1xuICByZXNvbHZlKHJlc29sdmVDb250ZXh0OiBSZXNvbHZlQ29udGV4dCwgdHJhbnM/OiBUcmFuc2l0aW9uKSB7XG4gICAgY29uc3QgJHEgPSBzZXJ2aWNlcy4kcTtcblxuICAgIC8vIEdldHMgYWxsIGRlcGVuZGVuY2llcyBmcm9tIFJlc29sdmVDb250ZXh0IGFuZCB3YWl0IGZvciB0aGVtIHRvIGJlIHJlc29sdmVkXG4gICAgY29uc3QgZ2V0UmVzb2x2YWJsZURlcGVuZGVuY2llcyA9ICgpID0+XG4gICAgICAkcS5hbGwocmVzb2x2ZUNvbnRleHQuZ2V0RGVwZW5kZW5jaWVzKHRoaXMpLm1hcChyZXNvbHZhYmxlID0+IHJlc29sdmFibGUuZ2V0KHJlc29sdmVDb250ZXh0LCB0cmFucykpKSBhcyBQcm9taXNlPFxuICAgICAgICBhbnlbXVxuICAgICAgPjtcblxuICAgIC8vIEludm9rZXMgdGhlIHJlc29sdmUgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIGFzIGFyZ3VtZW50c1xuICAgIGNvbnN0IGludm9rZVJlc29sdmVGbiA9IChyZXNvbHZlZERlcHM6IGFueVtdKSA9PiB0aGlzLnJlc29sdmVGbi5hcHBseShudWxsLCByZXNvbHZlZERlcHMpO1xuICAgIGNvbnN0IG5vZGU6IFBhdGhOb2RlID0gcmVzb2x2ZUNvbnRleHQuZmluZE5vZGUodGhpcyk7XG4gICAgY29uc3Qgc3RhdGU6IFN0YXRlT2JqZWN0ID0gbm9kZSAmJiBub2RlLnN0YXRlO1xuXG4gICAgY29uc3QgYXN5bmNQb2xpY3k6IFBvbGljeUFzeW5jID0gdGhpcy5nZXRQb2xpY3koc3RhdGUpLmFzeW5jO1xuICAgIGNvbnN0IGN1c3RvbUFzeW5jUG9saWN5ID0gaXNGdW5jdGlvbihhc3luY1BvbGljeSkgPyBhc3luY1BvbGljeSA6IGlkZW50aXR5O1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGZpbmFsIHZhbHVlIGhhcyBiZWVuIHJlc29sdmVkLCB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBSZXNvbHZhYmxlXG4gICAgY29uc3QgYXBwbHlSZXNvbHZlZFZhbHVlID0gKHJlc29sdmVkVmFsdWU6IGFueSkgPT4ge1xuICAgICAgdGhpcy5kYXRhID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNvbHZlRm4gPSBudWxsO1xuICAgICAgdHJhY2UudHJhY2VSZXNvbHZhYmxlUmVzb2x2ZWQodGhpcywgdHJhbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9O1xuXG4gICAgLy8gU2V0cyB0aGUgcHJvbWlzZSBwcm9wZXJ0eSBmaXJzdCwgdGhlbiBnZXRzUmVzb2x2YWJsZURlcGVuZGVuY2llcyBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvbWlzZSBjaGFpbi4gQWx3YXlzIHdhaXRzIG9uZSB0aWNrLlxuICAgIHJldHVybiAodGhpcy5wcm9taXNlID0gJHFcbiAgICAgIC53aGVuKClcbiAgICAgIC50aGVuKGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMpXG4gICAgICAudGhlbihpbnZva2VSZXNvbHZlRm4pXG4gICAgICAudGhlbihjdXN0b21Bc3luY1BvbGljeSlcbiAgICAgIC50aGVuKGFwcGx5UmVzb2x2ZWRWYWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBwcm9taXNlIGZvciB0aGlzIFJlc29sdmFibGUncyBkYXRhLlxuICAgKlxuICAgKiBGZXRjaGVzIHRoZSBkYXRhIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICogUmV0dXJucyB0aGUgZXhpc3RpbmcgcHJvbWlzZSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGZldGNoZWQgb25jZS5cbiAgICovXG4gIGdldChyZXNvbHZlQ29udGV4dDogUmVzb2x2ZUNvbnRleHQsIHRyYW5zPzogVHJhbnNpdGlvbik6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZSB8fCB0aGlzLnJlc29sdmUocmVzb2x2ZUNvbnRleHQsIHRyYW5zKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgUmVzb2x2YWJsZSh0b2tlbjogJHtzdHJpbmdpZnkodGhpcy50b2tlbil9LCByZXF1aXJlczogWyR7dGhpcy5kZXBzLm1hcChzdHJpbmdpZnkpfV0pYDtcbiAgfVxuXG4gIGNsb25lKCk6IFJlc29sdmFibGUge1xuICAgIHJldHVybiBuZXcgUmVzb2x2YWJsZSh0aGlzKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSByZXNvbHZlICovIC8qKiAqL1xuaW1wb3J0IHsgZmluZCwgdGFpbCwgdW5pcVIsIHVubmVzdFIsIGluQXJyYXkgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHByb3BFcSwgbm90IH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gJy4uL2NvbW1vbi90cmFjZSc7XG5pbXBvcnQgeyBzZXJ2aWNlcywgJEluamVjdG9yTGlrZSB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgcmVzb2x2ZVBvbGljaWVzLCBQb2xpY3lXaGVuLCBSZXNvbHZlUG9saWN5IH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuL3Jlc29sdmFibGUnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBQYXRoVXRpbHMgfSBmcm9tICcuLi9wYXRoL3BhdGhVdGlscyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9jb21tb24vc3RyaW5ncyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFVJSW5qZWN0b3IgfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuLi9jb21tb24nO1xuXG5jb25zdCB3aGVucyA9IHJlc29sdmVQb2xpY2llcy53aGVuO1xuY29uc3QgQUxMX1dIRU5TID0gW3doZW5zLkVBR0VSLCB3aGVucy5MQVpZXTtcbmNvbnN0IEVBR0VSX1dIRU5TID0gW3doZW5zLkVBR0VSXTtcblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWluZmVycmFibGUtdHlwZXNcbmV4cG9ydCBjb25zdCBOQVRJVkVfSU5KRUNUT1JfVE9LRU46IHN0cmluZyA9ICdOYXRpdmUgSW5qZWN0b3InO1xuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBEZXBlbmRlbmN5IEluamVjdGlvbiBmb3IgYSBwYXRoIG9mIG5vZGVzXG4gKlxuICogVUktUm91dGVyIHN0YXRlcyBhcmUgb3JnYW5pemVkIGFzIGEgdHJlZS5cbiAqIEEgbmVzdGVkIHN0YXRlIGhhcyBhIHBhdGggb2YgYW5jZXN0b3JzIHRvIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICogV2hlbiBhIHN0YXRlIGlzIGJlaW5nIGFjdGl2YXRlZCwgZWFjaCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHdyYXBwZWQgYXMgYSBbW1BhdGhOb2RlXV0uXG4gKiBBIGBQYXRoTm9kZWAgaXMgYSBzdGF0ZWZ1bCBvYmplY3QgdGhhdCBob2xkcyB0aGluZ3MgbGlrZSBwYXJhbWV0ZXJzIGFuZCByZXNvbHZhYmxlcyBmb3IgdGhlIHN0YXRlIGJlaW5nIGFjdGl2YXRlZC5cbiAqXG4gKiBUaGUgUmVzb2x2ZUNvbnRleHQgY2xvc2VzIG92ZXIgdGhlIFtbUGF0aE5vZGVdXXMsIGFuZCBwcm92aWRlcyBESSBmb3IgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgcGF0aC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc29sdmVDb250ZXh0IHtcbiAgX2luamVjdG9yOiBVSUluamVjdG9yO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhdGg6IFBhdGhOb2RlW10pIHt9XG5cbiAgLyoqIEdldHMgYWxsIHRoZSB0b2tlbnMgZm91bmQgaW4gdGhlIHJlc29sdmUgY29udGV4dCwgZGUtZHVwbGljYXRlZCAqL1xuICBnZXRUb2tlbnMoKTogYW55W10ge1xuICAgIHJldHVybiB0aGlzLl9wYXRoLnJlZHVjZSgoYWNjLCBub2RlKSA9PiBhY2MuY29uY2F0KG5vZGUucmVzb2x2YWJsZXMubWFwKHIgPT4gci50b2tlbikpLCBbXSkucmVkdWNlKHVuaXFSLCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgUmVzb2x2YWJsZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuXG4gICAqXG4gICAqIEdldHMgdGhlIGxhc3QgUmVzb2x2YWJsZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuIGluIHRoaXMgY29udGV4dCwgb3IgdW5kZWZpbmVkLlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgUmVzb2x2ZUNvbnRleHRcbiAgICovXG4gIGdldFJlc29sdmFibGUodG9rZW46IGFueSk6IFJlc29sdmFibGUge1xuICAgIGNvbnN0IG1hdGNoaW5nID0gdGhpcy5fcGF0aFxuICAgICAgLm1hcChub2RlID0+IG5vZGUucmVzb2x2YWJsZXMpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgLmZpbHRlcigocjogUmVzb2x2YWJsZSkgPT4gci50b2tlbiA9PT0gdG9rZW4pO1xuICAgIHJldHVybiB0YWlsKG1hdGNoaW5nKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBbW1Jlc29sdmVQb2xpY3ldXSBmb3IgdGhlIGdpdmVuIFtbUmVzb2x2YWJsZV1dICovXG4gIGdldFBvbGljeShyZXNvbHZhYmxlOiBSZXNvbHZhYmxlKTogUmVzb2x2ZVBvbGljeSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XG4gICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0UG9saWN5KG5vZGUuc3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBSZXNvbHZlQ29udGV4dCB0aGF0IGluY2x1ZGVzIGEgcG9ydGlvbiBvZiB0aGlzIG9uZVxuICAgKlxuICAgKiBHaXZlbiBhIHN0YXRlLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IFJlc29sdmVDb250ZXh0IGZyb20gdGhpcyBvbmUuXG4gICAqIFRoZSBuZXcgY29udGV4dCBzdGFydHMgYXQgdGhlIGZpcnN0IG5vZGUgKHJvb3QpIGFuZCBzdG9wcyBhdCB0aGUgbm9kZSBmb3IgdGhlIGBzdGF0ZWAgcGFyYW1ldGVyLlxuICAgKlxuICAgKiAjIyMjIFdoeVxuICAgKlxuICAgKiBXaGVuIGEgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLCB0aGUgbm9kZXMgaW4gdGhlIFwiVG8gUGF0aFwiIGFyZSBpbmplY3RlZCBmcm9tIGEgUmVzb2x2ZUNvbnRleHQuXG4gICAqIEEgUmVzb2x2ZUNvbnRleHQgY2xvc2VzIG92ZXIgYSBwYXRoIG9mIFtbUGF0aE5vZGVdXXMgYW5kIHByb2Nlc3NlcyB0aGUgcmVzb2x2YWJsZXMuXG4gICAqIFRoZSBcIlRvIFN0YXRlXCIgY2FuIGluamVjdCB2YWx1ZXMgZnJvbSBpdHMgb3duIHJlc29sdmFibGVzLCBhcyB3ZWxsIGFzIHRob3NlIGZyb20gYWxsIGl0cyBhbmNlc3RvciBzdGF0ZSdzIChub2RlJ3MpLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG5hcnJvd2VyIGNvbnRleHQgd2hlbiBpbmplY3RpbmcgYW5jZXN0b3Igbm9kZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBsZXQgQUJDRCA9IG5ldyBSZXNvbHZlQ29udGV4dChbQSwgQiwgQywgRF0pO2BcbiAgICpcbiAgICogR2l2ZW4gYSBwYXRoIGBbQSwgQiwgQywgRF1gLCB3aGVyZSBgQWAsIGBCYCwgYENgIGFuZCBgRGAgYXJlIG5vZGVzIGZvciBzdGF0ZXMgYGFgLCBgYmAsIGBjYCwgYGRgOlxuICAgKiBXaGVuIGluamVjdGluZyBgRGAsIGBEYCBzaG91bGQgaGF2ZSBhY2Nlc3MgdG8gYWxsIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAsIGBDYCwgYERgLlxuICAgKiBIb3dldmVyLCBgQmAgc2hvdWxkIG9ubHkgYmUgYWJsZSB0byBhY2Nlc3MgcmVzb2x2YWJsZXMgZnJvbSBgQWAsIGBCYC5cbiAgICpcbiAgICogV2hlbiByZXNvbHZpbmcgZm9yIHRoZSBgQmAgbm9kZSwgZmlyc3QgdGFrZSB0aGUgZnVsbCBcIlRvIFBhdGhcIiBDb250ZXh0IGBbQSxCLEMsRF1gIGFuZCBsaW1pdCB0byB0aGUgc3VicGF0aCBgW0EsQl1gLlxuICAgKiBgbGV0IEFCID0gQUJDRC5zdWJjb250ZXh0KGEpYFxuICAgKi9cbiAgc3ViQ29udGV4dChzdGF0ZTogU3RhdGVPYmplY3QpOiBSZXNvbHZlQ29udGV4dCB7XG4gICAgcmV0dXJuIG5ldyBSZXNvbHZlQ29udGV4dChQYXRoVXRpbHMuc3ViUGF0aCh0aGlzLl9wYXRoLCBub2RlID0+IG5vZGUuc3RhdGUgPT09IHN0YXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBSZXNvbHZhYmxlcyB0byB0aGUgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHN0YXRlXG4gICAqXG4gICAqIFRoaXMgYWRkcyBhIFtbUmVzb2x2YWJsZV1dIChnZW5lcmFsbHkgb25lIGNyZWF0ZWQgb24gdGhlIGZseTsgbm90IGRlY2xhcmVkIG9uIGEgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9jaykuXG4gICAqIFRoZSByZXNvbHZhYmxlIGlzIGFkZGVkIHRvIHRoZSBub2RlIG1hdGNoaW5nIHRoZSBgc3RhdGVgIHBhcmFtZXRlci5cbiAgICpcbiAgICogVGhlc2UgbmV3IHJlc29sdmFibGVzIGFyZSBub3QgYXV0b21hdGljYWxseSBmZXRjaGVkLlxuICAgKiBUaGUgY2FsbGluZyBjb2RlIHNob3VsZCBlaXRoZXIgZmV0Y2ggdGhlbSwgZmV0Y2ggc29tZXRoaW5nIHRoYXQgZGVwZW5kcyBvbiB0aGVtLFxuICAgKiBvciByZWx5IG9uIFtbcmVzb2x2ZVBhdGhdXSBiZWluZyBjYWxsZWQgd2hlbiBzb21lIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gICAqXG4gICAqIE5vdGU6IGVhY2ggcmVzb2x2YWJsZSdzIFtbUmVzb2x2ZVBvbGljeV1dIGlzIG1lcmdlZCB3aXRoIHRoZSBzdGF0ZSdzIHBvbGljeSwgYW5kIHRoZSBnbG9iYWwgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIG5ld1Jlc29sdmFibGVzIHRoZSBuZXcgUmVzb2x2YWJsZXNcbiAgICogQHBhcmFtIHN0YXRlIFVzZWQgdG8gZmluZCB0aGUgbm9kZSB0byBwdXQgdGhlIHJlc29sdmFibGUgb25cbiAgICovXG4gIGFkZFJlc29sdmFibGVzKG5ld1Jlc29sdmFibGVzOiBSZXNvbHZhYmxlW10sIHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICAgIGNvbnN0IG5vZGUgPSA8UGF0aE5vZGU+ZmluZCh0aGlzLl9wYXRoLCBwcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcbiAgICBjb25zdCBrZXlzID0gbmV3UmVzb2x2YWJsZXMubWFwKHIgPT4gci50b2tlbik7XG4gICAgbm9kZS5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuZmlsdGVyKHIgPT4ga2V5cy5pbmRleE9mKHIudG9rZW4pID09PSAtMSkuY29uY2F0KG5ld1Jlc29sdmFibGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcGF0aCBFbGVtZW50IHByb21pc2VzXG4gICAqXG4gICAqIEBwYXJhbSB3aGVuXG4gICAqIEBwYXJhbSB0cmFuc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fGFueX1cbiAgICovXG4gIHJlc29sdmVQYXRoKHdoZW46IFBvbGljeVdoZW4gPSAnTEFaWScsIHRyYW5zPzogVHJhbnNpdGlvbik6IFByb21pc2U8eyB0b2tlbjogYW55OyB2YWx1ZTogYW55IH1bXT4ge1xuICAgIC8vIFRoaXMgb3B0aW9uIGRldGVybWluZXMgd2hpY2ggJ3doZW4nIHBvbGljeSBSZXNvbHZhYmxlcyB3ZSBhcmUgYWJvdXQgdG8gZmV0Y2guXG4gICAgY29uc3Qgd2hlbk9wdGlvbjogc3RyaW5nID0gaW5BcnJheShBTExfV0hFTlMsIHdoZW4pID8gd2hlbiA6ICdMQVpZJztcbiAgICAvLyBJZiB0aGUgY2FsbGVyIHNwZWNpZmllZCBFQUdFUiwgb25seSB0aGUgRUFHRVIgUmVzb2x2YWJsZXMgYXJlIGZldGNoZWQuXG4gICAgLy8gaWYgdGhlIGNhbGxlciBzcGVjaWZpZWQgTEFaWSwgYm90aCBFQUdFUiBhbmQgTEFaWSBSZXNvbHZhYmxlcyBhcmUgZmV0Y2hlZC5gXG4gICAgY29uc3QgbWF0Y2hlZFdoZW5zID0gd2hlbk9wdGlvbiA9PT0gcmVzb2x2ZVBvbGljaWVzLndoZW4uRUFHRVIgPyBFQUdFUl9XSEVOUyA6IEFMTF9XSEVOUztcblxuICAgIC8vIGdldCB0aGUgc3VicGF0aCB0byB0aGUgc3RhdGUgYXJndW1lbnQsIGlmIHByb3ZpZGVkXG4gICAgdHJhY2UudHJhY2VSZXNvbHZlUGF0aCh0aGlzLl9wYXRoLCB3aGVuLCB0cmFucyk7XG5cbiAgICBjb25zdCBtYXRjaGVzUG9saWN5ID0gKGFjY2VwdGVkVmFsczogc3RyaW5nW10sIHdoZW5PckFzeW5jOiAnd2hlbicgfCAnYXN5bmMnKSA9PiAocmVzb2x2YWJsZTogUmVzb2x2YWJsZSkgPT5cbiAgICAgIGluQXJyYXkoYWNjZXB0ZWRWYWxzLCB0aGlzLmdldFBvbGljeShyZXNvbHZhYmxlKVt3aGVuT3JBc3luY10pO1xuXG4gICAgLy8gVHJpZ2dlciBhbGwgdGhlIChtYXRjaGluZykgUmVzb2x2YWJsZXMgaW4gdGhlIHBhdGhcbiAgICAvLyBSZWR1Y2UgYWxsIHRoZSBcIldBSVRcIiBSZXNvbHZhYmxlcyBpbnRvIGFuIGFycmF5XG4gICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8YW55PltdID0gdGhpcy5fcGF0aC5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZVJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5maWx0ZXIobWF0Y2hlc1BvbGljeShtYXRjaGVkV2hlbnMsICd3aGVuJykpO1xuICAgICAgY29uc3Qgbm93YWl0ID0gbm9kZVJlc29sdmFibGVzLmZpbHRlcihtYXRjaGVzUG9saWN5KFsnTk9XQUlUJ10sICdhc3luYycpKTtcbiAgICAgIGNvbnN0IHdhaXQgPSBub2RlUmVzb2x2YWJsZXMuZmlsdGVyKG5vdChtYXRjaGVzUG9saWN5KFsnTk9XQUlUJ10sICdhc3luYycpKSk7XG5cbiAgICAgIC8vIEZvciB0aGUgbWF0Y2hpbmcgUmVzb2x2YWJsZXMsIHN0YXJ0IHRoZWlyIGFzeW5jIGZldGNoIHByb2Nlc3MuXG4gICAgICBjb25zdCBzdWJDb250ZXh0ID0gdGhpcy5zdWJDb250ZXh0KG5vZGUuc3RhdGUpO1xuICAgICAgY29uc3QgZ2V0UmVzdWx0ID0gKHI6IFJlc29sdmFibGUpID0+XG4gICAgICAgIHJcbiAgICAgICAgICAuZ2V0KHN1YkNvbnRleHQsIHRyYW5zKVxuICAgICAgICAgIC8vIFJldHVybiBhIHR1cGxlIHRoYXQgaW5jbHVkZXMgdGhlIFJlc29sdmFibGUncyB0b2tlblxuICAgICAgICAgIC50aGVuKHZhbHVlID0+ICh7IHRva2VuOiByLnRva2VuLCB2YWx1ZTogdmFsdWUgfSkpO1xuICAgICAgbm93YWl0LmZvckVhY2goZ2V0UmVzdWx0KTtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHdhaXQubWFwKGdldFJlc3VsdCkpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFdhaXQgZm9yIGFsbCB0aGUgXCJXQUlUXCIgcmVzb2x2YWJsZXNcbiAgICByZXR1cm4gc2VydmljZXMuJHEuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIGluamVjdG9yKCk6IFVJSW5qZWN0b3Ige1xuICAgIHJldHVybiB0aGlzLl9pbmplY3RvciB8fCAodGhpcy5faW5qZWN0b3IgPSBuZXcgVUlJbmplY3RvckltcGwodGhpcykpO1xuICB9XG5cbiAgZmluZE5vZGUocmVzb2x2YWJsZTogUmVzb2x2YWJsZSk6IFBhdGhOb2RlIHtcbiAgICByZXR1cm4gZmluZCh0aGlzLl9wYXRoLCAobm9kZTogUGF0aE5vZGUpID0+IGluQXJyYXkobm9kZS5yZXNvbHZhYmxlcywgcmVzb2x2YWJsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFzeW5jIGRlcGVuZGVuY2llcyBvZiBhIFJlc29sdmFibGVcbiAgICpcbiAgICogR2l2ZW4gYSBSZXNvbHZhYmxlLCByZXR1cm5zIGl0cyBkZXBlbmRlbmNpZXMgYXMgYSBSZXNvbHZhYmxlW11cbiAgICovXG4gIGdldERlcGVuZGVuY2llcyhyZXNvbHZhYmxlOiBSZXNvbHZhYmxlKTogUmVzb2x2YWJsZVtdIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5maW5kTm9kZShyZXNvbHZhYmxlKTtcbiAgICAvLyBGaW5kIHdoaWNoIG90aGVyIHJlc29sdmFibGVzIGFyZSBcInZpc2libGVcIiB0byB0aGUgYHJlc29sdmFibGVgIGFyZ3VtZW50XG4gICAgLy8gc3VicGF0aCBzdG9wcGluZyBhdCByZXNvbHZhYmxlJ3Mgbm9kZSwgb3IgdGhlIHdob2xlIHBhdGggKGlmIHRoZSByZXNvbHZhYmxlIGlzbid0IGluIHRoZSBwYXRoKVxuICAgIGNvbnN0IHN1YlBhdGg6IFBhdGhOb2RlW10gPSBQYXRoVXRpbHMuc3ViUGF0aCh0aGlzLl9wYXRoLCB4ID0+IHggPT09IG5vZGUpIHx8IHRoaXMuX3BhdGg7XG4gICAgY29uc3QgYXZhaWxhYmxlUmVzb2x2YWJsZXM6IFJlc29sdmFibGVbXSA9IHN1YlBhdGhcbiAgICAgIC5yZWR1Y2UoKGFjYywgX25vZGUpID0+IGFjYy5jb25jYXQoX25vZGUucmVzb2x2YWJsZXMpLCBbXSkgLy8gYWxsIG9mIHN1YnBhdGgncyByZXNvbHZhYmxlc1xuICAgICAgLmZpbHRlcihyZXMgPT4gcmVzICE9PSByZXNvbHZhYmxlKTsgLy8gZmlsdGVyIG91dCB0aGUgYHJlc29sdmFibGVgIGFyZ3VtZW50XG5cbiAgICBjb25zdCBnZXREZXBlbmRlbmN5ID0gKHRva2VuOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nID0gYXZhaWxhYmxlUmVzb2x2YWJsZXMuZmlsdGVyKHIgPT4gci50b2tlbiA9PT0gdG9rZW4pO1xuICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCkgcmV0dXJuIHRhaWwobWF0Y2hpbmcpO1xuXG4gICAgICBjb25zdCBmcm9tSW5qZWN0b3IgPSB0aGlzLmluamVjdG9yKCkuZ2V0TmF0aXZlKHRva2VuKTtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChmcm9tSW5qZWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgRGVwZW5kZW5jeSBJbmplY3Rpb24gdG9rZW46ICcgKyBzdHJpbmdpZnkodG9rZW4pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRva2VuLCAoKSA9PiBmcm9tSW5qZWN0b3IsIFtdLCBmcm9tSW5qZWN0b3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVzb2x2YWJsZS5kZXBzLm1hcChnZXREZXBlbmRlbmN5KTtcbiAgfVxufVxuXG4vKiogQGludGVybmFsYXBpICovXG5jbGFzcyBVSUluamVjdG9ySW1wbCBpbXBsZW1lbnRzIFVJSW5qZWN0b3Ige1xuICBuYXRpdmU6ICRJbmplY3Rvckxpa2U7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGNvbnRleHQ6IFJlc29sdmVDb250ZXh0KSB7XG4gICAgdGhpcy5uYXRpdmUgPSB0aGlzLmdldChOQVRJVkVfSU5KRUNUT1JfVE9LRU4pIHx8IHNlcnZpY2VzLiRpbmplY3RvcjtcbiAgfVxuXG4gIGdldCh0b2tlbjogYW55KSB7XG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IHRoaXMuY29udGV4dC5nZXRSZXNvbHZhYmxlKHRva2VuKTtcbiAgICBpZiAocmVzb2x2YWJsZSkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dC5nZXRQb2xpY3kocmVzb2x2YWJsZSkuYXN5bmMgPT09ICdOT1dBSVQnKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldCh0aGlzLmNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc29sdmFibGUucmVzb2x2ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvbHZhYmxlIGFzeW5jIC5nZXQoKSBub3QgY29tcGxldGU6JyArIHN0cmluZ2lmeShyZXNvbHZhYmxlLnRva2VuKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2YWJsZS5kYXRhO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZSh0b2tlbik7XG4gIH1cblxuICBnZXRBc3luYyh0b2tlbjogYW55KSB7XG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IHRoaXMuY29udGV4dC5nZXRSZXNvbHZhYmxlKHRva2VuKTtcbiAgICBpZiAocmVzb2x2YWJsZSkgcmV0dXJuIHJlc29sdmFibGUuZ2V0KHRoaXMuY29udGV4dCk7XG4gICAgcmV0dXJuIHNlcnZpY2VzLiRxLndoZW4odGhpcy5uYXRpdmUuZ2V0KHRva2VuKSk7XG4gIH1cblxuICBnZXROYXRpdmUodG9rZW46IGFueSkge1xuICAgIHJldHVybiB0aGlzLm5hdGl2ZSAmJiB0aGlzLm5hdGl2ZS5nZXQodG9rZW4pO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuaW1wb3J0IHsgYXBwbHlQYWlycywgZXh0ZW5kLCBpZGVudGl0eSwgaW5oZXJpdCwgbWFwT2JqLCBub29wLCBPYmosIG9taXQsIHRhaWwsIHZhbHVlcywgY29weSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgaXNBcnJheSwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmdzJztcbmltcG9ydCB7IGlzLCBwYXR0ZXJuLCBwaXBlLCBwcm9wLCB2YWwgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBTdGF0ZU1hdGNoZXIgfSBmcm9tICcuL3N0YXRlTWF0Y2hlcic7XG5pbXBvcnQgeyBQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBVcmxNYXRjaGVyRmFjdG9yeSB9IGZyb20gJy4uL3VybC91cmxNYXRjaGVyRmFjdG9yeSc7XG5pbXBvcnQgeyBVcmxNYXRjaGVyIH0gZnJvbSAnLi4vdXJsL3VybE1hdGNoZXInO1xuaW1wb3J0IHsgUmVzb2x2YWJsZSB9IGZyb20gJy4uL3Jlc29sdmUvcmVzb2x2YWJsZSc7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgUmVzb2x2ZVBvbGljeSB9IGZyb20gJy4uL3Jlc29sdmUvaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhcmFtRGVjbGFyYXRpb24gfSBmcm9tICcuLi9wYXJhbXMnO1xuaW1wb3J0IHsgUGFyYW1GYWN0b3J5IH0gZnJvbSAnLi4vdXJsJztcblxuY29uc3QgcGFyc2VVcmwgPSAodXJsOiBzdHJpbmcpOiBhbnkgPT4ge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgcm9vdCA9IHVybC5jaGFyQXQoMCkgPT09ICdeJztcbiAgcmV0dXJuIHsgdmFsOiByb290ID8gdXJsLnN1YnN0cmluZygxKSA6IHVybCwgcm9vdCB9O1xufTtcblxuZXhwb3J0IHR5cGUgQnVpbGRlckZ1bmN0aW9uID0gKHN0YXRlOiBTdGF0ZU9iamVjdCwgcGFyZW50PzogQnVpbGRlckZ1bmN0aW9uKSA9PiBhbnk7XG5cbmludGVyZmFjZSBCdWlsZGVycyB7XG4gIFtrZXk6IHN0cmluZ106IEJ1aWxkZXJGdW5jdGlvbltdO1xuXG4gIG5hbWU6IEJ1aWxkZXJGdW5jdGlvbltdO1xuICBwYXJlbnQ6IEJ1aWxkZXJGdW5jdGlvbltdO1xuICBkYXRhOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgdXJsOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgbmF2aWdhYmxlOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgcGFyYW1zOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgdmlld3M6IEJ1aWxkZXJGdW5jdGlvbltdO1xuICBwYXRoOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgaW5jbHVkZXM6IEJ1aWxkZXJGdW5jdGlvbltdO1xuICByZXNvbHZhYmxlczogQnVpbGRlckZ1bmN0aW9uW107XG59XG5cbmZ1bmN0aW9uIG5hbWVCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICByZXR1cm4gc3RhdGUubmFtZTtcbn1cblxuZnVuY3Rpb24gc2VsZkJ1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gIHN0YXRlLnNlbGYuJCRzdGF0ZSA9ICgpID0+IHN0YXRlO1xuICByZXR1cm4gc3RhdGUuc2VsZjtcbn1cblxuZnVuY3Rpb24gZGF0YUJ1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcbiAgICBzdGF0ZS5kYXRhID0gc3RhdGUuc2VsZi5kYXRhID0gaW5oZXJpdChzdGF0ZS5wYXJlbnQuZGF0YSwgc3RhdGUuZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmRhdGE7XG59XG5cbmNvbnN0IGdldFVybEJ1aWxkZXIgPSAoJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXI6IFVybE1hdGNoZXJGYWN0b3J5LCByb290OiAoKSA9PiBTdGF0ZU9iamVjdCkgPT5cbiAgZnVuY3Rpb24gdXJsQnVpbGRlcihzdGF0ZU9iamVjdDogU3RhdGVPYmplY3QpIHtcbiAgICBsZXQgc3RhdGVEZWM6IFN0YXRlRGVjbGFyYXRpb24gPSBzdGF0ZU9iamVjdC5zZWxmO1xuXG4gICAgLy8gRm9yIGZ1dHVyZSBzdGF0ZXMsIGkuZS4sIHN0YXRlcyB3aG9zZSBuYW1lIGVuZHMgd2l0aCBgLioqYCxcbiAgICAvLyBtYXRjaCBhbnl0aGluZyB0aGF0IHN0YXJ0cyB3aXRoIHRoZSB1cmwgcHJlZml4XG4gICAgaWYgKHN0YXRlRGVjICYmIHN0YXRlRGVjLnVybCAmJiBzdGF0ZURlYy5uYW1lICYmIHN0YXRlRGVjLm5hbWUubWF0Y2goL1xcLlxcKlxcKiQvKSkge1xuICAgICAgY29uc3QgbmV3U3RhdGVEZWM6IFN0YXRlRGVjbGFyYXRpb24gPSB7fTtcbiAgICAgIGNvcHkoc3RhdGVEZWMsIG5ld1N0YXRlRGVjKTtcbiAgICAgIG5ld1N0YXRlRGVjLnVybCArPSAne3JlbWFpbmRlcjphbnl9JzsgLy8gbWF0Y2ggYW55IHBhdGggKC4qKVxuICAgICAgc3RhdGVEZWMgPSBuZXdTdGF0ZURlYztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSBzdGF0ZU9iamVjdC5wYXJlbnQ7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VVcmwoc3RhdGVEZWMudXJsKTtcbiAgICBjb25zdCB1cmwgPSAhcGFyc2VkID8gc3RhdGVEZWMudXJsIDogJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXIuY29tcGlsZShwYXJzZWQudmFsLCB7IHN0YXRlOiBzdGF0ZURlYyB9KTtcblxuICAgIGlmICghdXJsKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoISR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmlzTWF0Y2hlcih1cmwpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdXJsICcke3VybH0nIGluIHN0YXRlICcke3N0YXRlT2JqZWN0fSdgKTtcbiAgICByZXR1cm4gcGFyc2VkICYmIHBhcnNlZC5yb290ID8gdXJsIDogKChwYXJlbnQgJiYgcGFyZW50Lm5hdmlnYWJsZSkgfHwgcm9vdCgpKS51cmwuYXBwZW5kKDxVcmxNYXRjaGVyPnVybCk7XG4gIH07XG5cbmNvbnN0IGdldE5hdmlnYWJsZUJ1aWxkZXIgPSAoaXNSb290OiAoc3RhdGU6IFN0YXRlT2JqZWN0KSA9PiBib29sZWFuKSA9PlxuICBmdW5jdGlvbiBuYXZpZ2FibGVCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICAgIHJldHVybiAhaXNSb290KHN0YXRlKSAmJiBzdGF0ZS51cmwgPyBzdGF0ZSA6IHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5uYXZpZ2FibGUgOiBudWxsO1xuICB9O1xuXG5jb25zdCBnZXRQYXJhbXNCdWlsZGVyID0gKHBhcmFtRmFjdG9yeTogUGFyYW1GYWN0b3J5KSA9PlxuICBmdW5jdGlvbiBwYXJhbXNCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCk6IHsgW2tleTogc3RyaW5nXTogUGFyYW0gfSB7XG4gICAgY29uc3QgbWFrZUNvbmZpZ1BhcmFtID0gKGNvbmZpZzogUGFyYW1EZWNsYXJhdGlvbiwgaWQ6IHN0cmluZykgPT4gcGFyYW1GYWN0b3J5LmZyb21Db25maWcoaWQsIG51bGwsIHN0YXRlLnNlbGYpO1xuICAgIGNvbnN0IHVybFBhcmFtczogUGFyYW1bXSA9IChzdGF0ZS51cmwgJiYgc3RhdGUudXJsLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KSkgfHwgW107XG4gICAgY29uc3Qgbm9uVXJsUGFyYW1zOiBQYXJhbVtdID0gdmFsdWVzKG1hcE9iaihvbWl0KHN0YXRlLnBhcmFtcyB8fCB7fSwgdXJsUGFyYW1zLm1hcChwcm9wKCdpZCcpKSksIG1ha2VDb25maWdQYXJhbSkpO1xuICAgIHJldHVybiB1cmxQYXJhbXNcbiAgICAgIC5jb25jYXQobm9uVXJsUGFyYW1zKVxuICAgICAgLm1hcChwID0+IFtwLmlkLCBwXSlcbiAgICAgIC5yZWR1Y2UoYXBwbHlQYWlycywge30pO1xuICB9O1xuXG5mdW5jdGlvbiBwYXRoQnVpbGRlcihzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgcmV0dXJuIHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5wYXRoLmNvbmNhdChzdGF0ZSkgOiAvKnJvb3QqLyBbc3RhdGVdO1xufVxuXG5mdW5jdGlvbiBpbmNsdWRlc0J1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gIGNvbnN0IGluY2x1ZGVzID0gc3RhdGUucGFyZW50ID8gZXh0ZW5kKHt9LCBzdGF0ZS5wYXJlbnQuaW5jbHVkZXMpIDoge307XG4gIGluY2x1ZGVzW3N0YXRlLm5hbWVdID0gdHJ1ZTtcbiAgcmV0dXJuIGluY2x1ZGVzO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIHRoZSBgcmVzb2x2ZTpgIGJsb2NrIG9uIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogdmFsaWRhdGVzIHRoZSBgcmVzb2x2ZWAgcHJvcGVydHkgYW5kIGNvbnZlcnRzIGl0IHRvIGEgW1tSZXNvbHZhYmxlXV0gYXJyYXkuXG4gKlxuICogcmVzb2x2ZTogaW5wdXQgdmFsdWUgY2FuIGJlOlxuICpcbiAqIHtcbiAqICAgLy8gYW5hbHl6ZWQgYnV0IG5vdCBpbmplY3RlZFxuICogICBteUZvb1Jlc29sdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIjsgfSxcbiAqXG4gKiAgIC8vIGZ1bmN0aW9uLnRvU3RyaW5nKCkgcGFyc2VkLCBcIkRlcGVuZGVuY3lOYW1lXCIgZGVwIGFzIHN0cmluZyAobm90IG1pbi1zYWZlKVxuICogICBteUJhclJlc29sdmU6IGZ1bmN0aW9uKERlcGVuZGVuY3lOYW1lKSB7IHJldHVybiBEZXBlbmRlbmN5TmFtZS5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sXG4gKlxuICogICAvLyBBcnJheSBzcGxpdDsgXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmdcbiAqICAgbXlCYXpSZXNvbHZlOiBbIFwiRGVwZW5kZW5jeU5hbWVcIiwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gQXJyYXkgc3BsaXQ7IERlcGVuZGVuY3lUeXBlIGRlcCBhcyB0b2tlbiAoY29tcGFyZWQgdXNpbmcgPT09KVxuICogICBteVF1eFJlc29sdmU6IFsgRGVwZW5kZW5jeVR5cGUsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gdmFsLiRpbmplY3QgdXNlZCBhcyBkZXBzXG4gKiAgIC8vIHdoZXJlOlxuICogICAvLyAgICAgY29yZ2VSZXNvbHZlLiRpbmplY3QgPSBbXCJEZXBlbmRlbmN5TmFtZVwiXTtcbiAqICAgLy8gICAgIGZ1bmN0aW9uIGNvcmdlUmVzb2x2ZShkZXApIHsgZGVwLmZldGNoU29tZXRpbmdBc1Byb21pc2UoKSB9XG4gKiAgIC8vIHRoZW4gXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmdcbiAqICAgbXlDb3JnZVJlc29sdmU6IGNvcmdlUmVzb2x2ZSxcbiAqXG4gKiAgLy8gaW5qZWN0IHNlcnZpY2UgYnkgbmFtZVxuICogIC8vIFdoZW4gYSBzdHJpbmcgaXMgZm91bmQsIGRlc3VnYXIgY3JlYXRpbmcgYSByZXNvbHZlIHRoYXQgaW5qZWN0cyB0aGUgbmFtZWQgc2VydmljZVxuICogICBteUdyYXVsdFJlc29sdmU6IFwiU29tZVNlcnZpY2VcIlxuICogfVxuICpcbiAqIG9yOlxuICpcbiAqIFtcbiAqICAgbmV3IFJlc29sdmFibGUoXCJteUZvb1Jlc29sdmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBcIm15Rm9vRGF0YVwiIH0pLFxuICogICBuZXcgUmVzb2x2YWJsZShcIm15QmFyUmVzb2x2ZVwiLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sIFsgXCJEZXBlbmRlbmN5TmFtZVwiIF0pLFxuICogICB7IHByb3ZpZGU6IFwibXlCYXpSZXNvbHZlXCIsIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uKGRlcCkgeyBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LCBkZXBzOiBbIFwiRGVwZW5kZW5jeU5hbWVcIiBdIH1cbiAqIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmFibGVzQnVpbGRlcihzdGF0ZTogU3RhdGVPYmplY3QpOiBSZXNvbHZhYmxlW10ge1xuICBpbnRlcmZhY2UgVHVwbGUge1xuICAgIHRva2VuOiBhbnk7XG4gICAgdmFsOiBhbnk7XG4gICAgZGVwczogYW55W107XG4gICAgcG9saWN5OiBSZXNvbHZlUG9saWN5O1xuICB9XG5cbiAgLyoqIGNvbnZlcnQgcmVzb2x2ZToge30gYW5kIHJlc29sdmVQb2xpY3k6IHt9IG9iamVjdHMgdG8gYW4gYXJyYXkgb2YgdHVwbGVzICovXG4gIGNvbnN0IG9iamVjdHMyVHVwbGVzID0gKHJlc29sdmVPYmo6IE9iaiwgcmVzb2x2ZVBvbGljaWVzOiB7IFtrZXk6IHN0cmluZ106IFJlc29sdmVQb2xpY3kgfSkgPT5cbiAgICBPYmplY3Qua2V5cyhyZXNvbHZlT2JqIHx8IHt9KS5tYXAodG9rZW4gPT4gKHtcbiAgICAgIHRva2VuLFxuICAgICAgdmFsOiByZXNvbHZlT2JqW3Rva2VuXSxcbiAgICAgIGRlcHM6IHVuZGVmaW5lZCxcbiAgICAgIHBvbGljeTogcmVzb2x2ZVBvbGljaWVzW3Rva2VuXSxcbiAgICB9KSk7XG5cbiAgLyoqIGZldGNoIERJIGFubm90YXRpb25zIGZyb20gYSBmdW5jdGlvbiBvciBuZzEtc3R5bGUgYXJyYXkgKi9cbiAgY29uc3QgYW5ub3RhdGUgPSAoZm46IEZ1bmN0aW9uKSA9PiB7XG4gICAgY29uc3QgJGluamVjdG9yID0gc2VydmljZXMuJGluamVjdG9yO1xuICAgIC8vIG5nMSBkb2Vzbid0IGhhdmUgYW4gJGluamVjdG9yIHVudGlsIHJ1bnRpbWUuXG4gICAgLy8gSWYgdGhlICRpbmplY3RvciBkb2Vzbid0IGV4aXN0LCB1c2UgXCJkZWZlcnJlZFwiIGxpdGVyYWwgYXMgYVxuICAgIC8vIG1hcmtlciBpbmRpY2F0aW5nIHRoZXkgc2hvdWxkIGJlIGFubm90YXRlZCB3aGVuIHJ1bnRpbWUgc3RhcnRzXG4gICAgcmV0dXJuIGZuWyckaW5qZWN0J10gfHwgKCRpbmplY3RvciAmJiAkaW5qZWN0b3IuYW5ub3RhdGUoZm4sICRpbmplY3Rvci5zdHJpY3REaSkpIHx8IDxhbnk+J2RlZmVycmVkJztcbiAgfTtcblxuICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyBib3RoIGB0b2tlbmAgYW5kIGByZXNvbHZlRm5gLCBhbmQgaXMgcHJvYmFibHkgYSBbW1Jlc29sdmVMaXRlcmFsXV0gKi9cbiAgY29uc3QgaXNSZXNvbHZlTGl0ZXJhbCA9IChvYmo6IGFueSkgPT4gISEob2JqLnRva2VuICYmIG9iai5yZXNvbHZlRm4pO1xuXG4gIC8qKiB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhIHByb3ZpZGUgbGl0ZXJhbCwgb3IgYSBuZzIgUHJvdmlkZXIgKi9cbiAgY29uc3QgaXNMaWtlTmcyUHJvdmlkZXIgPSAob2JqOiBhbnkpID0+XG4gICAgISEoKG9iai5wcm92aWRlIHx8IG9iai50b2tlbikgJiYgKG9iai51c2VWYWx1ZSB8fCBvYmoudXNlRmFjdG9yeSB8fCBvYmoudXNlRXhpc3RpbmcgfHwgb2JqLnVzZUNsYXNzKSk7XG5cbiAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgdHVwbGUgZnJvbSBvYmoyVHVwbGVzICovXG4gIGNvbnN0IGlzVHVwbGVGcm9tT2JqID0gKG9iajogYW55KSA9PlxuICAgICEhKG9iaiAmJiBvYmoudmFsICYmIChpc1N0cmluZyhvYmoudmFsKSB8fCBpc0FycmF5KG9iai52YWwpIHx8IGlzRnVuY3Rpb24ob2JqLnZhbCkpKTtcblxuICAvKiogZXh0cmFjdHMgdGhlIHRva2VuIGZyb20gYSBQcm92aWRlciBvciBwcm92aWRlIGxpdGVyYWwgKi9cbiAgY29uc3QgZ2V0VG9rZW4gPSAocDogYW55KSA9PiBwLnByb3ZpZGUgfHwgcC50b2tlbjtcblxuICAvLyBwcmV0dGllci1pZ25vcmU6IEdpdmVuIGEgbGl0ZXJhbCByZXNvbHZlIG9yIHByb3ZpZGVyIG9iamVjdCwgcmV0dXJucyBhIFJlc29sdmFibGVcbiAgY29uc3QgbGl0ZXJhbDJSZXNvbHZhYmxlID0gcGF0dGVybihbXG4gICAgW3Byb3AoJ3Jlc29sdmVGbicpLCBwID0+IG5ldyBSZXNvbHZhYmxlKGdldFRva2VuKHApLCBwLnJlc29sdmVGbiwgcC5kZXBzLCBwLnBvbGljeSldLFxuICAgIFtwcm9wKCd1c2VGYWN0b3J5JyksIHAgPT4gbmV3IFJlc29sdmFibGUoZ2V0VG9rZW4ocCksIHAudXNlRmFjdG9yeSwgcC5kZXBzIHx8IHAuZGVwZW5kZW5jaWVzLCBwLnBvbGljeSldLFxuICAgIFtwcm9wKCd1c2VDbGFzcycpLCBwID0+IG5ldyBSZXNvbHZhYmxlKGdldFRva2VuKHApLCAoKSA9PiBuZXcgKDxhbnk+cC51c2VDbGFzcykoKSwgW10sIHAucG9saWN5KV0sXG4gICAgW3Byb3AoJ3VzZVZhbHVlJyksIHAgPT4gbmV3IFJlc29sdmFibGUoZ2V0VG9rZW4ocCksICgpID0+IHAudXNlVmFsdWUsIFtdLCBwLnBvbGljeSwgcC51c2VWYWx1ZSldLFxuICAgIFtwcm9wKCd1c2VFeGlzdGluZycpLCBwID0+IG5ldyBSZXNvbHZhYmxlKGdldFRva2VuKHApLCBpZGVudGl0eSwgW3AudXNlRXhpc3RpbmddLCBwLnBvbGljeSldLFxuICBdKTtcblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgY29uc3QgdHVwbGUyUmVzb2x2YWJsZSA9IHBhdHRlcm4oW1xuICAgIFtwaXBlKHByb3AoJ3ZhbCcpLCBpc1N0cmluZyksICAgKHR1cGxlOiBUdXBsZSkgPT4gbmV3IFJlc29sdmFibGUodHVwbGUudG9rZW4sIGlkZW50aXR5LCBbdHVwbGUudmFsXSwgdHVwbGUucG9saWN5KV0sXG4gICAgW3BpcGUocHJvcCgndmFsJyksIGlzQXJyYXkpLCAgICAodHVwbGU6IFR1cGxlKSA9PiBuZXcgUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgdGFpbCg8YW55W10+dHVwbGUudmFsKSwgdHVwbGUudmFsLnNsaWNlKDAsIC0xKSwgdHVwbGUucG9saWN5KV0sXG4gICAgW3BpcGUocHJvcCgndmFsJyksIGlzRnVuY3Rpb24pLCAodHVwbGU6IFR1cGxlKSA9PiBuZXcgUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgdHVwbGUudmFsLCBhbm5vdGF0ZSh0dXBsZS52YWwpLCB0dXBsZS5wb2xpY3kpXSxcbiAgXSk7XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IGl0ZW0yUmVzb2x2YWJsZSA9IDwob2JqOiBhbnkpID0+IFJlc29sdmFibGU+cGF0dGVybihbXG4gICAgW2lzKFJlc29sdmFibGUpLCAocjogUmVzb2x2YWJsZSkgPT4gcl0sXG4gICAgW2lzUmVzb2x2ZUxpdGVyYWwsIGxpdGVyYWwyUmVzb2x2YWJsZV0sXG4gICAgW2lzTGlrZU5nMlByb3ZpZGVyLCBsaXRlcmFsMlJlc29sdmFibGVdLFxuICAgIFtpc1R1cGxlRnJvbU9iaiwgdHVwbGUyUmVzb2x2YWJsZV0sXG4gICAgW3ZhbCh0cnVlKSwgKG9iajogYW55KSA9PiB7IHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNvbHZlIHZhbHVlOiAnICsgc3RyaW5naWZ5KG9iaikpOyB9LCBdLFxuICBdKTtcblxuICAvLyBJZiByZXNvbHZlQmxvY2sgaXMgYWxyZWFkeSBhbiBhcnJheSwgdXNlIGl0IGFzLWlzLlxuICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdCdzIGFuIG9iamVjdCBhbmQgY29udmVydCB0byBhbiBBcnJheSBvZiB0dXBsZXNcbiAgY29uc3QgZGVjbCA9IHN0YXRlLnJlc29sdmU7XG4gIGNvbnN0IGl0ZW1zOiBhbnlbXSA9IGlzQXJyYXkoZGVjbCkgPyBkZWNsIDogb2JqZWN0czJUdXBsZXMoZGVjbCwgc3RhdGUucmVzb2x2ZVBvbGljeSB8fCB7fSk7XG4gIHJldHVybiBpdGVtcy5tYXAoaXRlbTJSZXNvbHZhYmxlKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxhcGkgQSBpbnRlcm5hbCBnbG9iYWwgc2VydmljZVxuICpcbiAqIFN0YXRlQnVpbGRlciBpcyBhIGZhY3RvcnkgZm9yIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0cy5cbiAqXG4gKiBXaGVuIHlvdSByZWdpc3RlciBhIHN0YXRlIHdpdGggdGhlIFtbU3RhdGVSZWdpc3RyeV1dLCB5b3UgcmVnaXN0ZXIgYSBwbGFpbiBvbGQgamF2YXNjcmlwdCBvYmplY3Qgd2hpY2hcbiAqIGNvbmZvcm1zIHRvIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSBpbnRlcmZhY2UuICBUaGlzIGZhY3RvcnkgdGFrZXMgdGhhdCBvYmplY3QgYW5kIGJ1aWxkcyB0aGUgY29ycmVzcG9uZGluZ1xuICogW1tTdGF0ZU9iamVjdF1dIG9iamVjdCwgd2hpY2ggaGFzIGFuIEFQSSBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqIEN1c3RvbSBwcm9wZXJ0aWVzIG9yIEFQSSBtYXkgYmUgYWRkZWQgdG8gdGhlIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSBvYmplY3QgYnkgcmVnaXN0ZXJpbmcgYSBkZWNvcmF0b3IgZnVuY3Rpb25cbiAqIHVzaW5nIHRoZSBbW2J1aWxkZXJdXSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0ZUJ1aWxkZXIge1xuICAvKiogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBCdWlsZGVyRnVuY3Rpb25zIHJlZ2lzdGVyZWQsIGtleSdkIGJ5IHRoZSBuYW1lIG9mIHRoZSBTdGF0ZSBwcm9wZXJ0eSB0aGV5IGJ1aWxkICovXG4gIHByaXZhdGUgYnVpbGRlcnM6IEJ1aWxkZXJzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbWF0Y2hlcjogU3RhdGVNYXRjaGVyLCB1cmxNYXRjaGVyRmFjdG9yeTogVXJsTWF0Y2hlckZhY3RvcnkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IHJvb3QgPSAoKSA9PiBtYXRjaGVyLmZpbmQoJycpO1xuICAgIGNvbnN0IGlzUm9vdCA9IChzdGF0ZTogU3RhdGVPYmplY3QpID0+IHN0YXRlLm5hbWUgPT09ICcnO1xuXG4gICAgZnVuY3Rpb24gcGFyZW50QnVpbGRlcihzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICAgIGlmIChpc1Jvb3Qoc3RhdGUpKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBtYXRjaGVyLmZpbmQoc2VsZi5wYXJlbnROYW1lKHN0YXRlKSkgfHwgcm9vdCgpO1xuICAgIH1cblxuICAgIHRoaXMuYnVpbGRlcnMgPSB7XG4gICAgICBuYW1lOiBbbmFtZUJ1aWxkZXJdLFxuICAgICAgc2VsZjogW3NlbGZCdWlsZGVyXSxcbiAgICAgIHBhcmVudDogW3BhcmVudEJ1aWxkZXJdLFxuICAgICAgZGF0YTogW2RhdGFCdWlsZGVyXSxcbiAgICAgIC8vIEJ1aWxkIGEgVVJMTWF0Y2hlciBpZiBuZWNlc3NhcnksIGVpdGhlciB2aWEgYSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxcbiAgICAgIHVybDogW2dldFVybEJ1aWxkZXIodXJsTWF0Y2hlckZhY3RvcnksIHJvb3QpXSxcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igc3RhdGUgdGhhdCBoYXMgYSBVUkwgKGkuZS4gaXMgbmF2aWdhYmxlKVxuICAgICAgbmF2aWdhYmxlOiBbZ2V0TmF2aWdhYmxlQnVpbGRlcihpc1Jvb3QpXSxcbiAgICAgIHBhcmFtczogW2dldFBhcmFtc0J1aWxkZXIodXJsTWF0Y2hlckZhY3RvcnkucGFyYW1GYWN0b3J5KV0sXG4gICAgICAvLyBFYWNoIGZyYW1ld29yay1zcGVjaWZpYyB1aS1yb3V0ZXIgaW1wbGVtZW50YXRpb24gc2hvdWxkIGRlZmluZSBpdHMgb3duIGB2aWV3c2AgYnVpbGRlclxuICAgICAgLy8gZS5nLiwgc3JjL25nMS9zdGF0ZWJ1aWxkZXJzL3ZpZXdzLnRzXG4gICAgICB2aWV3czogW10sXG4gICAgICAvLyBLZWVwIGEgZnVsbCBwYXRoIGZyb20gdGhlIHJvb3QgZG93biB0byB0aGlzIHN0YXRlIGFzIHRoaXMgaXMgbmVlZGVkIGZvciBzdGF0ZSBhY3RpdmF0aW9uLlxuICAgICAgcGF0aDogW3BhdGhCdWlsZGVyXSxcbiAgICAgIC8vIFNwZWVkIHVwICRzdGF0ZS5pbmNsdWRlcygpIGFzIGl0J3MgdXNlZCBhIGxvdFxuICAgICAgaW5jbHVkZXM6IFtpbmNsdWRlc0J1aWxkZXJdLFxuICAgICAgcmVzb2x2YWJsZXM6IFtyZXNvbHZhYmxlc0J1aWxkZXJdLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tCdWlsZGVyRnVuY3Rpb25dXSBmb3IgYSBzcGVjaWZpYyBbW1N0YXRlT2JqZWN0XV0gcHJvcGVydHkgKGUuZy4sIGBwYXJlbnRgLCBgdXJsYCwgb3IgYHBhdGhgKS5cbiAgICogTW9yZSB0aGFuIG9uZSBCdWlsZGVyRnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIFRoZSBCdWlsZGVyRnVuY3Rpb24ocykgd2lsbCBiZSB1c2VkIHRvIGRlZmluZSB0aGUgcHJvcGVydHkgb24gYW55IHN1YnNlcXVlbnRseSBidWlsdCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFN0YXRlIHByb3BlcnR5IGJlaW5nIHJlZ2lzdGVyZWQgZm9yLlxuICAgKiBAcGFyYW0gZm4gVGhlIEJ1aWxkZXJGdW5jdGlvbiB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYnVpbGQgdGhlIFN0YXRlIHByb3BlcnR5XG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIEJ1aWxkZXJGdW5jdGlvblxuICAgKi9cbiAgYnVpbGRlcihuYW1lOiBzdHJpbmcsIGZuOiBCdWlsZGVyRnVuY3Rpb24pOiBCdWlsZGVyRnVuY3Rpb24gfCBCdWlsZGVyRnVuY3Rpb25bXSB8IEZ1bmN0aW9uIHtcbiAgICBjb25zdCBidWlsZGVycyA9IHRoaXMuYnVpbGRlcnM7XG4gICAgY29uc3QgYXJyYXkgPSBidWlsZGVyc1tuYW1lXSB8fCBbXTtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0OiBpZiBvbmx5IG9uZSBidWlsZGVyIGV4aXN0cywgcmV0dXJuIGl0LCBlbHNlIHJldHVybiB3aG9sZSBhcmFyeS5cbiAgICBpZiAoaXNTdHJpbmcobmFtZSkgJiYgIWlzRGVmaW5lZChmbikpIHJldHVybiBhcnJheS5sZW5ndGggPiAxID8gYXJyYXkgOiBhcnJheVswXTtcbiAgICBpZiAoIWlzU3RyaW5nKG5hbWUpIHx8ICFpc0Z1bmN0aW9uKGZuKSkgcmV0dXJuO1xuXG4gICAgYnVpbGRlcnNbbmFtZV0gPSBhcnJheTtcbiAgICBidWlsZGVyc1tuYW1lXS5wdXNoKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gYnVpbGRlcnNbbmFtZV0uc3BsaWNlKGJ1aWxkZXJzW25hbWVdLmluZGV4T2YoZm4sIDEpKSAmJiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhbGwgb2YgdGhlIHByb3BlcnRpZXMgb24gYW4gZXNzZW50aWFsbHkgYmxhbmsgU3RhdGUgb2JqZWN0LCByZXR1cm5pbmcgYSBTdGF0ZSBvYmplY3Qgd2hpY2ggaGFzIGFsbCBpdHNcbiAgICogcHJvcGVydGllcyBhbmQgQVBJIGJ1aWx0LlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgYW4gdW5pbml0aWFsaXplZCBTdGF0ZSBvYmplY3RcbiAgICogQHJldHVybnMgdGhlIGJ1aWx0IFN0YXRlIG9iamVjdFxuICAgKi9cbiAgYnVpbGQoc3RhdGU6IFN0YXRlT2JqZWN0KTogU3RhdGVPYmplY3Qge1xuICAgIGNvbnN0IHsgbWF0Y2hlciwgYnVpbGRlcnMgfSA9IHRoaXM7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnROYW1lKHN0YXRlKTtcblxuICAgIGlmIChwYXJlbnQgJiYgIW1hdGNoZXIuZmluZChwYXJlbnQsIHVuZGVmaW5lZCwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBidWlsZGVycykge1xuICAgICAgaWYgKCFidWlsZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNoYWluID0gYnVpbGRlcnNba2V5XS5yZWR1Y2UoXG4gICAgICAgIChwYXJlbnRGbjogQnVpbGRlckZ1bmN0aW9uLCBzdGVwOiBCdWlsZGVyRnVuY3Rpb24pID0+IF9zdGF0ZSA9PiBzdGVwKF9zdGF0ZSwgcGFyZW50Rm4pLFxuICAgICAgICBub29wXG4gICAgICApO1xuICAgICAgc3RhdGVba2V5XSA9IGNoYWluKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgcGFyZW50TmFtZShzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICAvLyBuYW1lID0gJ2Zvby5iYXIuYmF6LioqJ1xuICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS5uYW1lIHx8ICcnO1xuICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheicsICcuKionXVxuICAgIGNvbnN0IHNlZ21lbnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBzZWdtZW50cy5wb3AoKTtcbiAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhciddIChpZ25vcmUgLioqIHNlZ21lbnQgZm9yIGZ1dHVyZSBzdGF0ZXMpXG4gICAgaWYgKGxhc3RTZWdtZW50ID09PSAnKionKSBzZWdtZW50cy5wb3AoKTtcblxuICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzdGF0ZS5wYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZXMgdGhhdCBzcGVjaWZ5IHRoZSAncGFyZW50OicgcHJvcGVydHkgc2hvdWxkIG5vdCBoYXZlIGEgJy4nIGluIHRoZWlyIG5hbWUgKCR7bmFtZX0pYCk7XG4gICAgICB9XG5cbiAgICAgIC8vICdmb28uYmFyJ1xuICAgICAgcmV0dXJuIHNlZ21lbnRzLmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLnBhcmVudCkgcmV0dXJuICcnO1xuICAgIHJldHVybiBpc1N0cmluZyhzdGF0ZS5wYXJlbnQpID8gc3RhdGUucGFyZW50IDogc3RhdGUucGFyZW50Lm5hbWU7XG4gIH1cblxuICBuYW1lKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS5uYW1lO1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgIXN0YXRlLnBhcmVudCkgcmV0dXJuIG5hbWU7XG5cbiAgICBjb25zdCBwYXJlbnROYW1lID0gaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xuICAgIHJldHVybiBwYXJlbnROYW1lID8gcGFyZW50TmFtZSArICcuJyArIG5hbWUgOiBuYW1lO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiwgX1ZpZXdEZWNsYXJhdGlvbiwgX1N0YXRlRGVjbGFyYXRpb24sIExhenlMb2FkUmVzdWx0IH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgZGVmYXVsdHMsIHZhbHVlcywgZmluZCwgaW5oZXJpdCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgcHJvcEVxIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBVcmxNYXRjaGVyIH0gZnJvbSAnLi4vdXJsL3VybE1hdGNoZXInO1xuaW1wb3J0IHsgUmVzb2x2YWJsZSB9IGZyb20gJy4uL3Jlc29sdmUvcmVzb2x2YWJsZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU3RhdGVIb29rRm4gfSBmcm9tICcuLi90cmFuc2l0aW9uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4vdGFyZ2V0U3RhdGUnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBHbG9iIH0gZnJvbSAnLi4vY29tbW9uL2dsb2InO1xuaW1wb3J0IHsgaXNPYmplY3QsIGlzRnVuY3Rpb24gfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBVSS1Sb3V0ZXIgc3RhdGUuXG4gKlxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGNyZWF0ZWQgd2hlbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tTdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogQSByZWdpc3RlcmVkIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGlzIGF1Z21lbnRlZCB3aXRoIGEgZ2V0dGVyIChbW1N0YXRlRGVjbGFyYXRpb24uJCRzdGF0ZV1dKSB3aGljaCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFtbU3RhdGVPYmplY3RdXSBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBbW1N0YXRlRGVjbGFyYXRpb25dXS5cbiAqIEVhY2ggb2YgaXRzIG93biBwcm9wZXJ0aWVzIChpLmUuLCBgaGFzT3duUHJvcGVydHlgKSBhcmUgYnVpbHQgdXNpbmcgYnVpbGRlcnMgZnJvbSB0aGUgW1tTdGF0ZUJ1aWxkZXJdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlT2JqZWN0IHtcbiAgLyoqIFRoZSBwYXJlbnQgW1tTdGF0ZU9iamVjdF1dICovXG4gIHB1YmxpYyBwYXJlbnQ6IFN0YXRlT2JqZWN0O1xuXG4gIC8qKiBUaGUgbmFtZSB1c2VkIHRvIHJlZ2lzdGVyIHRoZSBzdGF0ZSAqL1xuICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuXG4gIC8qKiBQcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBbW1N0YXRlRGVjbGFyYXRpb24uYWJzdHJhY3RdXSAqL1xuICBwdWJsaWMgYWJzdHJhY3Q6IGJvb2xlYW47XG5cbiAgLyoqIFByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gKi9cbiAgcHVibGljIHJlc29sdmU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYW55W10gfCBGdW5jdGlvbiB9IHwgYW55W107XG5cbiAgLyoqIEEgbGlzdCBvZiBbW1Jlc29sdmFibGVdXSBvYmplY3RzLiAgVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIFtbcmVzb2x2ZV1dLiAqL1xuICBwdWJsaWMgcmVzb2x2YWJsZXM6IFJlc29sdmFibGVbXTtcblxuICAvKiogUHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVQb2xpY3ldXSAqL1xuICBwdWJsaWMgcmVzb2x2ZVBvbGljeTogYW55O1xuXG4gIC8qKiBBIGNvbXBpbGVkIFVSTE1hdGNoZXIgd2hpY2ggZGV0ZWN0cyB3aGVuIHRoZSBzdGF0ZSdzIFVSTCBpcyBtYXRjaGVkICovXG4gIHB1YmxpYyB1cmw6IFVybE1hdGNoZXI7XG5cbiAgLyoqIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgc3RhdGUsIGJ1aWx0IGZyb20gdGhlIFVSTCBhbmQgW1tTdGF0ZURlY2xhcmF0aW9uLnBhcmFtc11dICovXG4gIHB1YmxpYyBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogUGFyYW0gfTtcblxuICAvKipcbiAgICogVGhlIHZpZXdzIGZvciB0aGUgc3RhdGUuXG4gICAqIE5vdGU6IGBAdWlyb3V0ZXIvY29yZWAgZG9lcyBub3QgcmVnaXN0ZXIgYSBidWlsZGVyIGZvciB2aWV3cy5cbiAgICogVGhlIGZyYW1ld29yayBzcGVjaWZpYyBjb2RlIHNob3VsZCByZWdpc3RlciBhIGB2aWV3c2AgYnVpbGRlci5cbiAgICovXG4gIHB1YmxpYyB2aWV3czogeyBba2V5OiBzdHJpbmddOiBfVmlld0RlY2xhcmF0aW9uIH07XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBbW1N0YXRlRGVjbGFyYXRpb25dXSB1c2VkIHRvIGJ1aWxkIHRoaXMgW1tTdGF0ZU9iamVjdF1dLlxuICAgKiBOb3RlOiBgdGhpc2Agb2JqZWN0IGFsc28gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gdGhlIGBzZWxmYCBkZWNsYXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc2VsZjogU3RhdGVEZWNsYXJhdGlvbjtcblxuICAvKiogVGhlIG5lYXJlc3QgcGFyZW50IFtbU3RhdGVPYmplY3RdXSB3aGljaCBoYXMgYSBVUkwgKi9cbiAgcHVibGljIG5hdmlnYWJsZTogU3RhdGVPYmplY3Q7XG5cbiAgLyoqIFRoZSBwYXJlbnQgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMgZnJvbSB0aGlzIHN0YXRlIHVwIHRvIHRoZSByb290ICovXG4gIHB1YmxpYyBwYXRoOiBTdGF0ZU9iamVjdFtdO1xuXG4gIC8qKlxuICAgKiBQcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBbW1N0YXRlRGVjbGFyYXRpb24uZGF0YV1dXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIG9ubHkgZmllbGQgb24gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dIHdoaWNoIGlzIG11dGF0ZWQuXG4gICAqIFRoZSBkZWZpbml0aW9uIG9iamVjdCdzIGBkYXRhYCBmaWVsZCBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG9iamVjdFxuICAgKiB3aGljaCBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSB0aGUgcGFyZW50IHN0YXRlIGRlZmluaXRpb24ncyBgZGF0YWAgZmllbGQuXG4gICAqL1xuICBwdWJsaWMgZGF0YTogYW55O1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyZW50IFN0YXRlcycgbmFtZXMgYXMga2V5cyBhbmRcbiAgICogdHJ1ZSBhcyB0aGVpciB2YWx1ZXMuXG4gICAqL1xuICBwdWJsaWMgaW5jbHVkZXM6IHsgW25hbWU6IHN0cmluZ106IGJvb2xlYW4gfTtcblxuICAvKiogUHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gW1tTdGF0ZURlY2xhcmF0aW9uLm9uRXhpdF1dICovXG4gIHB1YmxpYyBvbkV4aXQ6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbjtcbiAgLyoqIFByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFtbU3RhdGVEZWNsYXJhdGlvbi5vblJldGFpbl1dICovXG4gIHB1YmxpYyBvblJldGFpbjogVHJhbnNpdGlvblN0YXRlSG9va0ZuO1xuICAvKiogUHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gW1tTdGF0ZURlY2xhcmF0aW9uLm9uRW50ZXJdXSAqL1xuICBwdWJsaWMgb25FbnRlcjogVHJhbnNpdGlvblN0YXRlSG9va0ZuO1xuXG4gIC8qKiBQcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXSAqL1xuICBwdWJsaWMgbGF6eUxvYWQ6ICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uLCBzdGF0ZTogU3RhdGVEZWNsYXJhdGlvbikgPT4gUHJvbWlzZTxMYXp5TG9hZFJlc3VsdD47XG5cbiAgLyoqIFByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFtbU3RhdGVEZWNsYXJhdGlvbi5yZWRpcmVjdFRvXV0gKi9cbiAgcmVkaXJlY3RUbzpcbiAgICB8IHN0cmluZ1xuICAgIHwgKCgkdHJhbnNpdGlvbiQ6IFRyYW5zaXRpb24pID0+IFRhcmdldFN0YXRlKVxuICAgIHwgeyBzdGF0ZTogc3RyaW5nIHwgU3RhdGVEZWNsYXJhdGlvbjsgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IH07XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgX19zdGF0ZU9iamVjdENhY2hlOiB7XG4gICAgLyoqIE1pZ2h0IGJlIG51bGwgKi9cbiAgICBuYW1lR2xvYj86IEdsb2I7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0YXRlIG9iamVjdCB0byBwdXQgdGhlIHByaXZhdGUvaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbnRvLlxuICAgKiBUaGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIGxvb2tzIGxpa2U6XG4gICAqIChJbnRlcm5hbCBTdGF0ZSBPYmplY3QpIC0+IChDb3B5IG9mIFN0YXRlLnByb3RvdHlwZSkgLT4gKFN0YXRlIERlY2xhcmF0aW9uIG9iamVjdCkgLT4gKFN0YXRlIERlY2xhcmF0aW9uJ3MgcHJvdG90eXBlLi4uKVxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVEZWNsIHRoZSB1c2VyLXN1cHBsaWVkIFN0YXRlIERlY2xhcmF0aW9uXG4gICAqIEByZXR1cm5zIHtTdGF0ZU9iamVjdH0gYW4gaW50ZXJuYWwgU3RhdGUgb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKHN0YXRlRGVjbDogX1N0YXRlRGVjbGFyYXRpb24pOiBTdGF0ZU9iamVjdCB7XG4gICAgc3RhdGVEZWNsID0gU3RhdGVPYmplY3QuaXNTdGF0ZUNsYXNzKHN0YXRlRGVjbCkgPyBuZXcgc3RhdGVEZWNsKCkgOiBzdGF0ZURlY2w7XG5cbiAgICBjb25zdCBzdGF0ZSA9IGluaGVyaXQoaW5oZXJpdChzdGF0ZURlY2wsIFN0YXRlT2JqZWN0LnByb3RvdHlwZSkpIGFzIFN0YXRlT2JqZWN0O1xuICAgIHN0YXRlRGVjbC4kJHN0YXRlID0gKCkgPT4gc3RhdGU7XG4gICAgc3RhdGUuc2VsZiA9IHN0YXRlRGVjbDtcbiAgICBzdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUgPSB7XG4gICAgICBuYW1lR2xvYjogR2xvYi5mcm9tU3RyaW5nKHN0YXRlLm5hbWUpLCAvLyBtaWdodCByZXR1cm4gbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLyoqIFByZWRpY2F0ZSB3aGljaCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBjbGFzcyB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvciAqL1xuICBzdGF0aWMgaXNTdGF0ZUNsYXNzID0gKHN0YXRlRGVjbDogX1N0YXRlRGVjbGFyYXRpb24pOiBzdGF0ZURlY2wgaXMgeyBuZXcgKCk6IFN0YXRlRGVjbGFyYXRpb24gfSA9PlxuICAgIGlzRnVuY3Rpb24oc3RhdGVEZWNsKSAmJiBzdGF0ZURlY2xbJ19fdWlSb3V0ZXJTdGF0ZSddID09PSB0cnVlO1xuXG4gIC8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCAqL1xuICBzdGF0aWMgaXNTdGF0ZSA9IChvYmo6IGFueSk6IG9iaiBpcyBTdGF0ZU9iamVjdCA9PiBpc09iamVjdChvYmpbJ19fc3RhdGVPYmplY3RDYWNoZSddKTtcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFN0YXRlLmNyZWF0ZSgpICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZz86IFN0YXRlRGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4gU3RhdGVPYmplY3QuY3JlYXRlKGNvbmZpZyB8fCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdGhlIHNhbWUgc3RhdGUuXG4gICAqXG4gICAqIENvbXBhcmVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3RhdGUgYWdhaW5zdCB0aGUgcGFzc2VkIHZhbHVlLCB3aGljaCBpcyBlaXRoZXIgYW4gb2JqZWN0XG4gICAqIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHRoZSBvcmlnaW5hbCBkZWZpbml0aW9uIG9iamVjdCBwYXNzZWQgdG9cbiAgICogYCRzdGF0ZVByb3ZpZGVyLnN0YXRlKClgLCBvciB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSByZWYgQ2FuIGJlIG9uZSBvZiAoYSkgYSBgU3RhdGVgIGluc3RhbmNlLCAoYikgYW4gb2JqZWN0IHRoYXQgd2FzIHBhc3NlZFxuICAgKiAgICAgICAgaW50byBgJHN0YXRlUHJvdmlkZXIuc3RhdGUoKWAsIChjKSB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUgb2YgYSBzdGF0ZSBhcyBhIHN0cmluZy5cbiAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYHJlZmAgbWF0Y2hlcyB0aGUgY3VycmVudCBgU3RhdGVgIGluc3RhbmNlLlxuICAgKi9cbiAgaXMocmVmOiBTdGF0ZU9iamVjdCB8IFN0YXRlRGVjbGFyYXRpb24gfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gcmVmIHx8IHRoaXMuc2VsZiA9PT0gcmVmIHx8IHRoaXMuZnFuKCkgPT09IHJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB0aGlzIGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBkb3Qgbm90YXRpb25cbiAgICogQHJldHVybnMgUmV0dXJucyBhIGRvdC1zZXBhcmF0ZWQgbmFtZSBvZiB0aGUgc3RhdGUuXG4gICAqL1xuICBmcW4oKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMucGFyZW50IHx8ICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkgcmV0dXJuIHRoaXMubmFtZTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJlbnQuZnFuKCk7XG4gICAgcmV0dXJuIG5hbWUgPyBuYW1lICsgJy4nICsgdGhpcy5uYW1lIDogdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGlzIHN0YXRlJ3MgdHJlZS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHJvb3Qgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXG4gICAqL1xuICByb290KCk6IFN0YXRlT2JqZWN0IHtcbiAgICByZXR1cm4gKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnJvb3QoKSkgfHwgdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGF0ZSdzIGBQYXJhbWAgb2JqZWN0c1xuICAgKlxuICAgKiBHZXRzIHRoZSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIG93bmVkIGJ5IHRoZSBzdGF0ZS5cbiAgICogSWYgYG9wdHMuaW5oZXJpdGAgaXMgdHJ1ZSwgaXQgYWxzbyBpbmNsdWRlcyB0aGUgYW5jZXN0b3Igc3RhdGVzJyBbW1BhcmFtXV0gb2JqZWN0cy5cbiAgICogSWYgYG9wdHMubWF0Y2hpbmdLZXlzYCBleGlzdHMsIHJldHVybnMgb25seSBgUGFyYW1gcyB3aG9zZSBgaWRgIGlzIGEga2V5IG9uIHRoZSBgbWF0Y2hpbmdLZXlzYCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgcGFyYW1ldGVycyhvcHRzPzogeyBpbmhlcml0PzogYm9vbGVhbjsgbWF0Y2hpbmdLZXlzPzogYW55IH0pOiBQYXJhbVtdIHtcbiAgICBvcHRzID0gZGVmYXVsdHMob3B0cywgeyBpbmhlcml0OiB0cnVlLCBtYXRjaGluZ0tleXM6IG51bGwgfSk7XG4gICAgY29uc3QgaW5oZXJpdGVkID0gKG9wdHMuaW5oZXJpdCAmJiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wYXJhbWV0ZXJzKCkpIHx8IFtdO1xuICAgIHJldHVybiBpbmhlcml0ZWRcbiAgICAgIC5jb25jYXQodmFsdWVzKHRoaXMucGFyYW1zKSlcbiAgICAgIC5maWx0ZXIocGFyYW0gPT4gIW9wdHMubWF0Y2hpbmdLZXlzIHx8IG9wdHMubWF0Y2hpbmdLZXlzLmhhc093blByb3BlcnR5KHBhcmFtLmlkKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpbmdsZSBbW1BhcmFtXV0gdGhhdCBpcyBvd25lZCBieSB0aGUgc3RhdGVcbiAgICpcbiAgICogSWYgYG9wdHMuaW5oZXJpdGAgaXMgdHJ1ZSwgaXQgYWxzbyBzZWFyY2hlcyB0aGUgYW5jZXN0b3Igc3RhdGVzYCBbW1BhcmFtXV1zLlxuICAgKiBAcGFyYW0gaWQgdGhlIG5hbWUgb2YgdGhlIFtbUGFyYW1dXSB0byByZXR1cm5cbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgcGFyYW1ldGVyKGlkOiBzdHJpbmcsIG9wdHM6IHsgaW5oZXJpdD86IGJvb2xlYW4gfSA9IHt9KTogUGFyYW0ge1xuICAgIHJldHVybiAoXG4gICAgICAodGhpcy51cmwgJiYgdGhpcy51cmwucGFyYW1ldGVyKGlkLCBvcHRzKSkgfHxcbiAgICAgIGZpbmQodmFsdWVzKHRoaXMucGFyYW1zKSwgcHJvcEVxKCdpZCcsIGlkKSkgfHxcbiAgICAgIChvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVyKGlkKSlcbiAgICApO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnFuKCk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgc3RhdGUgKi8gLyoqICovXG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFN0YXRlT3JOYW1lIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IHZhbHVlcyB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgc2FmZUNvbnNvbGUgfSBmcm9tICcuLi9jb21tb24vc2FmZUNvbnNvbGUnO1xuXG5leHBvcnQgY2xhc3MgU3RhdGVNYXRjaGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc3RhdGVzOiB7IFtrZXk6IHN0cmluZ106IFN0YXRlT2JqZWN0IH0pIHt9XG5cbiAgaXNSZWxhdGl2ZShzdGF0ZU5hbWU6IHN0cmluZykge1xuICAgIHN0YXRlTmFtZSA9IHN0YXRlTmFtZSB8fCAnJztcbiAgICByZXR1cm4gc3RhdGVOYW1lLmluZGV4T2YoJy4nKSA9PT0gMCB8fCBzdGF0ZU5hbWUuaW5kZXhPZignXicpID09PSAwO1xuICB9XG5cbiAgZmluZChzdGF0ZU9yTmFtZTogU3RhdGVPck5hbWUsIGJhc2U/OiBTdGF0ZU9yTmFtZSwgbWF0Y2hHbG9iID0gdHJ1ZSk6IFN0YXRlT2JqZWN0IHtcbiAgICBpZiAoIXN0YXRlT3JOYW1lICYmIHN0YXRlT3JOYW1lICE9PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc1N0ciA9IGlzU3RyaW5nKHN0YXRlT3JOYW1lKTtcbiAgICBsZXQgbmFtZTogc3RyaW5nID0gaXNTdHIgPyBzdGF0ZU9yTmFtZSA6ICg8YW55PnN0YXRlT3JOYW1lKS5uYW1lO1xuXG4gICAgaWYgKHRoaXMuaXNSZWxhdGl2ZShuYW1lKSkgbmFtZSA9IHRoaXMucmVzb2x2ZVBhdGgobmFtZSwgYmFzZSk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbbmFtZV07XG5cbiAgICBpZiAoc3RhdGUgJiYgKGlzU3RyIHx8ICghaXNTdHIgJiYgKHN0YXRlID09PSBzdGF0ZU9yTmFtZSB8fCBzdGF0ZS5zZWxmID09PSBzdGF0ZU9yTmFtZSkpKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0gZWxzZSBpZiAoaXNTdHIgJiYgbWF0Y2hHbG9iKSB7XG4gICAgICBjb25zdCBfc3RhdGVzID0gdmFsdWVzKHRoaXMuX3N0YXRlcyk7XG4gICAgICBjb25zdCBtYXRjaGVzID0gX3N0YXRlcy5maWx0ZXIoXG4gICAgICAgIF9zdGF0ZSA9PiBfc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlLm5hbWVHbG9iICYmIF9zdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUubmFtZUdsb2IubWF0Y2hlcyhuYW1lKVxuICAgICAgKTtcblxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBzYWZlQ29uc29sZS5lcnJvcihcbiAgICAgICAgICBgc3RhdGVNYXRjaGVyLmZpbmQ6IEZvdW5kIG11bHRpcGxlIG1hdGNoZXMgZm9yICR7bmFtZX0gdXNpbmcgZ2xvYjogYCxcbiAgICAgICAgICBtYXRjaGVzLm1hcChtYXRjaCA9PiBtYXRjaC5uYW1lKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXNvbHZlUGF0aChuYW1lOiBzdHJpbmcsIGJhc2U6IFN0YXRlT3JOYW1lKSB7XG4gICAgaWYgKCFiYXNlKSB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlZmVyZW5jZSBwb2ludCBnaXZlbiBmb3IgcGF0aCAnJHtuYW1lfSdgKTtcblxuICAgIGNvbnN0IGJhc2VTdGF0ZTogU3RhdGVPYmplY3QgPSB0aGlzLmZpbmQoYmFzZSk7XG5cbiAgICBjb25zdCBzcGxpdE5hbWUgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgcGF0aExlbmd0aCA9IHNwbGl0TmFtZS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwLFxuICAgICAgY3VycmVudCA9IGJhc2VTdGF0ZTtcblxuICAgIGZvciAoOyBpIDwgcGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3BsaXROYW1lW2ldID09PSAnJyAmJiBpID09PSAwKSB7XG4gICAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNwbGl0TmFtZVtpXSA9PT0gJ14nKSB7XG4gICAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihgUGF0aCAnJHtuYW1lfScgbm90IHZhbGlkIGZvciBzdGF0ZSAnJHtiYXNlU3RhdGUubmFtZX0nYCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcmVsTmFtZSA9IHNwbGl0TmFtZS5zbGljZShpKS5qb2luKCcuJyk7XG4gICAgcmV0dXJuIGN1cnJlbnQubmFtZSArIChjdXJyZW50Lm5hbWUgJiYgcmVsTmFtZSA/ICcuJyA6ICcnKSArIHJlbE5hbWU7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgc3RhdGUgKi8gLyoqICovXG5pbXBvcnQgeyBpbkFycmF5LCBpc1N0cmluZywgcHJvcCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBfU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBTdGF0ZUJ1aWxkZXIgfSBmcm9tICcuL3N0YXRlQnVpbGRlcic7XG5pbXBvcnQgeyBTdGF0ZVJlZ2lzdHJ5TGlzdGVuZXIgfSBmcm9tICcuL3N0YXRlUmVnaXN0cnknO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBjbGFzcyBTdGF0ZVF1ZXVlTWFuYWdlciBpbXBsZW1lbnRzIERpc3Bvc2FibGUge1xuICBxdWV1ZTogU3RhdGVPYmplY3RbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcixcbiAgICBwdWJsaWMgc3RhdGVzOiB7IFtrZXk6IHN0cmluZ106IFN0YXRlT2JqZWN0IH0sXG4gICAgcHVibGljIGJ1aWxkZXI6IFN0YXRlQnVpbGRlcixcbiAgICBwdWJsaWMgbGlzdGVuZXJzOiBTdGF0ZVJlZ2lzdHJ5TGlzdGVuZXJbXVxuICApIHt9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuXG4gIHJlZ2lzdGVyKHN0YXRlRGVjbDogX1N0YXRlRGVjbGFyYXRpb24pIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgY29uc3Qgc3RhdGUgPSBTdGF0ZU9iamVjdC5jcmVhdGUoc3RhdGVEZWNsKTtcbiAgICBjb25zdCBuYW1lID0gc3RhdGUubmFtZTtcblxuICAgIGlmICghaXNTdHJpbmcobmFtZSkpIHRocm93IG5ldyBFcnJvcignU3RhdGUgbXVzdCBoYXZlIGEgdmFsaWQgbmFtZScpO1xuICAgIGlmICh0aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBpbkFycmF5KHF1ZXVlLm1hcChwcm9wKCduYW1lJykpLCBuYW1lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGUgJyR7bmFtZX0nIGlzIGFscmVhZHkgZGVmaW5lZGApO1xuXG4gICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgdGhpcy5mbHVzaCgpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgeyBxdWV1ZSwgc3RhdGVzLCBidWlsZGVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWQ6IFN0YXRlT2JqZWN0W10gPSBbXSwgLy8gc3RhdGVzIHRoYXQgZ290IHJlZ2lzdGVyZWRcbiAgICAgIG9ycGhhbnM6IFN0YXRlT2JqZWN0W10gPSBbXSwgLy8gc3RhdGVzIHRoYXQgZG9uJ3QgeWV0IGhhdmUgYSBwYXJlbnQgcmVnaXN0ZXJlZFxuICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aCA9IHt9OyAvLyBrZWVwIHRyYWNrIG9mIGhvdyBsb25nIHRoZSBxdWV1ZSB3aGVuIGFuIG9ycGhhbiB3YXMgZmlyc3QgZW5jb3VudGVyZWRcbiAgICBjb25zdCBnZXRTdGF0ZSA9IG5hbWUgPT4gdGhpcy5zdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5zdGF0ZXNbbmFtZV07XG4gICAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgaWYgKHJlZ2lzdGVyZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoJ3JlZ2lzdGVyZWQnLCByZWdpc3RlcmVkLm1hcChzID0+IHMuc2VsZikpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHN0YXRlOiBTdGF0ZU9iamVjdCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBjb25zdCBuYW1lID0gc3RhdGUubmFtZTtcbiAgICAgIGNvbnN0IHJlc3VsdDogU3RhdGVPYmplY3QgPSBidWlsZGVyLmJ1aWxkKHN0YXRlKTtcbiAgICAgIGNvbnN0IG9ycGhhbklkeDogbnVtYmVyID0gb3JwaGFucy5pbmRleE9mKHN0YXRlKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1N0YXRlID0gZ2V0U3RhdGUobmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZ1N0YXRlICYmIGV4aXN0aW5nU3RhdGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGUgJyR7bmFtZX0nIGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdGdXR1cmVTdGF0ZSA9IGdldFN0YXRlKG5hbWUgKyAnLioqJyk7XG4gICAgICAgIGlmIChleGlzdGluZ0Z1dHVyZVN0YXRlKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGZ1dHVyZSBzdGF0ZSBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAgdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZXJlZ2lzdGVyKGV4aXN0aW5nRnV0dXJlU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGVzW25hbWVdID0gc3RhdGU7XG4gICAgICAgIHRoaXMuYXR0YWNoUm91dGUoc3RhdGUpO1xuICAgICAgICBpZiAob3JwaGFuSWR4ID49IDApIG9ycGhhbnMuc3BsaWNlKG9ycGhhbklkeCwgMSk7XG4gICAgICAgIHJlZ2lzdGVyZWQucHVzaChzdGF0ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNRdWV1ZUxlbmd0aFtuYW1lXTtcbiAgICAgIHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV0gPSBxdWV1ZS5sZW5ndGg7XG4gICAgICBpZiAob3JwaGFuSWR4ID49IDAgJiYgcHJldiA9PT0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIC8vIFdhaXQgdW50aWwgdHdvIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnMgd2hlcmUgbm8gYWRkaXRpb25hbCBzdGF0ZXMgd2VyZSBkZXF1ZXVlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIG9ycGhhbmVkIHN0YXRlICcke25hbWV9J2ApO1xuICAgICAgICBxdWV1ZS5wdXNoKHN0YXRlKTtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgICB9IGVsc2UgaWYgKG9ycGhhbklkeCA8IDApIHtcbiAgICAgICAgb3JwaGFucy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgfVxuXG4gICAgbm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfVxuXG4gIGF0dGFjaFJvdXRlKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICAgIGlmIChzdGF0ZS5hYnN0cmFjdCB8fCAhc3RhdGUudXJsKSByZXR1cm47XG4gICAgY29uc3QgcnVsZXNBcGkgPSB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLnJ1bGVzO1xuICAgIHJ1bGVzQXBpLnJ1bGUocnVsZXNBcGkudXJsUnVsZUZhY3RvcnkuY3JlYXRlKHN0YXRlKSk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgc3RhdGUgKi8gLyoqICovXG5cbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBTdGF0ZU1hdGNoZXIgfSBmcm9tICcuL3N0YXRlTWF0Y2hlcic7XG5pbXBvcnQgeyBTdGF0ZUJ1aWxkZXIgfSBmcm9tICcuL3N0YXRlQnVpbGRlcic7XG5pbXBvcnQgeyBTdGF0ZVF1ZXVlTWFuYWdlciB9IGZyb20gJy4vc3RhdGVRdWV1ZU1hbmFnZXInO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiwgX1N0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBCdWlsZGVyRnVuY3Rpb24gfSBmcm9tICcuL3N0YXRlQnVpbGRlcic7XG5pbXBvcnQgeyBTdGF0ZU9yTmFtZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IHJlbW92ZUZyb20gfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IHByb3BFcSB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuXG4vKipcbiAqIFRoZSBzaWduYXR1cmUgZm9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBwcm92aWRlZCB0byBbW1N0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkXV0uXG4gKlxuICogVGhpcyBjYWxsYmFjayByZWNlaXZlcyB0d28gcGFyYW1ldGVyczpcbiAqXG4gKiBAcGFyYW0gZXZlbnQgYSBzdHJpbmc7IGVpdGhlciBcInJlZ2lzdGVyZWRcIiBvciBcImRlcmVnaXN0ZXJlZFwiXG4gKiBAcGFyYW0gc3RhdGVzIHRoZSBsaXN0IG9mIFtbU3RhdGVEZWNsYXJhdGlvbl1dcyB0aGF0IHdlcmUgcmVnaXN0ZXJlZCAob3IgZGVyZWdpc3RlcmVkKS5cbiAqL1xuZXhwb3J0IHR5cGUgU3RhdGVSZWdpc3RyeUxpc3RlbmVyID0gKGV2ZW50OiAncmVnaXN0ZXJlZCcgfCAnZGVyZWdpc3RlcmVkJywgc3RhdGVzOiBTdGF0ZURlY2xhcmF0aW9uW10pID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0ZVJlZ2lzdHJ5IHtcbiAgcHJpdmF0ZSBfcm9vdDogU3RhdGVPYmplY3Q7XG4gIHByaXZhdGUgc3RhdGVzOiB7IFtrZXk6IHN0cmluZ106IFN0YXRlT2JqZWN0IH0gPSB7fTtcblxuICBtYXRjaGVyOiBTdGF0ZU1hdGNoZXI7XG4gIHByaXZhdGUgYnVpbGRlcjogU3RhdGVCdWlsZGVyO1xuICBzdGF0ZVF1ZXVlOiBTdGF0ZVF1ZXVlTWFuYWdlcjtcblxuICBsaXN0ZW5lcnM6IFN0YXRlUmVnaXN0cnlMaXN0ZW5lcltdID0gW107XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICB0aGlzLm1hdGNoZXIgPSBuZXcgU3RhdGVNYXRjaGVyKHRoaXMuc3RhdGVzKTtcbiAgICB0aGlzLmJ1aWxkZXIgPSBuZXcgU3RhdGVCdWlsZGVyKHRoaXMubWF0Y2hlciwgcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5KTtcbiAgICB0aGlzLnN0YXRlUXVldWUgPSBuZXcgU3RhdGVRdWV1ZU1hbmFnZXIocm91dGVyLCB0aGlzLnN0YXRlcywgdGhpcy5idWlsZGVyLCB0aGlzLmxpc3RlbmVycyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJSb290KCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpICovXG4gIHByaXZhdGUgX3JlZ2lzdGVyUm9vdCgpIHtcbiAgICBjb25zdCByb290U3RhdGVEZWY6IFN0YXRlRGVjbGFyYXRpb24gPSB7XG4gICAgICBuYW1lOiAnJyxcbiAgICAgIHVybDogJ14nLFxuICAgICAgdmlld3M6IG51bGwsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJyMnOiB7IHZhbHVlOiBudWxsLCB0eXBlOiAnaGFzaCcsIGR5bmFtaWM6IHRydWUgfSxcbiAgICAgIH0sXG4gICAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICB9O1xuXG4gICAgY29uc3QgX3Jvb3QgPSAodGhpcy5fcm9vdCA9IHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3Rlcihyb290U3RhdGVEZWYpKTtcbiAgICBfcm9vdC5uYXZpZ2FibGUgPSBudWxsO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuc3RhdGVRdWV1ZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmdldCgpLmZvckVhY2goc3RhdGUgPT4gdGhpcy5nZXQoc3RhdGUpICYmIHRoaXMuZGVyZWdpc3RlcihzdGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBTdGF0ZSBSZWdpc3RyeSBldmVudHNcbiAgICpcbiAgICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHN0YXRlcyBhcmUgcmVnaXN0ZXJlZCBvciBkZXJlZ2lzdGVyZWQgd2l0aCB0aGUgU3RhdGVSZWdpc3RyeS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBsZXQgYWxsU3RhdGVzID0gcmVnaXN0cnkuZ2V0KCk7XG4gICAqXG4gICAqIC8vIExhdGVyLCBpbnZva2UgZGVyZWdpc3RlckZuKCkgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgKiBsZXQgZGVyZWdpc3RlckZuID0gcmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKChldmVudCwgc3RhdGVzKSA9PiB7XG4gICAqICAgc3dpdGNoKGV2ZW50KSB7XG4gICAqICAgICBjYXNlOiAncmVnaXN0ZXJlZCc6XG4gICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IGFsbFN0YXRlcy5wdXNoKHN0YXRlKSk7XG4gICAqICAgICAgIGJyZWFrO1xuICAgKiAgICAgY2FzZTogJ2RlcmVnaXN0ZXJlZCc6XG4gICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICogICAgICAgICBsZXQgaWR4ID0gYWxsU3RhdGVzLmluZGV4T2Yoc3RhdGUpO1xuICAgKiAgICAgICAgIGlmIChpZHggIT09IC0xKSBhbGxTdGF0ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgICBicmVhaztcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGxpc3RlbmVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuIHRoZSByZWdpc3RlcmVkIHN0YXRlcyBjaGFuZ2VzLlxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBwYXJhbWV0ZXJzLCBgZXZlbnRgIGFuZCBgc3RhdGVgLlxuICAgKiAgICAgICAgU2VlIFtbU3RhdGVSZWdpc3RyeUxpc3RlbmVyXV1cbiAgICogQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlcnMgdGhlIGxpc3RlbmVyXG4gICAqL1xuICBvblN0YXRlc0NoYW5nZWQobGlzdGVuZXI6IFN0YXRlUmVnaXN0cnlMaXN0ZW5lcik6ICgpID0+IHZvaWQge1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkZXJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgICByZW1vdmVGcm9tKHRoaXMubGlzdGVuZXJzKShsaXN0ZW5lcik7XG4gICAgfS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGltcGxpY2l0IHJvb3Qgc3RhdGVcbiAgICpcbiAgICogR2V0cyB0aGUgcm9vdCBvZiB0aGUgc3RhdGUgdHJlZS5cbiAgICogVGhlIHJvb3Qgc3RhdGUgaXMgaW1wbGljaXRseSBjcmVhdGVkIGJ5IFVJLVJvdXRlci5cbiAgICogTm90ZTogdGhpcyByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gcmVwcmVzZW50YXRpb24sIG5vdCBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJvb3QgW1tTdGF0ZU9iamVjdF1dXG4gICAqL1xuICByb290KCkge1xuICAgIHJldHVybiB0aGlzLl9yb290O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBzdGF0ZSB0byB0aGUgcmVnaXN0cnlcbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgcXVldWVzIGl0IGZvciByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIE5vdGU6IGEgc3RhdGUgd2lsbCBiZSBxdWV1ZWQgaWYgdGhlIHN0YXRlJ3MgcGFyZW50IGlzbid0IHlldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVEZWZpbml0aW9uIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBzdGF0ZSB0byByZWdpc3Rlci5cbiAgICogQHJldHVybnMgdGhlIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSBvYmplY3QuXG4gICAqICAgICAgICAgIElmIHRoZSBzdGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQsIHRoZW4gdGhlIG9iamVjdCBpcyBmdWxseSBidWlsdCAoU2VlOiBbW1N0YXRlQnVpbGRlcl1dKS5cbiAgICogICAgICAgICAgSWYgdGhlIHN0YXRlIHdhcyBvbmx5IHF1ZXVlZCwgdGhlbiB0aGUgb2JqZWN0IGlzIG5vdCBmdWxseSBidWlsdC5cbiAgICovXG4gIHJlZ2lzdGVyKHN0YXRlRGVmaW5pdGlvbjogX1N0YXRlRGVjbGFyYXRpb24pOiBTdGF0ZU9iamVjdCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3RlcihzdGF0ZURlZmluaXRpb24pO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfZGVyZWdpc3RlclRyZWUoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gICAgY29uc3QgYWxsID0gdGhpcy5nZXQoKS5tYXAocyA9PiBzLiQkc3RhdGUoKSk7XG4gICAgY29uc3QgZ2V0Q2hpbGRyZW4gPSAoc3RhdGVzOiBTdGF0ZU9iamVjdFtdKSA9PiB7XG4gICAgICBjb25zdCBfY2hpbGRyZW4gPSBhbGwuZmlsdGVyKHMgPT4gc3RhdGVzLmluZGV4T2Yocy5wYXJlbnQpICE9PSAtMSk7XG4gICAgICByZXR1cm4gX2NoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IF9jaGlsZHJlbiA6IF9jaGlsZHJlbi5jb25jYXQoZ2V0Q2hpbGRyZW4oX2NoaWxkcmVuKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oW3N0YXRlXSk7XG4gICAgY29uc3QgZGVyZWdpc3RlcmVkOiBTdGF0ZU9iamVjdFtdID0gW3N0YXRlXS5jb25jYXQoY2hpbGRyZW4pLnJldmVyc2UoKTtcblxuICAgIGRlcmVnaXN0ZXJlZC5mb3JFYWNoKF9zdGF0ZSA9PiB7XG4gICAgICBjb25zdCBydWxlc0FwaSA9IHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXM7XG5cbiAgICAgIC8vIFJlbW92ZSBVUkwgcnVsZVxuICAgICAgcnVsZXNBcGlcbiAgICAgICAgLnJ1bGVzKClcbiAgICAgICAgLmZpbHRlcihwcm9wRXEoJ3N0YXRlJywgX3N0YXRlKSlcbiAgICAgICAgLmZvckVhY2gocnVsZSA9PiBydWxlc0FwaS5yZW1vdmVSdWxlKHJ1bGUpKTtcblxuICAgICAgLy8gUmVtb3ZlIHN0YXRlIGZyb20gcmVnaXN0cnlcbiAgICAgIGRlbGV0ZSB0aGlzLnN0YXRlc1tfc3RhdGUubmFtZV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVyZWdpc3RlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdGF0ZSBmcm9tIHRoZSByZWdpc3RyeVxuICAgKlxuICAgKiBUaGlzIHJlbW92ZXMgYSBzdGF0ZSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICogSWYgdGhlIHN0YXRlIGhhcyBjaGlsZHJlbiwgdGhleSBhcmUgYXJlIGFsc28gcmVtb3ZlZCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JOYW1lIHRoZSBzdGF0ZSdzIG5hbWUgb3Igb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEByZXR1cm5zIHtTdGF0ZU9iamVjdFtdfSBhIGxpc3Qgb2YgcmVtb3ZlZCBzdGF0ZXNcbiAgICovXG4gIGRlcmVnaXN0ZXIoc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lKSB7XG4gICAgY29uc3QgX3N0YXRlID0gdGhpcy5nZXQoc3RhdGVPck5hbWUpO1xuICAgIGlmICghX3N0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBkZXJlZ2lzdGVyIHN0YXRlOyBub3QgZm91bmQ6IFwiICsgc3RhdGVPck5hbWUpO1xuICAgIGNvbnN0IGRlcmVnaXN0ZXJlZFN0YXRlcyA9IHRoaXMuX2RlcmVnaXN0ZXJUcmVlKF9zdGF0ZS4kJHN0YXRlKCkpO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcignZGVyZWdpc3RlcmVkJywgZGVyZWdpc3RlcmVkU3RhdGVzLm1hcChzID0+IHMuc2VsZikpKTtcbiAgICByZXR1cm4gZGVyZWdpc3RlcmVkU3RhdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHJlZ2lzdGVyZWQgc3RhdGVzXG4gICAqXG4gICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBubyBhcmd1bWVudHMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgc3RhdGVzIHRoYXQgYXJlIGN1cnJlbnRseSByZWdpc3RlcmVkLlxuICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHJldHVybiBzdGF0ZXMgdGhhdCBhcmUgKnF1ZXVlZCogYnV0IG5vdCB5ZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHJldHVybiBhIGxpc3Qgb2YgW1tTdGF0ZURlY2xhcmF0aW9uXV1zXG4gICAqL1xuICBnZXQoKTogU3RhdGVEZWNsYXJhdGlvbltdO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVnaXN0ZXJlZCBzdGF0ZVxuICAgKlxuICAgKiBHaXZlbiBhIHN0YXRlIG9yIGEgbmFtZSwgZmluZHMgYW5kIHJldHVybnMgdGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHJldHVybiBzdGF0ZXMgdGhhdCBhcmUgKnF1ZXVlZCogYnV0IG5vdCB5ZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JOYW1lIGVpdGhlciB0aGUgbmFtZSBvZiBhIHN0YXRlLCBvciBhIHN0YXRlIG9iamVjdC5cbiAgICogQHBhcmFtIGJhc2UgdGhlIGJhc2Ugc3RhdGUgdG8gdXNlIHdoZW4gc3RhdGVPck5hbWUgaXMgcmVsYXRpdmUuXG4gICAqIEByZXR1cm4gYSByZWdpc3RlcmVkIFtbU3RhdGVEZWNsYXJhdGlvbl1dIHRoYXQgbWF0Y2hlZCB0aGUgYHN0YXRlT3JOYW1lYCwgb3IgbnVsbCBpZiB0aGUgc3RhdGUgaXNuJ3QgcmVnaXN0ZXJlZC5cbiAgICovXG4gIGdldChzdGF0ZU9yTmFtZTogU3RhdGVPck5hbWUsIGJhc2U/OiBTdGF0ZU9yTmFtZSk6IFN0YXRlRGVjbGFyYXRpb247XG4gIGdldChzdGF0ZU9yTmFtZT86IFN0YXRlT3JOYW1lLCBiYXNlPzogU3RhdGVPck5hbWUpOiBhbnkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gPFN0YXRlRGVjbGFyYXRpb25bXT5PYmplY3Qua2V5cyh0aGlzLnN0YXRlcykubWFwKG5hbWUgPT4gdGhpcy5zdGF0ZXNbbmFtZV0uc2VsZik7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzLm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgYmFzZSk7XG4gICAgcmV0dXJuIChmb3VuZCAmJiBmb3VuZC5zZWxmKSB8fCBudWxsO1xuICB9XG5cbiAgZGVjb3JhdG9yKG5hbWU6IHN0cmluZywgZnVuYzogQnVpbGRlckZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRlci5idWlsZGVyKG5hbWUsIGZ1bmMpO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHRyYW5zaXRpb24gKi8gLyoqICovXG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vc3RhdGUvaW50ZXJmYWNlJztcbmltcG9ydCB7IFByZWRpY2F0ZUJpbmFyeSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IFRhcmdldFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUvdGFyZ2V0U3RhdGUnO1xuaW1wb3J0IHsgUmVnaXN0ZXJlZEhvb2sgfSBmcm9tICcuL2hvb2tSZWdpc3RyeSc7XG5cbi8qKlxuICogVGhlIFRyYW5zaXRpb25PcHRpb25zIG9iamVjdCBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIGEgdHJhbnNpdGlvbi5cbiAqXG4gKiBJdCBpcyBwYXNzZWQgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0sIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dLlxuICogSXQgY2FuIGFsc28gYmUgdXNlZCB3aXRoIGEgYHVpU3JlZmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhpcyBvcHRpb24gY2hhbmdlcyBob3cgdGhlIFRyYW5zaXRpb24gaW50ZXJhY3RzIHdpdGggdGhlIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIgKFVSTCkuXG4gICAqXG4gICAqIC0gSWYgYHRydWVgLCBpdCB3aWxsIHVwZGF0ZSB0aGUgdXJsIGluIHRoZSBsb2NhdGlvbiBiYXIuXG4gICAqIC0gSWYgYGZhbHNlYCwgaXQgd2lsbCBub3QgdXBkYXRlIHRoZSB1cmwgaW4gdGhlIGxvY2F0aW9uIGJhci5cbiAgICogLSBJZiBpdCBpcyB0aGUgc3RyaW5nIGBcInJlcGxhY2VcImAsIGl0IHdpbGwgdXBkYXRlIHRoZSB1cmwgYW5kIGFsc28gcmVwbGFjZSB0aGUgbGFzdCBoaXN0b3J5IHJlY29yZC5cbiAgICpcbiAgICogQGRlZmF1bHQgYHRydWVgXG4gICAqL1xuICBsb2NhdGlvbj86IGJvb2xlYW4gfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJhbnNpdGlvbmluZyB0byByZWxhdGl2ZSBwYXRoIChlLmcgJ2BeYCcpLCB0aGlzIG9wdGlvbiBkZWZpbmVzIHdoaWNoIHN0YXRlIHRvIGJlIHJlbGF0aXZlIGZyb20uXG4gICAqIEBkZWZhdWx0IGAkc3RhdGUuY3VycmVudGBcbiAgICovXG4gIHJlbGF0aXZlPzogc3RyaW5nIHwgU3RhdGVEZWNsYXJhdGlvbiB8IFN0YXRlT2JqZWN0O1xuXG4gIC8qKlxuICAgKiBUaGlzIG9wdGlvbiBzZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2l0aW9uJ3MgcGFyYW1ldGVyIHZhbHVlcyBzaG91bGQgYmUgaW5oZXJpdGVkIGZyb21cbiAgICogdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICpcbiAgICogLSBJZiBgdHJ1ZWAsIGl0IHdpbGwgaW5oZXJpdCBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICogLSBJZiBgZmFsc2VgLCBvbmx5IHRoZSBwYXJhbWV0ZXJzIHdoaWNoIGFyZSBwcm92aWRlZCB0byBgdHJhbnNpdGlvblRvYCB3aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIGluaGVyaXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgbm90aWZ5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhpcyBvcHRpb24gbWF5IGJlIHVzZWQgdG8gZm9yY2Ugc3RhdGVzIHdoaWNoIGFyZSBjdXJyZW50bHkgYWN0aXZlIHRvIHJlbG9hZC5cbiAgICpcbiAgICogRHVyaW5nIGEgbm9ybWFsIHRyYW5zaXRpb24sIGEgc3RhdGUgaXMgXCJyZXRhaW5lZFwiIGlmOlxuICAgKiAtIEl0IHdhcyBwcmV2aW91c2x5IGFjdGl2ZVxuICAgKiAtIFRoZSBzdGF0ZSdzIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBub3QgY2hhbmdlZFxuICAgKiAtIEFsbCB0aGUgcGFyZW50IHN0YXRlcycgcGFyYW1ldGVyIHZhbHVlcyBoYXZlIG5vdCBjaGFuZ2VkXG4gICAqXG4gICAqIEZvcmNpbmcgYSByZWxvYWQgb2YgYSBzdGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGV4aXRlZCBhbmQgZW50ZXJlZCwgd2hpY2ggd2lsbDpcbiAgICogLSBSZWZldGNoIHRoYXQgc3RhdGUncyByZXNvbHZlIGRhdGFcbiAgICogLSBFeGl0IHRoZSBzdGF0ZSAob25FeGl0IGhvb2spXG4gICAqIC0gUmUtZW50ZXIgdGhlIHN0YXRlIChvbkVudGVyIGhvb2spXG4gICAqIC0gUmUtcmVuZGVyIHRoZSB2aWV3cyAoY29udHJvbGxlcnMgYW5kIHRlbXBsYXRlcylcbiAgICpcbiAgICogLSBXaGVuIGB0cnVlYCwgdGhlIGRlc3RpbmF0aW9uIHN0YXRlIChhbmQgYWxsIHBhcmVudCBzdGF0ZXMpIHdpbGwgYmUgcmVsb2FkZWQuXG4gICAqIC0gV2hlbiBpdCBpcyBhIHN0cmluZyBhbmQgaXMgdGhlIG5hbWUgb2YgYSBzdGF0ZSwgb3Igd2hlbiBpdCBpcyBhIFN0YXRlIG9iamVjdCxcbiAgICogICB0aGF0IHN0YXRlIGFuZCBhbnkgY2hpbGRyZW4gc3RhdGVzIHdpbGwgYmUgcmVsb2FkZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIHJlbG9hZD86IGJvb2xlYW4gfCBzdHJpbmcgfCBTdGF0ZURlY2xhcmF0aW9uIHwgU3RhdGVPYmplY3Q7XG4gIC8qKlxuICAgKiBZb3UgY2FuIGRlZmluZSB5b3VyIG93biBUcmFuc2l0aW9uIE9wdGlvbnMgaW5zaWRlIHRoaXMgcHJvcGVydHkgYW5kIHVzZSB0aGVtLCBlLmcuLCBmcm9tIGEgVHJhbnNpdGlvbiBIb29rXG4gICAqL1xuICBjdXN0b20/OiBhbnk7XG4gIC8qKlxuICAgKiBUaGlzIG9wdGlvbiBtYXkgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uIChpZiBvbmUgaXMgYWN0aXZlKSBpbiBmYXZvdXIgb2YgdGhlIHRoaXMgb25lLlxuICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvciB1aS1yb3V0ZXIuXG4gICAqXG4gICAqXG4gICAqIC0gV2hlbiBgdHJ1ZWAsIHRoZSBhY3RpdmUgdHJhbnNpdGlvbiB3aWxsIGJlIGNhbmNlbGVkIGFuZCBuZXcgdHJhbnNpdGlvbiB3aWxsIGJlZ2luLlxuICAgKiAtIHdoZW4gYGZhbHNlYCwgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBjYW5jZWxlZCBpZiBhIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBydW5uaW5nLiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gY2FzZXMgd2hlcmVcbiAgICogeW91IG9ubHkgd2FudCB0byBuYXZpZ2F0ZSB0byBhIGRpZmZlcmVudCBzdGF0ZSBpZiB5b3UgYXJlIG5vdCBhbHJlYWR5IG5hdmlnYXRpbmcgc29tZXdoZXJlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgdHJ1ZWBcbiAgICovXG4gIHN1cGVyY2VkZT86IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgcmVsb2FkU3RhdGU/OiBTdGF0ZU9iamVjdDtcbiAgLyoqIEBpbnRlcm5hbGFwaVxuICAgKiBJZiB0aGlzIHRyYW5zaXRpb24gaXMgYSByZWRpcmVjdCwgdGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgdGhlIG9yaWdpbmFsIFRyYW5zaXRpb24gKHdoaWNoIHdhcyByZWRpcmVjdGVkIHRvIHRoaXMgb25lKVxuICAgKi9cbiAgcmVkaXJlY3RlZEZyb20/OiBUcmFuc2l0aW9uO1xuICAvKiogQGludGVybmFsYXBpICovXG4gIGN1cnJlbnQ/OiAoKSA9PiBUcmFuc2l0aW9uO1xuICAvKiogQGludGVybmFsYXBpICovXG4gIHNvdXJjZT86ICdzcmVmJyB8ICd1cmwnIHwgJ3JlZGlyZWN0JyB8ICdvdGhlcndpc2UnIHwgJ3Vua25vd24nO1xufVxuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zaXRpb25Ib29rT3B0aW9ucyB7XG4gIGN1cnJlbnQ/OiAoKSA9PiBUcmFuc2l0aW9uOyAvLyBwYXRoP1xuICB0cmFuc2l0aW9uPzogVHJhbnNpdGlvbjtcbiAgaG9va1R5cGU/OiBzdHJpbmc7XG4gIHRhcmdldD86IGFueTtcbiAgdHJhY2VEYXRhPzogYW55O1xuICBiaW5kPzogYW55O1xuICBzdGF0ZUhvb2s/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRyZWVDaGFuZ2VzIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBQYXRocyB0aGF0IGFyZSBpbnZvbHZlZCBpbiBhIFRyYW5zaXRpb24uXG4gKlxuICogR2V0IGEgVHJlZUNoYW5nZXMgb2JqZWN0IHVzaW5nIFtbVHJhbnNpdGlvbi50cmVlQ2hhbmdlc11dXG4gKlxuICogQSBVSS1Sb3V0ZXIgVHJhbnNpdGlvbiBpcyBmcm9tIG9uZSBQYXRoIGluIGEgU3RhdGUgVHJlZSB0byBhbm90aGVyIFBhdGguICBGb3IgYSBnaXZlbiBUcmFuc2l0aW9uLFxuICogdGhpcyBvYmplY3Qgc3RvcmVzIHRoZSBcInRvXCIgYW5kIFwiZnJvbVwiIHBhdGhzLCBhcyB3ZWxsIGFzIHN1YnNldHMgb2YgdGhvc2U6IHRoZSBcInJldGFpbmVkXCIsXG4gKiBcImV4aXRpbmdcIiBhbmQgXCJlbnRlcmluZ1wiIHBhdGhzLlxuICpcbiAqIEVhY2ggcGF0aCBpbiBUcmVlQ2hhbmdlcyBpcyBhbiBhcnJheSBvZiBbW1BhdGhOb2RlXV0gb2JqZWN0cy4gRWFjaCBQYXRoTm9kZSBpbiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gYSBwb3J0aW9uXG4gKiBvZiBhIG5lc3RlZCBzdGF0ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhZCBhIG5lc3RlZCBzdGF0ZSBuYW1lZCBgZm9vLmJhci5iYXpgLCBpdCB3b3VsZCBoYXZlIHRocmVlXG4gKiBwb3J0aW9ucywgYGZvbywgYmFyLCBiYXpgLiAgSWYgeW91IHRyYW5zaXRpb25lZCAqKnRvKiogYGZvby5iYXIuYmF6YCBhbmQgaW5zcGVjdGVkIHRoZSBbW1RyZWVDaGFuZ2VzLnRvXV1cbiAqIFBhdGgsIHlvdSB3b3VsZCBmaW5kIGEgbm9kZSBpbiB0aGUgYXJyYXkgZm9yIGVhY2ggcG9ydGlvbjogYGZvb2AsIGBiYXJgLCBhbmQgYGJhemAuXG4gKlxuICogLS0tXG4gKlxuICogQHRvZG8gc2hvdyB2aXN1YWwgc3RhdGUgdHJlZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVDaGFuZ2VzIHtcbiAgLyoqIEBub2RvYyAqL1xuICBba2V5OiBzdHJpbmddOiBQYXRoTm9kZVtdIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBUaGUgcGF0aCBvZiBub2RlcyBpbiB0aGUgc3RhdGUgdHJlZSB0aGF0IHRoZSB0cmFuc2l0aW9uIGlzIGNvbWluZyAqZnJvbSogKi9cbiAgZnJvbTogUGF0aE5vZGVbXTtcblxuICAvKiogVGhlIHBhdGggb2Ygbm9kZXMgaW4gdGhlIHN0YXRlIHRyZWUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBnb2luZyAqdG8qICovXG4gIHRvOiBQYXRoTm9kZVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCBvZiBhY3RpdmUgbm9kZXMgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyByZXRhaW5pbmcuXG4gICAqXG4gICAqIFRoZXNlIG5vZGVzIGFyZSBuZWl0aGVyIGV4aXRlZCwgbm9yIGVudGVyZWQuXG4gICAqIEJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlc2Ugbm9kZXMgYXJlIGFjdGl2ZS5cbiAgICovXG4gIHJldGFpbmVkOiBQYXRoTm9kZVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCBvZiBhY3RpdmUgbm9kZXMgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyByZXRhaW5pbmcgd2l0aCB1cGRhdGVkIFwidG8gcGFyYW1zXCIgYXBwbGllZC5cbiAgICpcbiAgICogVGhlc2Ugbm9kZXMgYXJlIG5laXRoZXIgZXhpdGVkLCBub3IgZW50ZXJlZC5cbiAgICogQmVmb3JlIGFuZCBhZnRlciB0aGUgdHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGVzZSBub2RlcyBhcmUgYWN0aXZlLlxuICAgKlxuICAgKiBUaGlzIGlzIGEgc2hhbGxvdyBjb3B5IG9mIFtbcmV0YWluZWRdXSwgYnV0IHdpdGggbmV3IChkeW5hbWljKSBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gW1t0b11dIGFwcGxpZWQuXG4gICAqL1xuICByZXRhaW5lZFdpdGhUb1BhcmFtczogUGF0aE5vZGVbXTtcblxuICAvKipcbiAgICogVGhlIHBhdGggb2YgcHJldmlvdXNseSBhY3RpdmUgbm9kZXMgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBleGl0aW5nLlxuICAgKlxuICAgKiBBZnRlciB0aGUgVHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGVzZSBub2RlcyBhcmUgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IGEgc3RhdGUgdGhhdCBpcyBiZWluZyByZWxvYWRlZCAoZHVlIHRvIHBhcmFtZXRlciB2YWx1ZXMgY2hhbmdpbmcsIG9yIGByZWxvYWQ6IHRydWVgKSBtYXkgYmUgaW4gYm90aCB0aGVcbiAgICogYGV4aXRpbmdgIGFuZCBgZW50ZXJpbmdgIHBhdGhzLlxuICAgKi9cbiAgZXhpdGluZzogUGF0aE5vZGVbXTtcblxuICAvKipcbiAgICogVGhlIHBhdGggb2Ygbm9kZXMgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBlbnRlcmluZy5cbiAgICpcbiAgICogQWZ0ZXIgdGhlIFRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlc2Ugbm9kZXMgd2lsbCBiZSBhY3RpdmUuXG4gICAqIEJlY2F1c2UgdGhleSBhcmUgZW50ZXJpbmcsIHRoZXkgaGF2ZSB0aGVpciByZXNvbHZlcyBmZXRjaGVkLCBgb25FbnRlcmAgaG9va3MgcnVuLCBhbmQgdGhlaXIgdmlld3NcbiAgICogKGNvbXBvbmVudChzKSBvciBjb250cm9sbGVyKHMpK3RlbXBsYXRlKHMpKSByZWZyZXNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBhIHN0YXRlIHRoYXQgaXMgcmVsb2FkZWQgKGR1ZSB0byBwYXJhbWV0ZXIgdmFsdWVzIGNoYW5naW5nLCBvciBgcmVsb2FkOiB0cnVlYCkgbWF5IGJlIGluIGJvdGggdGhlXG4gICAqIGBleGl0aW5nYCBhbmQgYGVudGVyaW5nYCBwYXRocy5cbiAgICovXG4gIGVudGVyaW5nOiBQYXRoTm9kZVtdO1xufVxuXG5leHBvcnQgdHlwZSBJSG9va1JlZ2lzdHJhdGlvbiA9IChcbiAgbWF0Y2hDcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsXG4gIGNhbGxiYWNrOiBIb29rRm4sXG4gIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9uc1xuKSA9PiBGdW5jdGlvbjtcblxuLyoqXG4gKiBUaGUgc2lnbmF0dXJlIGZvciBUcmFuc2l0aW9uIEhvb2tzLlxuICpcbiAqIFRyYW5zaXRpb24gaG9va3MgYXJlIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGhvb2sgaW50byB0aGUgbGlmZWN5Y2xlIG9mIHRyYW5zaXRpb25zLlxuICogQXMgYSB0cmFuc2l0aW9uIHJ1bnMsIGl0IHJlYWNoZXMgY2VydGFpbiBsaWZlY3ljbGUgZXZlbnRzLlxuICogQXMgZWFjaCBldmVudCBvY2N1cnMsIHRoZSBob29rcyB3aGljaCBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhlIGV2ZW50IGFyZSBjYWxsZWQgKGluIHByaW9yaXR5IG9yZGVyKS5cbiAqXG4gKiBBIHRyYW5zaXRpb24gaG9vayBtYXkgYWx0ZXIgYSBUcmFuc2l0aW9uIGJ5IHJldHVybmluZyBhIFtbSG9va1Jlc3VsdF1dLlxuICpcbiAqICMjIyMgU2VlOlxuICpcbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uQmVmb3JlXV1cbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uU3RhcnRdXVxuICogLSBbW0lIb29rUmVnaXN0cnkub25GaW5pc2hdXVxuICogLSBbW0lIb29rUmVnaXN0cnkub25TdWNjZXNzXV1cbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uRXJyb3JdXVxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIHRoZSBjdXJyZW50IFtbVHJhbnNpdGlvbl1dXG4gKiBAcGFyYW0gaW5qZWN0b3IgKGZvciBuZzEgb3IgbmcyIG9ubHkpIHRoZSBpbmplY3RvciBzZXJ2aWNlXG4gKlxuICogQHJldHVybnMgYSBbW0hvb2tSZXN1bHRdXSB3aGljaCBtYXkgYWx0ZXIgdGhlIHRyYW5zaXRpb25cbiAqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNpdGlvbkhvb2tGbiB7XG4gICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKTogSG9va1Jlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgc2lnbmF0dXJlIGZvciBUcmFuc2l0aW9uIFN0YXRlIEhvb2tzLlxuICpcbiAqIEEgZnVuY3Rpb24gd2hpY2ggaG9va3MgaW50byBhIGxpZmVjeWNsZSBldmVudCBmb3IgYSBzcGVjaWZpYyBzdGF0ZS5cbiAqXG4gKiBUcmFuc2l0aW9uIFN0YXRlIEhvb2tzIGFyZSBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBob29rIGludG8gdGhlIGxpZmVjeWNsZSBldmVudHMgb2Ygc3BlY2lmaWMgc3RhdGVzIGR1cmluZyBhIHRyYW5zaXRpb24uXG4gKiBBcyBhIHRyYW5zaXRpb24gcnVucywgaXQgbWF5IGV4aXQgc29tZSBzdGF0ZXMsIHJldGFpbiAoa2VlcCkgc3RhdGVzLCBhbmQgZW50ZXIgc3RhdGVzLlxuICogQXMgZWFjaCBsaWZlY3ljbGUgZXZlbnQgb2NjdXJzLCB0aGUgaG9va3Mgd2hpY2ggYXJlIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCBhbmQgdGhhdCBzdGF0ZSBhcmUgY2FsbGVkIChpbiBwcmlvcml0eSBvcmRlcikuXG4gKlxuICogIyMjIyBTZWU6XG4gKlxuICogLSBbW0lIb29rUmVnaXN0cnkub25FeGl0XV1cbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uUmV0YWluXV1cbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uRW50ZXJdXVxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIHRoZSBjdXJyZW50IFtbVHJhbnNpdGlvbl1dXG4gKiBAcGFyYW0gc3RhdGUgdGhlIFtbU3RhdGVPYmplY3RdXSB0aGF0IHRoZSBob29rIGlzIGJvdW5kIHRvXG4gKiBAcGFyYW0gaW5qZWN0b3IgKGZvciBuZzEgb3IgbmcyIG9ubHkpIHRoZSBpbmplY3RvciBzZXJ2aWNlXG4gKlxuICogQHJldHVybnMgYSBbW0hvb2tSZXN1bHRdXSB3aGljaCBtYXkgYWx0ZXIgdGhlIHRyYW5zaXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2l0aW9uU3RhdGVIb29rRm4ge1xuICAodHJhbnNpdGlvbjogVHJhbnNpdGlvbiwgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pOiBIb29rUmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBzaWduYXR1cmUgZm9yIFRyYW5zaXRpb24gb25DcmVhdGUgSG9va3MuXG4gKlxuICogVHJhbnNpdGlvbiBvbkNyZWF0ZSBIb29rcyBhcmUgY2FsbGJhY2tzIHRoYXQgYWxsb3cgY3VzdG9taXphdGlvbiBvciBwcmVwcm9jZXNzaW5nIG9mXG4gKiBhIFRyYW5zaXRpb24gYmVmb3JlIGl0IGlzIHJldHVybmVkIGZyb20gW1tUcmFuc2l0aW9uU2VydmljZS5jcmVhdGVdXVxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIHRoZSBbW1RyYW5zaXRpb25dXSB0aGF0IHdhcyBqdXN0IGNyZWF0ZWRcbiAqIEByZXR1cm4gYSBbW1RyYW5zaXRpb25dXSB3aGljaCB3aWxsIHRoZW4gYmUgcmV0dXJuZWQgZnJvbSBbW1RyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZV1dXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNpdGlvbkNyZWF0ZUhvb2tGbiB7XG4gICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgSG9va0ZuID0gVHJhbnNpdGlvbkhvb2tGbiB8IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiB8IFRyYW5zaXRpb25DcmVhdGVIb29rRm47XG5cbi8qKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dIG9yIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV1cbiAqXG4gKiBXaGVuIHJldHVybmVkIGZyb20gYSBbW1RyYW5zaXRpb25Ib29rRm5dXSBvciBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dLCB0aGVzZSB2YWx1ZXMgYWx0ZXIgdGhlIHJ1bm5pbmcgW1tUcmFuc2l0aW9uXV06XG4gKlxuICogLSBgZmFsc2VgOiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGNhbmNlbGxlZC5cbiAqIC0gW1tUYXJnZXRTdGF0ZV1dOiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHJlZGlyZWN0ZWQgdG8gdGhlIG5ldyB0YXJnZXQgc3RhdGUgKHNlZTogW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0pXG4gKiAtIGBQcm9taXNlYDogdGhlIHRyYW5zaXRpb24gd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIG9yIHJlamVjdFxuICogICAgLSBJZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCAob3IgcmVzb2x2ZXMgdG8gYGZhbHNlYCksIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgY2FuY2VsbGVkXG4gKiAgICAtIElmIHRoZSBwcm9taXNlIHJlc29sdmVzIHRvIGEgW1tUYXJnZXRTdGF0ZV1dLCB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHJlZGlyZWN0ZWRcbiAqICAgIC0gSWYgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYW55dGhpbmcgZWxzZSwgdGhlIHRyYW5zaXRpb24gd2lsbCByZXN1bWVcbiAqIC0gQW55dGhpbmcgZWxzZTogdGhlIHRyYW5zaXRpb24gd2lsbCByZXN1bWVcbiAqL1xuZXhwb3J0IHR5cGUgSG9va1Jlc3VsdCA9IGJvb2xlYW4gfCBUYXJnZXRTdGF0ZSB8IHZvaWQgfCBQcm9taXNlPGJvb2xlYW4gfCBUYXJnZXRTdGF0ZSB8IHZvaWQ+O1xuXG4vKipcbiAqIFRoZXNlIG9wdGlvbnMgbWF5IGJlIHByb3ZpZGVkIHdoZW4gcmVnaXN0ZXJpbmcgYSBUcmFuc2l0aW9uIEhvb2sgKHN1Y2ggYXMgYG9uU3RhcnRgKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhvb2tSZWdPcHRpb25zIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHByaW9yaXR5IG9mIHRoZSByZWdpc3RlcmVkIGhvb2tcbiAgICpcbiAgICogSG9va3Mgb2YgdGhlIHNhbWUgdHlwZSAob25CZWZvcmUsIG9uU3RhcnQsIGV0YykgYXJlIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuICBBIGhvb2sgd2l0aCBhIGhpZ2hlciBwcmlvcml0eVxuICAgKiBpcyBpbnZva2VkIGJlZm9yZSBhIGhvb2sgd2l0aCBhIGxvd2VyIHByaW9yaXR5LlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBob29rIHByaW9yaXR5IGlzIDBcbiAgICovXG4gIHByaW9yaXR5PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgd2hhdCBgdGhpc2AgaXMgYm91bmQgdG8gZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cbiAgICovXG4gIGJpbmQ/OiBhbnk7XG5cbiAgLyoqXG4gICAqIExpbWl0cyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIGhvb2sgd2lsbCBiZSBpbnZva2VkLlxuICAgKiBPbmNlIHRoZSBob29rIGhhcyBiZWVuIGludm9rZWQgdGhpcyBtYW55IHRpbWVzLCBpdCBpcyBhdXRvbWF0aWNhbGx5IGRlcmVnaXN0ZXJlZC5cbiAgICovXG4gIGludm9rZUxpbWl0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIHNwZWNpZmllcyB0aGUgYXBpIGZvciByZWdpc3RlcmluZyBUcmFuc2l0aW9uIEhvb2tzLiAgQm90aCB0aGVcbiAqIFtbVHJhbnNpdGlvblNlcnZpY2VdXSBhbmQgYWxzbyB0aGUgW1tUcmFuc2l0aW9uXV0gb2JqZWN0IGl0c2VsZiBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UuXG4gKiBOb3RlOiB0aGUgVHJhbnNpdGlvbiBvYmplY3Qgb25seSBhbGxvd3MgaG9va3MgdG8gYmUgcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIFRyYW5zaXRpb24gaXMgc3RhcnRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJSG9va1JlZ2lzdHJ5IHtcbiAgLyoqIEBoaWRkZW4gcGxhY2UgdG8gc3RvcmUgdGhlIGhvb2tzICovXG4gIF9yZWdpc3RlcmVkSG9va3M6IHsgW2tleTogc3RyaW5nXTogUmVnaXN0ZXJlZEhvb2tbXSB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSwgY2FsbGVkICpiZWZvcmUgYSB0cmFuc2l0aW9uIHN0YXJ0cyouXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgYmVmb3JlIGEgdHJhbnNpdGlvbiBldmVuIGJlZ2lucy5cbiAgICogVGhpcyBob29rIGNhbiBiZSB1c2VmdWwgdG8gaW1wbGVtZW50IGxvZ2ljIHdoaWNoIHByZXZlbnRzIGEgdHJhbnNpdGlvbiBmcm9tIGV2ZW4gc3RhcnRpbmcsIHN1Y2hcbiAgICogYXMgYXV0aGVudGljYXRpb24sIHJlZGlyZWN0aW9uXG4gICAqXG4gICAqIFNlZSBbW1RyYW5zaXRpb25Ib29rRm5dXSBmb3IgdGhlIHNpZ25hdHVyZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoZSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIGhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBUbyBtYXRjaCBhbGwgVHJhbnNpdGlvbnMsIHVzZSBhbiBlbXB0eSBjcml0ZXJpYSBvYmplY3QgYHt9YC5cbiAgICpcbiAgICogIyMjIExpZmVjeWNsZVxuICAgKlxuICAgKiBgb25CZWZvcmVgIGhvb2tzIGFyZSBpbnZva2VkICpiZWZvcmUgYSBUcmFuc2l0aW9uIHN0YXJ0cyouXG4gICAqIE5vIHJlc29sdmVzIGhhdmUgYmVlbiBmZXRjaGVkIHlldC5cbiAgICogRWFjaCBgb25CZWZvcmVgIGhvb2sgaXMgaW52b2tlZCBzeW5jaHJvbm91c2x5LCBpbiB0aGUgc2FtZSBjYWxsIHN0YWNrIGFzIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dLlxuICAgKiBUaGUgcmVnaXN0ZXJlZCBgb25CZWZvcmVgIGhvb2tzIGFyZSBpbnZva2VkIGluIHByaW9yaXR5IG9yZGVyLlxuICAgKlxuICAgKiBOb3RlOiBkdXJpbmcgdGhlIGBvbkJlZm9yZWAgcGhhc2UsIGFkZGl0aW9uYWwgaG9va3MgY2FuIGJlIGFkZGVkIHRvIHRoZSBzcGVjaWZpYyBbW1RyYW5zaXRpb25dXSBpbnN0YW5jZS5cbiAgICogVGhlc2UgXCJvbi10aGUtZmx5XCIgaG9va3Mgb25seSBhZmZlY3QgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRyYW5zaXRpb24uLlxuICAgKlxuICAgKiAjIyMgUmV0dXJuIHZhbHVlXG4gICAqXG4gICAqIFRoZSBob29rJ3MgcmV0dXJuIHZhbHVlIGNhbiBiZSB1c2VkIHRvIHBhdXNlLCBjYW5jZWwsIG9yIHJlZGlyZWN0IHRoZSBjdXJyZW50IFRyYW5zaXRpb24uXG4gICAqIFNlZSBbW0hvb2tSZXN1bHRdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogSWYgYW55IGhvb2sgbW9kaWZpZXMgdGhlIHRyYW5zaXRpb24gKnN5bmNocm9ub3VzbHkqIChieSB0aHJvd2luZywgcmV0dXJuaW5nIGBmYWxzZWAsIG9yIHJldHVybmluZ1xuICAgKiBhIFtbVGFyZ2V0U3RhdGVdXSksIHRoZSByZW1haW5kZXIgb2YgdGhlIGhvb2tzIGFyZSBza2lwcGVkLlxuICAgKiBJZiBhIGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZSByZW1haW5kZXIgb2YgdGhlIGBvbkJlZm9yZWAgaG9va3MgYXJlIHN0aWxsIGludm9rZWQgc3luY2hyb25vdXNseS5cbiAgICogQWxsIHByb21pc2VzIGFyZSByZXNvbHZlZCwgYW5kIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseSBiZWZvcmUgdGhlIGBvblN0YXJ0YCBwaGFzZSBvZiB0aGUgVHJhbnNpdGlvbi5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVzXG4gICAqXG4gICAqICMjIyMgRGVmYXVsdCBTdWJzdGF0ZVxuICAgKlxuICAgKiBUaGlzIGV4YW1wbGUgcmVkaXJlY3RzIGFueSB0cmFuc2l0aW9uIGZyb20gJ2hvbWUnIHRvICdob21lLmRhc2hib2FyZCcuICBUaGlzIGlzIGNvbW1vbmx5IHJlZmVycmVkIHRvIGFzIGFcbiAgICogXCJkZWZhdWx0IHN1YnN0YXRlXCIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC8vIG5nMlxuICAgKiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7IHRvOiAnaG9tZScgfSwgKHRyYW5zOiBUcmFuc2l0aW9uKSA9PlxuICAgKiAgICAgdHJhbnMucm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQoXCJob21lLmRhc2hib2FyZFwiKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIERhdGEgRHJpdmVuIERlZmF1bHQgU3Vic3RhdGVcbiAgICpcbiAgICogVGhpcyBleGFtcGxlIHByb3ZpZGVzIGRhdGEtZHJpdmVuIGRlZmF1bHQgc3Vic3RhdGUgZnVuY3Rpb25hbGl0eS4gSXQgbWF0Y2hlcyBvbiBhIHRyYW5zaXRpb24gdG8gYW55IHN0YXRlXG4gICAqIHdoaWNoIGhhcyBgZGVmYXVsdFN1YnN0YXRlOiBcInNvbWUuc3ViLnN0YXRlXCJgIGRlZmluZWQuICBTZWU6IFtbVHJhbnNpdGlvbi50b11dIHdoaWNoIHJldHVybnMgdGhlIFwidG8gc3RhdGVcIlxuICAgKiBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAvLyBuZzFcbiAgICogLy8gc3RhdGUgZGVjbGFyYXRpb25cbiAgICoge1xuICAgKiAgIG5hbWU6ICdob21lJyxcbiAgICogICB0ZW1wbGF0ZTogJzxkaXYgdWktdmlldy8+JyxcbiAgICogICBkZWZhdWx0U3Vic3RhdGU6ICdob21lLmRhc2hib2FyZCdcbiAgICogfVxuICAgKlxuICAgKiB2YXIgY3JpdGVyaWEgPSB7XG4gICAqICAgdG86IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAqICAgICByZXR1cm4gc3RhdGUuZGVmYXVsdFN1YnN0YXRlICE9IG51bGw7XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqICR0cmFuc2l0aW9ucy5vbkJlZm9yZShjcml0ZXJpYSwgZnVuY3Rpb24odHJhbnM6IFRyYW5zaXRpb24pIHtcbiAgICogICB2YXIgc3Vic3RhdGUgPSB0cmFucy50bygpLmRlZmF1bHRTdWJzdGF0ZTtcbiAgICogICByZXR1cm4gdHJhbnMucm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQoc3Vic3RhdGUpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqICMjIyMgUmVxdWlyZSBhdXRoZW50aWNhdGlvblxuICAgKlxuICAgKiBUaGlzIGV4YW1wbGUgY2FuY2VscyBhIHRyYW5zaXRpb24gdG8gYSBzdGF0ZSB3aGljaCByZXF1aXJlcyBhdXRoZW50aWNhdGlvbiwgaWYgdGhlIHVzZXIgaXMgbm90IGN1cnJlbnRseSBhdXRoZW50aWNhdGVkLlxuICAgKlxuICAgKiBUaGlzIGV4YW1wbGUgYXNzdW1lcyBhIHN0YXRlIHRyZWUgd2hlcmUgYWxsIHN0YXRlcyB3aGljaCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uIGFyZSBjaGlsZHJlbiBvZiBhIHBhcmVudCBgJ3JlcXVpcmVhdXRoJ2Agc3RhdGUuXG4gICAqIFRoaXMgZXhhbXBsZSBhc3N1bWVzIGBNeUF1dGhTZXJ2aWNlYCBzeW5jaHJvbm91c2x5IHJldHVybnMgYSBib29sZWFuIGZyb20gYGlzQXV0aGVudGljYXRlZCgpYC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAvLyBuZzFcbiAgICogJHRyYW5zaXRpb25zLm9uQmVmb3JlKCB7IHRvOiAncmVxdWlyZWF1dGguKionIH0sIGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAqICAgdmFyIG15QXV0aFNlcnZpY2UgPSB0cmFucy5pbmplY3RvcigpLmdldCgnTXlBdXRoU2VydmljZScpO1xuICAgKiAgIC8vIElmIGlzQXV0aGVudGljYXRlZCByZXR1cm5zIGZhbHNlLCB0aGUgdHJhbnNpdGlvbiBpcyBjYW5jZWxsZWQuXG4gICAqICAgcmV0dXJuIG15QXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG1hdGNoQ3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvbkJlZm9yZShtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSwgY2FsbGVkIHdoZW4gYSB0cmFuc2l0aW9uIHN0YXJ0cy5cbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCBhcyBhIHRyYW5zaXRpb24gc3RhcnRzIHJ1bm5pbmcuXG4gICAqIFRoaXMgaG9vayBjYW4gYmUgdXNlZnVsIHRvIHBlcmZvcm0gc29tZSBhc3luY2hyb25vdXMgYWN0aW9uIGJlZm9yZSBjb21wbGV0aW5nIGEgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogU2VlIFtbVHJhbnNpdGlvbkhvb2tGbl1dIGZvciB0aGUgc2lnbmF0dXJlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhlIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBUcmFuc2l0aW9ucyB0aGUgaG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIFRvIG1hdGNoIGFsbCBUcmFuc2l0aW9ucywgdXNlIGFuIGVtcHR5IGNyaXRlcmlhIG9iamVjdCBge31gLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIGBvblN0YXJ0YCBob29rcyBhcmUgaW52b2tlZCBhc3luY2hyb25vdXNseSB3aGVuIHRoZSBUcmFuc2l0aW9uIHN0YXJ0cyBydW5uaW5nLlxuICAgKiBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIGBvbkJlZm9yZWAgcGhhc2UgaXMgY29tcGxldGUuXG4gICAqIEF0IHRoaXMgcG9pbnQsIHRoZSBUcmFuc2l0aW9uIGhhcyBub3QgeWV0IGV4aXRlZCBub3IgZW50ZXJlZCBhbnkgc3RhdGVzLlxuICAgKiBUaGUgcmVnaXN0ZXJlZCBgb25TdGFydGAgaG9va3MgYXJlIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuXG4gICAqXG4gICAqIE5vdGU6IEEgYnVpbHQtaW4gYG9uU3RhcnRgIGhvb2sgd2l0aCBoaWdoIHByaW9yaXR5IGlzIHVzZWQgdG8gZmV0Y2ggYW55IGVhZ2VyIHJlc29sdmUgZGF0YS5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byBwYXVzZSwgY2FuY2VsLCBvciByZWRpcmVjdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uLlxuICAgKiBTZWUgW1tIb29rUmVzdWx0XV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqICMjIyMgTG9naW4gZHVyaW5nIHRyYW5zaXRpb25cbiAgICpcbiAgICogVGhpcyBleGFtcGxlIGludGVyY2VwdHMgYW55IHRyYW5zaXRpb24gdG8gYSBzdGF0ZSB3aGljaCByZXF1aXJlcyBhdXRoZW50aWNhdGlvbiwgd2hlbiB0aGUgdXNlciBpc1xuICAgKiBub3QgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQuICBJdCBhbGxvd3MgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFzeW5jaHJvbm91c2x5LCB0aGVuIHJlc3VtZXMgdGhlXG4gICAqIHRyYW5zaXRpb24uICBJZiB0aGUgdXNlciBkaWQgbm90IGF1dGhlbnRpY2F0ZSBzdWNjZXNzZnVsbHksIGl0IHJlZGlyZWN0cyB0byB0aGUgXCJndWVzdFwiIHN0YXRlLCB3aGljaFxuICAgKiBkb2VzIG5vdCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBUaGlzIGV4YW1wbGUgYXNzdW1lczpcbiAgICogLSBhIHN0YXRlIHRyZWUgd2hlcmUgYWxsIHN0YXRlcyB3aGljaCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uIGFyZSBjaGlsZHJlbiBvZiBhIHBhcmVudCBgJ2F1dGgnYCBzdGF0ZS5cbiAgICogLSBgTXlBdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKWAgc3luY2hyb25vdXNseSByZXR1cm5zIGEgYm9vbGVhbi5cbiAgICogLSBgTXlBdXRoU2VydmljZS5hdXRoZW50aWNhdGUoKWAgcHJlc2VudHMgYSBsb2dpbiBkaWFsb2csIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZFxuICAgKiAgIG9yIHJlamVjdGVkLCB3aGV0aGVyIG9yIG5vdCB0aGUgbG9naW4gYXR0ZW1wdCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAvLyBuZzFcbiAgICogJHRyYW5zaXRpb25zLm9uU3RhcnQoIHsgdG86ICdhdXRoLioqJyB9LCBmdW5jdGlvbih0cmFucykge1xuICAgKiAgIHZhciAkc3RhdGUgPSB0cmFucy5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgKiAgIHZhciBNeUF1dGhTZXJ2aWNlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ015QXV0aFNlcnZpY2UnKTtcbiAgICpcbiAgICogICAvLyBJZiB0aGUgdXNlciBpcyBub3QgYXV0aGVudGljYXRlZFxuICAgKiAgIGlmICghTXlBdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgKlxuICAgKiAgICAgLy8gVGhlbiByZXR1cm4gYSBwcm9taXNlIGZvciBhIHN1Y2Nlc3NmdWwgbG9naW4uXG4gICAqICAgICAvLyBUaGUgdHJhbnNpdGlvbiB3aWxsIHdhaXQgZm9yIHRoaXMgcHJvbWlzZSB0byBzZXR0bGVcbiAgICpcbiAgICogICAgIHJldHVybiBNeUF1dGhTZXJ2aWNlLmF1dGhlbnRpY2F0ZSgpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgKlxuICAgKiAgICAgICAvLyBJZiB0aGUgYXV0aGVudGljYXRlKCkgbWV0aG9kIGZhaWxlZCBmb3Igd2hhdGV2ZXIgcmVhc29uLFxuICAgKiAgICAgICAvLyByZWRpcmVjdCB0byBhICdndWVzdCcgc3RhdGUgd2hpY2ggZG9lc24ndCByZXF1aXJlIGF1dGguXG4gICAqICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KFwiZ3Vlc3RcIik7XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG1hdGNoQ3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGluamVjdGVkIGFuZCBpbnZva2VkLlxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgKi9cbiAgb25TdGFydChtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dLCBjYWxsZWQgd2hlbiBhIHNwZWNpZmljIHN0YXRlIGlzIGVudGVyZWQuXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIChkdXJpbmcgYSB0cmFuc2l0aW9uKSB3aGVuIGEgc3BlY2lmaWMgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAgICpcbiAgICogU2luY2UgdGhpcyBob29rIGlzIHJ1biBvbmx5IHdoZW4gdGhlIHNwZWNpZmljIHN0YXRlIGlzIGJlaW5nICplbnRlcmVkKiwgaXQgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICogcGVyZm9ybWluZyB0YXNrcyB3aGVuIGVudGVyaW5nIGEgc3VibW9kdWxlL2ZlYXR1cmUgYXJlYSBzdWNoIGFzIGluaXRpYWxpemluZyBhIHN0YXRlZnVsIHNlcnZpY2UsXG4gICAqIG9yIGZvciBndWFyZGluZyBhY2Nlc3MgdG8gYSBzdWJtb2R1bGUvZmVhdHVyZSBhcmVhLlxuICAgKlxuICAgKiBTZWUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3IgdGhlIHNpZ25hdHVyZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoZSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIGhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBgb25FbnRlcmAgaG9va3MgZ2VuZXJhbGx5IHNwZWNpZnkgYHsgZW50ZXJpbmc6ICdzb21lc3RhdGUnIH1gLlxuICAgKiBUbyBtYXRjaCBhbGwgVHJhbnNpdGlvbnMsIHVzZSBhbiBlbXB0eSBjcml0ZXJpYSBvYmplY3QgYHt9YC5cbiAgICpcbiAgICogIyMjIExpZmVjeWNsZVxuICAgKlxuICAgKiBgb25FbnRlcmAgaG9va3MgYXJlIGludm9rZWQgd2hlbiB0aGUgVHJhbnNpdGlvbiBpcyBlbnRlcmluZyBhIHN0YXRlLlxuICAgKiBTdGF0ZXMgYXJlIGVudGVyZWQgYWZ0ZXIgdGhlIGBvblJldGFpbmAgcGhhc2UgaXMgY29tcGxldGUuXG4gICAqIElmIG1vcmUgdGhhbiBvbmUgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZCwgdGhlIHBhcmVudCBzdGF0ZSBpcyBlbnRlcmVkIGZpcnN0LlxuICAgKiBUaGUgcmVnaXN0ZXJlZCBgb25FbnRlcmAgaG9va3MgZm9yIGEgc3RhdGUgYXJlIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuXG4gICAqXG4gICAqIE5vdGU6IEEgYnVpbHQtaW4gYG9uRW50ZXJgIGhvb2sgd2l0aCBoaWdoIHByaW9yaXR5IGlzIHVzZWQgdG8gZmV0Y2ggbGF6eSByZXNvbHZlIGRhdGEgZm9yIHN0YXRlcyBiZWluZyBlbnRlcmVkLlxuICAgKlxuICAgKiAjIyMgUmV0dXJuIHZhbHVlXG4gICAqXG4gICAqIFRoZSBob29rJ3MgcmV0dXJuIHZhbHVlIGNhbiBiZSB1c2VkIHRvIHBhdXNlLCBjYW5jZWwsIG9yIHJlZGlyZWN0IHRoZSBjdXJyZW50IFRyYW5zaXRpb24uXG4gICAqIFNlZSBbW0hvb2tSZXN1bHRdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogIyMjIEluc2lkZSBhIHN0YXRlIGRlY2xhcmF0aW9uXG4gICAqXG4gICAqIEluc3RlYWQgb2YgcmVnaXN0ZXJpbmcgYG9uRW50ZXJgIGhvb2tzIHVzaW5nIHRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0sIHlvdSBtYXkgZGVmaW5lIGFuIGBvbkVudGVyYCBob29rXG4gICAqIGRpcmVjdGx5IG9uIGEgc3RhdGUgZGVjbGFyYXRpb24gKHNlZTogW1tTdGF0ZURlY2xhcmF0aW9uLm9uRW50ZXJdXSkuXG4gICAqXG4gICAqXG4gICAqICMjIyBFeGFtcGxlc1xuICAgKlxuICAgKiAjIyMjIEF1ZGl0IExvZ1xuICAgKlxuICAgKiBUaGlzIGV4YW1wbGUgdXNlcyBhIHNlcnZpY2UgdG8gbG9nIHRoYXQgYSB1c2VyIGhhcyBlbnRlcmVkIHRoZSBhZG1pbiBzZWN0aW9uIG9mIGFuIGFwcC5cbiAgICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlcmUgYXJlIHN1YnN0YXRlcyBvZiB0aGUgXCJhZG1pblwiIHN0YXRlLCBzdWNoIGFzIFwiYWRtaW4udXNlcnNcIiwgXCJhZG1pbi5wYWdlc1wiLCBldGMuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKlxuICAgKiAkdHJhbnNpdGlvbnMub25FbnRlcih7IGVudGVyaW5nOiAnYWRtaW4nIH0sIGZ1bmN0aW9uKHRyYW5zaXRpb24sIHN0YXRlKSB7XG4gICAqICAgdmFyIEF1ZGl0U2VydmljZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdBdWRpdFNlcnZpY2UnKTtcbiAgICogICBBdWRpdFNlcnZpY2UubG9nKFwiRW50ZXJlZCBcIiArIHN0YXRlLm5hbWUgKyBcIiBtb2R1bGUgd2hpbGUgdHJhbnNpdGlvbmluZyB0byBcIiArIHRyYW5zaXRpb24udG8oKS5uYW1lKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBBdWRpdCBMb2cgKGluc2lkZSBhIHN0YXRlIGRlY2xhcmF0aW9uKVxuICAgKlxuICAgKiBUaGUgYG9uRW50ZXJgIGluc2lkZSB0aGlzIHN0YXRlIGRlY2xhcmF0aW9uIGlzIHN5bnRhY3RpYyBzdWdhciBmb3IgdGhlIHByZXZpb3VzIEF1ZGl0IExvZyBleGFtcGxlLlxuICAgKiBgYGBcbiAgICoge1xuICAgKiAgIG5hbWU6ICdhZG1pbicsXG4gICAqICAgY29tcG9uZW50OiAnYWRtaW4nLFxuICAgKiAgIG9uRW50ZXI6IGZ1bmN0aW9uKCR0cmFuc2l0aW9uJCwgJHN0YXRlJCkge1xuICAgKiAgICAgdmFyIEF1ZGl0U2VydmljZSA9ICR0cmFuc2l0aW9uJC5pbmplY3RvcigpLmdldCgnQXVkaXRTZXJ2aWNlJyk7XG4gICAqICAgICBBdWRpdFNlcnZpY2UubG9nKFwiRW50ZXJlZCBcIiArIHN0YXRlLm5hbWUgKyBcIiBtb2R1bGUgd2hpbGUgdHJhbnNpdGlvbmluZyB0byBcIiArIHRyYW5zaXRpb24udG8oKS5uYW1lKTtcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGU6IEEgc3RhdGUgZGVjbGFyYXRpb24ncyBgb25FbnRlcmAgZnVuY3Rpb24gaXMgaW5qZWN0ZWQgZm9yIEFuZ3VsYXIgMSBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hDcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvbkVudGVyKG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgY2FsbGVkIHdoZW4gYSBzcGVjaWZpYyBzdGF0ZSBpcyByZXRhaW5lZC9rZXB0LlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCAoZHVyaW5nIGEgdHJhbnNpdGlvbikgZm9yXG4gICAqIGEgc3BlY2lmaWMgc3RhdGUgdGhhdCB3YXMgcHJldmlvdXNseSBhY3RpdmUgd2lsbCByZW1haW4gYWN0aXZlIChpcyBub3QgYmVpbmcgZW50ZXJlZCBub3IgZXhpdGVkKS5cbiAgICpcbiAgICogVGhpcyBob29rIGlzIGludm9rZWQgd2hlbiBhIHN0YXRlIGlzIFwicmV0YWluZWRcIiBvciBcImtlcHRcIi5cbiAgICogSXQgbWVhbnMgdGhlIHRyYW5zaXRpb24gaXMgY29taW5nICpmcm9tKiBhIHN1YnN0YXRlIG9mIHRoZSByZXRhaW5lZCBzdGF0ZSAqdG8qIGEgc3Vic3RhdGUgb2YgdGhlIHJldGFpbmVkIHN0YXRlLlxuICAgKiBUaGlzIGhvb2sgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBhY3Rpb25zIHdoZW4gdGhlIHVzZXIgbW92ZXMgZnJvbSBvbmUgc3Vic3RhdGUgdG8gYW5vdGhlciwgc3VjaCBhcyBiZXR3ZWVuIHN0ZXBzIGluIGEgd2l6YXJkLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogYG9uUmV0YWluYCBob29rcyBnZW5lcmFsbHkgc3BlY2lmeSBgeyByZXRhaW5lZDogJ3NvbWVzdGF0ZScgfWAuXG4gICAqIFRvIG1hdGNoIGFsbCBUcmFuc2l0aW9ucywgdXNlIGFuIGVtcHR5IGNyaXRlcmlhIG9iamVjdCBge31gLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIGBvblJldGFpbmAgaG9va3MgYXJlIGludm9rZWQgYWZ0ZXIgYW55IGBvbkV4aXRgIGhvb2tzIGhhdmUgYmVlbiBmaXJlZC5cbiAgICogSWYgbW9yZSB0aGFuIG9uZSBzdGF0ZSBpcyByZXRhaW5lZCwgdGhlIGNoaWxkIHN0YXRlcycgYG9uUmV0YWluYCBob29rcyBhcmUgaW52b2tlZCBmaXJzdC5cbiAgICogVGhlIHJlZ2lzdGVyZWQgYG9uUmV0YWluYCBob29rcyBmb3IgYSBzdGF0ZSBhcmUgaW52b2tlZCBpbiBwcmlvcml0eSBvcmRlci5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byBwYXVzZSwgY2FuY2VsLCBvciByZWRpcmVjdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uLlxuICAgKiBTZWUgW1tIb29rUmVzdWx0XV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqICMjIyBJbnNpZGUgYSBzdGF0ZSBkZWNsYXJhdGlvblxuICAgKlxuICAgKiBJbnN0ZWFkIG9mIHJlZ2lzdGVyaW5nIGBvblJldGFpbmAgaG9va3MgdXNpbmcgdGhlIFtbVHJhbnNpdGlvblNlcnZpY2VdXSwgeW91IG1heSBkZWZpbmUgYW4gYG9uUmV0YWluYCBob29rXG4gICAqIGRpcmVjdGx5IG9uIGEgc3RhdGUgZGVjbGFyYXRpb24gKHNlZTogW1tTdGF0ZURlY2xhcmF0aW9uLm9uUmV0YWluXV0pLlxuICAgKlxuICAgKiBOb3RlOiBBIHN0YXRlIGRlY2xhcmF0aW9uJ3MgYG9uUmV0YWluYCBmdW5jdGlvbiBpcyBpbmplY3RlZCBmb3IgQW5ndWxhciAxIG9ubHkuXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaENyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZC5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICovXG4gIG9uUmV0YWluKG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgY2FsbGVkIHdoZW4gYSBzcGVjaWZpYyBzdGF0ZSBpcyBleGl0ZWQuXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIChkdXJpbmcgYSB0cmFuc2l0aW9uKSB3aGVuIGEgc3BlY2lmaWMgc3RhdGUgaXMgYmVpbmcgZXhpdGVkLlxuICAgKlxuICAgKiBTaW5jZSB0aGlzIGhvb2sgaXMgcnVuIG9ubHkgd2hlbiB0aGUgc3BlY2lmaWMgc3RhdGUgaXMgYmVpbmcgKmV4aXRlZCosIGl0IGNhbiBiZSB1c2VmdWwgZm9yXG4gICAqIHBlcmZvcm1pbmcgdGFza3Mgd2hlbiBsZWF2aW5nIGEgc3VibW9kdWxlL2ZlYXR1cmUgYXJlYSBzdWNoIGFzIGNsZWFuaW5nIHVwIGEgc3RhdGVmdWwgc2VydmljZSxcbiAgICogb3IgZm9yIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBsZWF2aW5nIGEgc3RhdGUgb3Igc3VibW9kdWxlIHVudGlsIHNvbWUgY3JpdGVyaWEgaXMgc2F0aXNmaWVkLlxuICAgKlxuICAgKiBTZWUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3IgdGhlIHNpZ25hdHVyZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoZSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIGhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBgb25FeGl0YCBob29rcyBnZW5lcmFsbHkgc3BlY2lmeSBgeyBleGl0aW5nOiAnc29tZXN0YXRlJyB9YC5cbiAgICogVG8gbWF0Y2ggYWxsIFRyYW5zaXRpb25zLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogYG9uRXhpdGAgaG9va3MgYXJlIGludm9rZWQgd2hlbiB0aGUgVHJhbnNpdGlvbiBpcyBleGl0aW5nIGEgc3RhdGUuXG4gICAqIFN0YXRlcyBhcmUgZXhpdGVkIGFmdGVyIGFueSBgb25TdGFydGAgcGhhc2UgaXMgY29tcGxldGUuXG4gICAqIElmIG1vcmUgdGhhbiBvbmUgc3RhdGUgaXMgYmVpbmcgZXhpdGVkLCB0aGUgY2hpbGQgc3RhdGVzIGFyZSBleGl0ZWQgZmlyc3QuXG4gICAqIFRoZSByZWdpc3RlcmVkIGBvbkV4aXRgIGhvb2tzIGZvciBhIHN0YXRlIGFyZSBpbnZva2VkIGluIHByaW9yaXR5IG9yZGVyLlxuICAgKlxuICAgKiAjIyMgUmV0dXJuIHZhbHVlXG4gICAqXG4gICAqIFRoZSBob29rJ3MgcmV0dXJuIHZhbHVlIGNhbiBiZSB1c2VkIHRvIHBhdXNlLCBjYW5jZWwsIG9yIHJlZGlyZWN0IHRoZSBjdXJyZW50IFRyYW5zaXRpb24uXG4gICAqIFNlZSBbW0hvb2tSZXN1bHRdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogIyMjIEluc2lkZSBhIHN0YXRlIGRlY2xhcmF0aW9uXG4gICAqXG4gICAqIEluc3RlYWQgb2YgcmVnaXN0ZXJpbmcgYG9uRXhpdGAgaG9va3MgdXNpbmcgdGhlIFtbVHJhbnNpdGlvblNlcnZpY2VdXSwgeW91IG1heSBkZWZpbmUgYW4gYG9uRXhpdGAgaG9va1xuICAgKiBkaXJlY3RseSBvbiBhIHN0YXRlIGRlY2xhcmF0aW9uIChzZWU6IFtbU3RhdGVEZWNsYXJhdGlvbi5vbkV4aXRdXSkuXG4gICAqXG4gICAqIE5vdGU6IEEgc3RhdGUgZGVjbGFyYXRpb24ncyBgb25FeGl0YCBmdW5jdGlvbiBpcyBpbmplY3RlZCBmb3IgQW5ndWxhciAxIG9ubHkuXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaENyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZC5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICovXG4gIG9uRXhpdChtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgKmp1c3QgYmVmb3JlIGEgdHJhbnNpdGlvbiBmaW5pc2hlcyouXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQganVzdCBiZWZvcmUgYSB0cmFuc2l0aW9uIGZpbmlzaGVzLlxuICAgKiBUaGlzIGhvb2sgaXMgYSBsYXN0IGNoYW5jZSB0byBjYW5jZWwgb3IgcmVkaXJlY3QgYSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBTZWUgW1tUcmFuc2l0aW9uSG9va0ZuXV0gZm9yIHRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogVG8gbWF0Y2ggYWxsIFRyYW5zaXRpb25zLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogYG9uRmluaXNoYCBob29rcyBhcmUgaW52b2tlZCBhZnRlciB0aGUgYG9uRW50ZXJgIHBoYXNlIGlzIGNvbXBsZXRlLlxuICAgKiBUaGVzZSBob29rcyBhcmUgaW52b2tlZCBqdXN0IGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBcImNvbW1pdHRlZFwiLlxuICAgKiBFYWNoIGhvb2sgaXMgaW52b2tlZCBpbiBwcmlvcml0eSBvcmRlci5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byBwYXVzZSwgY2FuY2VsLCBvciByZWRpcmVjdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uLlxuICAgKiBTZWUgW1tIb29rUmVzdWx0XV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaENyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZC5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICovXG4gIG9uRmluaXNoKG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgYWZ0ZXIgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb24gY29tcGxldGVkLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGFmdGVyIGEgdHJhbnNpdGlvbiBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICAgKlxuICAgKiBTZWUgW1tUcmFuc2l0aW9uSG9va0ZuXV0gZm9yIHRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogVG8gbWF0Y2ggYWxsIFRyYW5zaXRpb25zLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogYG9uU3VjY2Vzc2AgaG9va3MgYXJlIGNoYWluZWQgb2ZmIHRoZSBUcmFuc2l0aW9uJ3MgcHJvbWlzZSAoc2VlIFtbVHJhbnNpdGlvbi5wcm9taXNlXV0pLlxuICAgKiBJZiB0aGUgVHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsIGFuZCBpdHMgcHJvbWlzZSBpcyByZXNvbHZlZCwgdGhlbiB0aGUgYG9uU3VjY2Vzc2AgaG9va3MgYXJlIGludm9rZWQuXG4gICAqIFNpbmNlIHRoZXNlIGhvb2tzIGFyZSBydW4gYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaXMgb3ZlciwgdGhlaXIgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqIFRoZSBgb25TdWNjZXNzYCBob29rcyBhcmUgaW52b2tlZCBpbiBwcmlvcml0eSBvcmRlci5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBTaW5jZSB0aGUgVHJhbnNpdGlvbiBpcyBhbHJlYWR5IGNvbXBsZXRlZCwgdGhlIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hDcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvblN1Y2Nlc3MobWF0Y2hDcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uSG9va0ZuXV0sIGNhbGxlZCBhZnRlciBhIHRyYW5zaXRpb24gaGFzIGVycm9yZWQuXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGhhcyBiZWVuIHJlamVjdGVkIGZvciBhbnkgcmVhc29uLlxuICAgKlxuICAgKiBTZWUgW1tUcmFuc2l0aW9uSG9va0ZuXV0gZm9yIHRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogVG8gbWF0Y2ggYWxsIFRyYW5zaXRpb25zLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogVGhlIGBvbkVycm9yYCBob29rcyBhcmUgY2hhaW5lZCBvZmYgdGhlIFRyYW5zaXRpb24ncyBwcm9taXNlIChzZWUgW1tUcmFuc2l0aW9uLnByb21pc2VdXSkuXG4gICAqIElmIGEgVHJhbnNpdGlvbiBmYWlscywgaXRzIHByb21pc2UgaXMgcmVqZWN0ZWQgYW5kIHRoZSBgb25FcnJvcmAgaG9va3MgYXJlIGludm9rZWQuXG4gICAqIFRoZSBgb25FcnJvcmAgaG9va3MgYXJlIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuXG4gICAqXG4gICAqIFNpbmNlIHRoZXNlIGhvb2tzIGFyZSBydW4gYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaXMgb3ZlciwgdGhlaXIgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqXG4gICAqIEEgdHJhbnNpdGlvbiBcImVycm9yc1wiIGlmIGl0IHdhcyBzdGFydGVkLCBidXQgZmFpbGVkIHRvIGNvbXBsZXRlIChmb3IgYW55IHJlYXNvbikuXG4gICAqIEEgKm5vbi1leGhhdXN0aXZlIGxpc3QqIG9mIHJlYXNvbnMgYSB0cmFuc2l0aW9uIGNhbiBlcnJvcjpcbiAgICpcbiAgICogLSBBIHRyYW5zaXRpb24gd2FzIGNhbmNlbGxlZCBiZWNhdXNlIGEgbmV3IHRyYW5zaXRpb24gc3RhcnRlZCB3aGlsZSBpdCB3YXMgc3RpbGwgcnVubmluZyAoYFRyYW5zaXRpb24gc3VwZXJzZWRlZGApXG4gICAqIC0gQSB0cmFuc2l0aW9uIHdhcyBjYW5jZWxsZWQgYnkgYSBUcmFuc2l0aW9uIEhvb2sgcmV0dXJuaW5nIGZhbHNlXG4gICAqIC0gQSB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkIGJ5IGEgVHJhbnNpdGlvbiBIb29rIHJldHVybmluZyBhIFtbVGFyZ2V0U3RhdGVdXVxuICAgKiAtIEEgVHJhbnNpdGlvbiBIb29rIG9yIHJlc29sdmUgZnVuY3Rpb24gdGhyZXcgYW4gZXJyb3JcbiAgICogLSBBIFRyYW5zaXRpb24gSG9vayByZXR1cm5lZCBhIHJlamVjdGVkIHByb21pc2VcbiAgICogLSBBIHJlc29sdmUgZnVuY3Rpb24gcmV0dXJuZWQgYSByZWplY3RlZCBwcm9taXNlXG4gICAqXG4gICAqIFRvIGNoZWNrIHRoZSBmYWlsdXJlIHJlYXNvbiwgaW5zcGVjdCB0aGUgcmV0dXJuIHZhbHVlIG9mIFtbVHJhbnNpdGlvbi5lcnJvcl1dLlxuICAgKlxuICAgKiBOb3RlOiBgb25FcnJvcmAgc2hvdWxkIGJlIHVzZWQgZm9yIHRhcmdldGVkIGVycm9yIGhhbmRsaW5nLCBvciBlcnJvciByZWNvdmVyeS5cbiAgICogRm9yIHNpbXBsZSBjYXRjaC1hbGwgZXJyb3IgcmVwb3J0aW5nLCB1c2UgW1tTdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcl1dLlxuICAgKlxuICAgKiAjIyMgUmV0dXJuIHZhbHVlXG4gICAqXG4gICAqIFNpbmNlIHRoZSBUcmFuc2l0aW9uIGlzIGFscmVhZHkgY29tcGxldGVkLCB0aGUgaG9vaydzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaENyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZC5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICovXG4gIG9uRXJyb3IobWF0Y2hDcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgaG9va3Mgb2YgYSBnaXZlbiBgaG9va05hbWVgIHR5cGVcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogJHRyYW5zaXRpb25zLmdldEhvb2tzKFwib25FbnRlclwiKVxuICAgKiBgYGBcbiAgICovXG4gIGdldEhvb2tzKGhvb2tOYW1lOiBzdHJpbmcpOiBSZWdpc3RlcmVkSG9va1tdO1xufVxuXG4vKiogQSBwcmVkaWNhdGUgdHlwZSB3aGljaCB0ZXN0cyBpZiBhIFtbU3RhdGVPYmplY3RdXSBhbmQgW1tUcmFuc2l0aW9uXV0gcGFzc2VzIHNvbWUgdGVzdC4gUmV0dXJucyBhIGJvb2xlYW4uICovXG5leHBvcnQgdHlwZSBJU3RhdGVNYXRjaCA9IFByZWRpY2F0ZUJpbmFyeTxTdGF0ZU9iamVjdCwgVHJhbnNpdGlvbj47XG5cbi8qKlxuICogVGhpcyBvYmplY3QgaXMgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBvciBub3QgYSBUcmFuc2l0aW9uIEhvb2sgaXMgaW52b2tlZCBmb3IgYSBwYXJ0aWN1bGFyIHRyYW5zaXRpb24sXG4gKiBiYXNlZCBvbiB0aGUgVHJhbnNpdGlvbidzIFwidG8gc3RhdGVcIiBhbmQgXCJmcm9tIHN0YXRlXCIuXG4gKlxuICogRWFjaCBwcm9wZXJ0eSAoYHRvYCwgYGZyb21gLCBgZXhpdGluZ2AsIGByZXRhaW5lZGAsIGFuZCBgZW50ZXJpbmdgKSBjYW4gYmUgYSBzdGF0ZSBbW0dsb2JdXSBzdHJpbmcsXG4gKiBhIGJvb2xlYW4sIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0YXRlIGFuZCByZXR1cm5zIGEgYm9vbGVhbiAoc2VlIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0pXG4gKlxuICogQWxsIHByb3BlcnRpZXMgYXJlIG9wdGlvbmFsLiAgSWYgYW55IHByb3BlcnR5IGlzIG9taXR0ZWQsIGl0IGlzIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlIGB0cnVlYCwgYW5kIGFsd2F5cyBtYXRjaGVzLlxuICogVG8gbWF0Y2ggYW55IHRyYW5zaXRpb24sIHVzZSBhbiBlbXB0eSBjcml0ZXJpYSBvYmplY3QgYHt9YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogLy8gVGhpcyBtYXRjaGVzIGEgdHJhbnNpdGlvbiBjb21pbmcgZnJvbSB0aGUgYHBhcmVudGAgc3RhdGUgYW5kIGdvaW5nIHRvIHRoZSBgcGFyZW50LmNoaWxkYCBzdGF0ZS5cbiAqIHZhciBtYXRjaCA9IHtcbiAqICAgdG86ICdwYXJlbnQnLFxuICogICBmcm9tOiAncGFyZW50LmNoaWxkJ1xuICogfVxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIFRoaXMgbWF0Y2hlcyBhIHRyYW5zaXRpb24gY29taW5nIGZyb20gYW55IHN1YnN0YXRlIG9mIGBwYXJlbnRgIGFuZCBnb2luZyBkaXJlY3RseSB0byB0aGUgYHBhcmVudGAgc3RhdGUuXG4gKiB2YXIgbWF0Y2ggPSB7XG4gKiAgIHRvOiAncGFyZW50JyxcbiAqICAgZnJvbTogJ3BhcmVudC4qKidcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBUaGlzIG1hdGNoZXMgYSB0cmFuc2l0aW9uIGNvbWluZyBmcm9tIGFueSBzdGF0ZSBhbmQgZ29pbmcgdG8gYW55IHN1YnN0YXRlIG9mIGBteW1vZHVsZWBcbiAqIHZhciBtYXRjaCA9IHtcbiAqICAgdG86ICdteW1vZHVsZS4qKidcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBUaGlzIG1hdGNoZXMgYSB0cmFuc2l0aW9uIGNvbWluZyBmcm9tIGFueSBzdGF0ZSBhbmQgZ29pbmcgdG8gYW55IHN0YXRlIHRoYXQgaGFzIGBkYXRhLmF1dGhSZXF1aXJlZGBcbiAqIC8vIHNldCB0byBhIHRydXRoeSB2YWx1ZS5cbiAqIHZhciBtYXRjaCA9IHtcbiAqICAgdG86IGZ1bmN0aW9uKHN0YXRlKSB7XG4gKiAgICAgcmV0dXJuIHN0YXRlLmRhdGEgIT0gbnVsbCAmJiBzdGF0ZS5kYXRhLmF1dGhSZXF1aXJlZCA9PT0gdHJ1ZTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogLy8gVGhpcyB3aWxsIG1hdGNoIHdoZW4gcm91dGUgaXMganVzdCBlbnRlcmVkIChpbml0aWFsIGxvYWQpIG9yIHdoZW4gdGhlIHN0YXRlIGlzIGhhcmQtcmVmcmVzaGVkXG4gKiAvLyBieSBzcGVjaWZ5aW5nIGB7cmVmcmVzaDogdHJ1ZX1gIGFzIHRyYW5zaXRpb24gb3B0aW9ucy5cbiAqIHZhciBtYXRjaCA9IHtcbiAqICAgZnJvbTogKHN0YXRlLCB0cmFuc2l0aW9uKSA9PiBzdGF0ZS5zZWxmLm5hbWUgPT09ICcnIHx8IHRyYW5zaXRpb24ub3B0aW9ucygpLnJlbG9hZFxuICogfVxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIFRoaXMgbWF0Y2hlcyBhIHRyYW5zaXRpb24gdGhhdCBpcyBleGl0aW5nIGBwYXJlbnQuY2hpbGRgXG4gKiB2YXIgbWF0Y2ggPSB7XG4gKiAgIGV4aXRpbmc6ICdwYXJlbnQuY2hpbGQnXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb29rTWF0Y2hDcml0ZXJpYSB7XG4gIFtrZXk6IHN0cmluZ106IEhvb2tNYXRjaENyaXRlcmlvbiB8IHVuZGVmaW5lZDtcblxuICAvKiogQSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dIHRvIG1hdGNoIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSAqL1xuICB0bz86IEhvb2tNYXRjaENyaXRlcmlvbjtcbiAgLyoqIEEgW1tIb29rTWF0Y2hDcml0ZXJpb25dXSB0byBtYXRjaCB0aGUgb3JpZ2luYWwgKGZyb20pIHN0YXRlICovXG4gIGZyb20/OiBIb29rTWF0Y2hDcml0ZXJpb247XG4gIC8qKiBBIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0gdG8gbWF0Y2ggYW55IHN0YXRlIHRoYXQgd291bGQgYmUgZXhpdGluZyAqL1xuICBleGl0aW5nPzogSG9va01hdGNoQ3JpdGVyaW9uO1xuICAvKiogQSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dIHRvIG1hdGNoIGFueSBzdGF0ZSB0aGF0IHdvdWxkIGJlIHJldGFpbmVkICovXG4gIHJldGFpbmVkPzogSG9va01hdGNoQ3JpdGVyaW9uO1xuICAvKiogQSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dIHRvIG1hdGNoIGFueSBzdGF0ZSB0aGF0IHdvdWxkIGJlIGVudGVyaW5nICovXG4gIGVudGVyaW5nPzogSG9va01hdGNoQ3JpdGVyaW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNYXRjaGluZ05vZGVzIHtcbiAgW2tleTogc3RyaW5nXTogUGF0aE5vZGVbXTtcblxuICB0bzogUGF0aE5vZGVbXTtcbiAgZnJvbTogUGF0aE5vZGVbXTtcbiAgZXhpdGluZzogUGF0aE5vZGVbXTtcbiAgcmV0YWluZWQ6IFBhdGhOb2RlW107XG4gIGVudGVyaW5nOiBQYXRoTm9kZVtdO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlcmVkSG9va3Mge1xuICBba2V5OiBzdHJpbmddOiBSZWdpc3RlcmVkSG9va1tdO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoVHlwZXMge1xuICBba2V5OiBzdHJpbmddOiBQYXRoVHlwZTtcblxuICB0bzogUGF0aFR5cGU7XG4gIGZyb206IFBhdGhUeXBlO1xuICBleGl0aW5nOiBQYXRoVHlwZTtcbiAgcmV0YWluZWQ6IFBhdGhUeXBlO1xuICBlbnRlcmluZzogUGF0aFR5cGU7XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhUeXBlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzY29wZTogVHJhbnNpdGlvbkhvb2tTY29wZTtcbn1cblxuLyoqXG4gKiBIb29rIENyaXRlcmlvbiB1c2VkIHRvIG1hdGNoIGEgdHJhbnNpdGlvbi5cbiAqXG4gKiBBIFtbR2xvYl1dIHN0cmluZyB0aGF0IG1hdGNoZXMgdGhlIG5hbWUgb2YgYSBzdGF0ZS5cbiAqXG4gKiBPciwgYSBmdW5jdGlvbiB3aXRoIHRoZSBzaWduYXR1cmUgYGZ1bmN0aW9uKHN0YXRlLCB0cmFuc2l0aW9uKSB7IHJldHVybiBtYXRjaGVzOyB9YFxuICogd2hpY2ggc2hvdWxkIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgYSBzdGF0ZSBtYXRjaGVzLlxuICpcbiAqIE9yLCBgdHJ1ZWAgdG8gYWx3YXlzIG1hdGNoXG4gKi9cbmV4cG9ydCB0eXBlIEhvb2tNYXRjaENyaXRlcmlvbiA9IHN0cmluZyB8IElTdGF0ZU1hdGNoIHwgYm9vbGVhbjtcblxuZW51bSBUcmFuc2l0aW9uSG9va1BoYXNlIHtcbiAgQ1JFQVRFLFxuICBCRUZPUkUsXG4gIFJVTixcbiAgU1VDQ0VTUyxcbiAgRVJST1IsXG59XG5lbnVtIFRyYW5zaXRpb25Ib29rU2NvcGUge1xuICBUUkFOU0lUSU9OLFxuICBTVEFURSxcbn1cblxuZXhwb3J0IHsgVHJhbnNpdGlvbkhvb2tQaGFzZSwgVHJhbnNpdGlvbkhvb2tTY29wZSB9O1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiAqL1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2tPcHRpb25zLCBIb29rUmVzdWx0LCBUcmFuc2l0aW9uSG9va1BoYXNlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgZGVmYXVsdHMsIG5vb3AsIHNpbGVudFJlamVjdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgZm5Ub1N0cmluZywgbWF4TGVuZ3RoIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZ3MnO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgaXMsIHBhcnNlIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gJy4uL2NvbW1vbi90cmFjZSc7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgUmVqZWN0aW9uIH0gZnJvbSAnLi9yZWplY3RGYWN0b3J5JztcbmltcG9ydCB7IFRhcmdldFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUvdGFyZ2V0U3RhdGUnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBUcmFuc2l0aW9uRXZlbnRUeXBlIH0gZnJvbSAnLi90cmFuc2l0aW9uRXZlbnRUeXBlJztcbmltcG9ydCB7IFJlZ2lzdGVyZWRIb29rIH0gZnJvbSAnLi9ob29rUmVnaXN0cnknO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlL2ludGVyZmFjZSc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zOiBUcmFuc2l0aW9uSG9va09wdGlvbnMgPSB7XG4gIGN1cnJlbnQ6IG5vb3AsXG4gIHRyYW5zaXRpb246IG51bGwsXG4gIHRyYWNlRGF0YToge30sXG4gIGJpbmQ6IG51bGwsXG59O1xuXG5leHBvcnQgdHlwZSBHZXRSZXN1bHRIYW5kbGVyID0gKGhvb2s6IFRyYW5zaXRpb25Ib29rKSA9PiBSZXN1bHRIYW5kbGVyO1xuZXhwb3J0IHR5cGUgR2V0RXJyb3JIYW5kbGVyID0gKGhvb2s6IFRyYW5zaXRpb25Ib29rKSA9PiBFcnJvckhhbmRsZXI7XG5cbmV4cG9ydCB0eXBlIFJlc3VsdEhhbmRsZXIgPSAocmVzdWx0OiBIb29rUmVzdWx0KSA9PiBQcm9taXNlPEhvb2tSZXN1bHQ+O1xuZXhwb3J0IHR5cGUgRXJyb3JIYW5kbGVyID0gKGVycm9yOiBhbnkpID0+IFByb21pc2U8YW55PjtcblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2l0aW9uSG9vayB7XG4gIHR5cGU6IFRyYW5zaXRpb25FdmVudFR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZXNlIEdldFJlc3VsdEhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAgICogRWFjaCBIb29rVHlwZSBjaG9vc2VzIGEgR2V0UmVzdWx0SGFuZGxlciAoU2VlOiBbW1RyYW5zaXRpb25TZXJ2aWNlLl9kZWZpbmVDb3JlRXZlbnRzXV0pXG4gICAqL1xuICBzdGF0aWMgSEFORExFX1JFU1VMVDogR2V0UmVzdWx0SGFuZGxlciA9IChob29rOiBUcmFuc2l0aW9uSG9vaykgPT4gKHJlc3VsdDogSG9va1Jlc3VsdCkgPT5cbiAgICBob29rLmhhbmRsZUhvb2tSZXN1bHQocmVzdWx0KTtcblxuICAvKipcbiAgICogSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UgcmVqZWN0aW9uLCBsb2cgaXQuXG4gICAqIE90aGVyd2lzZSwgaWdub3JlIHRoZSByZXN1bHQuXG4gICAqL1xuICBzdGF0aWMgTE9HX1JFSkVDVEVEX1JFU1VMVDogR2V0UmVzdWx0SGFuZGxlciA9IChob29rOiBUcmFuc2l0aW9uSG9vaykgPT4gKHJlc3VsdDogSG9va1Jlc3VsdCkgPT4ge1xuICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIHJlc3VsdC5jYXRjaChlcnIgPT4gaG9vay5sb2dFcnJvcihSZWplY3Rpb24ubm9ybWFsaXplKGVycikpKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGVzZSBHZXRFcnJvckhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAgICogRWFjaCBIb29rVHlwZSBjaG9vc2VzIGEgR2V0RXJyb3JIYW5kbGVyIChTZWU6IFtbVHJhbnNpdGlvblNlcnZpY2UuX2RlZmluZUNvcmVFdmVudHNdXSlcbiAgICovXG4gIHN0YXRpYyBMT0dfRVJST1I6IEdldEVycm9ySGFuZGxlciA9IChob29rOiBUcmFuc2l0aW9uSG9vaykgPT4gKGVycm9yOiBhbnkpID0+IGhvb2subG9nRXJyb3IoZXJyb3IpO1xuXG4gIHN0YXRpYyBSRUpFQ1RfRVJST1I6IEdldEVycm9ySGFuZGxlciA9IChob29rOiBUcmFuc2l0aW9uSG9vaykgPT4gKGVycm9yOiBhbnkpID0+IHNpbGVudFJlamVjdGlvbihlcnJvcik7XG5cbiAgc3RhdGljIFRIUk9XX0VSUk9SOiBHZXRFcnJvckhhbmRsZXIgPSAoaG9vazogVHJhbnNpdGlvbkhvb2spID0+IChlcnJvcjogYW55KSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYWlucyB0b2dldGhlciBhbiBhcnJheSBvZiBUcmFuc2l0aW9uSG9va3MuXG4gICAqXG4gICAqIEdpdmVuIGEgbGlzdCBvZiBbW1RyYW5zaXRpb25Ib29rXV0gb2JqZWN0cywgY2hhaW5zIHRoZW0gdG9nZXRoZXIuXG4gICAqIEVhY2ggaG9vayBpcyBpbnZva2VkIGFmdGVyIHRoZSBwcmV2aW91cyBvbmUgY29tcGxldGVzLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBob29rczogVHJhbnNpdGlvbkhvb2tbXSA9IGdldEhvb2tzKCk7XG4gICAqIGxldCBwcm9taXNlOiBQcm9taXNlPGFueT4gPSBUcmFuc2l0aW9uSG9vay5jaGFpbihob29rcyk7XG4gICAqXG4gICAqIHByb21pc2UudGhlbihoYW5kbGVTdWNjZXNzLCBoYW5kbGVFcnJvcik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaG9va3MgdGhlIGxpc3Qgb2YgaG9va3MgdG8gY2hhaW4gdG9nZXRoZXJcbiAgICogQHBhcmFtIHdhaXRGb3IgaWYgcHJvdmlkZWQsIHRoZSBjaGFpbiBpcyBgLnRoZW4oKWAnZWQgb2ZmIHRoaXMgcHJvbWlzZVxuICAgKiBAcmV0dXJucyBhIGBQcm9taXNlYCBmb3Igc2VxdWVudGlhbGx5IGludm9raW5nIHRoZSBob29rcyAoaW4gb3JkZXIpXG4gICAqL1xuICBzdGF0aWMgY2hhaW4oaG9va3M6IFRyYW5zaXRpb25Ib29rW10sIHdhaXRGb3I/OiBQcm9taXNlPGFueT4pOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIENoYWluIHRoZSBuZXh0IGhvb2sgb2ZmIHRoZSBwcmV2aW91c1xuICAgIGNvbnN0IGNyZWF0ZUhvb2tDaGFpblIgPSAocHJldjogUHJvbWlzZTxhbnk+LCBuZXh0SG9vazogVHJhbnNpdGlvbkhvb2spID0+IHByZXYudGhlbigoKSA9PiBuZXh0SG9vay5pbnZva2VIb29rKCkpO1xuICAgIHJldHVybiBob29rcy5yZWR1Y2UoY3JlYXRlSG9va0NoYWluUiwgd2FpdEZvciB8fCBzZXJ2aWNlcy4kcS53aGVuKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIHRoZSBwcm92aWRlZCBUcmFuc2l0aW9uSG9va3MsIGluIG9yZGVyLlxuICAgKiBFYWNoIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgY2hlY2tlZC5cbiAgICogSWYgYW55IGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gdGhlIHJlc3Qgb2YgdGhlIGhvb2tzIGFyZSBjaGFpbmVkIG9mZiB0aGF0IHByb21pc2UsIGFuZCB0aGUgcHJvbWlzZSBpcyByZXR1cm5lZC5cbiAgICogSWYgbm8gaG9vayByZXR1cm5zIGEgcHJvbWlzZSwgdGhlbiBhbGwgaG9va3MgYXJlIHByb2Nlc3NlZCBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gaG9va3MgdGhlIGxpc3Qgb2YgVHJhbnNpdGlvbkhvb2tzIHRvIGludm9rZVxuICAgKiBAcGFyYW0gZG9uZUNhbGxiYWNrIGEgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIGFmdGVyIGFsbCB0aGUgaG9va3MgaGF2ZSBzdWNjZXNzZnVsbHkgY29tcGxldGVkXG4gICAqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIHJlc3VsdCwgb3IgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2tcbiAgICovXG4gIHN0YXRpYyBpbnZva2VIb29rczxUPihob29rczogVHJhbnNpdGlvbkhvb2tbXSwgZG9uZUNhbGxiYWNrOiAocmVzdWx0PzogSG9va1Jlc3VsdCkgPT4gVCk6IFByb21pc2U8YW55PiB8IFQge1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGhvb2tzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IGhvb2tSZXN1bHQgPSBob29rc1tpZHhdLmludm9rZUhvb2soKTtcblxuICAgICAgaWYgKGlzUHJvbWlzZShob29rUmVzdWx0KSkge1xuICAgICAgICBjb25zdCByZW1haW5pbmdIb29rcyA9IGhvb2tzLnNsaWNlKGlkeCArIDEpO1xuXG4gICAgICAgIHJldHVybiBUcmFuc2l0aW9uSG9vay5jaGFpbihyZW1haW5pbmdIb29rcywgaG9va1Jlc3VsdCkudGhlbihkb25lQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb25lQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYWxsIFRyYW5zaXRpb25Ib29rcywgaWdub3JpbmcgdGhlaXIgcmV0dXJuIHZhbHVlLlxuICAgKi9cbiAgc3RhdGljIHJ1bkFsbEhvb2tzKGhvb2tzOiBUcmFuc2l0aW9uSG9va1tdKTogdm9pZCB7XG4gICAgaG9va3MuZm9yRWFjaChob29rID0+IGhvb2suaW52b2tlSG9vaygpKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICBwcml2YXRlIHN0YXRlQ29udGV4dDogU3RhdGVEZWNsYXJhdGlvbixcbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRIb29rOiBSZWdpc3RlcmVkSG9vayxcbiAgICBwcml2YXRlIG9wdGlvbnM6IFRyYW5zaXRpb25Ib29rT3B0aW9uc1xuICApIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy50eXBlID0gcmVnaXN0ZXJlZEhvb2suZXZlbnRUeXBlO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1N1cGVyc2VkZWQgPSAoKSA9PiB0aGlzLnR5cGUuaG9va1BoYXNlID09PSBUcmFuc2l0aW9uSG9va1BoYXNlLlJVTiAmJiAhdGhpcy5vcHRpb25zLnRyYW5zaXRpb24uaXNBY3RpdmUoKTtcblxuICBsb2dFcnJvcihlcnIpOiBhbnkge1xuICAgIHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVTZXJ2aWNlLmRlZmF1bHRFcnJvckhhbmRsZXIoKShlcnIpO1xuICB9XG5cbiAgaW52b2tlSG9vaygpOiBQcm9taXNlPEhvb2tSZXN1bHQ+IHwgdm9pZCB7XG4gICAgY29uc3QgaG9vayA9IHRoaXMucmVnaXN0ZXJlZEhvb2s7XG4gICAgaWYgKGhvb2suX2RlcmVnaXN0ZXJlZCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xuICAgIGlmIChub3RDdXJyZW50KSByZXR1cm4gbm90Q3VycmVudDtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdHJhY2UudHJhY2VIb29rSW52b2NhdGlvbih0aGlzLCB0aGlzLnRyYW5zaXRpb24sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgaW52b2tlQ2FsbGJhY2sgPSAoKSA9PiBob29rLmNhbGxiYWNrLmNhbGwob3B0aW9ucy5iaW5kLCB0aGlzLnRyYW5zaXRpb24sIHRoaXMuc3RhdGVDb250ZXh0KTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZUVyciA9IGVyciA9PiBSZWplY3Rpb24ubm9ybWFsaXplKGVycikudG9Qcm9taXNlKCk7XG5cbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IGVyciA9PiBob29rLmV2ZW50VHlwZS5nZXRFcnJvckhhbmRsZXIodGhpcykoZXJyKTtcblxuICAgIGNvbnN0IGhhbmRsZVJlc3VsdCA9IHJlc3VsdCA9PiBob29rLmV2ZW50VHlwZS5nZXRSZXN1bHRIYW5kbGVyKHRoaXMpKHJlc3VsdCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW52b2tlQ2FsbGJhY2soKTtcblxuICAgICAgaWYgKCF0aGlzLnR5cGUuc3luY2hyb25vdXMgJiYgaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYXRjaChub3JtYWxpemVFcnIpLnRoZW4oaGFuZGxlUmVzdWx0LCBoYW5kbGVFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiBjYWxsYmFjayB0aHJvd3MgKHN5bmNocm9ub3VzbHkpXG4gICAgICByZXR1cm4gaGFuZGxlRXJyb3IoUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGhvb2suaW52b2tlTGltaXQgJiYgKytob29rLmludm9rZUNvdW50ID49IGhvb2suaW52b2tlTGltaXQpIHtcbiAgICAgICAgaG9vay5kZXJlZ2lzdGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIFRyYW5zaXRpb24gSG9vay5cbiAgICpcbiAgICogQSBob29rIGNhbiByZXR1cm4gZmFsc2UgKGNhbmNlbCksIGEgVGFyZ2V0U3RhdGUgKHJlZGlyZWN0KSxcbiAgICogb3IgYSBwcm9taXNlICh3aGljaCBtYXkgbGF0ZXIgcmVzb2x2ZSB0byBmYWxzZSBvciBhIHJlZGlyZWN0KVxuICAgKlxuICAgKiBUaGlzIGFsc28gaGFuZGxlcyBcInRyYW5zaXRpb24gc3VwZXJzZWRlZFwiIC0tIHdoZW4gYSBuZXcgdHJhbnNpdGlvblxuICAgKiB3YXMgc3RhcnRlZCB3aGlsZSB0aGUgaG9vayB3YXMgc3RpbGwgcnVubmluZ1xuICAgKi9cbiAgaGFuZGxlSG9va1Jlc3VsdChyZXN1bHQ6IEhvb2tSZXN1bHQpOiBQcm9taXNlPEhvb2tSZXN1bHQ+IHtcbiAgICBjb25zdCBub3RDdXJyZW50ID0gdGhpcy5nZXROb3RDdXJyZW50UmVqZWN0aW9uKCk7XG4gICAgaWYgKG5vdEN1cnJlbnQpIHJldHVybiBub3RDdXJyZW50O1xuXG4gICAgLy8gSG9vayByZXR1cm5lZCBhIHByb21pc2VcbiAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJlcHJvY2VzcyB3aXRoIHRoZSByZXN1bHRpbmcgdmFsdWVcbiAgICAgIHJldHVybiByZXN1bHQudGhlbih2YWwgPT4gdGhpcy5oYW5kbGVIb29rUmVzdWx0KHZhbCkpO1xuICAgIH1cblxuICAgIHRyYWNlLnRyYWNlSG9va1Jlc3VsdChyZXN1bHQsIHRoaXMudHJhbnNpdGlvbiwgdGhpcy5vcHRpb25zKTtcblxuICAgIC8vIEhvb2sgcmV0dXJuZWQgZmFsc2VcbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgLy8gQWJvcnQgdGhpcyBUcmFuc2l0aW9uXG4gICAgICByZXR1cm4gUmVqZWN0aW9uLmFib3J0ZWQoJ0hvb2sgYWJvcnRlZCB0cmFuc2l0aW9uJykudG9Qcm9taXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNUYXJnZXRTdGF0ZSA9IGlzKFRhcmdldFN0YXRlKTtcbiAgICAvLyBob29rIHJldHVybmVkIGEgVGFyZ2V0U3RhdGVcbiAgICBpZiAoaXNUYXJnZXRTdGF0ZShyZXN1bHQpKSB7XG4gICAgICAvLyBIYWx0IHRoZSBjdXJyZW50IFRyYW5zaXRpb24gYW5kIHJlZGlyZWN0IChhIG5ldyBUcmFuc2l0aW9uKSB0byB0aGUgVGFyZ2V0U3RhdGUuXG4gICAgICByZXR1cm4gUmVqZWN0aW9uLnJlZGlyZWN0ZWQocmVzdWx0KS50b1Byb21pc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgUmVqZWN0aW9uIHByb21pc2UgaWYgdGhlIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQgZHVlXG4gICAqIHRvIGEgc3RvcHBlZCByb3V0ZXIgKGRpc3Bvc2VkKSwgb3IgYSBuZXcgdHJhbnNpdGlvbiBoYXMgc3RhcnRlZCBhbmQgc3VwZXJzZWRlZCB0aGlzIG9uZS5cbiAgICovXG4gIHByaXZhdGUgZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyO1xuXG4gICAgLy8gVGhlIHJvdXRlciBpcyBzdG9wcGVkXG4gICAgaWYgKHJvdXRlci5fZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybiBSZWplY3Rpb24uYWJvcnRlZChgVUlSb3V0ZXIgaW5zdGFuY2UgIyR7cm91dGVyLiRpZH0gaGFzIGJlZW4gc3RvcHBlZCAoZGlzcG9zZWQpYCkudG9Qcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbi5fYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIFJlamVjdGlvbi5hYm9ydGVkKCkudG9Qcm9taXNlKCk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB0cmFuc2l0aW9uIGlzIG5vIGxvbmdlciBjdXJyZW50LlxuICAgIC8vIEFub3RoZXIgdHJhbnNpdGlvbiBzdGFydGVkIHdoaWxlIHRoaXMgaG9vayB3YXMgc3RpbGwgcnVubmluZy5cbiAgICBpZiAodGhpcy5pc1N1cGVyc2VkZWQoKSkge1xuICAgICAgLy8gQWJvcnQgdGhpcyB0cmFuc2l0aW9uXG4gICAgICByZXR1cm4gUmVqZWN0aW9uLnN1cGVyc2VkZWQodGhpcy5vcHRpb25zLmN1cnJlbnQoKSkudG9Qcm9taXNlKCk7XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zLCByZWdpc3RlcmVkSG9vayB9ID0gdGhpcztcbiAgICBjb25zdCBldmVudCA9IHBhcnNlKCd0cmFjZURhdGEuaG9va1R5cGUnKShvcHRpb25zKSB8fCAnaW50ZXJuYWwnLFxuICAgICAgY29udGV4dCA9IHBhcnNlKCd0cmFjZURhdGEuY29udGV4dC5zdGF0ZS5uYW1lJykob3B0aW9ucykgfHwgcGFyc2UoJ3RyYWNlRGF0YS5jb250ZXh0Jykob3B0aW9ucykgfHwgJ3Vua25vd24nLFxuICAgICAgbmFtZSA9IGZuVG9TdHJpbmcocmVnaXN0ZXJlZEhvb2suY2FsbGJhY2spO1xuICAgIHJldHVybiBgJHtldmVudH0gY29udGV4dDogJHtjb250ZXh0fSwgJHttYXhMZW5ndGgoMjAwLCBuYW1lKX1gO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHRyYW5zaXRpb24gKi8gLyoqICovXG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgR2xvYiwgZXh0ZW5kLCByZW1vdmVGcm9tLCB0YWlsLCB2YWx1ZXMsIGlkZW50aXR5LCBtYXBPYmogfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7XG4gIFRyYW5zaXRpb25TdGF0ZUhvb2tGbixcbiAgVHJhbnNpdGlvbkhvb2tGbixcbiAgVHJhbnNpdGlvbkhvb2tQaGFzZSwgLy8gaGFzIG9yIGlzIHVzaW5nXG4gIFRyYW5zaXRpb25Ib29rU2NvcGUsXG4gIElIb29rUmVnaXN0cnksXG4gIFBhdGhUeXBlLFxufSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbmltcG9ydCB7XG4gIEhvb2tSZWdPcHRpb25zLFxuICBIb29rTWF0Y2hDcml0ZXJpYSxcbiAgVHJlZUNoYW5nZXMsXG4gIEhvb2tNYXRjaENyaXRlcmlvbixcbiAgSU1hdGNoaW5nTm9kZXMsXG4gIEhvb2tGbixcbn0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IFRyYW5zaXRpb25FdmVudFR5cGUgfSBmcm9tICcuL3RyYW5zaXRpb25FdmVudFR5cGUnO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuL3RyYW5zaXRpb25TZXJ2aWNlJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBzdGF0ZSBtYXRjaGVzIHRoZSBtYXRjaENyaXRlcmlhXG4gKlxuICogQGhpZGRlblxuICpcbiAqIEBwYXJhbSBzdGF0ZSBhIFN0YXRlIE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSBjcml0ZXJpb25cbiAqIC0gSWYgYSBzdHJpbmcsIG1hdGNoU3RhdGUgdXNlcyB0aGUgc3RyaW5nIGFzIGEgZ2xvYi1tYXRjaGVyIGFnYWluc3QgdGhlIHN0YXRlIG5hbWVcbiAqIC0gSWYgYW4gYXJyYXkgKG9mIHN0cmluZ3MpLCBtYXRjaFN0YXRlIHVzZXMgZWFjaCBzdHJpbmcgaW4gdGhlIGFycmF5IGFzIGEgZ2xvYi1tYXRjaGVycyBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAgIGFuZCByZXR1cm5zIGEgcG9zaXRpdmUgbWF0Y2ggaWYgYW55IG9mIHRoZSBnbG9icyBtYXRjaC5cbiAqIC0gSWYgYSBmdW5jdGlvbiwgbWF0Y2hTdGF0ZSBjYWxscyB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3RhdGUgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZnVuY3Rpb24ncyByZXN1bHQgaXMgdHJ1dGh5LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFN0YXRlKHN0YXRlOiBTdGF0ZU9iamVjdCwgY3JpdGVyaW9uOiBIb29rTWF0Y2hDcml0ZXJpb24sIHRyYW5zaXRpb246IFRyYW5zaXRpb24pIHtcbiAgY29uc3QgdG9NYXRjaCA9IGlzU3RyaW5nKGNyaXRlcmlvbikgPyBbY3JpdGVyaW9uXSA6IGNyaXRlcmlvbjtcblxuICBmdW5jdGlvbiBtYXRjaEdsb2JzKF9zdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICBjb25zdCBnbG9iU3RyaW5ncyA9IDxzdHJpbmdbXT50b01hdGNoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdsb2IgPSBuZXcgR2xvYihnbG9iU3RyaW5nc1tpXSk7XG5cbiAgICAgIGlmICgoZ2xvYiAmJiBnbG9iLm1hdGNoZXMoX3N0YXRlLm5hbWUpKSB8fCAoIWdsb2IgJiYgZ2xvYlN0cmluZ3NbaV0gPT09IF9zdGF0ZS5uYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hGbiA9IDxhbnk+KGlzRnVuY3Rpb24odG9NYXRjaCkgPyB0b01hdGNoIDogbWF0Y2hHbG9icyk7XG4gIHJldHVybiAhIW1hdGNoRm4oc3RhdGUsIHRyYW5zaXRpb24pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogVGhlIHJlZ2lzdHJhdGlvbiBkYXRhIGZvciBhIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RlcmVkSG9vayB7XG4gIHByaW9yaXR5OiBudW1iZXI7XG4gIGJpbmQ6IGFueTtcbiAgaW52b2tlQ291bnQgPSAwO1xuICBpbnZva2VMaW1pdDogbnVtYmVyO1xuICBfZGVyZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHRyYW5TdmM6IFRyYW5zaXRpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBldmVudFR5cGU6IFRyYW5zaXRpb25FdmVudFR5cGUsXG4gICAgcHVibGljIGNhbGxiYWNrOiBIb29rRm4sXG4gICAgcHVibGljIG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLFxuICAgIHB1YmxpYyByZW1vdmVIb29rRnJvbVJlZ2lzdHJ5OiAoaG9vazogUmVnaXN0ZXJlZEhvb2spID0+IHZvaWQsXG4gICAgb3B0aW9uczogSG9va1JlZ09wdGlvbnMgPSB7fSBhcyBhbnlcbiAgKSB7XG4gICAgdGhpcy5wcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcbiAgICB0aGlzLmJpbmQgPSBvcHRpb25zLmJpbmQgfHwgbnVsbDtcbiAgICB0aGlzLmludm9rZUxpbWl0ID0gb3B0aW9ucy5pbnZva2VMaW1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXRjaGluZyBbW1BhdGhOb2RlXV1zXG4gICAqXG4gICAqIEdpdmVuIGFuIGFycmF5IG9mIFtbUGF0aE5vZGVdXXMsIGFuZCBhIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0sIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZ1xuICAgKiB0aGUgW1tQYXRoTm9kZV1dcyB0aGF0IHRoZSBjcml0ZXJpYSBtYXRjaGVzLCBvciBgbnVsbGAgaWYgdGhlcmUgd2VyZSBubyBtYXRjaGluZyBub2Rlcy5cbiAgICpcbiAgICogUmV0dXJuaW5nIGBudWxsYCBpcyBzaWduaWZpY2FudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBkZWZhdWx0XG4gICAqIFwibWF0Y2gtYWxsIGNyaXRlcmlvbiB2YWx1ZVwiIG9mIGB0cnVlYCBjb21wYXJlZCB0byBhIGAoKSA9PiB0cnVlYCBmdW5jdGlvbixcbiAgICogd2hlbiB0aGUgbm9kZXMgaXMgYW4gZW1wdHkgYXJyYXkuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHRvIGFsbG93IGEgdHJhbnNpdGlvbiBtYXRjaCBjcml0ZXJpYSBvZiBgZW50ZXJpbmc6IHRydWVgXG4gICAqIHRvIHN0aWxsIG1hdGNoIGEgdHJhbnNpdGlvbiwgZXZlbiB3aGVuIGBlbnRlcmluZyA9PT0gW11gLiAgQ29udHJhc3QgdGhhdFxuICAgKiB3aXRoIGBlbnRlcmluZzogKHN0YXRlKSA9PiB0cnVlYCB3aGljaCBvbmx5IG1hdGNoZXMgd2hlbiBhIHN0YXRlIGlzIGFjdHVhbGx5XG4gICAqIGJlaW5nIGVudGVyZWQuXG4gICAqL1xuICBwcml2YXRlIF9tYXRjaGluZ05vZGVzKG5vZGVzOiBQYXRoTm9kZVtdLCBjcml0ZXJpb246IEhvb2tNYXRjaENyaXRlcmlvbiwgdHJhbnNpdGlvbjogVHJhbnNpdGlvbik6IFBhdGhOb2RlW10ge1xuICAgIGlmIChjcml0ZXJpb24gPT09IHRydWUpIHJldHVybiBub2RlcztcbiAgICBjb25zdCBtYXRjaGluZyA9IG5vZGVzLmZpbHRlcihub2RlID0+IG1hdGNoU3RhdGUobm9kZS5zdGF0ZSwgY3JpdGVyaW9uLCB0cmFuc2l0aW9uKSk7XG4gICAgcmV0dXJuIG1hdGNoaW5nLmxlbmd0aCA/IG1hdGNoaW5nIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZWZhdWx0IG1hdGNoIGNyaXRlcmlhIChhbGwgYHRydWVgKVxuICAgKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBoYXMgYWxsIHRoZSBjcml0ZXJpYSBtYXRjaCBwYXRocyBhcyBrZXlzIGFuZCBgdHJ1ZWAgYXMgdmFsdWVzLCBpLmUuOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB7XG4gICAqICAgdG86IHRydWUsXG4gICAqICAgZnJvbTogdHJ1ZSxcbiAgICogICBlbnRlcmluZzogdHJ1ZSxcbiAgICogICBleGl0aW5nOiB0cnVlLFxuICAgKiAgIHJldGFpbmVkOiB0cnVlLFxuICAgKiB9XG4gICAqL1xuICBwcml2YXRlIF9nZXREZWZhdWx0TWF0Y2hDcml0ZXJpYSgpOiBIb29rTWF0Y2hDcml0ZXJpYSB7XG4gICAgcmV0dXJuIG1hcE9iaih0aGlzLnRyYW5TdmMuX3BsdWdpbmFwaS5fZ2V0UGF0aFR5cGVzKCksICgpID0+IHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgbWF0Y2hpbmcgbm9kZXMgYXMgW1tJTWF0Y2hpbmdOb2Rlc11dXG4gICAqXG4gICAqIENyZWF0ZSBhIElNYXRjaGluZ05vZGVzIG9iamVjdCBmcm9tIHRoZSBUcmFuc2l0aW9uSG9va1R5cGVzIHRoYXQgaXMgcm91Z2hseSBlcXVpdmFsZW50IHRvOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBsZXQgbWF0Y2hlczogSU1hdGNoaW5nTm9kZXMgPSB7XG4gICAqICAgdG86ICAgICAgIF9tYXRjaGluZ05vZGVzKFt0YWlsKHRyZWVDaGFuZ2VzLnRvKV0sICAgbWMudG8pLFxuICAgKiAgIGZyb206ICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy5mcm9tKV0sIG1jLmZyb20pLFxuICAgKiAgIGV4aXRpbmc6ICBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5leGl0aW5nLCAgICAgIG1jLmV4aXRpbmcpLFxuICAgKiAgIHJldGFpbmVkOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5yZXRhaW5lZCwgICAgIG1jLnJldGFpbmVkKSxcbiAgICogICBlbnRlcmluZzogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZW50ZXJpbmcsICAgICBtYy5lbnRlcmluZyksXG4gICAqIH07XG4gICAqIGBgYFxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0TWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlczogVHJlZUNoYW5nZXMsIHRyYW5zaXRpb246IFRyYW5zaXRpb24pOiBJTWF0Y2hpbmdOb2RlcyB7XG4gICAgY29uc3QgY3JpdGVyaWEgPSBleHRlbmQodGhpcy5fZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEoKSwgdGhpcy5tYXRjaENyaXRlcmlhKTtcbiAgICBjb25zdCBwYXRoczogUGF0aFR5cGVbXSA9IHZhbHVlcyh0aGlzLnRyYW5TdmMuX3BsdWdpbmFwaS5fZ2V0UGF0aFR5cGVzKCkpO1xuXG4gICAgcmV0dXJuIHBhdGhzLnJlZHVjZShcbiAgICAgIChtbjogSU1hdGNoaW5nTm9kZXMsIHBhdGh0eXBlOiBQYXRoVHlwZSkgPT4ge1xuICAgICAgICAvLyBTVEFURSBzY29wZSBjcml0ZXJpYSBtYXRjaGVzIGFnYWluc3QgZXZlcnkgbm9kZSBpbiB0aGUgcGF0aC5cbiAgICAgICAgLy8gVFJBTlNJVElPTiBzY29wZSBjcml0ZXJpYSBtYXRjaGVzIGFnYWluc3Qgb25seSB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoXG4gICAgICAgIGNvbnN0IGlzU3RhdGVIb29rID0gcGF0aHR5cGUuc2NvcGUgPT09IFRyYW5zaXRpb25Ib29rU2NvcGUuU1RBVEU7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0cmVlQ2hhbmdlc1twYXRodHlwZS5uYW1lXSB8fCBbXTtcbiAgICAgICAgY29uc3Qgbm9kZXM6IFBhdGhOb2RlW10gPSBpc1N0YXRlSG9vayA/IHBhdGggOiBbdGFpbChwYXRoKV07XG5cbiAgICAgICAgbW5bcGF0aHR5cGUubmFtZV0gPSB0aGlzLl9tYXRjaGluZ05vZGVzKG5vZGVzLCBjcml0ZXJpYVtwYXRodHlwZS5uYW1lXSwgdHJhbnNpdGlvbik7XG4gICAgICAgIHJldHVybiBtbjtcbiAgICAgIH0sXG4gICAgICB7fSBhcyBJTWF0Y2hpbmdOb2Rlc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIGhvb2sncyBbW21hdGNoQ3JpdGVyaWFdXSBtYXRjaCB0aGUgZ2l2ZW4gW1tUcmVlQ2hhbmdlc11dXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIElNYXRjaGluZ05vZGVzIG9iamVjdCwgb3IgbnVsbC4gSWYgYW4gSU1hdGNoaW5nTm9kZXMgb2JqZWN0IGlzIHJldHVybmVkLCBpdHMgdmFsdWVzXG4gICAqIGFyZSB0aGUgbWF0Y2hpbmcgW1tQYXRoTm9kZV1dcyBmb3IgZWFjaCBbW0hvb2tNYXRjaENyaXRlcmlvbl1dICh0bywgZnJvbSwgZXhpdGluZywgcmV0YWluZWQsIGVudGVyaW5nKVxuICAgKi9cbiAgbWF0Y2hlcyh0cmVlQ2hhbmdlczogVHJlZUNoYW5nZXMsIHRyYW5zaXRpb246IFRyYW5zaXRpb24pOiBJTWF0Y2hpbmdOb2RlcyB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2dldE1hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMsIHRyYW5zaXRpb24pO1xuXG4gICAgLy8gQ2hlY2sgaWYgYWxsIHRoZSBjcml0ZXJpYSBtYXRjaGVkIHRoZSBUcmVlQ2hhbmdlcyBvYmplY3RcbiAgICBjb25zdCBhbGxNYXRjaGVkID0gdmFsdWVzKG1hdGNoZXMpLmV2ZXJ5KGlkZW50aXR5KTtcbiAgICByZXR1cm4gYWxsTWF0Y2hlZCA/IG1hdGNoZXMgOiBudWxsO1xuICB9XG5cbiAgZGVyZWdpc3RlcigpIHtcbiAgICB0aGlzLnJlbW92ZUhvb2tGcm9tUmVnaXN0cnkodGhpcyk7XG4gICAgdGhpcy5fZGVyZWdpc3RlcmVkID0gdHJ1ZTtcbiAgfVxufVxuXG4vKiogQGhpZGRlbiBSZXR1cm4gYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gb2YgdGhlIHJlcXVlc3RlZCB0eXBlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFdmVudChcbiAgcmVnaXN0cnk6IElIb29rUmVnaXN0cnksXG4gIHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSxcbiAgZXZlbnRUeXBlOiBUcmFuc2l0aW9uRXZlbnRUeXBlXG4pIHtcbiAgLy8gQ3JlYXRlIHRoZSBvYmplY3Qgd2hpY2ggaG9sZHMgdGhlIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rcy5cbiAgY29uc3QgX3JlZ2lzdGVyZWRIb29rcyA9IChyZWdpc3RyeS5fcmVnaXN0ZXJlZEhvb2tzID0gcmVnaXN0cnkuX3JlZ2lzdGVyZWRIb29rcyB8fCB7fSk7XG4gIGNvbnN0IGhvb2tzID0gKF9yZWdpc3RlcmVkSG9va3NbZXZlbnRUeXBlLm5hbWVdID0gW10pO1xuICBjb25zdCByZW1vdmVIb29rRm46IChob29rOiBSZWdpc3RlcmVkSG9vaykgPT4gdm9pZCA9IHJlbW92ZUZyb20oaG9va3MpO1xuXG4gIC8vIENyZWF0ZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBvbiB0aGUgSUhvb2tSZWdpc3RyeSBmb3IgdGhlIGV2ZW50XG4gIHJlZ2lzdHJ5W2V2ZW50VHlwZS5uYW1lXSA9IGhvb2tSZWdpc3RyYXRpb25GbjtcblxuICBmdW5jdGlvbiBob29rUmVnaXN0cmF0aW9uRm4obWF0Y2hPYmplY3QsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZWdpc3RlcmVkSG9vayA9IG5ldyBSZWdpc3RlcmVkSG9vayhcbiAgICAgIHRyYW5zaXRpb25TZXJ2aWNlLFxuICAgICAgZXZlbnRUeXBlLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBtYXRjaE9iamVjdCxcbiAgICAgIHJlbW92ZUhvb2tGbixcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGhvb2tzLnB1c2gocmVnaXN0ZXJlZEhvb2spO1xuICAgIHJldHVybiByZWdpc3RlcmVkSG9vay5kZXJlZ2lzdGVyLmJpbmQocmVnaXN0ZXJlZEhvb2spO1xuICB9XG5cbiAgcmV0dXJuIGhvb2tSZWdpc3RyYXRpb25Gbjtcbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdHJhbnNpdGlvbiAqLyAvKiogKi9cbmltcG9ydCB7IGV4dGVuZCwgdGFpbCwgYXNzZXJ0UHJlZGljYXRlLCB1bm5lc3RSLCBpZGVudGl0eSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcblxuaW1wb3J0IHtcbiAgVHJhbnNpdGlvbk9wdGlvbnMsXG4gIFRyYW5zaXRpb25Ib29rT3B0aW9ucyxcbiAgSUhvb2tSZWdpc3RyeSxcbiAgVHJlZUNoYW5nZXMsXG4gIElNYXRjaGluZ05vZGVzLFxuICBUcmFuc2l0aW9uSG9va1BoYXNlLFxuICBUcmFuc2l0aW9uSG9va1Njb3BlLFxufSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2sgfSBmcm9tICcuL3RyYW5zaXRpb25Ib29rJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uRXZlbnRUeXBlIH0gZnJvbSAnLi90cmFuc2l0aW9uRXZlbnRUeXBlJztcbmltcG9ydCB7IFJlZ2lzdGVyZWRIb29rIH0gZnJvbSAnLi9ob29rUmVnaXN0cnknO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgcmV0dXJucyBhcHBsaWNhYmxlIFRyYW5zaXRpb25Ib29rcyBmb3IgYSBzcGVjaWZpYyBUcmFuc2l0aW9uIGluc3RhbmNlLlxuICpcbiAqIEhvb2tzIChbW1JlZ2lzdGVyZWRIb29rXV0pIG1heSBiZSByZWdpc3RlcmVkIGdsb2JhbGx5LCBlLmcuLCAkdHJhbnNpdGlvbnMub25FbnRlciguLi4pLCBvciBsb2NhbGx5LCBlLmcuXG4gKiBteVRyYW5zaXRpb24ub25FbnRlciguLi4pLiAgVGhlIEhvb2tCdWlsZGVyIGZpbmRzIG1hdGNoaW5nIFJlZ2lzdGVyZWRIb29rcyAod2hlcmUgdGhlIG1hdGNoIGNyaXRlcmlhIGlzXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIG9mIGhvb2spXG4gKlxuICogVGhlIEhvb2tCdWlsZGVyIGFsc28gY29udmVydHMgUmVnaXN0ZXJlZEhvb2tzIG9iamVjdHMgdG8gVHJhbnNpdGlvbkhvb2sgb2JqZWN0cywgd2hpY2ggYXJlIHVzZWQgdG8gcnVuIGEgVHJhbnNpdGlvbi5cbiAqXG4gKiBUaGUgSG9va0J1aWxkZXIgY29uc3RydWN0b3IgaXMgZ2l2ZW4gdGhlICR0cmFuc2l0aW9ucyBzZXJ2aWNlIGFuZCBhIFRyYW5zaXRpb24gaW5zdGFuY2UuICBUaHVzLCBhIEhvb2tCdWlsZGVyXG4gKiBpbnN0YW5jZSBtYXkgb25seSBiZSB1c2VkIGZvciBvbmUgc3BlY2lmaWMgVHJhbnNpdGlvbiBvYmplY3QuIChzaWRlIG5vdGU6IHRoZSBfdHJlZUNoYW5nZXMgYWNjZXNzb3IgaXMgcHJpdmF0ZVxuICogaW4gdGhlIFRyYW5zaXRpb24gY2xhc3MsIHNvIHdlIG11c3QgYWxzbyBwcm92aWRlIHRoZSBUcmFuc2l0aW9uJ3MgX3RyZWVDaGFuZ2VzKVxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEhvb2tCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7fVxuXG4gIGJ1aWxkSG9va3NGb3JQaGFzZShwaGFzZTogVHJhbnNpdGlvbkhvb2tQaGFzZSk6IFRyYW5zaXRpb25Ib29rW10ge1xuICAgIGNvbnN0ICR0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgcmV0dXJuICR0cmFuc2l0aW9ucy5fcGx1Z2luYXBpXG4gICAgICAuX2dldEV2ZW50cyhwaGFzZSlcbiAgICAgIC5tYXAodHlwZSA9PiB0aGlzLmJ1aWxkSG9va3ModHlwZSkpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgLmZpbHRlcihpZGVudGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBuZXdseSBidWlsdCBUcmFuc2l0aW9uSG9vayBvYmplY3RzLlxuICAgKlxuICAgKiAtIEZpbmRzIGFsbCBSZWdpc3RlcmVkSG9va3MgcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIGBob29rVHlwZWAgd2hpY2ggbWF0Y2hlZCB0aGUgdHJhbnNpdGlvbidzIFtbVHJlZUNoYW5nZXNdXS5cbiAgICogLSBGaW5kcyBbW1BhdGhOb2RlXV0gKG9yIGBQYXRoTm9kZVtdYCkgdG8gdXNlIGFzIHRoZSBUcmFuc2l0aW9uSG9vayBjb250ZXh0KHMpXG4gICAqIC0gRm9yIGVhY2ggb2YgdGhlIFtbUGF0aE5vZGVdXXMsIGNyZWF0ZXMgYSBUcmFuc2l0aW9uSG9va1xuICAgKlxuICAgKiBAcGFyYW0gaG9va1R5cGUgdGhlIHR5cGUgb2YgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uLCBlLmcuLCAnb25FbnRlcicsICdvbkZpbmlzaCcuXG4gICAqL1xuICBidWlsZEhvb2tzKGhvb2tUeXBlOiBUcmFuc2l0aW9uRXZlbnRUeXBlKTogVHJhbnNpdGlvbkhvb2tbXSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbjtcbiAgICBjb25zdCB0cmVlQ2hhbmdlcyA9IHRyYW5zaXRpb24udHJlZUNoYW5nZXMoKTtcblxuICAgIC8vIEZpbmQgYWxsIHRoZSBtYXRjaGluZyByZWdpc3RlcmVkIGhvb2tzIGZvciBhIGdpdmVuIGhvb2sgdHlwZVxuICAgIGNvbnN0IG1hdGNoaW5nSG9va3MgPSB0aGlzLmdldE1hdGNoaW5nSG9va3MoaG9va1R5cGUsIHRyZWVDaGFuZ2VzLCB0cmFuc2l0aW9uKTtcbiAgICBpZiAoIW1hdGNoaW5nSG9va3MpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGJhc2VIb29rT3B0aW9ucyA9IDxUcmFuc2l0aW9uSG9va09wdGlvbnM+e1xuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICAgIGN1cnJlbnQ6IHRyYW5zaXRpb24ub3B0aW9ucygpLmN1cnJlbnQsXG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VUcmFuc2l0aW9uSG9va3MgPSAoaG9vazogUmVnaXN0ZXJlZEhvb2spID0+IHtcbiAgICAgIC8vIEZldGNoIHRoZSBOb2RlcyB0aGF0IGNhdXNlZCB0aGlzIGhvb2sgdG8gbWF0Y2guXG4gICAgICBjb25zdCBtYXRjaGVzOiBJTWF0Y2hpbmdOb2RlcyA9IGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcywgdHJhbnNpdGlvbik7XG4gICAgICAvLyBTZWxlY3QgdGhlIFBhdGhOb2RlW10gdGhhdCB3aWxsIGJlIHVzZWQgYXMgVHJhbnNpdGlvbkhvb2sgY29udGV4dCBvYmplY3RzXG4gICAgICBjb25zdCBtYXRjaGluZ05vZGVzOiBQYXRoTm9kZVtdID0gbWF0Y2hlc1tob29rVHlwZS5jcml0ZXJpYU1hdGNoUGF0aC5uYW1lXTtcblxuICAgICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIEhvb2tUdXBsZXNcbiAgICAgIHJldHVybiBtYXRjaGluZ05vZGVzLm1hcChub2RlID0+IHtcbiAgICAgICAgY29uc3QgX29wdGlvbnMgPSBleHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmluZDogaG9vay5iaW5kLFxuICAgICAgICAgICAgdHJhY2VEYXRhOiB7IGhvb2tUeXBlOiBob29rVHlwZS5uYW1lLCBjb250ZXh0OiBub2RlIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYXNlSG9va09wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IGhvb2tUeXBlLmNyaXRlcmlhTWF0Y2hQYXRoLnNjb3BlID09PSBUcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFID8gbm9kZS5zdGF0ZS5zZWxmIDogbnVsbDtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbkhvb2sgPSBuZXcgVHJhbnNpdGlvbkhvb2sodHJhbnNpdGlvbiwgc3RhdGUsIGhvb2ssIF9vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIDxIb29rVHVwbGU+eyBob29rLCBub2RlLCB0cmFuc2l0aW9uSG9vayB9O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBtYXRjaGluZ0hvb2tzXG4gICAgICAubWFwKG1ha2VUcmFuc2l0aW9uSG9va3MpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgLnNvcnQodHVwbGVTb3J0KGhvb2tUeXBlLnJldmVyc2VTb3J0KSlcbiAgICAgIC5tYXAodHVwbGUgPT4gdHVwbGUudHJhbnNpdGlvbkhvb2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBSZWdpc3RlcmVkSG9va3MgZnJvbTpcbiAgICogLSBUaGUgVHJhbnNpdGlvbiBvYmplY3QgaW5zdGFuY2UgaG9vayByZWdpc3RyeVxuICAgKiAtIFRoZSBUcmFuc2l0aW9uU2VydmljZSAoJHRyYW5zaXRpb25zKSBnbG9iYWwgaG9vayByZWdpc3RyeVxuICAgKlxuICAgKiB3aGljaCBtYXRjaGVkOlxuICAgKiAtIHRoZSBldmVudFR5cGVcbiAgICogLSB0aGUgbWF0Y2hDcml0ZXJpYSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlZCBbW1JlZ2lzdGVyZWRIb29rXV1zXG4gICAqL1xuICBwdWJsaWMgZ2V0TWF0Y2hpbmdIb29rcyhcbiAgICBob29rVHlwZTogVHJhbnNpdGlvbkV2ZW50VHlwZSxcbiAgICB0cmVlQ2hhbmdlczogVHJlZUNoYW5nZXMsXG4gICAgdHJhbnNpdGlvbjogVHJhbnNpdGlvblxuICApOiBSZWdpc3RlcmVkSG9va1tdIHtcbiAgICBjb25zdCBpc0NyZWF0ZSA9IGhvb2tUeXBlLmhvb2tQaGFzZSA9PT0gVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7XG5cbiAgICAvLyBJbnN0YW5jZSBhbmQgR2xvYmFsIGhvb2sgcmVnaXN0cmllc1xuICAgIGNvbnN0ICR0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgY29uc3QgcmVnaXN0cmllcyA9IGlzQ3JlYXRlID8gWyR0cmFuc2l0aW9uc10gOiBbdGhpcy50cmFuc2l0aW9uLCAkdHJhbnNpdGlvbnNdO1xuXG4gICAgcmV0dXJuIHJlZ2lzdHJpZXNcbiAgICAgIC5tYXAoKHJlZzogSUhvb2tSZWdpc3RyeSkgPT4gcmVnLmdldEhvb2tzKGhvb2tUeXBlLm5hbWUpKSAvLyBHZXQgbmFtZWQgaG9va3MgZnJvbSByZWdpc3RyaWVzXG4gICAgICAuZmlsdGVyKGFzc2VydFByZWRpY2F0ZShpc0FycmF5LCBgYnJva2VuIGV2ZW50IG5hbWVkOiAke2hvb2tUeXBlLm5hbWV9YCkpIC8vIFNhbml0eSBjaGVja1xuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gVW4tbmVzdCBSZWdpc3RlcmVkSG9va1tdW10gdG8gUmVnaXN0ZXJlZEhvb2tbXSBhcnJheVxuICAgICAgLmZpbHRlcihob29rID0+IGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcywgdHJhbnNpdGlvbikpOyAvLyBPbmx5IHRob3NlIHNhdGlzZnlpbmcgbWF0Y2hDcml0ZXJpYVxuICB9XG59XG5cbmludGVyZmFjZSBIb29rVHVwbGUge1xuICBob29rOiBSZWdpc3RlcmVkSG9vaztcbiAgbm9kZTogUGF0aE5vZGU7XG4gIHRyYW5zaXRpb25Ib29rOiBUcmFuc2l0aW9uSG9vaztcbn1cblxuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIGEgc29ydCBmdW5jdGlvbiBmb3IgSG9va1R1cGxlcy5cbiAqXG4gKiBUaGUgc29ydCBmdW5jdGlvbiBmaXJzdCBjb21wYXJlcyB0aGUgUGF0aE5vZGUgZGVwdGggKGhvdyBkZWVwIGluIHRoZSBzdGF0ZSB0cmVlIGEgbm9kZSBpcyksIHRoZW4gY29tcGFyZXNcbiAqIHRoZSBFdmVudEhvb2sgcHJpb3JpdHkuXG4gKlxuICogQHBhcmFtIHJldmVyc2VEZXB0aFNvcnQgYSBib29sZWFuLCB3aGVuIHRydWUsIHJldmVyc2VzIHRoZSBzb3J0IG9yZGVyIGZvciB0aGUgbm9kZSBkZXB0aFxuICogQHJldHVybnMgYSB0dXBsZSBzb3J0IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHR1cGxlU29ydChyZXZlcnNlRGVwdGhTb3J0ID0gZmFsc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vZGVEZXB0aFRoZW5Qcmlvcml0eShsOiBIb29rVHVwbGUsIHI6IEhvb2tUdXBsZSk6IG51bWJlciB7XG4gICAgY29uc3QgZmFjdG9yID0gcmV2ZXJzZURlcHRoU29ydCA/IC0xIDogMTtcbiAgICBjb25zdCBkZXB0aERlbHRhID0gKGwubm9kZS5zdGF0ZS5wYXRoLmxlbmd0aCAtIHIubm9kZS5zdGF0ZS5wYXRoLmxlbmd0aCkgKiBmYWN0b3I7XG4gICAgcmV0dXJuIGRlcHRoRGVsdGEgIT09IDAgPyBkZXB0aERlbHRhIDogci5ob29rLnByaW9yaXR5IC0gbC5ob29rLnByaW9yaXR5O1xuICB9O1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiAqL1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tICcuLi9jb21tb24vdHJhY2UnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmdzJztcbmltcG9ydCB7IG1hcCwgZmluZCwgZXh0ZW5kLCBtZXJnZVIsIHRhaWwsIG9taXQsIGFycmF5VHVwbGVzLCB1bm5lc3RSLCBpZGVudGl0eSwgYW55VHJ1ZVIgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGlzT2JqZWN0LCBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IHByb3AsIHByb3BFcSwgdmFsLCBub3QsIGlzIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uLCBTdGF0ZU9yTmFtZSB9IGZyb20gJy4uL3N0YXRlL2ludGVyZmFjZSc7XG5pbXBvcnQge1xuICBUcmFuc2l0aW9uT3B0aW9ucyxcbiAgVHJlZUNoYW5nZXMsXG4gIElIb29rUmVnaXN0cnksXG4gIFRyYW5zaXRpb25Ib29rUGhhc2UsXG4gIFJlZ2lzdGVyZWRIb29rcyxcbiAgSG9va1JlZ09wdGlvbnMsXG4gIEhvb2tNYXRjaENyaXRlcmlhLFxuICBUcmFuc2l0aW9uU3RhdGVIb29rRm4sXG4gIFRyYW5zaXRpb25Ib29rRm4sXG59IGZyb20gJy4vaW50ZXJmYWNlJzsgLy8gaGFzIG9yIGlzIHVzaW5nXG5pbXBvcnQgeyBUcmFuc2l0aW9uSG9vayB9IGZyb20gJy4vdHJhbnNpdGlvbkhvb2snO1xuaW1wb3J0IHsgbWF0Y2hTdGF0ZSwgbWFrZUV2ZW50LCBSZWdpc3RlcmVkSG9vayB9IGZyb20gJy4vaG9va1JlZ2lzdHJ5JztcbmltcG9ydCB7IEhvb2tCdWlsZGVyIH0gZnJvbSAnLi9ob29rQnVpbGRlcic7XG5pbXBvcnQgeyBQYXRoTm9kZSB9IGZyb20gJy4uL3BhdGgvcGF0aE5vZGUnO1xuaW1wb3J0IHsgUGF0aFV0aWxzIH0gZnJvbSAnLi4vcGF0aC9wYXRoVXRpbHMnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL3RhcmdldFN0YXRlJztcbmltcG9ydCB7IFBhcmFtIH0gZnJvbSAnLi4vcGFyYW1zL3BhcmFtJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuLi9yZXNvbHZlL3Jlc29sdmFibGUnO1xuaW1wb3J0IHsgVmlld0NvbmZpZyB9IGZyb20gJy4uL3ZpZXcvaW50ZXJmYWNlJztcbmltcG9ydCB7IFJlc29sdmVDb250ZXh0IH0gZnJvbSAnLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dCc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBVSUluamVjdG9yIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFJhd1BhcmFtcyB9IGZyb20gJy4uL3BhcmFtcy9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUmVzb2x2YWJsZUxpdGVyYWwgfSBmcm9tICcuLi9yZXNvbHZlL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBSZWplY3Rpb24gfSBmcm9tICcuL3JlamVjdEZhY3RvcnknO1xuaW1wb3J0IHsgYXBwbHlQYWlycywgZmxhdHRlblIsIHVuaXFSIH0gZnJvbSAnLi4vY29tbW9uJztcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHN0YXRlU2VsZjogKF9zdGF0ZTogU3RhdGVPYmplY3QpID0+IFN0YXRlRGVjbGFyYXRpb24gPSBwcm9wKCdzZWxmJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gc3RhdGVzLlxuICpcbiAqIFdoZW4gbmF2aWdhdGluZyB0byBhIHN0YXRlLCB3ZSBhcmUgdHJhbnNpdGlvbmluZyAqKmZyb20qKiB0aGUgY3VycmVudCBzdGF0ZSAqKnRvKiogdGhlIG5ldyBzdGF0ZS5cbiAqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdG8vZnJvbSBzdGF0ZXMsIHBhcmFtZXRlcnMsIHJlc29sdmVzLlxuICogSXQgaGFzIGluZm9ybWF0aW9uIGFib3V0IGFsbCBzdGF0ZXMgYmVpbmcgZW50ZXJlZCBhbmQgZXhpdGVkIGFzIGEgcmVzdWx0IG9mIHRoZSB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNpdGlvbiBpbXBsZW1lbnRzIElIb29rUmVnaXN0cnkge1xuICAvKiogQGhpZGRlbiAqL1xuICBzdGF0aWMgZGlUb2tlbiA9IFRyYW5zaXRpb247XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIGFuIGF1dG8gaW5jcmVtZW50aW5nIGludGVnZXIsIHN0YXJ0aW5nIGZyb20gYDBgLlxuICAgKi9cbiAgJGlkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcbiAgICpcbiAgICogVGhpcyByZWZlcmVuY2UgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZSByb3V0ZXIgc2VydmljZXMsIHN1Y2ggYXMgdGhlIFtbU3RhdGVTZXJ2aWNlXV1cbiAgICovXG4gIHJvdXRlcjogVUlSb3V0ZXI7XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfZGVmZXJyZWQgPSBzZXJ2aWNlcy4kcS5kZWZlcigpO1xuICAvKipcbiAgICogVGhpcyBwcm9taXNlIGlzIHJlc29sdmVkIG9yIHJlamVjdGVkIGJhc2VkIG9uIHRoZSBvdXRjb21lIG9mIHRoZSBUcmFuc2l0aW9uLlxuICAgKlxuICAgKiBXaGVuIHRoZSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkXG4gICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgdW5zdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoZSBbW1JlamVjdGlvbl1dIG9yIGphdmFzY3JpcHQgZXJyb3JcbiAgICovXG4gIHByb21pc2U6IFByb21pc2U8YW55PiA9IHRoaXMuX2RlZmVycmVkLnByb21pc2U7XG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSB0cmFuc2l0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAqXG4gICAqIEFmdGVyIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uLCB0aGlzIHZhbHVlIGlzIHNldCB0byB0cnVlLlxuICAgKiBBZnRlciBhbiB1bnN1Y2Nlc3NmdWwgdHJhbnNpdGlvbiwgdGhpcyB2YWx1ZSBpcyBzZXQgdG8gZmFsc2UuXG4gICAqXG4gICAqIFRoZSB2YWx1ZSB3aWxsIGJlIHVuZGVmaW5lZCBpZiB0aGUgdHJhbnNpdGlvbiBpcyBub3QgY29tcGxldGVcbiAgICovXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIC8qKiBAaGlkZGVuICovXG4gIF9hYm9ydGVkOiBib29sZWFuO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9lcnJvcjogUmVqZWN0aW9uO1xuXG4gIC8qKiBAaGlkZGVuIEhvbGRzIHRoZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgc3VjaCBhcyB0aG9zZSBwYXNzZWQgdG8gVHJhbnNpdGlvbi5vblN0YXJ0KCkgKi9cbiAgX3JlZ2lzdGVyZWRIb29rczogUmVnaXN0ZXJlZEhvb2tzID0ge307XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnM7XG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX3RyZWVDaGFuZ2VzOiBUcmVlQ2hhbmdlcztcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfdGFyZ2V0U3RhdGU6IFRhcmdldFN0YXRlO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9ob29rQnVpbGRlciA9IG5ldyBIb29rQnVpbGRlcih0aGlzKTtcblxuICAvKiogQGhpZGRlbiAqL1xuICBvbkJlZm9yZShjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvblN0YXJ0KGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uRXhpdChjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uUmV0YWluKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25FbnRlcihjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uRmluaXNoKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uU3VjY2Vzcyhjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvbkVycm9yKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiogQGhpZGRlblxuICAgKiBDcmVhdGVzIHRoZSB0cmFuc2l0aW9uLWxldmVsIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uc1xuICAgKiAod2hpY2ggY2FuIHRoZW4gYmUgdXNlZCB0byByZWdpc3RlciBob29rcylcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMoKSB7XG4gICAgdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuX3BsdWdpbmFwaVxuICAgICAgLl9nZXRFdmVudHMoKVxuICAgICAgLmZpbHRlcih0eXBlID0+IHR5cGUuaG9va1BoYXNlICE9PSBUcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURSlcbiAgICAgIC5mb3JFYWNoKHR5cGUgPT4gbWFrZUV2ZW50KHRoaXMsIHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLCB0eXBlKSk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpICovXG4gIGdldEhvb2tzKGhvb2tOYW1lOiBzdHJpbmcpOiBSZWdpc3RlcmVkSG9va1tdIHtcbiAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZEhvb2tzW2hvb2tOYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFRyYW5zaXRpb24gb2JqZWN0LlxuICAgKlxuICAgKiBJZiB0aGUgdGFyZ2V0IHN0YXRlIGlzIG5vdCB2YWxpZCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICpcbiAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBwYXRoIG9mIFtbUGF0aE5vZGVdXXMgZnJvbSB3aGljaCB0aGUgdHJhbnNpdGlvbiBpcyBsZWF2aW5nLiAgVGhlIGxhc3Qgbm9kZSBpbiB0aGUgYGZyb21QYXRoYFxuICAgKiAgICAgICAgZW5jYXBzdWxhdGVzIHRoZSBcImZyb20gc3RhdGVcIi5cbiAgICogQHBhcmFtIHRhcmdldFN0YXRlIFRoZSB0YXJnZXQgc3RhdGUgYW5kIHBhcmFtZXRlcnMgYmVpbmcgdHJhbnNpdGlvbmVkIHRvIChhbHNvLCB0aGUgdHJhbnNpdGlvbiBvcHRpb25zKVxuICAgKiBAcGFyYW0gcm91dGVyIFRoZSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZyb21QYXRoOiBQYXRoTm9kZVtdLCB0YXJnZXRTdGF0ZTogVGFyZ2V0U3RhdGUsIHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICB0aGlzLl90YXJnZXRTdGF0ZSA9IHRhcmdldFN0YXRlO1xuXG4gICAgaWYgKCF0YXJnZXRTdGF0ZS52YWxpZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IoKSk7XG4gICAgfVxuXG4gICAgLy8gY3VycmVudCgpIGlzIGFzc3VtZWQgdG8gY29tZSBmcm9tIHRhcmdldFN0YXRlLm9wdGlvbnMsIGJ1dCBwcm92aWRlIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb3RoZXJ3aXNlLlxuICAgIHRoaXMuX29wdGlvbnMgPSBleHRlbmQoeyBjdXJyZW50OiB2YWwodGhpcykgfSwgdGFyZ2V0U3RhdGUub3B0aW9ucygpKTtcbiAgICB0aGlzLiRpZCA9IHJvdXRlci50cmFuc2l0aW9uU2VydmljZS5fdHJhbnNpdGlvbkNvdW50Kys7XG4gICAgY29uc3QgdG9QYXRoID0gUGF0aFV0aWxzLmJ1aWxkVG9QYXRoKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSk7XG4gICAgdGhpcy5fdHJlZUNoYW5nZXMgPSBQYXRoVXRpbHMudHJlZUNoYW5nZXMoZnJvbVBhdGgsIHRvUGF0aCwgdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZSk7XG4gICAgdGhpcy5jcmVhdGVUcmFuc2l0aW9uSG9va1JlZ0ZucygpO1xuXG4gICAgY29uc3Qgb25DcmVhdGVIb29rcyA9IHRoaXMuX2hvb2tCdWlsZGVyLmJ1aWxkSG9va3NGb3JQaGFzZShUcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURSk7XG4gICAgVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3Mob25DcmVhdGVIb29rcywgKCkgPT4gbnVsbCk7XG5cbiAgICB0aGlzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlWaWV3Q29uZmlncyhyb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgY29uc3QgZW50ZXJpbmdTdGF0ZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZy5tYXAobm9kZSA9PiBub2RlLnN0YXRlKTtcbiAgICBQYXRoVXRpbHMuYXBwbHlWaWV3Q29uZmlncyhyb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuJHZpZXcsIHRoaXMuX3RyZWVDaGFuZ2VzLnRvLCBlbnRlcmluZ1N0YXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsYXBpXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBmcm9tIFtTdGF0ZV0gb2JqZWN0XG4gICAqL1xuICAkZnJvbSgpIHtcbiAgICByZXR1cm4gdGFpbCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tKS5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGludGVybmFsIHRvIFtTdGF0ZV0gb2JqZWN0XG4gICAqL1xuICAkdG8oKSB7XG4gICAgcmV0dXJuIHRhaWwodGhpcy5fdHJlZUNoYW5nZXMudG8pLnN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwiZnJvbSBzdGF0ZVwiXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHN0YXRlIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgY29taW5nICpmcm9tKi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyAoXCJmcm9tIHN0YXRlXCIpLlxuICAgKi9cbiAgZnJvbSgpOiBTdGF0ZURlY2xhcmF0aW9uIHtcbiAgICByZXR1cm4gdGhpcy4kZnJvbSgpLnNlbGY7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJ0byBzdGF0ZVwiXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHN0YXRlIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgZ29pbmcgKnRvKi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXG4gICAqL1xuICB0bygpOiBTdGF0ZURlY2xhcmF0aW9uIHtcbiAgICByZXR1cm4gdGhpcy4kdG8oKS5zZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIFRhcmdldCBTdGF0ZVxuICAgKlxuICAgKiBBIHRyYW5zaXRpb24ncyBbW1RhcmdldFN0YXRlXV0gZW5jYXBzdWxhdGVzIHRoZSBbW3RvXV0gc3RhdGUsIHRoZSBbW3BhcmFtc11dLCBhbmQgdGhlIFtbb3B0aW9uc11dIGFzIGEgc2luZ2xlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIFtbVGFyZ2V0U3RhdGVdXSBvZiB0aGlzIFRyYW5zaXRpb25cbiAgICovXG4gIHRhcmdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHRyYW5zaXRpb25zIGFyZSBlcXVpdmFsZW50LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaXMoY29tcGFyZTogVHJhbnNpdGlvbiB8IHsgdG8/OiBhbnk7IGZyb20/OiBhbnkgfSk6IGJvb2xlYW4ge1xuICAgIGlmIChjb21wYXJlIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xuICAgICAgLy8gVE9ETzogQWxzbyBjb21wYXJlIHBhcmFtZXRlcnNcbiAgICAgIHJldHVybiB0aGlzLmlzKHsgdG86IGNvbXBhcmUuJHRvKCkubmFtZSwgZnJvbTogY29tcGFyZS4kZnJvbSgpLm5hbWUgfSk7XG4gICAgfVxuICAgIHJldHVybiAhKFxuICAgICAgKGNvbXBhcmUudG8gJiYgIW1hdGNoU3RhdGUodGhpcy4kdG8oKSwgY29tcGFyZS50bywgdGhpcykpIHx8XG4gICAgICAoY29tcGFyZS5mcm9tICYmICFtYXRjaFN0YXRlKHRoaXMuJGZyb20oKSwgY29tcGFyZS5mcm9tLCB0aGlzKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdHJhbnNpdGlvbiBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGEgdHJhbnNpdGlvbiBhcyBrZXkvdmFsdWUgcGFpcnMuXG4gICAqIFRoaXMgb2JqZWN0IGlzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgcmV0dXJucyB0aGUgbmV3IHBhcmFtZXRlciB2YWx1ZXMgKGZvciB0aGUgXCJ0byBzdGF0ZVwiKS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgdG9QYXJhbXMgPSB0cmFuc2l0aW9uLnBhcmFtcygpO1xuICAgKiBgYGBcbiAgICpcbiAgICogVG8gcmV0dXJuIHRoZSBwcmV2aW91cyBwYXJhbWV0ZXIgdmFsdWVzLCAgc3VwcGx5IGAnZnJvbSdgIGFzIHRoZSBgcGF0aG5hbWVgIGFyZ3VtZW50LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBmcm9tUGFyYW1zID0gdHJhbnNpdGlvbi5wYXJhbXMoJ2Zyb20nKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBwYXRobmFtZSB0aGUgbmFtZSBvZiB0aGUgdHJlZUNoYW5nZXMgcGF0aCB0byBnZXQgcGFyYW1ldGVyIHZhbHVlcyBmb3I6XG4gICAqICAgKGAndG8nYCwgYCdmcm9tJ2AsIGAnZW50ZXJpbmcnYCwgYCdleGl0aW5nJ2AsIGAncmV0YWluZWQnYClcbiAgICpcbiAgICogQHJldHVybnMgdHJhbnNpdGlvbiBwYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgZGVzaXJlZCBwYXRoLlxuICAgKi9cbiAgcGFyYW1zKHBhdGhuYW1lPzogc3RyaW5nKTogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBhbnkgfTtcbiAgcGFyYW1zPFQ+KHBhdGhuYW1lPzogc3RyaW5nKTogVDtcbiAgcGFyYW1zKHBhdGhuYW1lID0gJ3RvJykge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXS5tYXAocHJvcCgncGFyYW1WYWx1ZXMnKSkucmVkdWNlKG1lcmdlUiwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXcgdmFsdWVzIG9mIGFueSBwYXJhbWV0ZXJzIHRoYXQgY2hhbmdlZCBkdXJpbmcgdGhpcyB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIGFueSBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgaGF2ZSBjaGFuZ2VkIGR1cmluZyBhIHRyYW5zaXRpb24sIGFzIGtleS92YWx1ZSBwYWlycy5cbiAgICpcbiAgICogLSBBbnkgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGhhdmUgY2hhbmdlZCB3aWxsIGJlIHByZXNlbnQgb24gdGhlIHJldHVybmVkIG9iamVjdCByZWZsZWN0aW5nIHRoZSBuZXcgdmFsdWUuXG4gICAqIC0gQW55IHBhcmFtZXRlcnMgdGhhdCAqbm90KiBoYXZlIGNoYW5nZWQgd2lsbCBub3QgYmUgcHJlc2VudCBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgKiAtIEFueSBuZXcgcGFyYW1ldGVycyB0aGF0IHdlcmVuJ3QgcHJlc2VudCBpbiB0aGUgXCJmcm9tXCIgc3RhdGUsIGJ1dCBhcmUgbm93IHByZXNlbnQgaW4gdGhlIFwidG9cIiBzdGF0ZSB3aWxsIGJlIHByZXNlbnQgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICogLSBBbnkgcHJldmlvdXMgcGFyYW1ldGVycyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCAoYmVjYXVzZSB0aGUgXCJ0b1wiIHN0YXRlIGRvZXNuJ3QgaGF2ZSB0aGVtKSB3aWxsIGJlIGluY2x1ZGVkIHdpdGggYSB2YWx1ZSBvZiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIG9iamVjdCBpcyBpbW11dGFibGUuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZXM6XG4gICAqXG4gICAqIEdpdmVuOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgc3RhdGVBID0geyBuYW1lOiAnc3RhdGVBJywgdXJsOiAnL3N0YXRlQS86cGFyYW0xL3BhcmFtMicgfVxuICAgKiB2YXIgc3RhdGVCID0geyBuYW1lOiAnc3RhdGVCJywgdXJsOiAnL3N0YXRlQi86cGFyYW0zJyB9XG4gICAqIHZhciBzdGF0ZUMgPSB7IG5hbWU6ICdzdGF0ZUIubmVzdCcsIHVybDogJy9uZXN0LzpwYXJhbTQnIH1cbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZSAxXG4gICAqXG4gICAqIEZyb20gYC9zdGF0ZUEvYWJjL2RlZmAgdG8gYC9zdGF0ZUEvYWJjL3h5emBcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNoYW5nZWQgPSB0cmFuc2l0aW9uLnBhcmFtc0NoYW5nZWQoKVxuICAgKiAvLyBjaGFuZ2VkIGlzIHsgcGFyYW0yOiAneHl6JyB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgdmFsdWUgb2YgYHBhcmFtMmAgY2hhbmdlZCB0byBgeHl6YC5cbiAgICogVGhlIHZhbHVlIG9mIGBwYXJhbTFgIHN0YXllZCB0aGUgc2FtZSBzbyBpdHMgdmFsdWUgaXMgbm90IHByZXNlbnQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZSAyXG4gICAqXG4gICAqIEZyb20gYC9zdGF0ZUEvYWJjL2RlZmAgdG8gYC9zdGF0ZUIvMTIzYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgY2hhbmdlZCA9IHRyYW5zaXRpb24ucGFyYW1zQ2hhbmdlZCgpXG4gICAqIC8vIGNoYW5nZWQgaXMgeyBwYXJhbTE6IHVuZGVmaW5lZCwgcGFyYW0yOiB1bmRlZmluZWQsIHBhcmFtMzogJzEyMycgfVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHZhbHVlIGBwYXJhbTNgIGlzIHByZXNlbnQgYmVjYXVzZSBpdCBpcyBhIG5ldyBwYXJhbS5cbiAgICogQm90aCBgcGFyYW0xYCBhbmQgYHBhcmFtMmAgYXJlIG5vIGxvbmdlciBwcmVzZW50IHNvIHRoZWlyIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlIDNcbiAgICpcbiAgICogRnJvbSBgL3N0YXRlQi8xMjNgIHRvIGAvc3RhdGVCLzEyMy9uZXN0LzQ1NmBcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNoYW5nZWQgPSB0cmFuc2l0aW9uLnBhcmFtc0NoYW5nZWQoKVxuICAgKiAvLyBjaGFuZ2VkIGlzIHsgcGFyYW00OiAnNDU2JyB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgdmFsdWUgYHBhcmFtNGAgaXMgcHJlc2VudCBiZWNhdXNlIGl0IGlzIGEgbmV3IHBhcmFtLlxuICAgKiBUaGUgdmFsdWUgb2YgYHBhcmFtM2AgZGlkIG5vdCBjaGFuZ2UsIHNvIGl0cyB2YWx1ZSBpcyBub3QgcHJlc2VudC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGNoYW5nZWQgcGFyYW1ldGVyIGtleXMvdmFsdWVzLlxuICAgKi9cbiAgcGFyYW1zQ2hhbmdlZCgpOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IGFueSB9O1xuICBwYXJhbXNDaGFuZ2VkPFQ+KCk6IFQ7XG4gIHBhcmFtc0NoYW5nZWQoKSB7XG4gICAgY29uc3QgZnJvbVBhcmFtcyA9IHRoaXMucGFyYW1zKCdmcm9tJyk7XG4gICAgY29uc3QgdG9QYXJhbXMgPSB0aGlzLnBhcmFtcygndG8nKTtcblxuICAgIC8vIEFsbCB0aGUgcGFyYW1ldGVycyBkZWNsYXJlZCBvbiBib3RoIHRoZSBcInRvXCIgYW5kIFwiZnJvbVwiIHBhdGhzXG4gICAgY29uc3QgYWxsUGFyYW1EZXNjcmlwdG9yczogUGFyYW1bXSA9IFtdXG4gICAgICAuY29uY2F0KHRoaXMuX3RyZWVDaGFuZ2VzLnRvKVxuICAgICAgLmNvbmNhdCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tKVxuICAgICAgLm1hcChwYXRoTm9kZSA9PiBwYXRoTm9kZS5wYXJhbVNjaGVtYSlcbiAgICAgIC5yZWR1Y2UoZmxhdHRlblIsIFtdKVxuICAgICAgLnJlZHVjZSh1bmlxUiwgW10pO1xuXG4gICAgY29uc3QgY2hhbmdlZFBhcmFtRGVzY3JpcHRvcnMgPSBQYXJhbS5jaGFuZ2VkKGFsbFBhcmFtRGVzY3JpcHRvcnMsIGZyb21QYXJhbXMsIHRvUGFyYW1zKTtcblxuICAgIHJldHVybiBjaGFuZ2VkUGFyYW1EZXNjcmlwdG9ycy5yZWR1Y2UoKGNoYW5nZWRWYWx1ZXMsIGRlc2NyaXB0b3IpID0+IHtcbiAgICAgIGNoYW5nZWRWYWx1ZXNbZGVzY3JpcHRvci5pZF0gPSB0b1BhcmFtc1tkZXNjcmlwdG9yLmlkXTtcbiAgICAgIHJldHVybiBjaGFuZ2VkVmFsdWVzO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgW1tVSUluamVjdG9yXV0gRGVwZW5kZW5jeSBJbmplY3RvclxuICAgKlxuICAgKiBSZXR1cm5zIGEgRGVwZW5kZW5jeSBJbmplY3RvciBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKHRvIHN0YXRlKS5cbiAgICogVGhlIGluamVjdG9yIHByb3ZpZGVzIHJlc29sdmUgdmFsdWVzIHdoaWNoIHRoZSB0YXJnZXQgc3RhdGUgaGFzIGFjY2VzcyB0by5cbiAgICpcbiAgICogVGhlIGBVSUluamVjdG9yYCBjYW4gYWxzbyBwcm92aWRlIHZhbHVlcyBmcm9tIHRoZSBuYXRpdmUgcm9vdC9nbG9iYWwgaW5qZWN0b3IgKG5nMS9uZzIpLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC5vbkVudGVyKHsgZW50ZXJpbmc6ICdteVN0YXRlJyB9LCB0cmFucyA9PiB7XG4gICAqICAgdmFyIG15UmVzb2x2ZVZhbHVlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ215UmVzb2x2ZScpO1xuICAgKiAgIC8vIEluamVjdCBhIGdsb2JhbCBzZXJ2aWNlIGZyb20gdGhlIGdsb2JhbC9uYXRpdmUgaW5qZWN0b3IgKGlmIGl0IGV4aXN0cylcbiAgICogICB2YXIgTXlTZXJ2aWNlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ015U2VydmljZScpO1xuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogSW4gc29tZSBjYXNlcyAoc3VjaCBhcyBgb25CZWZvcmVgKSwgeW91IG1heSBuZWVkIGFjY2VzcyB0byBzb21lIHJlc29sdmUgZGF0YSBidXQgaXQgaGFzIG5vdCB5ZXQgYmVlbiBmZXRjaGVkLlxuICAgKiBZb3UgY2FuIHVzZSBbW1VJSW5qZWN0b3IuZ2V0QXN5bmNdXSB0byBnZXQgYSBwcm9taXNlIGZvciB0aGUgZGF0YS5cbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAub25CZWZvcmUoe30sIHRyYW5zID0+IHtcbiAgICogICByZXR1cm4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYygnbXlSZXNvbHZlJykudGhlbihteVJlc29sdmVWYWx1ZSA9PlxuICAgKiAgICAgcmV0dXJuIG15UmVzb2x2ZVZhbHVlICE9PSAnQUJPUlQnO1xuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIElmIGEgYHN0YXRlYCBpcyBwcm92aWRlZCwgdGhlIGluamVjdG9yIHRoYXQgaXMgcmV0dXJuZWQgd2lsbCBiZSBsaW1pdGVkIHRvIHJlc29sdmUgdmFsdWVzIHRoYXQgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiBib3RoIGEgcGFyZW50IHN0YXRlIGBmb29gIGFuZCBhIGNoaWxkIHN0YXRlIGBmb28uYmFyYCBoYXZlIGJvdGggZGVmaW5lZCBhIHJlc29sdmUgc3VjaCBhcyBgZGF0YWAuXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLm9uRW50ZXIoeyB0bzogJ2Zvby5iYXInIH0sIHRyYW5zID0+IHtcbiAgICogICAvLyByZXR1cm5zIHJlc3VsdCBvZiBgZm9vYCBzdGF0ZSdzIGBteVJlc29sdmVgIHJlc29sdmVcbiAgICogICAvLyBldmVuIHRob3VnaCBgZm9vLmJhcmAgYWxzbyBoYXMgYSBgbXlSZXNvbHZlYCByZXNvbHZlXG4gICAqICAgdmFyIGZvb0RhdGEgPSB0cmFucy5pbmplY3RvcignZm9vJykuZ2V0KCdteVJlc29sdmUnKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3UgbmVlZCByZXNvbHZlIGRhdGEgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZXMsIHBhc3MgYCdmcm9tJ2AgYXMgYHBhdGhOYW1lYC5cbiAgICogVGhlIHJlc29sdmUgZGF0YSBmcm9tIHRoZSBgZnJvbWAgcGF0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC5vbkV4aXQoeyBleGl0aW5nOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgKiAgIC8vIEdldHMgdGhlIHJlc29sdmUgdmFsdWUgb2YgYG15UmVzb2x2ZWAgZnJvbSB0aGUgc3RhdGUgYmVpbmcgZXhpdGVkXG4gICAqICAgdmFyIGZvb0RhdGEgPSB0cmFucy5pbmplY3RvcihudWxsLCAnZnJvbScpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIExpbWl0cyB0aGUgcmVzb2x2ZXMgcHJvdmlkZWQgdG8gb25seSB0aGUgcmVzb2x2ZXMgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAqIEBwYXJhbSBwYXRoTmFtZSBEZWZhdWx0OiBgJ3RvJ2A6IENob29zZXMgdGhlIHBhdGggZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgaW5qZWN0b3IuIFVzZSB0aGlzIHRvIGFjY2VzcyByZXNvbHZlcyBmb3IgYGV4aXRpbmdgIHN0YXRlcy5cbiAgICpcbiAgICogQHJldHVybnMgYSBbW1VJSW5qZWN0b3JdXVxuICAgKi9cbiAgaW5qZWN0b3Ioc3RhdGU/OiBTdGF0ZU9yTmFtZSwgcGF0aE5hbWUgPSAndG8nKTogVUlJbmplY3RvciB7XG4gICAgbGV0IHBhdGg6IFBhdGhOb2RlW10gPSB0aGlzLl90cmVlQ2hhbmdlc1twYXRoTmFtZV07XG4gICAgaWYgKHN0YXRlKSBwYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgbm9kZSA9PiBub2RlLnN0YXRlID09PSBzdGF0ZSB8fCBub2RlLnN0YXRlLm5hbWUgPT09IHN0YXRlKTtcbiAgICByZXR1cm4gbmV3IFJlc29sdmVDb250ZXh0KHBhdGgpLmluamVjdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgYXZhaWxhYmxlIHJlc29sdmUgdG9rZW5zIChrZXlzKVxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFtbaW5qZWN0b3JdXSB0byBpbnNwZWN0IHRoZSByZXNvbHZlIHZhbHVlc1xuICAgKiBhdmFpbGFibGUgdG8gdGhlIFRyYW5zaXRpb24uXG4gICAqXG4gICAqIFRoaXMgcmV0dXJucyBhbGwgdGhlIHRva2VucyBkZWZpbmVkIG9uIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gYmxvY2tzLCBmb3IgdGhlIHN0YXRlc1xuICAgKiBpbiB0aGUgVHJhbnNpdGlvbidzIFtbVHJlZUNoYW5nZXMudG9dXSBwYXRoLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFRoaXMgZXhhbXBsZSBsb2dzIGFsbCByZXNvbHZlIHZhbHVlc1xuICAgKiBgYGBqc1xuICAgKiBsZXQgdG9rZW5zID0gdHJhbnMuZ2V0UmVzb2x2ZVRva2VucygpO1xuICAgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiBjb25zb2xlLmxvZyh0b2tlbiArIFwiID0gXCIgKyB0cmFucy5pbmplY3RvcigpLmdldCh0b2tlbikpKTtcbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgcHJvbWlzZXMgZm9yIGVhY2ggcmVzb2x2ZSB2YWx1ZS5cbiAgICogVGhpcyB0cmlnZ2VycyBmZXRjaGVzIG9mIHJlc29sdmVzIChpZiBhbnkgaGF2ZSBub3QgeWV0IGJlZW4gZmV0Y2hlZCkuXG4gICAqIFdoZW4gYWxsIHByb21pc2VzIGhhdmUgYWxsIHNldHRsZWQsIGl0IGxvZ3MgdGhlIHJlc29sdmUgdmFsdWVzLlxuICAgKiBgYGBqc1xuICAgKiBsZXQgdG9rZW5zID0gdHJhbnMuZ2V0UmVzb2x2ZVRva2VucygpO1xuICAgKiBsZXQgcHJvbWlzZSA9IHRva2Vucy5tYXAodG9rZW4gPT4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYyh0b2tlbikpO1xuICAgKiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gY29uc29sZS5sb2coXCJSZXNvbHZlZCB2YWx1ZXM6IFwiICsgdmFsdWVzKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlOiBBbmd1bGFyIDEgdXNlcnMgd2hvdWxkIHVzZSBgJHEuYWxsKClgXG4gICAqXG4gICAqIEBwYXJhbSBwYXRobmFtZSByZXNvbHZlIGNvbnRleHQncyBwYXRoIG5hbWUgKGUuZy4sIGB0b2Agb3IgYGZyb21gKVxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiByZXNvbHZlIHRva2VucyAoa2V5cylcbiAgICovXG4gIGdldFJlc29sdmVUb2tlbnMocGF0aG5hbWUgPSAndG8nKTogYW55W10ge1xuICAgIHJldHVybiBuZXcgUmVzb2x2ZUNvbnRleHQodGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdKS5nZXRUb2tlbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEeW5hbWljYWxseSBhZGRzIGEgbmV3IFtbUmVzb2x2YWJsZV1dIChpLmUuLCBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dKSB0byB0aGlzIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEFsbG93cyBhIHRyYW5zaXRpb24gaG9vayB0byBkeW5hbWljYWxseSBhZGQgYSBSZXNvbHZhYmxlIHRvIHRoaXMgVHJhbnNpdGlvbi5cbiAgICpcbiAgICogVXNlIHRoZSBbW1RyYW5zaXRpb24uaW5qZWN0b3JdXSB0byByZXRyaWV2ZSB0aGUgcmVzb2x2ZWQgZGF0YSBpbiBzdWJzZXF1ZW50IGhvb2tzIChbW1VJSW5qZWN0b3IuZ2V0XV0pLlxuICAgKlxuICAgKiBJZiBhIGBzdGF0ZWAgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBSZXNvbHZhYmxlIGlzIHByb2Nlc3NlZCB3aGVuIHRoYXQgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAgICogSWYgbm8gYHN0YXRlYCBpcyBwcm92aWRlZCB0aGVuIHRoZSByb290IHN0YXRlIGlzIHVzZWQuXG4gICAqIElmIHRoZSBnaXZlbiBgc3RhdGVgIGhhcyBhbHJlYWR5IGJlZW4gZW50ZXJlZCwgdGhlIFJlc29sdmFibGUgaXMgcHJvY2Vzc2VkIHdoZW4gYW55IGNoaWxkIHN0YXRlIGlzIGVudGVyZWQuXG4gICAqIElmIG5vIGNoaWxkIHN0YXRlcyB3aWxsIGJlIGVudGVyZWQsIHRoZSBSZXNvbHZhYmxlIGlzIHByb2Nlc3NlZCBkdXJpbmcgdGhlIGBvbkZpbmlzaGAgcGhhc2Ugb2YgdGhlIFRyYW5zaXRpb24uXG4gICAqXG4gICAqIFRoZSBgc3RhdGVgIGFyZ3VtZW50IGFsc28gc2NvcGVzIHRoZSByZXNvbHZlZCBkYXRhLlxuICAgKiBUaGUgcmVzb2x2ZWQgZGF0YSBpcyBhdmFpbGFibGUgZnJvbSB0aGUgaW5qZWN0b3IgZm9yIHRoYXQgYHN0YXRlYCBhbmQgYW55IGNoaWxkcmVuIHN0YXRlcy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdHJhbnNpdGlvbiA9PiB7XG4gICAqICAgdHJhbnNpdGlvbi5hZGRSZXNvbHZhYmxlKHtcbiAgICogICAgIHRva2VuOiAnbXlSZXNvbHZlJyxcbiAgICogICAgIGRlcHM6IFsnTXlTZXJ2aWNlJ10sXG4gICAqICAgICByZXNvbHZlRm46IG15U2VydmljZSA9PiBteVNlcnZpY2UuZ2V0RGF0YSgpXG4gICAqICAgfSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJlc29sdmFibGUgYSBbW1Jlc29sdmFibGVMaXRlcmFsXV0gb2JqZWN0IChvciBhIFtbUmVzb2x2YWJsZV1dKVxuICAgKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIGluIHRoZSBcInRvIHBhdGhcIiB3aGljaCBzaG91bGQgcmVjZWl2ZSB0aGUgbmV3IHJlc29sdmUgKG90aGVyd2lzZSwgdGhlIHJvb3Qgc3RhdGUpXG4gICAqL1xuICBhZGRSZXNvbHZhYmxlKHJlc29sdmFibGU6IFJlc29sdmFibGUgfCBSZXNvbHZhYmxlTGl0ZXJhbCwgc3RhdGU6IFN0YXRlT3JOYW1lID0gJycpOiB2b2lkIHtcbiAgICByZXNvbHZhYmxlID0gaXMoUmVzb2x2YWJsZSkocmVzb2x2YWJsZSkgPyByZXNvbHZhYmxlIDogbmV3IFJlc29sdmFibGUocmVzb2x2YWJsZSk7XG5cbiAgICBjb25zdCBzdGF0ZU5hbWU6IHN0cmluZyA9IHR5cGVvZiBzdGF0ZSA9PT0gJ3N0cmluZycgPyBzdGF0ZSA6IHN0YXRlLm5hbWU7XG4gICAgY29uc3QgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IGZpbmQodG9wYXRoLCBub2RlID0+IG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGVOYW1lKTtcbiAgICBjb25zdCByZXNvbHZlQ29udGV4dDogUmVzb2x2ZUNvbnRleHQgPSBuZXcgUmVzb2x2ZUNvbnRleHQodG9wYXRoKTtcbiAgICByZXNvbHZlQ29udGV4dC5hZGRSZXNvbHZhYmxlcyhbcmVzb2x2YWJsZSBhcyBSZXNvbHZhYmxlXSwgdGFyZ2V0Tm9kZS5zdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHJhbnNpdGlvbiBmcm9tIHdoaWNoIHRoaXMgdHJhbnNpdGlvbiB3YXMgcmVkaXJlY3RlZC5cbiAgICpcbiAgICogSWYgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyBhIHJlZGlyZWN0LCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2l0aW9uIHRoYXQgd2FzIHJlZGlyZWN0ZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgKiB0cmFuc2l0aW9uQS5vblN0YXJ0KHt9LCAoKSA9PiAkc3RhdGUudGFyZ2V0KCdCJykpO1xuICAgKiAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHsgdG86ICdCJyB9LCAodHJhbnMpID0+IHtcbiAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdCJzsgLy8gdHJ1ZVxuICAgKiAgIHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgVGhlIHByZXZpb3VzIFRyYW5zaXRpb24sIG9yIG51bGwgaWYgdGhpcyBUcmFuc2l0aW9uIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3Rpb25cbiAgICovXG4gIHJlZGlyZWN0ZWRGcm9tKCk6IFRyYW5zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnJlZGlyZWN0ZWRGcm9tIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgb3JpZ2luYWwgdHJhbnNpdGlvbiBpbiBhIHJlZGlyZWN0IGNoYWluXG4gICAqXG4gICAqIEEgdHJhbnNpdGlvbiBtaWdodCBiZWxvbmcgdG8gYSBsb25nIGNoYWluIG9mIG11bHRpcGxlIHJlZGlyZWN0cy5cbiAgICogVGhpcyBtZXRob2Qgd2Fsa3MgdGhlIFtbcmVkaXJlY3RlZEZyb21dXSBjaGFpbiBiYWNrIHRvIHRoZSBvcmlnaW5hbCAoZmlyc3QpIHRyYW5zaXRpb24gaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vIHN0YXRlc1xuICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdBJywgcmVkaXJlY3RUbzogJ0InIH0pO1xuICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdCJywgcmVkaXJlY3RUbzogJ0MnIH0pO1xuICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdDJywgcmVkaXJlY3RUbzogJ0QnIH0pO1xuICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdEJyB9KTtcbiAgICpcbiAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgKlxuICAgKiAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHsgdG86ICdEJyB9LCAodHJhbnMpID0+IHtcbiAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdEJzsgLy8gdHJ1ZVxuICAgKiAgIHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkudG8oKS5uYW1lID09PSAnQyc7IC8vIHRydWVcbiAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKSA9PT0gdHJhbnNpdGlvbkE7IC8vIHRydWVcbiAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKS50bygpLm5hbWUgPT09ICdBJzsgLy8gdHJ1ZVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBUcmFuc2l0aW9uIHRoYXQgc3RhcnRlZCBhIHJlZGlyZWN0IGNoYWluXG4gICAqL1xuICBvcmlnaW5hbFRyYW5zaXRpb24oKTogVHJhbnNpdGlvbiB7XG4gICAgY29uc3QgcmYgPSB0aGlzLnJlZGlyZWN0ZWRGcm9tKCk7XG4gICAgcmV0dXJuIChyZiAmJiByZi5vcmlnaW5hbFRyYW5zaXRpb24oKSkgfHwgdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRyYW5zaXRpb24gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBUcmFuc2l0aW9uLlxuICAgKi9cbiAgb3B0aW9ucygpOiBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGVudGVyZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IHdpbGwgYmUgZW50ZXJlZCBkdXJpbmcgdGhpcyB0cmFuc2l0aW9uLlxuICAgKi9cbiAgZW50ZXJpbmcoKTogU3RhdGVEZWNsYXJhdGlvbltdIHtcbiAgICByZXR1cm4gbWFwKHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nLCBwcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGV4aXRlZCBkdXJpbmcgdGhpcyB0cmFuc2l0aW9uLlxuICAgKi9cbiAgZXhpdGluZygpOiBTdGF0ZURlY2xhcmF0aW9uW10ge1xuICAgIHJldHVybiBtYXAodGhpcy5fdHJlZUNoYW5nZXMuZXhpdGluZywgcHJvcCgnc3RhdGUnKSlcbiAgICAgIC5tYXAoc3RhdGVTZWxmKVxuICAgICAgLnJldmVyc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgcmV0YWluZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IGFyZSBhbHJlYWR5IGVudGVyZWQgZnJvbSBhIHByZXZpb3VzIFRyYW5zaXRpb24sIHRoYXQgd2lsbCBub3QgYmVcbiAgICogICAgZXhpdGVkIGR1cmluZyB0aGlzIFRyYW5zaXRpb25cbiAgICovXG4gIHJldGFpbmVkKCk6IFN0YXRlRGVjbGFyYXRpb25bXSB7XG4gICAgcmV0dXJuIG1hcCh0aGlzLl90cmVlQ2hhbmdlcy5yZXRhaW5lZCwgcHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBbW1ZpZXdDb25maWddXXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgVHJhbnNpdGlvblxuICAgKlxuICAgKiBFYWNoIHN0YXRlIGNhbiBkZWZpbmUgb25lIG9yIG1vcmUgdmlld3MgKHRlbXBsYXRlL2NvbnRyb2xsZXIpLCB3aGljaCBhcmUgZW5jYXBzdWxhdGVkIGFzIGBWaWV3Q29uZmlnYCBvYmplY3RzLlxuICAgKiBUaGlzIG1ldGhvZCBmZXRjaGVzIHRoZSBgVmlld0NvbmZpZ3NgIGZvciBhIGdpdmVuIHBhdGggaW4gdGhlIFRyYW5zaXRpb24gKGUuZy4sIFwidG9cIiBvciBcImVudGVyaW5nXCIpLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aG5hbWUgdGhlIG5hbWUgb2YgdGhlIHBhdGggdG8gZmV0Y2ggdmlld3MgZm9yOlxuICAgKiAgIChgJ3RvJ2AsIGAnZnJvbSdgLCBgJ2VudGVyaW5nJ2AsIGAnZXhpdGluZydgLCBgJ3JldGFpbmVkJ2ApXG4gICAqIEBwYXJhbSBzdGF0ZSBJZiBwcm92aWRlZCwgb25seSByZXR1cm5zIHRoZSBgVmlld0NvbmZpZ2BzIGZvciBhIHNpbmdsZSBzdGF0ZSBpbiB0aGUgcGF0aFxuICAgKlxuICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgVmlld0NvbmZpZyBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIHZpZXdzKHBhdGhuYW1lID0gJ2VudGVyaW5nJywgc3RhdGU/OiBTdGF0ZU9iamVjdCk6IFZpZXdDb25maWdbXSB7XG4gICAgbGV0IHBhdGggPSB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV07XG4gICAgcGF0aCA9ICFzdGF0ZSA/IHBhdGggOiBwYXRoLmZpbHRlcihwcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcbiAgICByZXR1cm4gcGF0aFxuICAgICAgLm1hcChwcm9wKCd2aWV3cycpKVxuICAgICAgLmZpbHRlcihpZGVudGl0eSlcbiAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdHJhbnNpdGlvbidzIHRyZWUgY2hhbmdlc1xuICAgKlxuICAgKiBBIHRyYW5zaXRpb24gZ29lcyBmcm9tIG9uZSBzdGF0ZS9wYXJhbWV0ZXJzIHRvIGFub3RoZXIgc3RhdGUvcGFyYW1ldGVycy5cbiAgICogRHVyaW5nIGEgdHJhbnNpdGlvbiwgc3RhdGVzIGFyZSBlbnRlcmVkIGFuZC9vciBleGl0ZWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB2YXJpb3VzIGJyYW5jaGVzIChwYXRocykgd2hpY2ggcmVwcmVzZW50IHRoZSBjaGFuZ2VzIHRvIHRoZVxuICAgKiBhY3RpdmUgc3RhdGUgdHJlZSB0aGF0IGFyZSBjYXVzZWQgYnkgdGhlIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwYXRobmFtZSBUaGUgbmFtZSBvZiB0aGUgdHJlZSBjaGFuZ2VzIHBhdGggdG8gZ2V0OlxuICAgKiAgIChgJ3RvJ2AsIGAnZnJvbSdgLCBgJ2VudGVyaW5nJ2AsIGAnZXhpdGluZydgLCBgJ3JldGFpbmVkJ2ApXG4gICAqL1xuICB0cmVlQ2hhbmdlcyhwYXRobmFtZTogc3RyaW5nKTogUGF0aE5vZGVbXTtcbiAgdHJlZUNoYW5nZXMoKTogVHJlZUNoYW5nZXM7XG4gIHRyZWVDaGFuZ2VzKHBhdGhuYW1lPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lID8gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdIDogdGhpcy5fdHJlZUNoYW5nZXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0cmFuc2l0aW9uIHRoYXQgaXMgYSByZWRpcmVjdGlvbiBvZiB0aGUgY3VycmVudCBvbmUuXG4gICAqXG4gICAqIFRoaXMgdHJhbnNpdGlvbiBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFtbVHJhbnNpdGlvblNlcnZpY2VdXSBob29rIHRvXG4gICAqIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiB0byBhIG5ldyBzdGF0ZSBhbmQvb3Igc2V0IG9mIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxuICAgKi9cbiAgcmVkaXJlY3QodGFyZ2V0U3RhdGU6IFRhcmdldFN0YXRlKTogVHJhbnNpdGlvbiB7XG4gICAgbGV0IHJlZGlyZWN0cyA9IDEsXG4gICAgICB0cmFuczogVHJhbnNpdGlvbiA9IHRoaXM7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgICB3aGlsZSAoKHRyYW5zID0gdHJhbnMucmVkaXJlY3RlZEZyb20oKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCsrcmVkaXJlY3RzID4gMjApIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgY29uc2VjdXRpdmUgVHJhbnNpdGlvbiByZWRpcmVjdHMgKDIwKylgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWRpcmVjdE9wdHM6IFRyYW5zaXRpb25PcHRpb25zID0geyByZWRpcmVjdGVkRnJvbTogdGhpcywgc291cmNlOiAncmVkaXJlY3QnIH07XG4gICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIGNhdXNlZCBieSBVUkwgc3luYywgdGhlbiB1c2UgeyBsb2NhdGlvbjogJ3JlcGxhY2UnIH1cbiAgICAvLyBvbiB0aGUgbmV3IHRyYW5zaXRpb24gKHVubGVzcyB0aGUgdGFyZ2V0IHN0YXRlIGV4cGxpY2l0bHkgc3BlY2lmaWVzIGxvY2F0aW9uOiBmYWxzZSkuXG4gICAgLy8gVGhpcyBjYXVzZXMgdGhlIG9yaWdpbmFsIHVybCB0byBiZSByZXBsYWNlZCB3aXRoIHRoZSB1cmwgZm9yIHRoZSByZWRpcmVjdCB0YXJnZXRcbiAgICAvLyBzbyB0aGUgb3JpZ2luYWwgdXJsIGRpc2FwcGVhcnMgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgIGlmICh0aGlzLm9wdGlvbnMoKS5zb3VyY2UgPT09ICd1cmwnICYmIHRhcmdldFN0YXRlLm9wdGlvbnMoKS5sb2NhdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZGlyZWN0T3B0cy5sb2NhdGlvbiA9ICdyZXBsYWNlJztcbiAgICB9XG5cbiAgICBjb25zdCBuZXdPcHRpb25zID0gZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMoKSwgdGFyZ2V0U3RhdGUub3B0aW9ucygpLCByZWRpcmVjdE9wdHMpO1xuICAgIHRhcmdldFN0YXRlID0gdGFyZ2V0U3RhdGUud2l0aE9wdGlvbnMobmV3T3B0aW9ucywgdHJ1ZSk7XG5cbiAgICBjb25zdCBuZXdUcmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKHRoaXMuX3RyZWVDaGFuZ2VzLmZyb20sIHRhcmdldFN0YXRlKTtcbiAgICBjb25zdCBvcmlnaW5hbEVudGVyaW5nTm9kZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZztcbiAgICBjb25zdCByZWRpcmVjdEVudGVyaW5nTm9kZXMgPSBuZXdUcmFuc2l0aW9uLl90cmVlQ2hhbmdlcy5lbnRlcmluZztcblxuICAgIC8vIC0tLSBSZS11c2UgcmVzb2x2ZSBkYXRhIGZyb20gb3JpZ2luYWwgdHJhbnNpdGlvbiAtLS1cbiAgICAvLyBXaGVuIHJlZGlyZWN0aW5nIGZyb20gYSBwYXJlbnQgc3RhdGUgdG8gYSBjaGlsZCBzdGF0ZSB3aGVyZSB0aGUgcGFyZW50IHBhcmFtZXRlciB2YWx1ZXMgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgLy8gKGJlY2F1c2Ugb2YgdGhlIHJlZGlyZWN0KSwgdGhlIHJlc29sdmVzIGZldGNoZWQgYnkgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gYXJlIHN0aWxsIHZhbGlkIGluIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkZWZpbmUgYSByZWRpcmVjdCBvbiBhIHBhcmVudCBzdGF0ZSB3aGljaCBkZXBlbmRzIG9uIGFuIGFzeW5jIHJlc29sdmUgdmFsdWUuXG4gICAgLy8gWW91IGNhbiB3YWl0IGZvciB0aGUgcmVzb2x2ZSwgdGhlbiByZWRpcmVjdCB0byBhIGNoaWxkIHN0YXRlIGJhc2VkIG9uIHRoZSByZXN1bHQuXG4gICAgLy8gVGhlIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbiBkb2VzIG5vdCBoYXZlIHRvIHJlLWZldGNoIHRoZSByZXNvbHZlLlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3Qgbm9kZUlzUmVsb2FkaW5nID0gKHJlbG9hZFN0YXRlOiBTdGF0ZU9iamVjdCkgPT4gKG5vZGU6IFBhdGhOb2RlKSA9PiB7XG4gICAgICByZXR1cm4gcmVsb2FkU3RhdGUgJiYgbm9kZS5zdGF0ZS5pbmNsdWRlc1tyZWxvYWRTdGF0ZS5uYW1lXTtcbiAgICB9O1xuXG4gICAgLy8gRmluZCBhbnkgXCJlbnRlcmluZ1wiIG5vZGVzIGluIHRoZSByZWRpcmVjdCBwYXRoIHRoYXQgbWF0Y2ggdGhlIG9yaWdpbmFsIHBhdGggYW5kIGFyZW4ndCBiZWluZyByZWxvYWRlZFxuICAgIGNvbnN0IG1hdGNoaW5nRW50ZXJpbmdOb2RlczogUGF0aE5vZGVbXSA9IFBhdGhVdGlscy5tYXRjaGluZyhcbiAgICAgIHJlZGlyZWN0RW50ZXJpbmdOb2RlcyxcbiAgICAgIG9yaWdpbmFsRW50ZXJpbmdOb2RlcyxcbiAgICAgIFBhdGhVdGlscy5ub25EeW5hbWljUGFyYW1zXG4gICAgKS5maWx0ZXIobm90KG5vZGVJc1JlbG9hZGluZyh0YXJnZXRTdGF0ZS5vcHRpb25zKCkucmVsb2FkU3RhdGUpKSk7XG5cbiAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIChwb3NzaWJseSBwcmUtcmVzb2x2ZWQpIHJlc29sdmFibGVzIGZvciB0aGUgbWF0Y2hpbmcgZW50ZXJpbmcgbm9kZXMuXG4gICAgbWF0Y2hpbmdFbnRlcmluZ05vZGVzLmZvckVhY2goKG5vZGUsIGlkeCkgPT4ge1xuICAgICAgbm9kZS5yZXNvbHZhYmxlcyA9IG9yaWdpbmFsRW50ZXJpbmdOb2Rlc1tpZHhdLnJlc29sdmFibGVzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ld1RyYW5zaXRpb247XG4gIH1cblxuICAvKiogQGhpZGRlbiBJZiBhIHRyYW5zaXRpb24gZG9lc24ndCBleGl0L2VudGVyIGFueSBzdGF0ZXMsIHJldHVybnMgYW55IFtbUGFyYW1dXSB3aG9zZSB2YWx1ZSBjaGFuZ2VkICovXG4gIHByaXZhdGUgX2NoYW5nZWRQYXJhbXMoKTogUGFyYW1bXSB7XG4gICAgY29uc3QgdGMgPSB0aGlzLl90cmVlQ2hhbmdlcztcblxuICAgIC8qKiBSZXR1cm4gdW5kZWZpbmVkIGlmIGl0J3Mgbm90IGEgXCJkeW5hbWljXCIgdHJhbnNpdGlvbiwgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29ucyAqL1xuICAgIC8vIElmIHVzZXIgZXhwbGljaXRseSB3YW50cyBhIHJlbG9hZFxuICAgIGlmICh0aGlzLl9vcHRpb25zLnJlbG9hZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBJZiBhbnkgc3RhdGVzIGFyZSBleGl0aW5nIG9yIGVudGVyaW5nXG4gICAgaWYgKHRjLmV4aXRpbmcubGVuZ3RoIHx8IHRjLmVudGVyaW5nLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBJZiB0by9mcm9tIHBhdGggbGVuZ3RocyBkaWZmZXJcbiAgICBpZiAodGMudG8ubGVuZ3RoICE9PSB0Yy5mcm9tLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBJZiB0aGUgdG8vZnJvbSBwYXRocyBhcmUgZGlmZmVyZW50XG4gICAgY29uc3QgcGF0aHNEaWZmZXI6IGJvb2xlYW4gPSBhcnJheVR1cGxlcyh0Yy50bywgdGMuZnJvbSlcbiAgICAgIC5tYXAodHVwbGUgPT4gdHVwbGVbMF0uc3RhdGUgIT09IHR1cGxlWzFdLnN0YXRlKVxuICAgICAgLnJlZHVjZShhbnlUcnVlUiwgZmFsc2UpO1xuICAgIGlmIChwYXRoc0RpZmZlcikgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIC8vIEZpbmQgYW55IHBhcmFtZXRlciB2YWx1ZXMgdGhhdCBkaWZmZXJcbiAgICBjb25zdCBub2RlU2NoZW1hczogUGFyYW1bXVtdID0gdGMudG8ubWFwKChub2RlOiBQYXRoTm9kZSkgPT4gbm9kZS5wYXJhbVNjaGVtYSk7XG4gICAgY29uc3QgW3RvVmFsdWVzLCBmcm9tVmFsdWVzXSA9IFt0Yy50bywgdGMuZnJvbV0ubWFwKHBhdGggPT4gcGF0aC5tYXAoeCA9PiB4LnBhcmFtVmFsdWVzKSk7XG4gICAgY29uc3QgdHVwbGVzID0gYXJyYXlUdXBsZXMobm9kZVNjaGVtYXMsIHRvVmFsdWVzLCBmcm9tVmFsdWVzKTtcblxuICAgIHJldHVybiB0dXBsZXMubWFwKChbc2NoZW1hLCB0b1ZhbHMsIGZyb21WYWxzXSkgPT4gUGFyYW0uY2hhbmdlZChzY2hlbWEsIHRvVmFscywgZnJvbVZhbHMpKS5yZWR1Y2UodW5uZXN0UiwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBkeW5hbWljLlxuICAgKlxuICAgKiBBIHRyYW5zaXRpb24gaXMgZHluYW1pYyBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYnV0IGF0IGxlYXN0IG9uZSBkeW5hbWljIHBhcmFtZXRlciBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgVHJhbnNpdGlvbiBpcyBkeW5hbWljXG4gICAqL1xuICBkeW5hbWljKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VkUGFyYW1zKCk7XG4gICAgcmV0dXJuICFjaGFuZ2VzID8gZmFsc2UgOiBjaGFuZ2VzLm1hcCh4ID0+IHguZHluYW1pYykucmVkdWNlKGFueVRydWVSLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQuXG4gICAqXG4gICAqIEEgdHJhbnNpdGlvbiBpcyBpZ25vcmVkIGlmIG5vIHN0YXRlcyBhcmUgZW50ZXJlZCBub3IgZXhpdGVkLCBhbmQgbm8gcGFyYW1ldGVyIHZhbHVlcyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgaWdub3JlZC5cbiAgICovXG4gIGlnbm9yZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5faWdub3JlZFJlYXNvbigpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgX2lnbm9yZWRSZWFzb24oKTogJ1NhbWVBc0N1cnJlbnQnIHwgJ1NhbWVBc1BlbmRpbmcnIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgIGNvbnN0IHJlbG9hZFN0YXRlID0gdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZTtcblxuICAgIGNvbnN0IHNhbWUgPSAocGF0aEEsIHBhdGhCKSA9PiB7XG4gICAgICBpZiAocGF0aEEubGVuZ3RoICE9PSBwYXRoQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IG1hdGNoaW5nID0gUGF0aFV0aWxzLm1hdGNoaW5nKHBhdGhBLCBwYXRoQik7XG4gICAgICByZXR1cm4gcGF0aEEubGVuZ3RoID09PSBtYXRjaGluZy5maWx0ZXIobm9kZSA9PiAhcmVsb2FkU3RhdGUgfHwgIW5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV0pLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgY29uc3QgbmV3VEMgPSB0aGlzLnRyZWVDaGFuZ2VzKCk7XG4gICAgY29uc3QgcGVuZFRDID0gcGVuZGluZyAmJiBwZW5kaW5nLnRyZWVDaGFuZ2VzKCk7XG5cbiAgICBpZiAocGVuZFRDICYmIHNhbWUocGVuZFRDLnRvLCBuZXdUQy50bykgJiYgc2FtZShwZW5kVEMuZXhpdGluZywgbmV3VEMuZXhpdGluZykpIHJldHVybiAnU2FtZUFzUGVuZGluZyc7XG4gICAgaWYgKG5ld1RDLmV4aXRpbmcubGVuZ3RoID09PSAwICYmIG5ld1RDLmVudGVyaW5nLmxlbmd0aCA9PT0gMCAmJiBzYW1lKG5ld1RDLmZyb20sIG5ld1RDLnRvKSkgcmV0dXJuICdTYW1lQXNDdXJyZW50JztcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSB0cmFuc2l0aW9uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdlbmVyYWxseSBjYWxsZWQgZnJvbSB0aGUgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cbiAgICpcbiAgICogQGludGVybmFsYXBpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb24uXG4gICAqL1xuICBydW4oKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBydW5BbGxIb29rcyA9IFRyYW5zaXRpb25Ib29rLnJ1bkFsbEhvb2tzO1xuXG4gICAgLy8gR2V0cyB0cmFuc2l0aW9uIGhvb2tzIGFycmF5IGZvciB0aGUgZ2l2ZW4gcGhhc2VcbiAgICBjb25zdCBnZXRIb29rc0ZvciA9IChwaGFzZTogVHJhbnNpdGlvbkhvb2tQaGFzZSkgPT4gdGhpcy5faG9va0J1aWxkZXIuYnVpbGRIb29rc0ZvclBoYXNlKHBoYXNlKTtcblxuICAgIC8vIFdoZW4gdGhlIGNoYWluIGlzIGNvbXBsZXRlLCB0aGVuIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICAgIGNvbnN0IHRyYW5zaXRpb25TdWNjZXNzID0gKCkgPT4ge1xuICAgICAgdHJhY2UudHJhY2VTdWNjZXNzKHRoaXMuJHRvKCksIHRoaXMpO1xuICAgICAgdGhpcy5zdWNjZXNzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2RlZmVycmVkLnJlc29sdmUodGhpcy50bygpKTtcbiAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKFRyYW5zaXRpb25Ib29rUGhhc2UuU1VDQ0VTUykpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmFuc2l0aW9uRXJyb3IgPSAocmVhc29uOiBSZWplY3Rpb24pID0+IHtcbiAgICAgIHRyYWNlLnRyYWNlRXJyb3IocmVhc29uLCB0aGlzKTtcbiAgICAgIHRoaXMuc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgdGhpcy5fZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICB0aGlzLl9lcnJvciA9IHJlYXNvbjtcbiAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKFRyYW5zaXRpb25Ib29rUGhhc2UuRVJST1IpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcnVuVHJhbnNpdGlvbiA9ICgpID0+IHtcbiAgICAgIC8vIFdhaXQgdG8gYnVpbGQgdGhlIFJVTiBob29rIGNoYWluIHVudGlsIHRoZSBCRUZPUkUgaG9va3MgYXJlIGRvbmVcbiAgICAgIC8vIFRoaXMgYWxsb3dzIGEgQkVGT1JFIGhvb2sgdG8gZHluYW1pY2FsbHkgYWRkIGFkZGl0aW9uYWwgUlVOIGhvb2tzIHZpYSB0aGUgVHJhbnNpdGlvbiBvYmplY3QuXG4gICAgICBjb25zdCBhbGxSdW5Ib29rcyA9IGdldEhvb2tzRm9yKFRyYW5zaXRpb25Ib29rUGhhc2UuUlVOKTtcbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiBzZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3MoYWxsUnVuSG9va3MsIGRvbmUpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdGFydFRyYW5zaXRpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCBnbG9iYWxzID0gdGhpcy5yb3V0ZXIuZ2xvYmFscztcblxuICAgICAgZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IHRoaXMuJGlkO1xuICAgICAgZ2xvYmFscy50cmFuc2l0aW9uID0gdGhpcztcbiAgICAgIGdsb2JhbHMudHJhbnNpdGlvbkhpc3RvcnkuZW5xdWV1ZSh0aGlzKTtcblxuICAgICAgdHJhY2UudHJhY2VUcmFuc2l0aW9uU3RhcnQodGhpcyk7XG5cbiAgICAgIHJldHVybiBzZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFsbEJlZm9yZUhvb2tzID0gZ2V0SG9va3NGb3IoVHJhbnNpdGlvbkhvb2tQaGFzZS5CRUZPUkUpO1xuICAgIFRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbEJlZm9yZUhvb2tzLCBzdGFydFRyYW5zaXRpb24pXG4gICAgICAudGhlbihydW5UcmFuc2l0aW9uKVxuICAgICAgLnRoZW4odHJhbnNpdGlvblN1Y2Nlc3MsIHRyYW5zaXRpb25FcnJvcik7XG5cbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICB9XG5cbiAgLyoqIENoZWNrcyBpZiB0aGlzIHRyYW5zaXRpb24gaXMgY3VycmVudGx5IGFjdGl2ZS9ydW5uaW5nLiAqL1xuICBpc0FjdGl2ZSA9ICgpID0+IHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbiA9PT0gdGhpcztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBUcmFuc2l0aW9uIGlzIHZhbGlkXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICovXG4gIHZhbGlkKCkge1xuICAgIHJldHVybiAhdGhpcy5lcnJvcigpIHx8IHRoaXMuc3VjY2VzcyAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFib3J0cyB0aGlzIHRyYW5zaXRpb25cbiAgICpcbiAgICogSW1wZXJhdGl2ZSBBUEkgdG8gYWJvcnQgYSBUcmFuc2l0aW9uLlxuICAgKiBUaGlzIG9ubHkgYXBwbGllcyB0byBUcmFuc2l0aW9ucyB0aGF0IGFyZSBub3QgeWV0IGNvbXBsZXRlLlxuICAgKi9cbiAgYWJvcnQoKSB7XG4gICAgLy8gRG8gbm90IHNldCBmbGFnIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgY29tcGxldGVcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5zdWNjZXNzKSkge1xuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBUcmFuc2l0aW9uIGVycm9yIHJlYXNvbi5cbiAgICpcbiAgICogSWYgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCAoYW5kIGNvdWxkIG5vdCBiZSBydW4pLCByZXR1cm5zIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZC5cbiAgICogSWYgdGhlIHRyYW5zaXRpb24gd2FzIHZhbGlkIGFuZCByYW4sIGJ1dCB3YXMgbm90IHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdHJhbnNpdGlvbiByZWplY3Rpb24gZXhwbGFpbmluZyB3aHkgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAqL1xuICBlcnJvcigpOiBSZWplY3Rpb24ge1xuICAgIGNvbnN0IHN0YXRlOiBTdGF0ZU9iamVjdCA9IHRoaXMuJHRvKCk7XG5cbiAgICBpZiAoc3RhdGUuc2VsZi5hYnN0cmFjdCkge1xuICAgICAgcmV0dXJuIFJlamVjdGlvbi5pbnZhbGlkKGBDYW5ub3QgdHJhbnNpdGlvbiB0byBhYnN0cmFjdCBzdGF0ZSAnJHtzdGF0ZS5uYW1lfSdgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbURlZnMgPSBzdGF0ZS5wYXJhbWV0ZXJzKCk7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJhbXMoKTtcbiAgICBjb25zdCBpbnZhbGlkUGFyYW1zID0gcGFyYW1EZWZzLmZpbHRlcihwYXJhbSA9PiAhcGFyYW0udmFsaWRhdGVzKHZhbHVlc1twYXJhbS5pZF0pKTtcblxuICAgIGlmIChpbnZhbGlkUGFyYW1zLmxlbmd0aCkge1xuICAgICAgY29uc3QgaW52YWxpZFZhbHVlcyA9IGludmFsaWRQYXJhbXMubWFwKHBhcmFtID0+IGBbJHtwYXJhbS5pZH06JHtzdHJpbmdpZnkodmFsdWVzW3BhcmFtLmlkXSl9XWApLmpvaW4oJywgJyk7XG4gICAgICBjb25zdCBkZXRhaWwgPSBgVGhlIGZvbGxvd2luZyBwYXJhbWV0ZXIgdmFsdWVzIGFyZSBub3QgdmFsaWQgZm9yIHN0YXRlICcke3N0YXRlLm5hbWV9JzogJHtpbnZhbGlkVmFsdWVzfWA7XG4gICAgICByZXR1cm4gUmVqZWN0aW9uLmludmFsaWQoZGV0YWlsKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWNjZXNzID09PSBmYWxzZSkgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2l0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2l0aW9uXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBmcm9tU3RhdGVPck5hbWUgPSB0aGlzLmZyb20oKTtcbiAgICBjb25zdCB0b1N0YXRlT3JOYW1lID0gdGhpcy50bygpO1xuXG4gICAgY29uc3QgYXZvaWRFbXB0eUhhc2ggPSAocGFyYW1zOiBSYXdQYXJhbXMpID0+XG4gICAgICBwYXJhbXNbJyMnXSAhPT0gbnVsbCAmJiBwYXJhbXNbJyMnXSAhPT0gdW5kZWZpbmVkID8gcGFyYW1zIDogb21pdChwYXJhbXMsIFsnIyddKTtcblxuICAgIC8vIChYKSBtZWFucyB0aGUgdG8gc3RhdGUgaXMgaW52YWxpZC5cbiAgICBjb25zdCBpZCA9IHRoaXMuJGlkLFxuICAgICAgZnJvbSA9IGlzT2JqZWN0KGZyb21TdGF0ZU9yTmFtZSkgPyBmcm9tU3RhdGVPck5hbWUubmFtZSA6IGZyb21TdGF0ZU9yTmFtZSxcbiAgICAgIGZyb21QYXJhbXMgPSBzdHJpbmdpZnkoYXZvaWRFbXB0eUhhc2godGhpcy5fdHJlZUNoYW5nZXMuZnJvbS5tYXAocHJvcCgncGFyYW1WYWx1ZXMnKSkucmVkdWNlKG1lcmdlUiwge30pKSksXG4gICAgICB0b1ZhbGlkID0gdGhpcy52YWxpZCgpID8gJycgOiAnKFgpICcsXG4gICAgICB0byA9IGlzT2JqZWN0KHRvU3RhdGVPck5hbWUpID8gdG9TdGF0ZU9yTmFtZS5uYW1lIDogdG9TdGF0ZU9yTmFtZSxcbiAgICAgIHRvUGFyYW1zID0gc3RyaW5naWZ5KGF2b2lkRW1wdHlIYXNoKHRoaXMucGFyYW1zKCkpKTtcblxuICAgIHJldHVybiBgVHJhbnNpdGlvbiMke2lkfSggJyR7ZnJvbX0nJHtmcm9tUGFyYW1zfSAtPiAke3RvVmFsaWR9JyR7dG99JyR7dG9QYXJhbXN9IClgO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHVybCAqLyAvKiogKi9cbmltcG9ydCB7IG1hcCwgaW5oZXJpdCwgaWRlbnRpdHksIHVubmVzdCwgdGFpbCwgZmluZCwgT2JqLCBhbGxUcnVlUiwgdW5uZXN0UiwgYXJyYXlUdXBsZXMgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHByb3AsIHByb3BFcSB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgaXNBcnJheSwgaXNTdHJpbmcsIGlzRGVmaW5lZCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFBhcmFtLCBEZWZUeXBlIH0gZnJvbSAnLi4vcGFyYW1zL3BhcmFtJztcbmltcG9ydCB7IFBhcmFtVHlwZXMgfSBmcm9tICcuLi9wYXJhbXMvcGFyYW1UeXBlcyc7XG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMvaW50ZXJmYWNlJztcbmltcG9ydCB7IFVybE1hdGNoZXJDb21waWxlQ29uZmlnIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgam9pbk5laWdoYm9yc1IsIHNwbGl0T25EZWxpbSB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmdzJztcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gJy4uL3BhcmFtcyc7XG5pbXBvcnQgeyBkZWZhdWx0cyB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBQYXJhbUZhY3RvcnkgfSBmcm9tICcuL3VybE1hdGNoZXJGYWN0b3J5JztcblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHF1b3RlUmVnRXhwKHN0cjogYW55LCBwYXJhbT86IGFueSkge1xuICBsZXQgc3Vycm91bmRQYXR0ZXJuID0gWycnLCAnJ10sXG4gICAgcmVzdWx0ID0gc3RyLnJlcGxhY2UoL1tcXFxcXFxbXFxdXFxeJCorPy4oKXx7fV0vZywgJ1xcXFwkJicpO1xuICBpZiAoIXBhcmFtKSByZXR1cm4gcmVzdWx0O1xuXG4gIHN3aXRjaCAocGFyYW0uc3F1YXNoKSB7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsnKCcsICcpJyArIChwYXJhbS5pc09wdGlvbmFsID8gJz8nIDogJycpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdHJ1ZTpcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoPzovKCcsICcpfC8pPyddO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFtgKCR7cGFyYW0uc3F1YXNofXxgLCAnKT8nXTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXJhbS50eXBlLnBhdHRlcm4uc291cmNlICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgbWVtb2l6ZVRvID0gKG9iajogT2JqLCBfcHJvcDogc3RyaW5nLCBmbjogRnVuY3Rpb24pID0+IChvYmpbX3Byb3BdID0gb2JqW19wcm9wXSB8fCBmbigpKTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHNwbGl0T25TbGFzaCA9IHNwbGl0T25EZWxpbSgnLycpO1xuXG4vKiogQGhpZGRlbiAqL1xuaW50ZXJmYWNlIFVybE1hdGNoZXJDYWNoZSB7XG4gIHNlZ21lbnRzPzogYW55W107XG4gIHdlaWdodHM/OiBudW1iZXJbXTtcbiAgcGF0aD86IFVybE1hdGNoZXJbXTtcbiAgcGFyZW50PzogVXJsTWF0Y2hlcjtcbiAgcGF0dGVybj86IFJlZ0V4cDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmludGVyZmFjZSBNYXRjaERldGFpbHMge1xuICBpZDogc3RyaW5nO1xuICByZWdleHA6IHN0cmluZztcbiAgc2VnbWVudDogc3RyaW5nO1xuICB0eXBlOiBQYXJhbVR5cGU7XG59XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBkZWZhdWx0Q29uZmlnOiBVcmxNYXRjaGVyQ29tcGlsZUNvbmZpZyA9IHtcbiAgc3RhdGU6IHsgcGFyYW1zOiB7fSB9LFxuICBzdHJpY3Q6IHRydWUsXG4gIGNhc2VJbnNlbnNpdGl2ZTogdHJ1ZSxcbn07XG5cbi8qKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMuXG4gKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMgYW5kIGV4dHJhY3RzIG5hbWVkIHBhcmFtZXRlcnMgZnJvbSB0aGUgcGF0aCBvciB0aGUgc2VhcmNoXG4gKiBwYXJ0IG9mIHRoZSBVUkwuXG4gKlxuICogQSBVUkwgcGF0dGVybiBjb25zaXN0cyBvZiBhIHBhdGggcGF0dGVybiwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSAnPycgYW5kIGEgbGlzdCBvZiBzZWFyY2ggKHF1ZXJ5KVxuICogcGFyYW1ldGVycy4gTXVsdGlwbGUgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5ICcmJy4gU2VhcmNoIHBhcmFtZXRlcnNcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xuICogdGhlIG1hdGNoZWQgcGFyYW1ldGVycyByZXR1cm5lZCBieSBbW1VybE1hdGNoZXIuZXhlY11dLlxuICpcbiAqIC0gKlBhdGggcGFyYW1ldGVycyogYXJlIGRlZmluZWQgdXNpbmcgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXJzIChgL3NvbWVwYXRoL3twYXJhbX1gKVxuICogb3IgY29sb24gcGxhY2Vob2xkZXJzIChgL3NvbWVQYXRoLzpwYXJhbWApLlxuICpcbiAqIC0gKkEgcGFyYW1ldGVyIFJlZ0V4cCogbWF5IGJlIGRlZmluZWQgZm9yIGEgcGFyYW0gYWZ0ZXIgYSBjb2xvblxuICogKGAvc29tZVBhdGgve3BhcmFtOlthLXpBLVowLTldK31gKSBpbiBhIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyLlxuICogVGhlIHJlZ2V4cCBtdXN0IG1hdGNoIGZvciB0aGUgdXJsIHRvIGJlIG1hdGNoZWQuXG4gKiBTaG91bGQgdGhlIHJlZ2V4cCBpdHNlbGYgY29udGFpbiBjdXJseSBicmFjZXMsIHRoZXkgbXVzdCBiZSBpbiBtYXRjaGVkIHBhaXJzIG9yIGVzY2FwZWQgd2l0aCBhIGJhY2tzbGFzaC5cbiAqXG4gKiBOb3RlOiBhIFJlZ0V4cCBwYXJhbWV0ZXIgd2lsbCBlbmNvZGUgaXRzIHZhbHVlIHVzaW5nIGVpdGhlciBbW1BhcmFtVHlwZXMucGF0aF1dIG9yIFtbUGFyYW1UeXBlcy5xdWVyeV1dLlxuICpcbiAqIC0gKkN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMqIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhZnRlciBhIGNvbG9uIChgL3NvbWVQYXRoL3twYXJhbTppbnR9YCkgaW4gY3VybHkgYnJhY2UgcGFyYW1ldGVycy5cbiAqICAgU2VlIFtbVXJsTWF0Y2hlckZhY3RvcnkudHlwZV1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIC0gKkNhdGNoLWFsbCBwYXJhbWV0ZXJzKiBhcmUgZGVmaW5lZCB1c2luZyBhbiBhc3RlcmlzayBwbGFjZWhvbGRlciAoYC9zb21lcGF0aC8qY2F0Y2hhbGxwYXJhbWApLlxuICogICBBIGNhdGNoLWFsbCAqIHBhcmFtZXRlciB2YWx1ZSB3aWxsIGNvbnRhaW4gdGhlIHJlbWFpbmRlciBvZiB0aGUgVVJMLlxuICpcbiAqIC0tLVxuICpcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXG4gKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS5cbiAqIEEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiAnLycuIEZvciBjYXRjaC1hbGxcbiAqIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogKiBgJy9oZWxsby8nYCAtIE1hdGNoZXMgb25seSBpZiB0aGUgcGF0aCBpcyBleGFjdGx5ICcvaGVsbG8vJy4gVGhlcmUgaXMgbm8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yXG4gKiAgIHRyYWlsaW5nIHNsYXNoZXMsIGFuZCBwYXR0ZXJucyBoYXZlIHRvIG1hdGNoIHRoZSBlbnRpcmUgcGF0aCwgbm90IGp1c3QgYSBwcmVmaXguXG4gKiAqIGAnL3VzZXIvOmlkJ2AgLSBNYXRjaGVzICcvdXNlci9ib2InIG9yICcvdXNlci8xMjM0ISEhJyBvciBldmVuICcvdXNlci8nIGJ1dCBub3QgJy91c2VyJyBvclxuICogICAnL3VzZXIvYm9iL2RldGFpbHMnLiBUaGUgc2Vjb25kIHBhdGggc2VnbWVudCB3aWxsIGJlIGNhcHR1cmVkIGFzIHRoZSBwYXJhbWV0ZXIgJ2lkJy5cbiAqICogYCcvdXNlci97aWR9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgdXNpbmcgY3VybHkgYnJhY2Ugc3ludGF4LlxuICogKiBgJy91c2VyL3tpZDpbXi9dKn0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUuXG4gKiAqIGAnL3VzZXIve2lkOlswLTlhLWZBLUZdezEsOH19J2AgLSBTaW1pbGFyIHRvIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgb25seSBtYXRjaGVzIGlmIHRoZSBpZFxuICogICBwYXJhbWV0ZXIgY29uc2lzdHMgb2YgMSB0byA4IGhleCBkaWdpdHMuXG4gKiAqIGAnL2ZpbGVzL3twYXRoOi4qfSdgIC0gTWF0Y2hlcyBhbnkgVVJMIHN0YXJ0aW5nIHdpdGggJy9maWxlcy8nIGFuZCBjYXB0dXJlcyB0aGUgcmVzdCBvZiB0aGVcbiAqICAgcGF0aCBpbnRvIHRoZSBwYXJhbWV0ZXIgJ3BhdGgnLlxuICogKiBgJy9maWxlcy8qcGF0aCdgIC0gZGl0dG8uXG4gKiAqIGAnL2NhbGVuZGFyL3tzdGFydDpkYXRlfSdgIC0gTWF0Y2hlcyBcIi9jYWxlbmRhci8yMDE0LTExLTEyXCIgKGJlY2F1c2UgdGhlIHBhdHRlcm4gZGVmaW5lZFxuICogICBpbiB0aGUgYnVpbHQtaW4gIGBkYXRlYCBQYXJhbVR5cGUgbWF0Y2hlcyBgMjAxNC0xMS0xMmApIGFuZCBwcm92aWRlcyBhIERhdGUgb2JqZWN0IGluICRzdGF0ZVBhcmFtcy5zdGFydFxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFVybE1hdGNoZXIge1xuICAvKiogQGhpZGRlbiAqL1xuICBzdGF0aWMgbmFtZVZhbGlkYXRvcjogUmVnRXhwID0gL15cXHcrKFstLl0rXFx3KykqKD86XFxbXFxdKT8kLztcblxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9jYWNoZTogVXJsTWF0Y2hlckNhY2hlID0geyBwYXRoOiBbdGhpc10gfTtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfY2hpbGRyZW46IFVybE1hdGNoZXJbXSA9IFtdO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9wYXJhbXM6IFBhcmFtW10gPSBbXTtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfc2VnbWVudHM6IHN0cmluZ1tdID0gW107XG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2NvbXBpbGVkOiBzdHJpbmdbXSA9IFtdO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogVXJsTWF0Y2hlckNvbXBpbGVDb25maWc7XG5cbiAgLyoqIFRoZSBwYXR0ZXJuIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciAqL1xuICBwdWJsaWMgcGF0dGVybjogc3RyaW5nO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIHN0YXRpYyBlbmNvZGVEYXNoZXMoc3RyOiBzdHJpbmcpIHtcbiAgICAvLyBSZXBsYWNlIGRhc2hlcyB3aXRoIGVuY29kZWQgXCJcXC1cIlxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKFxuICAgICAgLy0vZyxcbiAgICAgIGMgPT5cbiAgICAgICAgYCU1QyUke2NcbiAgICAgICAgICAuY2hhckNvZGVBdCgwKVxuICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAudG9VcHBlckNhc2UoKX1gXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBwYXRoIHNlZ21lbnRzIGFuZCBwYXRoIHBhcmFtcywgaW4gb3JkZXIgKi9cbiAgc3RhdGljIHBhdGhTZWdtZW50c0FuZFBhcmFtcyhtYXRjaGVyOiBVcmxNYXRjaGVyKSB7XG4gICAgY29uc3Qgc3RhdGljU2VnbWVudHMgPSBtYXRjaGVyLl9zZWdtZW50cztcbiAgICBjb25zdCBwYXRoUGFyYW1zID0gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihwID0+IHAubG9jYXRpb24gPT09IERlZlR5cGUuUEFUSCk7XG4gICAgcmV0dXJuIGFycmF5VHVwbGVzKHN0YXRpY1NlZ21lbnRzLCBwYXRoUGFyYW1zLmNvbmNhdCh1bmRlZmluZWQpKVxuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgIC5maWx0ZXIoeCA9PiB4ICE9PSAnJyAmJiBpc0RlZmluZWQoeCkpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gR2l2ZW4gYSBtYXRjaGVyLCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgbWF0Y2hlcidzIHF1ZXJ5IHBhcmFtcyAqL1xuICBzdGF0aWMgcXVlcnlQYXJhbXMobWF0Y2hlcjogVXJsTWF0Y2hlcik6IFBhcmFtW10ge1xuICAgIHJldHVybiBtYXRjaGVyLl9wYXJhbXMuZmlsdGVyKHAgPT4gcC5sb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0gpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIFVybE1hdGNoZXJzXG4gICAqXG4gICAqIFRoaXMgY29tcGFyaXNvbiBmdW5jdGlvbiBjb252ZXJ0cyBhIFVybE1hdGNoZXIgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGF0aCBzZWdtZW50cy5cbiAgICogRWFjaCBzdGF0aWMgcGF0aCBzZWdtZW50IGlzIGEgc3RhdGljIHN0cmluZyBiZXR3ZWVuIGEgcGF0aCBzZXBhcmF0b3IgKHNsYXNoIGNoYXJhY3RlcikuXG4gICAqIEVhY2ggZHluYW1pYyBzZWdtZW50IGlzIGEgcGF0aCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHNvcnRzIHN0YXRpYyBzZWdtZW50cyBiZWZvcmUgZHluYW1pYyBvbmVzLlxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUoYTogVXJsTWF0Y2hlciwgYjogVXJsTWF0Y2hlcik6IG51bWJlciB7XG4gICAgLyoqXG4gICAgICogVHVybiBhIFVybE1hdGNoZXIgYW5kIGFsbCBpdHMgcGFyZW50IG1hdGNoZXJzIGludG8gYW4gYXJyYXlcbiAgICAgKiBvZiBzbGFzaCBsaXRlcmFscyAnLycsIHN0cmluZyBsaXRlcmFscywgYW5kIFBhcmFtIG9iamVjdHNcbiAgICAgKlxuICAgICAqIFRoaXMgZXhhbXBsZSBtYXRjaGVyIG1hdGNoZXMgc3RyaW5ncyBsaWtlIFwiL2Zvby86cGFyYW0vdGFpbFwiOlxuICAgICAqIHZhciBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvb1wiKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiLzpwYXJhbVwiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcIi9cIikpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCJ0YWlsXCIpKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gc2VnbWVudHMobWF0Y2hlcik7IC8vIFsgJy8nLCAnZm9vJywgJy8nLCBQYXJhbSwgJy8nLCAndGFpbCcgXVxuICAgICAqXG4gICAgICogQ2FjaGVzIHRoZSByZXN1bHQgYXMgYG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzYFxuICAgICAqL1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKG1hdGNoZXI6IFVybE1hdGNoZXIpID0+XG4gICAgICAobWF0Y2hlci5fY2FjaGUuc2VnbWVudHMgPVxuICAgICAgICBtYXRjaGVyLl9jYWNoZS5zZWdtZW50cyB8fFxuICAgICAgICBtYXRjaGVyLl9jYWNoZS5wYXRoXG4gICAgICAgICAgLm1hcChVcmxNYXRjaGVyLnBhdGhTZWdtZW50c0FuZFBhcmFtcylcbiAgICAgICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgICAgIC5yZWR1Y2Uoam9pbk5laWdoYm9yc1IsIFtdKVxuICAgICAgICAgIC5tYXAoeCA9PiAoaXNTdHJpbmcoeCkgPyBzcGxpdE9uU2xhc2goeCkgOiB4KSlcbiAgICAgICAgICAucmVkdWNlKHVubmVzdFIsIFtdKSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzb3J0IHdlaWdodCBmb3IgZWFjaCBzZWdtZW50IG9mIGEgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogQ2FjaGVzIHRoZSByZXN1bHQgYXMgYG1hdGNoZXIuX2NhY2hlLndlaWdodHNgXG4gICAgICovXG4gICAgY29uc3Qgd2VpZ2h0cyA9IChtYXRjaGVyOiBVcmxNYXRjaGVyKSA9PlxuICAgICAgKG1hdGNoZXIuX2NhY2hlLndlaWdodHMgPVxuICAgICAgICBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzIHx8XG4gICAgICAgIHNlZ21lbnRzKG1hdGNoZXIpLm1hcChzZWdtZW50ID0+IHtcbiAgICAgICAgICAvLyBTb3J0IHNsYXNoZXMgZmlyc3QsIHRoZW4gc3RhdGljIHN0cmluZ3MsIHRoZSBQYXJhbXNcbiAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gJy8nKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoc2VnbWVudCkpIHJldHVybiAyO1xuICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgUGFyYW0pIHJldHVybiAzO1xuICAgICAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIHNob3J0ZXIgYXJyYXkgaW4tcGxhY2UgKG11dGF0ZXMpXG4gICAgICovXG4gICAgY29uc3QgcGFkQXJyYXlzID0gKGw6IGFueVtdLCByOiBhbnlbXSwgcGFkVmFsOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KGwubGVuZ3RoLCByLmxlbmd0aCk7XG4gICAgICB3aGlsZSAobC5sZW5ndGggPCBsZW4pIGwucHVzaChwYWRWYWwpO1xuICAgICAgd2hpbGUgKHIubGVuZ3RoIDwgbGVuKSByLnB1c2gocGFkVmFsKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgd2VpZ2h0c0EgPSB3ZWlnaHRzKGEpLFxuICAgICAgd2VpZ2h0c0IgPSB3ZWlnaHRzKGIpO1xuICAgIHBhZEFycmF5cyh3ZWlnaHRzQSwgd2VpZ2h0c0IsIDApO1xuXG4gICAgY29uc3QgX3BhaXJzID0gYXJyYXlUdXBsZXMod2VpZ2h0c0EsIHdlaWdodHNCKTtcbiAgICBsZXQgY21wLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IF9wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgY21wID0gX3BhaXJzW2ldWzBdIC0gX3BhaXJzW2ldWzFdO1xuICAgICAgaWYgKGNtcCAhPT0gMCkgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGF0dGVybiBUaGUgcGF0dGVybiB0byBjb21waWxlIGludG8gYSBtYXRjaGVyLlxuICAgKiBAcGFyYW0gcGFyYW1UeXBlcyBUaGUgW1tQYXJhbVR5cGVzXV0gcmVnaXN0cnlcbiAgICogQHBhcmFtIHBhcmFtRmFjdG9yeSBBIFtbUGFyYW1GYWN0b3J5XV0gb2JqZWN0XG4gICAqIEBwYXJhbSBjb25maWcgIEEgW1tVcmxNYXRjaGVyQ29tcGlsZUNvbmZpZ11dIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuOiBzdHJpbmcsIHBhcmFtVHlwZXM6IFBhcmFtVHlwZXMsIHBhcmFtRmFjdG9yeTogUGFyYW1GYWN0b3J5LCBjb25maWc/OiBVcmxNYXRjaGVyQ29tcGlsZUNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnID0gZGVmYXVsdHMoY29uZmlnLCBkZWZhdWx0Q29uZmlnKTtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuXG4gICAgLy8gRmluZCBhbGwgcGxhY2Vob2xkZXJzIGFuZCBjcmVhdGUgYSBjb21waWxlZCBwYXR0ZXJuLCB1c2luZyBlaXRoZXIgY2xhc3NpYyBvciBjdXJseSBzeW50YXg6XG4gICAgLy8gICAnKicgbmFtZVxuICAgIC8vICAgJzonIG5hbWVcbiAgICAvLyAgICd7JyBuYW1lICd9J1xuICAgIC8vICAgJ3snIG5hbWUgJzonIHJlZ2V4cCAnfSdcbiAgICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGlzIHNvbWV3aGF0IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGUgbmVlZCB0byBhbGxvdyBjdXJseSBicmFjZXNcbiAgICAvLyBpbnNpZGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVGhlIHBsYWNlaG9sZGVyIHJlZ2V4cCBicmVha3MgZG93biBhcyBmb2xsb3dzOlxuICAgIC8vICAgIChbOipdKShbXFx3XFxbXFxdXSspICAgICAgICAgICAgICAtIGNsYXNzaWMgcGxhY2Vob2xkZXIgKCQxIC8gJDIpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZSlcbiAgICAvLyAgICBcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooIC4uLiApKT9cXH0gIC0gY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIgKCQzKSB3aXRoIG9wdGlvbmFsIHJlZ2V4cC90eXBlIC4uLiAoJDQpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZVxuICAgIC8vICAgICg/OiAuLi4gfCAuLi4gfCAuLi4gKSsgICAgICAgICAtIHRoZSByZWdleHAgY29uc2lzdHMgb2YgYW55IG51bWJlciBvZiBhdG9tcywgYW4gYXRvbSBiZWluZyBlaXRoZXJcbiAgICAvLyAgICBbXnt9XFxcXF0rICAgICAgICAgICAgICAgICAgICAgICAtIGFueXRoaW5nIG90aGVyIHRoYW4gY3VybHkgYnJhY2VzIG9yIGJhY2tzbGFzaFxuICAgIC8vICAgIFxcXFwuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYSBiYWNrc2xhc2ggZXNjYXBlXG4gICAgLy8gICAgXFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9ICAgICAgICAgIC0gYSBtYXRjaGVkIHNldCBvZiBjdXJseSBicmFjZXMgY29udGFpbmluZyBvdGhlciBhdG9tc1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gLyhbOipdKShbXFx3XFxbXFxdXSspfFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2c7XG4gICAgY29uc3Qgc2VhcmNoUGxhY2Vob2xkZXIgPSAvKFs6XT8pKFtcXHdcXFtcXF0uLV0rKXxcXHsoW1xcd1xcW1xcXS4tXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2c7XG4gICAgY29uc3QgcGF0dGVybnM6IGFueVtdW10gPSBbXTtcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgbGV0IG1hdGNoQXJyYXk6IFJlZ0V4cEV4ZWNBcnJheTtcblxuICAgIGNvbnN0IGNoZWNrUGFyYW1FcnJvcnMgPSAoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKCFVcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IudGVzdChpZCkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbWV0ZXIgbmFtZSAnJHtpZH0nIGluIHBhdHRlcm4gJyR7cGF0dGVybn0nYCk7XG4gICAgICBpZiAoZmluZCh0aGlzLl9wYXJhbXMsIHByb3BFcSgnaWQnLCBpZCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZSAnJHtpZH0nIGluIHBhdHRlcm4gJyR7cGF0dGVybn0nYCk7XG4gICAgfTtcblxuICAgIC8vIFNwbGl0IGludG8gc3RhdGljIHNlZ21lbnRzIHNlcGFyYXRlZCBieSBwYXRoIHBhcmFtZXRlciBwbGFjZWhvbGRlcnMuXG4gICAgLy8gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpcyBhbHdheXMgMSBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICAgIGNvbnN0IG1hdGNoRGV0YWlscyA9IChtOiBSZWdFeHBFeGVjQXJyYXksIGlzU2VhcmNoOiBib29sZWFuKTogTWF0Y2hEZXRhaWxzID0+IHtcbiAgICAgIC8vIElFWzc4XSByZXR1cm5zICcnIGZvciB1bm1hdGNoZWQgZ3JvdXBzIGluc3RlYWQgb2YgbnVsbFxuICAgICAgY29uc3QgaWQ6IHN0cmluZyA9IG1bMl0gfHwgbVszXTtcbiAgICAgIGNvbnN0IHJlZ2V4cDogc3RyaW5nID0gaXNTZWFyY2ggPyBtWzRdIDogbVs0XSB8fCAobVsxXSA9PT0gJyonID8gJ1tcXFxcc1xcXFxTXSonIDogbnVsbCk7XG5cbiAgICAgIGNvbnN0IG1ha2VSZWdleHBUeXBlID0gc3RyID0+XG4gICAgICAgIGluaGVyaXQocGFyYW1UeXBlcy50eXBlKGlzU2VhcmNoID8gJ3F1ZXJ5JyA6ICdwYXRoJyksIHtcbiAgICAgICAgICBwYXR0ZXJuOiBuZXcgUmVnRXhwKHN0ciwgdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKSxcbiAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICByZWdleHAsXG4gICAgICAgIHNlZ21lbnQ6IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QsIG0uaW5kZXgpLFxuICAgICAgICB0eXBlOiAhcmVnZXhwID8gbnVsbCA6IHBhcmFtVHlwZXMudHlwZShyZWdleHApIHx8IG1ha2VSZWdleHBUeXBlKHJlZ2V4cCksXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBsZXQgZGV0YWlsczogTWF0Y2hEZXRhaWxzO1xuICAgIGxldCBzZWdtZW50OiBzdHJpbmc7XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgIHdoaWxlICgobWF0Y2hBcnJheSA9IHBsYWNlaG9sZGVyLmV4ZWMocGF0dGVybikpKSB7XG4gICAgICBkZXRhaWxzID0gbWF0Y2hEZXRhaWxzKG1hdGNoQXJyYXksIGZhbHNlKTtcbiAgICAgIGlmIChkZXRhaWxzLnNlZ21lbnQuaW5kZXhPZignPycpID49IDApIGJyZWFrOyAvLyB3ZSdyZSBpbnRvIHRoZSBzZWFyY2ggcGFydFxuXG4gICAgICBjaGVja1BhcmFtRXJyb3JzKGRldGFpbHMuaWQpO1xuICAgICAgdGhpcy5fcGFyYW1zLnB1c2gocGFyYW1GYWN0b3J5LmZyb21QYXRoKGRldGFpbHMuaWQsIGRldGFpbHMudHlwZSwgY29uZmlnLnN0YXRlKSk7XG4gICAgICB0aGlzLl9zZWdtZW50cy5wdXNoKGRldGFpbHMuc2VnbWVudCk7XG4gICAgICBwYXR0ZXJucy5wdXNoKFtkZXRhaWxzLnNlZ21lbnQsIHRhaWwodGhpcy5fcGFyYW1zKV0pO1xuICAgICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcbiAgICB9XG4gICAgc2VnbWVudCA9IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QpO1xuXG4gICAgLy8gRmluZCBhbnkgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGFzdCBzZWdtZW50XG4gICAgY29uc3QgaSA9IHNlZ21lbnQuaW5kZXhPZignPycpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgY29uc3Qgc2VhcmNoID0gc2VnbWVudC5zdWJzdHJpbmcoaSk7XG4gICAgICBzZWdtZW50ID0gc2VnbWVudC5zdWJzdHJpbmcoMCwgaSk7XG5cbiAgICAgIGlmIChzZWFyY2gubGVuZ3RoID4gMCkge1xuICAgICAgICBsYXN0ID0gMDtcblxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgICAgICB3aGlsZSAoKG1hdGNoQXJyYXkgPSBzZWFyY2hQbGFjZWhvbGRlci5leGVjKHNlYXJjaCkpKSB7XG4gICAgICAgICAgZGV0YWlscyA9IG1hdGNoRGV0YWlscyhtYXRjaEFycmF5LCB0cnVlKTtcbiAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKGRldGFpbHMuaWQpO1xuICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKHBhcmFtRmFjdG9yeS5mcm9tU2VhcmNoKGRldGFpbHMuaWQsIGRldGFpbHMudHlwZSwgY29uZmlnLnN0YXRlKSk7XG4gICAgICAgICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcbiAgICAgICAgICAvLyBjaGVjayBpZiA/JlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB0aGlzLl9jb21waWxlZCA9IHBhdHRlcm5zLm1hcChfcGF0dGVybiA9PiBxdW90ZVJlZ0V4cC5hcHBseShudWxsLCBfcGF0dGVybikpLmNvbmNhdChxdW90ZVJlZ0V4cChzZWdtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb25jYXRlbmF0ZWQgVXJsTWF0Y2hlclxuICAgKlxuICAgKiBCdWlsZHMgYSBuZXcgVXJsTWF0Y2hlciBieSBhcHBlbmRpbmcgYW5vdGhlciBVcmxNYXRjaGVyIHRvIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIEEgYFVybE1hdGNoZXJgIGluc3RhbmNlIHRvIGFwcGVuZCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGBVcmxNYXRjaGVyYC5cbiAgICovXG4gIGFwcGVuZCh1cmw6IFVybE1hdGNoZXIpOiBVcmxNYXRjaGVyIHtcbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKHVybCk7XG4gICAgdXJsLl9jYWNoZSA9IHtcbiAgICAgIHBhdGg6IHRoaXMuX2NhY2hlLnBhdGguY29uY2F0KHVybCksXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBwYXR0ZXJuOiBudWxsLFxuICAgIH07XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIGlzUm9vdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucGF0aFswXSA9PT0gdGhpcztcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBpbnB1dCBwYXR0ZXJuIHN0cmluZyAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgdGhlIHNwZWNpZmllZCB1cmwvcGF0aCBhZ2FpbnN0IHRoaXMgbWF0Y2hlci5cbiAgICpcbiAgICogVGVzdHMgaWYgdGhlIGdpdmVuIHVybCBtYXRjaGVzIHRoaXMgbWF0Y2hlcidzIHBhdHRlcm4sIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYXB0dXJlZFxuICAgKiBwYXJhbWV0ZXIgdmFsdWVzLiAgUmV0dXJucyBudWxsIGlmIHRoZSBwYXRoIGRvZXMgbm90IG1hdGNoLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSB2YWx1ZXNcbiAgICogb2YgYW55IHNlYXJjaCBwYXJhbWV0ZXJzIHRoYXQgYXJlIG1lbnRpb25lZCBpbiB0aGUgcGF0dGVybiwgYnV0IHRoZWlyIHZhbHVlIG1heSBiZSBudWxsIGlmXG4gICAqIHRoZXkgYXJlIG5vdCBwcmVzZW50IGluIGBzZWFyY2hgLiBUaGlzIG1lYW5zIHRoYXQgc2VhcmNoIHBhcmFtZXRlcnMgYXJlIGFsd2F5cyB0cmVhdGVkXG4gICAqIGFzIG9wdGlvbmFsLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EmcicpLmV4ZWMoJy91c2VyL2JvYicsIHtcbiAgICogICB4OiAnMScsIHE6ICdoZWxsbydcbiAgICogfSk7XG4gICAqIC8vIHJldHVybnMgeyBpZDogJ2JvYicsIHE6ICdoZWxsbycsIHI6IG51bGwgfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHBhdGggICAgVGhlIFVSTCBwYXRoIHRvIG1hdGNoLCBlLmcuIGAkbG9jYXRpb24ucGF0aCgpYC5cbiAgICogQHBhcmFtIHNlYXJjaCAgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzLCBlLmcuIGAkbG9jYXRpb24uc2VhcmNoKClgLlxuICAgKiBAcGFyYW0gaGFzaCAgICBVUkwgaGFzaCBlLmcuIGAkbG9jYXRpb24uaGFzaCgpYC5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNhcHR1cmVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqL1xuICBleGVjKHBhdGg6IHN0cmluZywgc2VhcmNoOiBhbnkgPSB7fSwgaGFzaD86IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pOiBSYXdQYXJhbXMge1xuICAgIGNvbnN0IG1hdGNoID0gbWVtb2l6ZVRvKHRoaXMuX2NhY2hlLCAncGF0dGVybicsICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgICBbXG4gICAgICAgICAgJ14nLFxuICAgICAgICAgIHVubmVzdCh0aGlzLl9jYWNoZS5wYXRoLm1hcChwcm9wKCdfY29tcGlsZWQnKSkpLmpvaW4oJycpLFxuICAgICAgICAgIHRoaXMuY29uZmlnLnN0cmljdCA9PT0gZmFsc2UgPyAnLz8nIDogJycsXG4gICAgICAgICAgJyQnLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgICB0aGlzLmNvbmZpZy5jYXNlSW5zZW5zaXRpdmUgPyAnaScgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfSkuZXhlYyhwYXRoKTtcblxuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gICAgLy8gb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHsgaXNvbGF0ZTogZmFsc2UgfSk7XG5cbiAgICBjb25zdCBhbGxQYXJhbXM6IFBhcmFtW10gPSB0aGlzLnBhcmFtZXRlcnMoKSxcbiAgICAgIHBhdGhQYXJhbXM6IFBhcmFtW10gPSBhbGxQYXJhbXMuZmlsdGVyKHBhcmFtID0+ICFwYXJhbS5pc1NlYXJjaCgpKSxcbiAgICAgIHNlYXJjaFBhcmFtczogUGFyYW1bXSA9IGFsbFBhcmFtcy5maWx0ZXIocGFyYW0gPT4gcGFyYW0uaXNTZWFyY2goKSksXG4gICAgICBuUGF0aFNlZ21lbnRzID0gdGhpcy5fY2FjaGUucGF0aC5tYXAodXJsbSA9PiB1cmxtLl9zZWdtZW50cy5sZW5ndGggLSAxKS5yZWR1Y2UoKGEsIHgpID0+IGEgKyB4KSxcbiAgICAgIHZhbHVlczogUmF3UGFyYW1zID0ge307XG5cbiAgICBpZiAoblBhdGhTZWdtZW50cyAhPT0gbWF0Y2gubGVuZ3RoIC0gMSkgdGhyb3cgbmV3IEVycm9yKGBVbmJhbGFuY2VkIGNhcHR1cmUgZ3JvdXAgaW4gcm91dGUgJyR7dGhpcy5wYXR0ZXJufSdgKTtcblxuICAgIGZ1bmN0aW9uIGRlY29kZVBhdGhBcnJheShwYXJhbVZhbDogc3RyaW5nKSB7XG4gICAgICBjb25zdCByZXZlcnNlU3RyaW5nID0gKHN0cjogc3RyaW5nKSA9PlxuICAgICAgICBzdHJcbiAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgIGNvbnN0IHVucXVvdGVEYXNoZXMgPSAoc3RyOiBzdHJpbmcpID0+IHN0ci5yZXBsYWNlKC9cXFxcLS9nLCAnLScpO1xuXG4gICAgICBjb25zdCBzcGxpdCA9IHJldmVyc2VTdHJpbmcocGFyYW1WYWwpLnNwbGl0KC8tKD8hXFxcXCkvKTtcbiAgICAgIGNvbnN0IGFsbFJldmVyc2VkID0gbWFwKHNwbGl0LCByZXZlcnNlU3RyaW5nKTtcbiAgICAgIHJldHVybiBtYXAoYWxsUmV2ZXJzZWQsIHVucXVvdGVEYXNoZXMpLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QYXRoU2VnbWVudHM7IGkrKykge1xuICAgICAgY29uc3QgcGFyYW06IFBhcmFtID0gcGF0aFBhcmFtc1tpXTtcbiAgICAgIGxldCB2YWx1ZTogYW55IHwgYW55W10gPSBtYXRjaFtpICsgMV07XG5cbiAgICAgIC8vIGlmIHRoZSBwYXJhbSB2YWx1ZSBtYXRjaGVzIGEgcHJlLXJlcGxhY2UgcGFpciwgcmVwbGFjZSB0aGUgdmFsdWUgYmVmb3JlIGRlY29kaW5nLlxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHZhbHVlKSB2YWx1ZSA9IHBhcmFtLnJlcGxhY2Vbal0udG87XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgJiYgcGFyYW0uYXJyYXkgPT09IHRydWUpIHZhbHVlID0gZGVjb2RlUGF0aEFycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcbiAgICAgIHZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IHNlYXJjaFtwYXJhbS5pZF07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcmFtLnJlcGxhY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpIHZhbHVlID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcbiAgICAgIHZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzaCkgdmFsdWVzWycjJ10gPSBoYXNoO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaGlkZGVuXG4gICAqIFJldHVybnMgYWxsIHRoZSBbW1BhcmFtXV0gb2JqZWN0cyBvZiBhbGwgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhpcyBwYXR0ZXJuIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48UGFyYW0+fSAgQW4gYXJyYXkgb2YgW1tQYXJhbV1dIG9iamVjdHMuIE11c3QgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkuIElmIHRoZVxuICAgKiAgICBwYXR0ZXJuIGhhcyBubyBwYXJhbWV0ZXJzLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAgICovXG4gIHBhcmFtZXRlcnMob3B0czogYW55ID0ge30pOiBQYXJhbVtdIHtcbiAgICBpZiAob3B0cy5pbmhlcml0ID09PSBmYWxzZSkgcmV0dXJuIHRoaXMuX3BhcmFtcztcbiAgICByZXR1cm4gdW5uZXN0KHRoaXMuX2NhY2hlLnBhdGgubWFwKG1hdGNoZXIgPT4gbWF0Y2hlci5fcGFyYW1zKSk7XG4gIH1cblxuICAvKipcbiAgICogQGhpZGRlblxuICAgKiBSZXR1cm5zIGEgc2luZ2xlIHBhcmFtZXRlciBmcm9tIHRoaXMgVXJsTWF0Y2hlciBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWRcbiAgICogQHBhcmFtIG9wdHNcbiAgICogQHJldHVybnMge1R8UGFyYW18YW55fGJvb2xlYW58VXJsTWF0Y2hlcnxudWxsfVxuICAgKi9cbiAgcGFyYW1ldGVyKGlkOiBzdHJpbmcsIG9wdHM6IGFueSA9IHt9KTogUGFyYW0ge1xuICAgIGNvbnN0IGZpbmRQYXJhbSA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgdGhpcy5fcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbS5pZCA9PT0gaWQpIHJldHVybiBwYXJhbTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY2FjaGUucGFyZW50O1xuICAgIHJldHVybiBmaW5kUGFyYW0oKSB8fCAob3B0cy5pbmhlcml0ICE9PSBmYWxzZSAmJiBwYXJlbnQgJiYgcGFyZW50LnBhcmFtZXRlcihpZCwgb3B0cykpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdmFsdWVzIGFnYWluc3QgdGhpcyBVcmxNYXRjaGVyXG4gICAqXG4gICAqIENoZWNrcyBhbiBvYmplY3QgaGFzaCBvZiBwYXJhbWV0ZXJzIHRvIHZhbGlkYXRlIHRoZWlyIGNvcnJlY3RuZXNzIGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVyXG4gICAqIHR5cGVzIG9mIHRoaXMgYFVybE1hdGNoZXJgLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBvYmplY3QgaGFzaCBvZiBwYXJhbWV0ZXJzIHRvIHZhbGlkYXRlLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBgcGFyYW1zYCB2YWxpZGF0ZXMsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgKi9cbiAgdmFsaWRhdGVzKHBhcmFtczogUmF3UGFyYW1zKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsaWRQYXJhbVZhbCA9IChwYXJhbTogUGFyYW0sIHZhbDogYW55KSA9PiAhcGFyYW0gfHwgcGFyYW0udmFsaWRhdGVzKHZhbCk7XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBJJ20gbm90IHN1cmUgd2h5IHRoaXMgY2hlY2tzIG9ubHkgdGhlIHBhcmFtIGtleXMgcGFzc2VkIGluLCBhbmQgbm90IGFsbCB0aGUgcGFyYW1zIGtub3duIHRvIHRoZSBtYXRjaGVyXG4gICAgY29uc3QgcGFyYW1TY2hlbWEgPSB0aGlzLnBhcmFtZXRlcnMoKS5maWx0ZXIocGFyYW1EZWYgPT4gcGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtRGVmLmlkKSk7XG4gICAgcmV0dXJuIHBhcmFtU2NoZW1hLm1hcChwYXJhbURlZiA9PiB2YWxpZFBhcmFtVmFsKHBhcmFtRGVmLCBwYXJhbXNbcGFyYW1EZWYuaWRdKSkucmVkdWNlKGFsbFRydWVSLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzLCBjcmVhdGVzIGEgVVJMIGZyb20gdGhpcyBVcmxNYXRjaGVyLlxuICAgKlxuICAgKiBDcmVhdGVzIGEgVVJMIHRoYXQgbWF0Y2hlcyB0aGlzIHBhdHRlcm4gYnkgc3Vic3RpdHV0aW5nIHRoZSBzcGVjaWZpZWQgdmFsdWVzXG4gICAqIGZvciB0aGUgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmZvcm1hdCh7IGlkOidib2InLCBxOid5ZXMnIH0pO1xuICAgKiAvLyByZXR1cm5zICcvdXNlci9ib2I/cT15ZXMnXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzICB0aGUgdmFsdWVzIHRvIHN1YnN0aXR1dGUgZm9yIHRoZSBwYXJhbWV0ZXJzIGluIHRoaXMgcGF0dGVybi5cbiAgICogQHJldHVybnMgdGhlIGZvcm1hdHRlZCBVUkwgKHBhdGggYW5kIG9wdGlvbmFsbHkgc2VhcmNoIHBhcnQpLlxuICAgKi9cbiAgZm9ybWF0KHZhbHVlczogUmF3UGFyYW1zID0ge30pIHtcbiAgICAvLyBCdWlsZCB0aGUgZnVsbCBwYXRoIG9mIFVybE1hdGNoZXJzIChpbmNsdWRpbmcgYWxsIHBhcmVudCBVcmxNYXRjaGVycylcbiAgICBjb25zdCB1cmxNYXRjaGVycyA9IHRoaXMuX2NhY2hlLnBhdGg7XG5cbiAgICAvLyBFeHRyYWN0IGFsbCB0aGUgc3RhdGljIHNlZ21lbnRzIGFuZCBQYXJhbXMgKHByb2Nlc3NlZCBhcyBQYXJhbURldGFpbHMpXG4gICAgLy8gaW50byBhbiBvcmRlcmVkIGFycmF5XG4gICAgY29uc3QgcGF0aFNlZ21lbnRzQW5kUGFyYW1zOiBBcnJheTxzdHJpbmcgfCBQYXJhbURldGFpbHM+ID0gdXJsTWF0Y2hlcnNcbiAgICAgIC5tYXAoVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgLm1hcCh4ID0+IChpc1N0cmluZyh4KSA/IHggOiBnZXREZXRhaWxzKHgpKSk7XG5cbiAgICAvLyBFeHRyYWN0IHRoZSBxdWVyeSBwYXJhbXMgaW50byBhIHNlcGFyYXRlIGFycmF5XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IEFycmF5PFBhcmFtRGV0YWlscz4gPSB1cmxNYXRjaGVyc1xuICAgICAgLm1hcChVcmxNYXRjaGVyLnF1ZXJ5UGFyYW1zKVxuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgIC5tYXAoZ2V0RGV0YWlscyk7XG5cbiAgICBjb25zdCBpc0ludmFsaWQgPSAocGFyYW06IFBhcmFtRGV0YWlscykgPT4gcGFyYW0uaXNWYWxpZCA9PT0gZmFsc2U7XG4gICAgaWYgKHBhdGhTZWdtZW50c0FuZFBhcmFtcy5jb25jYXQocXVlcnlQYXJhbXMpLmZpbHRlcihpc0ludmFsaWQpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBQYXJhbSwgYXBwbGllcyB0aGUgcGFyYW1ldGVyIHZhbHVlLCB0aGVuIHJldHVybnMgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHBhcmFtOiBQYXJhbSk6IFBhcmFtRGV0YWlscyB7XG4gICAgICAvLyBOb3JtYWxpemUgdG8gdHlwZWQgdmFsdWVcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW0udmFsdWUodmFsdWVzW3BhcmFtLmlkXSk7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gcGFyYW0udmFsaWRhdGVzKHZhbHVlKTtcbiAgICAgIGNvbnN0IGlzRGVmYXVsdFZhbHVlID0gcGFyYW0uaXNEZWZhdWx0VmFsdWUodmFsdWUpO1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gc3F1YXNoIG1vZGUgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgIGNvbnN0IHNxdWFzaCA9IGlzRGVmYXVsdFZhbHVlID8gcGFyYW0uc3F1YXNoIDogZmFsc2U7XG4gICAgICAvLyBBbGxvdyB0aGUgUGFyYW1ldGVyJ3MgVHlwZSB0byBlbmNvZGUgdGhlIHZhbHVlXG4gICAgICBjb25zdCBlbmNvZGVkID0gcGFyYW0udHlwZS5lbmNvZGUodmFsdWUpO1xuXG4gICAgICByZXR1cm4geyBwYXJhbSwgdmFsdWUsIGlzVmFsaWQsIGlzRGVmYXVsdFZhbHVlLCBzcXVhc2gsIGVuY29kZWQgfTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB1cCB0aGUgcGF0aC1wb3J0aW9uIGZyb20gdGhlIGxpc3Qgb2Ygc3RhdGljIHNlZ21lbnRzIGFuZCBwYXJhbWV0ZXJzXG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHBhdGhTZWdtZW50c0FuZFBhcmFtcy5yZWR1Y2UoKGFjYzogc3RyaW5nLCB4OiBzdHJpbmcgfCBQYXJhbURldGFpbHMpID0+IHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgc3RhdGljIHNlZ21lbnQgKGEgcmF3IHN0cmluZyk7IGp1c3QgYXBwZW5kIGl0XG4gICAgICBpZiAoaXNTdHJpbmcoeCkpIHJldHVybiBhY2MgKyB4O1xuXG4gICAgICAvLyBPdGhlcndpc2UsIGl0J3MgYSBQYXJhbURldGFpbHMuXG4gICAgICBjb25zdCB7IHNxdWFzaCwgZW5jb2RlZCwgcGFyYW0gfSA9IHg7XG5cbiAgICAgIC8vIElmIHNxdWFzaCBpcyA9PT0gdHJ1ZSwgdHJ5IHRvIHJlbW92ZSBhIHNsYXNoIGZyb20gdGhlIHBhdGhcbiAgICAgIGlmIChzcXVhc2ggPT09IHRydWUpIHJldHVybiBhY2MubWF0Y2goL1xcLyQvKSA/IGFjYy5zbGljZSgwLCAtMSkgOiBhY2M7XG4gICAgICAvLyBJZiBzcXVhc2ggaXMgYSBzdHJpbmcsIHVzZSB0aGUgc3RyaW5nIGZvciB0aGUgcGFyYW0gdmFsdWVcbiAgICAgIGlmIChpc1N0cmluZyhzcXVhc2gpKSByZXR1cm4gYWNjICsgc3F1YXNoO1xuICAgICAgaWYgKHNxdWFzaCAhPT0gZmFsc2UpIHJldHVybiBhY2M7IC8vID9cbiAgICAgIGlmIChlbmNvZGVkID09IG51bGwpIHJldHVybiBhY2M7XG4gICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBhcnJheSwgZW5jb2RlIHRoZSB2YWx1ZSB1c2luZyBlbmNvZGVEYXNoZXNcbiAgICAgIGlmIChpc0FycmF5KGVuY29kZWQpKSByZXR1cm4gYWNjICsgbWFwKDxzdHJpbmdbXT5lbmNvZGVkLCBVcmxNYXRjaGVyLmVuY29kZURhc2hlcykuam9pbignLScpO1xuICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB0eXBlIGlzIFwicmF3XCIsIHRoZW4gZG8gbm90IGVuY29kZVVSSUNvbXBvbmVudFxuICAgICAgaWYgKHBhcmFtLnJhdykgcmV0dXJuIGFjYyArIGVuY29kZWQ7XG4gICAgICAvLyBFbmNvZGUgdGhlIHZhbHVlXG4gICAgICByZXR1cm4gYWNjICsgZW5jb2RlVVJJQ29tcG9uZW50KDxzdHJpbmc+ZW5jb2RlZCk7XG4gICAgfSwgJycpO1xuXG4gICAgLy8gQnVpbGQgdGhlIHF1ZXJ5IHN0cmluZyBieSBhcHBseWluZyBwYXJhbWV0ZXIgdmFsdWVzIChhcnJheSBvciByZWd1bGFyKVxuICAgIC8vIHRoZW4gbWFwcGluZyB0byBrZXk9dmFsdWUsIHRoZW4gZmxhdHRlbmluZyBhbmQgam9pbmluZyB1c2luZyBcIiZcIlxuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXNcbiAgICAgIC5tYXAoKHBhcmFtRGV0YWlsczogUGFyYW1EZXRhaWxzKSA9PiB7XG4gICAgICAgIGxldCB7IHBhcmFtLCBzcXVhc2gsIGVuY29kZWQsIGlzRGVmYXVsdFZhbHVlIH0gPSBwYXJhbURldGFpbHM7XG4gICAgICAgIGlmIChlbmNvZGVkID09IG51bGwgfHwgKGlzRGVmYXVsdFZhbHVlICYmIHNxdWFzaCAhPT0gZmFsc2UpKSByZXR1cm47XG4gICAgICAgIGlmICghaXNBcnJheShlbmNvZGVkKSkgZW5jb2RlZCA9IFs8c3RyaW5nPmVuY29kZWRdO1xuICAgICAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgaWYgKCFwYXJhbS5yYXcpIGVuY29kZWQgPSBtYXAoPHN0cmluZ1tdPmVuY29kZWQsIGVuY29kZVVSSUNvbXBvbmVudCk7XG5cbiAgICAgICAgcmV0dXJuICg8c3RyaW5nW10+ZW5jb2RlZCkubWFwKHZhbCA9PiBgJHtwYXJhbS5pZH09JHt2YWx9YCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihpZGVudGl0eSlcbiAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgICAuam9pbignJicpO1xuXG4gICAgLy8gQ29uY2F0IHRoZSBwYXRoc3RyaW5nIHdpdGggdGhlIHF1ZXJ5U3RyaW5nIChpZiBleGlzdHMpIGFuZCB0aGUgaGFzaFN0cmluZyAoaWYgZXhpc3RzKVxuICAgIHJldHVybiBwYXRoU3RyaW5nICsgKHF1ZXJ5U3RyaW5nID8gYD8ke3F1ZXJ5U3RyaW5nfWAgOiAnJykgKyAodmFsdWVzWycjJ10gPyAnIycgKyB2YWx1ZXNbJyMnXSA6ICcnKTtcbiAgfVxufVxuXG4vKiogQGhpZGRlbiAqL1xuaW50ZXJmYWNlIFBhcmFtRGV0YWlscyB7XG4gIHBhcmFtOiBQYXJhbTtcbiAgdmFsdWU6IGFueTtcbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgaXNEZWZhdWx0VmFsdWU6IGJvb2xlYW47XG4gIHNxdWFzaDogYm9vbGVhbiB8IHN0cmluZztcbiAgZW5jb2RlZDogc3RyaW5nIHwgc3RyaW5nW107XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHVybCAqLyAvKiogKi9cbmltcG9ydCB7IGV4dGVuZCwgZm9yRWFjaCwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc09iamVjdCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBVcmxNYXRjaGVyIH0gZnJvbSAnLi91cmxNYXRjaGVyJztcbmltcG9ydCB7IERlZlR5cGUsIFBhcmFtLCBQYXJhbVR5cGUsIFBhcmFtVHlwZURlZmluaXRpb24gfSBmcm9tICcuLi9wYXJhbXMnO1xuaW1wb3J0IHsgVXJsTWF0Y2hlckNvbXBpbGVDb25maWcgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgY2xhc3MgUGFyYW1GYWN0b3J5IHtcbiAgZnJvbUNvbmZpZyhpZDogc3RyaW5nLCB0eXBlOiBQYXJhbVR5cGUsIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhbShpZCwgdHlwZSwgRGVmVHlwZS5DT05GSUcsIHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnLCBzdGF0ZSk7XG4gIH1cblxuICBmcm9tUGF0aChpZDogc3RyaW5nLCB0eXBlOiBQYXJhbVR5cGUsIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhbShpZCwgdHlwZSwgRGVmVHlwZS5QQVRILCB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZywgc3RhdGUpO1xuICB9XG5cbiAgZnJvbVNlYXJjaChpZDogc3RyaW5nLCB0eXBlOiBQYXJhbVR5cGUsIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhbShpZCwgdHlwZSwgRGVmVHlwZS5TRUFSQ0gsIHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnLCBzdGF0ZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHt9XG59XG5cbi8qKlxuICogRmFjdG9yeSBmb3IgW1tVcmxNYXRjaGVyXV0gaW5zdGFuY2VzLlxuICpcbiAqIFRoZSBmYWN0b3J5IGlzIGF2YWlsYWJsZSB0byBuZzEgc2VydmljZXMgYXNcbiAqIGAkdXJsTWF0Y2hlckZhY3RvcnlgIG9yIG5nMSBwcm92aWRlcnMgYXMgYCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyYC5cbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIFVybE1hdGNoZXJGYWN0b3J5IHtcbiAgLyoqIEBpbnRlcm5hbGFwaSBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmb3IgYSBnaXZlbiBsb2NhdGlvbiAoRGVmVHlwZSkgKi9cbiAgcGFyYW1GYWN0b3J5ID0gbmV3IFBhcmFtRmFjdG9yeSh0aGlzLnJvdXRlcik7XG5cbiAgLy8gVE9ETzogbW92ZSBpbXBsZW1lbnRhdGlvbnMgdG8gVXJsQ29uZmlnICh1cmxTZXJ2aWNlLmNvbmZpZylcbiAgY29uc3RydWN0b3IoLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSByb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgZXh0ZW5kKHRoaXMsIHsgVXJsTWF0Y2hlciwgUGFyYW0gfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFtbVXJsTWF0Y2hlcl1dIGZvciB0aGUgc3BlY2lmaWVkIHBhdHRlcm4uXG4gICAqXG4gICAqIEBwYXJhbSBwYXR0ZXJuICBUaGUgVVJMIHBhdHRlcm4uXG4gICAqIEBwYXJhbSBjb25maWcgIFRoZSBjb25maWcgb2JqZWN0IGhhc2guXG4gICAqIEByZXR1cm5zIFRoZSBVcmxNYXRjaGVyLlxuICAgKi9cbiAgY29tcGlsZShwYXR0ZXJuOiBzdHJpbmcsIGNvbmZpZz86IFVybE1hdGNoZXJDb21waWxlQ29uZmlnKSB7XG4gICAgY29uc3QgdXJsQ29uZmlnID0gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgLy8gYmFja3dhcmQtY29tcGF0aWJsZSBzdXBwb3J0IGZvciBjb25maWcucGFyYW1zIC0+IGNvbmZpZy5zdGF0ZS5wYXJhbXNcbiAgICBjb25zdCBwYXJhbXMgPSBjb25maWcgJiYgIWNvbmZpZy5zdGF0ZSAmJiAoY29uZmlnIGFzIGFueSkucGFyYW1zO1xuICAgIGNvbmZpZyA9IHBhcmFtcyA/IHsgc3RhdGU6IHsgcGFyYW1zIH0sIC4uLmNvbmZpZyB9IDogY29uZmlnO1xuICAgIGNvbnN0IGdsb2JhbENvbmZpZyA9IHsgc3RyaWN0OiB1cmxDb25maWcuX2lzU3RyaWN0TW9kZSwgY2FzZUluc2Vuc2l0aXZlOiB1cmxDb25maWcuX2lzQ2FzZUluc2Vuc2l0aXZlIH07XG4gICAgcmV0dXJuIG5ldyBVcmxNYXRjaGVyKHBhdHRlcm4sIHVybENvbmZpZy5wYXJhbVR5cGVzLCB0aGlzLnBhcmFtRmFjdG9yeSwgZXh0ZW5kKGdsb2JhbENvbmZpZywgY29uZmlnKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgW1tVcmxNYXRjaGVyXV0sIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIG9iamVjdCAgVGhlIG9iamVjdCB0byBwZXJmb3JtIHRoZSB0eXBlIGNoZWNrIGFnYWluc3QuXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IG1hdGNoZXMgdGhlIGBVcmxNYXRjaGVyYCBpbnRlcmZhY2UsIGJ5XG4gICAqICAgICAgICAgIGltcGxlbWVudGluZyBhbGwgdGhlIHNhbWUgbWV0aG9kcy5cbiAgICovXG4gIGlzTWF0Y2hlcihvYmplY3Q6IGFueSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IHR5cGVvZj9cbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICAgIGZvckVhY2goVXJsTWF0Y2hlci5wcm90b3R5cGUsICh2YWwsIG5hbWUpID0+IHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHJlc3VsdCA9IHJlc3VsdCAmJiAoaXNEZWZpbmVkKG9iamVjdFtuYW1lXSkgJiYgaXNGdW5jdGlvbihvYmplY3RbbmFtZV0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgJGdldCgpIHtcbiAgICBjb25zdCB1cmxDb25maWcgPSB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICB1cmxDb25maWcucGFyYW1UeXBlcy5lbnF1ZXVlID0gZmFsc2U7XG4gICAgdXJsQ29uZmlnLnBhcmFtVHlwZXMuX2ZsdXNoVHlwZVF1ZXVlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsQ29uZmlnLmNhc2VJbnNlbnNpdGl2ZV1dICovXG4gIGNhc2VJbnNlbnNpdGl2ZSA9ICh2YWx1ZT86IGJvb2xlYW4pID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSh2YWx1ZSk7XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybENvbmZpZy5kZWZhdWx0U3F1YXNoUG9saWN5XV0gKi9cbiAgZGVmYXVsdFNxdWFzaFBvbGljeSA9ICh2YWx1ZT86IGJvb2xlYW4gfCBzdHJpbmcpID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnLmRlZmF1bHRTcXVhc2hQb2xpY3kodmFsdWUpO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxDb25maWcuc3RyaWN0TW9kZV1dICovXG4gIHN0cmljdE1vZGUgPSAodmFsdWU/OiBib29sZWFuKSA9PiB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZy5zdHJpY3RNb2RlKHZhbHVlKTtcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsQ29uZmlnLnR5cGVdXSAqL1xuICB0eXBlID0gKG5hbWU6IHN0cmluZywgZGVmaW5pdGlvbj86IFBhcmFtVHlwZURlZmluaXRpb24sIGRlZmluaXRpb25Gbj86ICgpID0+IFBhcmFtVHlwZURlZmluaXRpb24pID0+IHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5jb25maWcudHlwZShuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pIHx8IHRoaXM7XG4gIH07XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHVybCAqLyAvKiogKi9cbmltcG9ydCB7IFVybE1hdGNoZXIgfSBmcm9tICcuL3VybE1hdGNoZXInO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IGlkZW50aXR5LCBleHRlbmQgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGlzLCBwYXR0ZXJuIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IFJhd1BhcmFtcyB9IGZyb20gJy4uL3BhcmFtcy9pbnRlcmZhY2UnO1xuaW1wb3J0IHtcbiAgVXJsUnVsZSxcbiAgVXJsUnVsZU1hdGNoRm4sXG4gIFVybFJ1bGVIYW5kbGVyRm4sXG4gIFVybFJ1bGVUeXBlLFxuICBVcmxQYXJ0cyxcbiAgTWF0Y2hlclVybFJ1bGUsXG4gIFN0YXRlUnVsZSxcbiAgUmVnRXhwUnVsZSxcbn0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXVxuICpcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXSBmcm9tIGE6XG4gKlxuICogLSBgc3RyaW5nYFxuICogLSBbW1VybE1hdGNoZXJdXVxuICogLSBgUmVnRXhwYFxuICogLSBbW1N0YXRlT2JqZWN0XV1cbiAqIEBpbnRlcm5hbGFwaVxuICovXG5leHBvcnQgY2xhc3MgVXJsUnVsZUZhY3Rvcnkge1xuICBzdGF0aWMgaXNVcmxSdWxlID0gb2JqID0+IG9iaiAmJiBbJ3R5cGUnLCAnbWF0Y2gnLCAnaGFuZGxlciddLmV2ZXJ5KGtleSA9PiBpc0RlZmluZWQob2JqW2tleV0pKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcm91dGVyOiBVSVJvdXRlcikge31cblxuICBjb21waWxlKHN0cjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoc3RyKTtcbiAgfVxuXG4gIGNyZWF0ZShcbiAgICB3aGF0OiBzdHJpbmcgfCBVcmxNYXRjaGVyIHwgU3RhdGVPYmplY3QgfCBSZWdFeHAgfCBVcmxSdWxlTWF0Y2hGbixcbiAgICBoYW5kbGVyPzogc3RyaW5nIHwgVXJsUnVsZUhhbmRsZXJGblxuICApOiBVcmxSdWxlIHtcbiAgICBjb25zdCBpc1N0YXRlID0gU3RhdGVPYmplY3QuaXNTdGF0ZTtcbiAgICBjb25zdCBtYWtlUnVsZSA9IHBhdHRlcm4oW1xuICAgICAgW2lzU3RyaW5nLCAoX3doYXQ6IHN0cmluZykgPT4gbWFrZVJ1bGUodGhpcy5jb21waWxlKF93aGF0KSldLFxuICAgICAgW2lzKFVybE1hdGNoZXIpLCAoX3doYXQ6IFVybE1hdGNoZXIpID0+IHRoaXMuZnJvbVVybE1hdGNoZXIoX3doYXQsIGhhbmRsZXIpXSxcbiAgICAgIFtpc1N0YXRlLCAoX3doYXQ6IFN0YXRlT2JqZWN0KSA9PiB0aGlzLmZyb21TdGF0ZShfd2hhdCwgdGhpcy5yb3V0ZXIpXSxcbiAgICAgIFtpcyhSZWdFeHApLCAoX3doYXQ6IFJlZ0V4cCkgPT4gdGhpcy5mcm9tUmVnRXhwKF93aGF0LCBoYW5kbGVyKV0sXG4gICAgICBbaXNGdW5jdGlvbiwgKF93aGF0OiBVcmxSdWxlTWF0Y2hGbikgPT4gbmV3IEJhc2VVcmxSdWxlKF93aGF0LCBoYW5kbGVyIGFzIFVybFJ1bGVIYW5kbGVyRm4pXSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHJ1bGUgPSBtYWtlUnVsZSh3aGF0KTtcbiAgICBpZiAoIXJ1bGUpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ3doYXQnIGluIHdoZW4oKVwiKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFVybFJ1bGUgd2hpY2ggbWF0Y2hlcyBiYXNlZCBvbiBhIFVybE1hdGNoZXJcbiAgICpcbiAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgYHN0cmluZ2AsIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYW5vdGhlciBbW1VybE1hdGNoZXJdXVxuICAgKlxuICAgKiAjIyBIYW5kbGVyIGFzIGEgZnVuY3Rpb25cbiAgICpcbiAgICogSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGg6XG4gICAqXG4gICAqIC0gbWF0Y2hlZCBwYXJhbWV0ZXIgdmFsdWVzIChbW1Jhd1BhcmFtc11dIGZyb20gW1tVcmxNYXRjaGVyLmV4ZWNdXSlcbiAgICogLSB1cmw6IHRoZSBjdXJyZW50IFVybCAoW1tVcmxQYXJ0c11dKVxuICAgKiAtIHJvdXRlcjogdGhlIHJvdXRlciBvYmplY3QgKFtbVUlSb3V0ZXJdXSlcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcbiAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXIsIG1hdGNoID0+IFwiL2hvbWUvXCIgKyBtYXRjaC5mb29JZCArIFwiL1wiICsgbWF0Y2guYmFySWQpO1xuICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMgSGFuZGxlciBhcyBVcmxNYXRjaGVyXG4gICAqXG4gICAqIElmIGBoYW5kbGVyYCBpcyBhIFVybE1hdGNoZXIsIHRoZSBoYW5kbGVyIG1hdGNoZXIgaXMgdXNlZCB0byBjcmVhdGUgdGhlIG5ldyB1cmwuXG4gICAqIFRoZSBgaGFuZGxlcmAgVXJsTWF0Y2hlciBpcyBmb3JtYXR0ZWQgdXNpbmcgdGhlIG1hdGNoZWQgcGFyYW0gZnJvbSB0aGUgZmlyc3QgbWF0Y2hlci5cbiAgICogVGhlIHVybCBpcyByZXBsYWNlZCB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHVybE1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vLzpmb29JZC86YmFySWRcIik7XG4gICAqIHZhciBoYW5kbGVyID0gJHVtZi5jb21waWxlKFwiL2hvbWUvOmZvb0lkLzpiYXJJZFwiKTtcbiAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXIsIGhhbmRsZXIpO1xuICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xuICAgKiBgYGBcbiAgICovXG4gIGZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXI6IFVybE1hdGNoZXIsIGhhbmRsZXI6IHN0cmluZyB8IFVybE1hdGNoZXIgfCBVcmxSdWxlSGFuZGxlckZuKTogTWF0Y2hlclVybFJ1bGUge1xuICAgIGxldCBfaGFuZGxlcjogVXJsUnVsZUhhbmRsZXJGbiA9IGhhbmRsZXIgYXMgYW55O1xuICAgIGlmIChpc1N0cmluZyhoYW5kbGVyKSkgaGFuZGxlciA9IHRoaXMucm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoaGFuZGxlcik7XG4gICAgaWYgKGlzKFVybE1hdGNoZXIpKGhhbmRsZXIpKSBfaGFuZGxlciA9IChtYXRjaDogUmF3UGFyYW1zKSA9PiAoaGFuZGxlciBhcyBVcmxNYXRjaGVyKS5mb3JtYXQobWF0Y2gpO1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hVcmxQYXJhbXRlcnModXJsOiBVcmxQYXJ0cyk6IFJhd1BhcmFtcyB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB1cmxNYXRjaGVyLmV4ZWModXJsLnBhdGgsIHVybC5zZWFyY2gsIHVybC5oYXNoKTtcbiAgICAgIHJldHVybiB1cmxNYXRjaGVyLnZhbGlkYXRlcyhwYXJhbXMpICYmIHBhcmFtcztcbiAgICB9XG5cbiAgICAvLyBQcmlvcml0aXplIFVSTHMsIGxvd2VzdCB0byBoaWdoZXN0OlxuICAgIC8vIC0gU29tZSBvcHRpb25hbCBVUkwgcGFyYW1ldGVycywgYnV0IG5vbmUgbWF0Y2hlZFxuICAgIC8vIC0gTm8gb3B0aW9uYWwgcGFyYW1ldGVycyBpbiBVUkxcbiAgICAvLyAtIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycywgc29tZSBtYXRjaGVkXG4gICAgLy8gLSBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMsIGFsbCBtYXRjaGVkXG4gICAgZnVuY3Rpb24gbWF0Y2hQcmlvcml0eShwYXJhbXM6IFJhd1BhcmFtcyk6IG51bWJlciB7XG4gICAgICBjb25zdCBvcHRpb25hbCA9IHVybE1hdGNoZXIucGFyYW1ldGVycygpLmZpbHRlcihwYXJhbSA9PiBwYXJhbS5pc09wdGlvbmFsKTtcbiAgICAgIGlmICghb3B0aW9uYWwubGVuZ3RoKSByZXR1cm4gMC4wMDAwMDE7XG4gICAgICBjb25zdCBtYXRjaGVkID0gb3B0aW9uYWwuZmlsdGVyKHBhcmFtID0+IHBhcmFtc1twYXJhbS5pZF0pO1xuICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoIC8gb3B0aW9uYWwubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IGRldGFpbHMgPSB7IHVybE1hdGNoZXIsIG1hdGNoUHJpb3JpdHksIHR5cGU6ICdVUkxNQVRDSEVSJyB9O1xuICAgIHJldHVybiBleHRlbmQobmV3IEJhc2VVcmxSdWxlKG1hdGNoVXJsUGFyYW10ZXJzLCBfaGFuZGxlciksIGRldGFpbHMpIGFzIE1hdGNoZXJVcmxSdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGEgc3RhdGUgYnkgaXRzIHVybFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tU3RhdGUoJHN0YXRlLmdldCgnZm9vJyksIHJvdXRlcik7XG4gICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTtcbiAgICogLy8gU3RhcnRzIGEgdHJhbnNpdGlvbiB0byAnZm9vJyB3aXRoIHBhcmFtczogeyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAqIGBgYFxuICAgKi9cbiAgZnJvbVN0YXRlKHN0YXRlOiBTdGF0ZU9iamVjdCwgcm91dGVyOiBVSVJvdXRlcik6IFN0YXRlUnVsZSB7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBtYXRjaCBieSB0cmFuc2l0aW9uaW5nIHRvIG1hdGNoZWQgc3RhdGVcbiAgICAgKlxuICAgICAqIEZpcnN0IGNoZWNrcyBpZiB0aGUgcm91dGVyIHNob3VsZCBzdGFydCBhIG5ldyB0cmFuc2l0aW9uLlxuICAgICAqIEEgbmV3IHRyYW5zaXRpb24gaXMgbm90IHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IHN0YXRlJ3MgVVJMXG4gICAgICogYW5kIHRoZSBuZXcgVVJMIGFyZSBhbHJlYWR5IGlkZW50aWNhbFxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZXIgPSAobWF0Y2g6IFJhd1BhcmFtcykgPT4ge1xuICAgICAgY29uc3QgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgIGNvbnN0IGdsb2JhbHMgPSByb3V0ZXIuZ2xvYmFscztcbiAgICAgIGlmICgkc3RhdGUuaHJlZihzdGF0ZSwgbWF0Y2gpICE9PSAkc3RhdGUuaHJlZihnbG9iYWxzLmN1cnJlbnQsIGdsb2JhbHMucGFyYW1zKSkge1xuICAgICAgICAkc3RhdGUudHJhbnNpdGlvblRvKHN0YXRlLCBtYXRjaCwgeyBpbmhlcml0OiB0cnVlLCBzb3VyY2U6ICd1cmwnIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkZXRhaWxzID0geyBzdGF0ZSwgdHlwZTogJ1NUQVRFJyB9O1xuICAgIHJldHVybiBleHRlbmQodGhpcy5mcm9tVXJsTWF0Y2hlcihzdGF0ZS51cmwsIGhhbmRsZXIpLCBkZXRhaWxzKSBhcyBTdGF0ZVJ1bGU7XG4gIH1cblxuICAvKipcbiAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYmFzZWQgb24gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICpcbiAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYSBzdHJpbmcuXG4gICAqXG4gICAqICMjIEhhbmRsZXIgYXMgYSBmdW5jdGlvblxuICAgKlxuICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aDpcbiAgICpcbiAgICogLSByZWdleHAgbWF0Y2ggYXJyYXkgKGZyb20gYHJlZ2V4cGApXG4gICAqIC0gdXJsOiB0aGUgY3VycmVudCBVcmwgKFtbVXJsUGFydHNdXSlcbiAgICogLSByb3V0ZXI6IHRoZSByb3V0ZXIgb2JqZWN0IChbW1VJUm91dGVyXV0pXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgbWF0Y2ggPT4gXCIvaG9tZS9cIiArIG1hdGNoWzFdKVxuICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vL2JhcicpOyAvLyByZXN1bHRzIGluIFsgJy9mb28vYmFyJywgJ2JhcicgXVxuICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lL2JhcidcbiAgICogYGBgXG4gICAqXG4gICAqICMjIEhhbmRsZXIgYXMgc3RyaW5nXG4gICAqXG4gICAqIElmIGBoYW5kbGVyYCBpcyBhIHN0cmluZywgdGhlIHVybCBpcyAqcmVwbGFjZWQgYnkgdGhlIHN0cmluZyogd2hlbiB0aGUgUnVsZSBpcyBpbnZva2VkLlxuICAgKiBUaGUgc3RyaW5nIGlzIGZpcnN0IGludGVycG9sYXRlZCB1c2luZyBgc3RyaW5nLnJlcGxhY2UoKWAgc3R5bGUgcGF0dGVybi5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVJlZ0V4cCgvXlxcL2Zvb1xcLyhiYXJ8YmF6KSQvLCBcIi9ob21lLyQxXCIpXG4gICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vYmFyJyk7IC8vIHJlc3VsdHMgaW4gWyAnL2Zvby9iYXInLCAnYmFyJyBdXG4gICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvYmFyJ1xuICAgKiBgYGBcbiAgICovXG4gIGZyb21SZWdFeHAocmVnZXhwOiBSZWdFeHAsIGhhbmRsZXI6IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm4pOiBSZWdFeHBSdWxlIHtcbiAgICBpZiAocmVnZXhwLmdsb2JhbCB8fCByZWdleHAuc3RpY2t5KSB0aHJvdyBuZXcgRXJyb3IoJ1J1bGUgUmVnRXhwIG11c3Qgbm90IGJlIGdsb2JhbCBvciBzdGlja3knKTtcblxuICAgIC8qKlxuICAgICAqIElmIGhhbmRsZXIgaXMgYSBzdHJpbmcsIHRoZSB1cmwgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgc3RyaW5nLlxuICAgICAqIElmIHRoZSBzdHJpbmcgaGFzIGFueSBTdHJpbmcucmVwbGFjZSgpIHN0eWxlIHZhcmlhYmxlcyBpbiBpdCAobGlrZSBgJDJgKSxcbiAgICAgKiB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNhcHR1cmVzIGZyb20gW1ttYXRjaF1dXG4gICAgICovXG4gICAgY29uc3QgcmVkaXJlY3RVcmxUbyA9IChtYXRjaDogUmVnRXhwRXhlY0FycmF5KSA9PlxuICAgICAgLy8gSW50ZXJwb2xhdGVzIG1hdGNoZWQgdmFsdWVzIGludG8gJDEgJDIsIGV0YyB1c2luZyBhIFN0cmluZy5yZXBsYWNlKCktc3R5bGUgcGF0dGVyblxuICAgICAgKGhhbmRsZXIgYXMgc3RyaW5nKS5yZXBsYWNlKC9cXCQoXFwkfFxcZHsxLDJ9KS8sIChtLCB3aGF0KSA9PiBtYXRjaFt3aGF0ID09PSAnJCcgPyAwIDogTnVtYmVyKHdoYXQpXSk7XG5cbiAgICBjb25zdCBfaGFuZGxlciA9IGlzU3RyaW5nKGhhbmRsZXIpID8gcmVkaXJlY3RVcmxUbyA6IGhhbmRsZXI7XG5cbiAgICBjb25zdCBtYXRjaFBhcmFtc0Zyb21SZWdleHAgPSAodXJsOiBVcmxQYXJ0cyk6IFJlZ0V4cEV4ZWNBcnJheSA9PiByZWdleHAuZXhlYyh1cmwucGF0aCk7XG5cbiAgICBjb25zdCBkZXRhaWxzID0geyByZWdleHAsIHR5cGU6ICdSRUdFWFAnIH07XG4gICAgcmV0dXJuIGV4dGVuZChuZXcgQmFzZVVybFJ1bGUobWF0Y2hQYXJhbXNGcm9tUmVnZXhwLCBfaGFuZGxlciksIGRldGFpbHMpIGFzIFJlZ0V4cFJ1bGU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGJhc2UgcnVsZSB3aGljaCBjYWxscyBgbWF0Y2hgXG4gKlxuICogVGhlIHZhbHVlIGZyb20gdGhlIGBtYXRjaGAgZnVuY3Rpb24gaXMgcGFzc2VkIHRocm91Z2ggdG8gdGhlIGBoYW5kbGVyYC5cbiAqIEBpbnRlcm5hbGFwaVxuICovXG5leHBvcnQgY2xhc3MgQmFzZVVybFJ1bGUgaW1wbGVtZW50cyBVcmxSdWxlIHtcbiAgJGlkOiBudW1iZXI7XG4gIHByaW9yaXR5OiBudW1iZXI7XG4gIF9ncm91cDogbnVtYmVyO1xuICB0eXBlOiBVcmxSdWxlVHlwZSA9ICdSQVcnO1xuICBoYW5kbGVyOiBVcmxSdWxlSGFuZGxlckZuO1xuICBtYXRjaFByaW9yaXR5ID0gbWF0Y2ggPT4gMCAtIHRoaXMuJGlkO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtYXRjaDogVXJsUnVsZU1hdGNoRm4sIGhhbmRsZXI/OiBVcmxSdWxlSGFuZGxlckZuKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlciB8fCBpZGVudGl0eTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQgeyBzdHJpcExhc3RQYXRoRWxlbWVudCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBVcmxNYXRjaGVyIH0gZnJvbSAnLi91cmxNYXRjaGVyJztcbmltcG9ydCB7IFJhd1BhcmFtcyB9IGZyb20gJy4uL3BhcmFtcyc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBVcmxSdWxlRmFjdG9yeSB9IGZyb20gJy4vdXJsUnVsZSc7XG5pbXBvcnQgeyBNYXRjaFJlc3VsdCwgVXJsUGFydHMsIFVybFJ1bGUsIFVybFJ1bGVIYW5kbGVyRm4gfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSwgVGFyZ2V0U3RhdGVEZWYgfSBmcm9tICcuLi9zdGF0ZSc7XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhcHBlbmRCYXNlUGF0aCh1cmw6IHN0cmluZywgaXNIdG1sNTogYm9vbGVhbiwgYWJzb2x1dGU6IGJvb2xlYW4sIGJhc2VIcmVmOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoYmFzZUhyZWYgPT09ICcvJykgcmV0dXJuIHVybDtcbiAgaWYgKGlzSHRtbDUpIHJldHVybiBzdHJpcExhc3RQYXRoRWxlbWVudChiYXNlSHJlZikgKyB1cmw7XG4gIGlmIChhYnNvbHV0ZSkgcmV0dXJuIGJhc2VIcmVmLnNsaWNlKDEpICsgdXJsO1xuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgVVJMIGFuZCByZXNwb25kcyB0byBVUkwgY2hhbmdlc1xuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICogVGhpcyBjbGFzcyBpcyBub3cgY29uc2lkZXJlZCB0byBiZSBhbiBpbnRlcm5hbCBBUElcbiAqIFVzZSB0aGUgW1tVcmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAqIEZvciBjb25maWd1cmluZyBVUkwgcnVsZXMsIHVzZSB0aGUgW1tVcmxSdWxlc11dIHdoaWNoIGNhbiBiZSBmb3VuZCBhcyBbW1VybFNlcnZpY2UucnVsZXNdXS5cbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIFVybFJvdXRlciB7XG4gIC8qKiB1c2VkIHRvIGNyZWF0ZSBbW1VybFJ1bGVdXSBvYmplY3RzIGZvciBjb21tb24gY2FzZXMgKi9cbiAgcHVibGljIHVybFJ1bGVGYWN0b3J5OiBVcmxSdWxlRmFjdG9yeTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBsb2NhdGlvbjogc3RyaW5nO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge1xuICAgIHRoaXMudXJsUnVsZUZhY3RvcnkgPSBuZXcgVXJsUnVsZUZhY3Rvcnkocm91dGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBBUEkuXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgdXBkYXRlKHJlYWQ/OiBib29sZWFuKSB7XG4gICAgY29uc3QgJHVybCA9IHRoaXMucm91dGVyLmxvY2F0aW9uU2VydmljZTtcbiAgICBpZiAocmVhZCkge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9ICR1cmwudXJsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgkdXJsLnVybCgpID09PSB0aGlzLmxvY2F0aW9uKSByZXR1cm47XG5cbiAgICAkdXJsLnVybCh0aGlzLmxvY2F0aW9uLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBBUEkuXG4gICAqXG4gICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICogQHBhcmFtIHVybE1hdGNoZXJcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmxNYXRjaGVyOiBVcmxNYXRjaGVyLCBwYXJhbXM/OiBSYXdQYXJhbXMsIG9wdGlvbnM/OiB7IHJlcGxhY2U/OiBzdHJpbmcgfCBib29sZWFuIH0pIHtcbiAgICBjb25zdCByZXBsYWNlID0gb3B0aW9ucyAmJiAhIW9wdGlvbnMucmVwbGFjZTtcbiAgICB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLnVybCh1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMgfHwge30pLCByZXBsYWNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW5kIHJldHVybnMgYSBVUkwgd2l0aCBpbnRlcnBvbGF0ZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvYWJvdXQvOnBlcnNvblwiKTtcbiAgICogcGFyYW1zID0geyBwZXJzb246IFwiYm9iXCIgfTtcbiAgICogJGJvYiA9ICR1cmxSb3V0ZXIuaHJlZihtYXRjaGVyLCBwYXJhbXMpO1xuICAgKiAvLyAkYm9iID09IFwiL2Fib3V0L2JvYlwiO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHVybE1hdGNoZXIgVGhlIFtbVXJsTWF0Y2hlcl1dIG9iamVjdCB3aGljaCBpcyB1c2VkIGFzIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGdlbmVyYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIG1hdGNoZXIncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuICAgKlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBmdWxseSBjb21waWxlZCBVUkwsIG9yIGBudWxsYCBpZiBgcGFyYW1zYCBmYWlsIHZhbGlkYXRpb24gYWdhaW5zdCBgdXJsTWF0Y2hlcmBcbiAgICovXG4gIGhyZWYodXJsTWF0Y2hlcjogVXJsTWF0Y2hlciwgcGFyYW1zPzogYW55LCBvcHRpb25zPzogeyBhYnNvbHV0ZTogYm9vbGVhbiB9KTogc3RyaW5nIHtcbiAgICBsZXQgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zKTtcbiAgICBpZiAodXJsID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBhYnNvbHV0ZTogZmFsc2UgfTtcblxuICAgIGNvbnN0IGNmZyA9IHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnO1xuICAgIGNvbnN0IGlzSHRtbDUgPSBjZmcuaHRtbDVNb2RlKCk7XG4gICAgaWYgKCFpc0h0bWw1ICYmIHVybCAhPT0gbnVsbCkge1xuICAgICAgdXJsID0gJyMnICsgY2ZnLmhhc2hQcmVmaXgoKSArIHVybDtcbiAgICB9XG4gICAgdXJsID0gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBvcHRpb25zLmFic29sdXRlLCBjZmcuYmFzZUhyZWYoKSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGUgfHwgIXVybCkge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICBjb25zdCBzbGFzaCA9ICFpc0h0bWw1ICYmIHVybCA/ICcvJyA6ICcnO1xuICAgIGNvbnN0IGNmZ1BvcnQgPSBjZmcucG9ydCgpO1xuICAgIGNvbnN0IHBvcnQgPSA8YW55PihjZmdQb3J0ID09PSA4MCB8fCBjZmdQb3J0ID09PSA0NDMgPyAnJyA6ICc6JyArIGNmZ1BvcnQpO1xuXG4gICAgcmV0dXJuIFtjZmcucHJvdG9jb2woKSwgJzovLycsIGNmZy5ob3N0KCksIHBvcnQsIHNsYXNoLCB1cmxdLmpvaW4oJycpO1xuICB9XG5cbiAgLy8gRGVsZWdhdGUgdGhlc2UgY2FsbHMgdG8gW1tVcmxTZXJ2aWNlXV1cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybFNlcnZpY2Uuc3luY11dKi9cbiAgcHVibGljIHN5bmMgPSAoZXZ0PykgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5zeW5jKGV2dCk7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxTZXJ2aWNlLmxpc3Rlbl1dKi9cbiAgcHVibGljIGxpc3RlbiA9IChlbmFibGVkPzogYm9vbGVhbik6IEZ1bmN0aW9uID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UubGlzdGVuKGVuYWJsZWQpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsU2VydmljZS5kZWZlckludGVyY2VwdF1dKi9cbiAgcHVibGljIGRlZmVySW50ZXJjZXB0ID0gKGRlZmVyPzogYm9vbGVhbikgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5kZWZlckludGVyY2VwdChkZWZlcik7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxTZXJ2aWNlLmludGVyY2VwdERlZmVycmVkXV0qL1xuICBwdWJsaWMgZ2V0IGludGVyY2VwdERlZmVycmVkKCkge1xuICAgIHJldHVybiB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmludGVyY2VwdERlZmVycmVkO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxTZXJ2aWNlLm1hdGNoXV0qL1xuICBwdWJsaWMgbWF0Y2ggPSAodXJsUGFydHM6IFVybFBhcnRzKTogTWF0Y2hSZXN1bHQgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5tYXRjaCh1cmxQYXJ0cyk7XG5cbiAgLy8gRGVsZWdhdGUgdGhlc2UgY2FsbHMgdG8gW1tVcmxSdWxlc11dXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxSdWxlcy5pbml0aWFsXV0qL1xuICBwdWJsaWMgaW5pdGlhbCA9IChoYW5kbGVyOiBzdHJpbmcgfCBVcmxSdWxlSGFuZGxlckZuIHwgVGFyZ2V0U3RhdGUgfCBUYXJnZXRTdGF0ZURlZik6IHZvaWQgPT5cbiAgICB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLnJ1bGVzLmluaXRpYWwoaGFuZGxlcik7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxSdWxlcy5vdGhlcndpc2VdXSovXG4gIHB1YmxpYyBvdGhlcndpc2UgPSAoaGFuZGxlcjogc3RyaW5nIHwgVXJsUnVsZUhhbmRsZXJGbiB8IFRhcmdldFN0YXRlIHwgVGFyZ2V0U3RhdGVEZWYpOiB2b2lkID0+XG4gICAgdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5vdGhlcndpc2UoaGFuZGxlcik7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxSdWxlcy5yZW1vdmVSdWxlXV0qL1xuICBwdWJsaWMgcmVtb3ZlUnVsZSA9IChydWxlOiBVcmxSdWxlKTogdm9pZCA9PiB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLnJ1bGVzLnJlbW92ZVJ1bGUocnVsZSk7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxSdWxlcy5ydWxlXV0qL1xuICBwdWJsaWMgcnVsZSA9IChydWxlOiBVcmxSdWxlKTogRnVuY3Rpb24gPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5ydWxlKHJ1bGUpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMucnVsZXNdXSovXG4gIHB1YmxpYyBydWxlcyA9ICgpOiBVcmxSdWxlW10gPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5ydWxlcygpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMuc29ydF1dKi9cbiAgcHVibGljIHNvcnQgPSAoY29tcGFyZUZuPzogKGE6IFVybFJ1bGUsIGI6IFVybFJ1bGUpID0+IG51bWJlcikgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5zb3J0KGNvbXBhcmVGbik7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxSdWxlcy53aGVuXV0qL1xuICBwdWJsaWMgd2hlbiA9IChcbiAgICBtYXRjaGVyOiBSZWdFeHAgfCBVcmxNYXRjaGVyIHwgc3RyaW5nLFxuICAgIGhhbmRsZXI6IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm4sXG4gICAgb3B0aW9ucz86IHsgcHJpb3JpdHk6IG51bWJlciB9XG4gICk6IFVybFJ1bGUgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy53aGVuKG1hdGNoZXIsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB2aWV3ICovIC8qKiAqL1xuaW1wb3J0IHsgZXF1YWxzLCBhcHBseVBhaXJzLCByZW1vdmVGcm9tLCBUeXBlZE1hcCwgaW5BcnJheSwgZmluZCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgY3VycnksIHByb3AgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5IH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tICcuLi9jb21tb24vdHJhY2UnO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IEFjdGl2ZVVJVmlldywgVmlld0NvbnRleHQsIFZpZXdDb25maWcgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBfVmlld0RlY2xhcmF0aW9uIH0gZnJvbSAnLi4vc3RhdGUvaW50ZXJmYWNlJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcblxuZXhwb3J0IHR5cGUgVmlld0NvbmZpZ0ZhY3RvcnkgPSAocGF0aDogUGF0aE5vZGVbXSwgZGVjbDogX1ZpZXdEZWNsYXJhdGlvbikgPT4gVmlld0NvbmZpZyB8IFZpZXdDb25maWdbXTtcblxuZXhwb3J0IGludGVyZmFjZSBWaWV3U2VydmljZVBsdWdpbkFQSSB7XG4gIF9yb290Vmlld0NvbnRleHQoY29udGV4dD86IFZpZXdDb250ZXh0KTogVmlld0NvbnRleHQ7XG4gIF92aWV3Q29uZmlnRmFjdG9yeSh2aWV3VHlwZTogc3RyaW5nLCBmYWN0b3J5OiBWaWV3Q29uZmlnRmFjdG9yeSk7XG4gIC8qKiBAcGFyYW0gaWQgcm91dGVyLiRpZCArIFwiLlwiICsgdWlWaWV3LmlkICovXG4gIF9yZWdpc3RlcmVkVUlWaWV3KGlkOiBzdHJpbmcpOiBBY3RpdmVVSVZpZXc7XG4gIF9yZWdpc3RlcmVkVUlWaWV3cygpOiBBY3RpdmVVSVZpZXdbXTtcbiAgX2FjdGl2ZVZpZXdDb25maWdzKCk6IFZpZXdDb25maWdbXTtcbiAgX29uU3luYyhsaXN0ZW5lcjogVmlld1N5bmNMaXN0ZW5lcik6IEZ1bmN0aW9uO1xufVxuXG4vLyBBIHVpVmlldyBhbmQgaXRzIG1hdGNoaW5nIHZpZXdDb25maWdcbmV4cG9ydCBpbnRlcmZhY2UgVmlld1R1cGxlIHtcbiAgdWlWaWV3OiBBY3RpdmVVSVZpZXc7XG4gIHZpZXdDb25maWc6IFZpZXdDb25maWc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld1N5bmNMaXN0ZW5lciB7XG4gICh2aWV3VHVwbGVzOiBWaWV3VHVwbGVbXSk6IHZvaWQ7XG59XG5cbi8qKlxuICogVGhlIFZpZXcgc2VydmljZVxuICpcbiAqIFRoaXMgc2VydmljZSBwYWlycyBleGlzdGluZyBgdWktdmlld2AgY29tcG9uZW50cyAod2hpY2ggbGl2ZSBpbiB0aGUgRE9NKVxuICogd2l0aCB2aWV3IGNvbmZpZ3MgKGZyb20gdGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdHM6IFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dKS5cbiAqXG4gKiAtIEFmdGVyIGEgc3VjY2Vzc2Z1bCBUcmFuc2l0aW9uLCB0aGUgdmlld3MgZnJvbSB0aGUgbmV3bHkgZW50ZXJlZCBzdGF0ZXMgYXJlIGFjdGl2YXRlZCB2aWEgW1thY3RpdmF0ZVZpZXdDb25maWddXS5cbiAqICAgVGhlIHZpZXdzIGZyb20gZXhpdGVkIHN0YXRlcyBhcmUgZGVhY3RpdmF0ZWQgdmlhIFtbZGVhY3RpdmF0ZVZpZXdDb25maWddXS5cbiAqICAgKFNlZTogdGhlIFtbcmVnaXN0ZXJBY3RpdmF0ZVZpZXdzXV0gVHJhbnNpdGlvbiBIb29rKVxuICpcbiAqIC0gQXMgYHVpLXZpZXdgIGNvbXBvbmVudHMgcG9wIGluIGFuZCBvdXQgb2YgZXhpc3RlbmNlLCB0aGV5IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgdXNpbmcgW1tyZWdpc3RlclVJVmlld11dLlxuICpcbiAqIC0gV2hlbiB0aGUgW1tzeW5jXV0gZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgcmVnaXN0ZXJlZCBgdWktdmlld2AocykgKFtbQWN0aXZlVUlWaWV3XV0pXG4gKiBhcmUgY29uZmlndXJlZCB3aXRoIHRoZSBtYXRjaGluZyBbW1ZpZXdDb25maWddXShzKVxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZXdTZXJ2aWNlIHtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfdWlWaWV3czogQWN0aXZlVUlWaWV3W10gPSBbXTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfdmlld0NvbmZpZ3M6IFZpZXdDb25maWdbXSA9IFtdO1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9yb290Q29udGV4dDogVmlld0NvbnRleHQ7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3ZpZXdDb25maWdGYWN0b3JpZXM6IHsgW2tleTogc3RyaW5nXTogVmlld0NvbmZpZ0ZhY3RvcnkgfSA9IHt9O1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9saXN0ZW5lcnM6IFZpZXdTeW5jTGlzdGVuZXJbXSA9IFtdO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgcHVibGljIF9wbHVnaW5hcGk6IFZpZXdTZXJ2aWNlUGx1Z2luQVBJID0ge1xuICAgIF9yb290Vmlld0NvbnRleHQ6IHRoaXMuX3Jvb3RWaWV3Q29udGV4dC5iaW5kKHRoaXMpLFxuICAgIF92aWV3Q29uZmlnRmFjdG9yeTogdGhpcy5fdmlld0NvbmZpZ0ZhY3RvcnkuYmluZCh0aGlzKSxcbiAgICBfcmVnaXN0ZXJlZFVJVmlldzogKGlkOiBzdHJpbmcpID0+IGZpbmQodGhpcy5fdWlWaWV3cywgdmlldyA9PiBgJHt0aGlzLnJvdXRlci4kaWR9LiR7dmlldy5pZH1gID09PSBpZCksXG4gICAgX3JlZ2lzdGVyZWRVSVZpZXdzOiAoKSA9PiB0aGlzLl91aVZpZXdzLFxuICAgIF9hY3RpdmVWaWV3Q29uZmlnczogKCkgPT4gdGhpcy5fdmlld0NvbmZpZ3MsXG4gICAgX29uU3luYzogKGxpc3RlbmVyOiBWaWV3U3luY0xpc3RlbmVyKSA9PiB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gKCkgPT4gcmVtb3ZlRnJvbSh0aGlzLl9saXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHVpLXZpZXcgYW5kIGEgVmlld0NvbmZpZywgZGV0ZXJtaW5lcyBpZiB0aGV5IFwibWF0Y2hcIi5cbiAgICpcbiAgICogQSB1aS12aWV3IGhhcyBhIGZ1bGx5IHF1YWxpZmllZCBuYW1lIChmcW4pIGFuZCBhIGNvbnRleHQgb2JqZWN0LiAgVGhlIGZxbiBpcyBidWlsdCBmcm9tIGl0cyBvdmVyYWxsIGxvY2F0aW9uIGluXG4gICAqIHRoZSBET00sIGRlc2NyaWJpbmcgaXRzIG5lc3RpbmcgcmVsYXRpb25zaGlwIHRvIGFueSBwYXJlbnQgdWktdmlldyB0YWdzIGl0IGlzIG5lc3RlZCBpbnNpZGUgb2YuXG4gICAqXG4gICAqIEEgVmlld0NvbmZpZyBoYXMgYSB0YXJnZXQgdWktdmlldyBuYW1lIGFuZCBhIGNvbnRleHQgYW5jaG9yLiAgVGhlIHVpLXZpZXcgbmFtZSBjYW4gYmUgYSBzaW1wbGUgbmFtZSwgb3JcbiAgICogY2FuIGJlIGEgc2VnbWVudGVkIHVpLXZpZXcgcGF0aCwgZGVzY3JpYmluZyBhIHBvcnRpb24gb2YgYSB1aS12aWV3IGZxbi5cbiAgICpcbiAgICogSW4gb3JkZXIgZm9yIGEgdWktdmlldyB0byBtYXRjaCBWaWV3Q29uZmlnLCB1aS12aWV3J3MgJHR5cGUgbXVzdCBtYXRjaCB0aGUgVmlld0NvbmZpZydzICR0eXBlXG4gICAqXG4gICAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNpbXBsZSBuYW1lIChubyBkb3RzKSwgdGhlbiBhIHVpLXZpZXcgbWF0Y2hlcyBpZjpcbiAgICogLSB0aGUgdWktdmlldydzIG5hbWUgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gICAqIC0gdGhlIHVpLXZpZXcncyBjb250ZXh0IG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3JcbiAgICpcbiAgICogSWYgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgdWktdmlldyBuYW1lIGlzIGEgc2VnbWVudGVkIG5hbWUgKHdpdGggZG90cyksIHRoZW4gYSB1aS12aWV3IG1hdGNoZXMgaWY6XG4gICAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgd2hlcmU6XG4gICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IChpbmRleCAwKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yXG4gICAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgKGluZGV4IDEuLm4pIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2ggdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogRE9NOlxuICAgKiA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIHJvb3QgY29udGV4dCAobmFtZTogXCJcIikgLS0+XG4gICAqICAgPHVpLXZpZXcgbmFtZT1cImZvb1wiPiAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQVwiICAgICAgLS0+XG4gICAqICAgICA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkJcIiAgICAtLT5cbiAgICogICAgICAgPHVpLXZpZXcgbmFtZT1cImJhclwiPiAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkIuQ1wiICAtLT5cbiAgICogICAgICAgPC91aS12aWV3PlxuICAgKiAgICAgPC91aS12aWV3PlxuICAgKiAgIDwvdWktdmlldz5cbiAgICogPC91aS12aWV3PlxuICAgKlxuICAgKiB1aVZpZXdzOiBbXG4gICAqICB7IGZxbjogXCIkZGVmYXVsdFwiLCAgICAgICAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIlwiIH0gfSxcbiAgICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvb1wiLCAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQVwiIH0gfSxcbiAgICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdFwiLCAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQS5CXCIgfSB9XG4gICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQi5DXCIgfSB9XG4gICAqIF1cbiAgICpcbiAgICogVGhlc2UgZm91ciB2aWV3IGNvbmZpZ3MgYWxsIG1hdGNoIHRoZSB1aS12aWV3IHdpdGggdGhlIGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCI6XG4gICAqXG4gICAqIC0gVmlld0NvbmZpZzE6IHsgdWlWaWV3TmFtZTogXCJiYXJcIiwgICAgICAgICAgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CLkNcIiB9XG4gICAqIC0gVmlld0NvbmZpZzI6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5iYXJcIiwgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CXCIgfVxuICAgKiAtIFZpZXdDb25maWczOiB7IHVpVmlld05hbWU6IFwiZm9vLiRkZWZhdWx0LmJhclwiLCAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkFcIiB9XG4gICAqIC0gVmlld0NvbmZpZzQ6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIHVpVmlld0NvbnRleHRBbmNob3I6IFwiXCIgfVxuICAgKlxuICAgKiBVc2luZyBWaWV3Q29uZmlnMyBhcyBhbiBleGFtcGxlLCBpdCBtYXRjaGVzIHRoZSB1aS12aWV3IHdpdGggZnFuIFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiIGJlY2F1c2U6XG4gICAqIC0gVGhlIFZpZXdDb25maWcncyBzZWdtZW50ZWQgdGFyZ2V0IG5hbWUgaXM6IFsgXCJmb29cIiwgXCIkZGVmYXVsdFwiLCBcImJhclwiIF1cbiAgICogLSBUaGVyZSBleGlzdHMgYSBwYXJlbnQgdWktdmlldyAod2hpY2ggaGFzIGZxbjogXCIkZGVmYXVsdC5mb29cIikgd2hlcmU6XG4gICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBcImZvb1wiIG1hdGNoZXMgdGhlIGZpcnN0IHNlZ21lbnQgXCJmb29cIiBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBcIkFcIiBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yIGNvbnRleHQgXCJBXCJcbiAgICogLSBBbmQgdGhlIHJlbWFpbmluZyBzZWdtZW50cyBbIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdLmpvaW4oXCIuXCJfIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2hcbiAgICogICB0aGUgdGFpbCBvZiB0aGUgdWktdmlldydzIGZxbiBcImRlZmF1bHQuYmFyXCJcbiAgICpcbiAgICogQGludGVybmFsYXBpXG4gICAqL1xuICBzdGF0aWMgbWF0Y2hlcyA9ICh1aVZpZXdzQnlGcW46IFR5cGVkTWFwPEFjdGl2ZVVJVmlldz4sIHVpVmlldzogQWN0aXZlVUlWaWV3KSA9PiAodmlld0NvbmZpZzogVmlld0NvbmZpZykgPT4ge1xuICAgIC8vIERvbid0IHN1cHBseSBhbiBuZzEgdWktdmlldyB3aXRoIGFuIG5nMiBWaWV3Q29uZmlnLCBldGNcbiAgICBpZiAodWlWaWV3LiR0eXBlICE9PSB2aWV3Q29uZmlnLnZpZXdEZWNsLiR0eXBlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBTcGxpdCBuYW1lcyBhcGFydCBmcm9tIGJvdGggdmlld0NvbmZpZyBhbmQgdWlWaWV3IGludG8gc2VnbWVudHNcbiAgICBjb25zdCB2YyA9IHZpZXdDb25maWcudmlld0RlY2w7XG4gICAgY29uc3QgdmNTZWdtZW50cyA9IHZjLiR1aVZpZXdOYW1lLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdWl2U2VnbWVudHMgPSB1aVZpZXcuZnFuLnNwbGl0KCcuJyk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFpbHMgb2YgdGhlIHNlZ21lbnQgYXJyYXlzIG1hdGNoLiBleCwgdGhlc2UgYXJyYXlzJyB0YWlscyBtYXRjaDpcbiAgICAvLyB2YzogW1wiZm9vXCIsIFwiYmFyXCJdLCB1aXYgZnFuOiBbXCIkZGVmYXVsdFwiLCBcImZvb1wiLCBcImJhclwiXVxuICAgIGlmICghZXF1YWxzKHZjU2VnbWVudHMsIHVpdlNlZ21lbnRzLnNsaWNlKDAgLSB2Y1NlZ21lbnRzLmxlbmd0aCkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGZxbiBlbmRpbmcgYXQgdGhlIGZpcnN0IHNlZ21lbnQgb2YgdGhlIHZpZXdDb25maWcgbWF0Y2hlcyB0aGUgY29udGV4dDpcbiAgICAvLyBbXCIkZGVmYXVsdFwiLCBcImZvb1wiXS5qb2luKFwiLlwiKSA9PSBcIiRkZWZhdWx0LmZvb1wiLCBkb2VzIHRoZSB1aS12aWV3ICRkZWZhdWx0LmZvbyBjb250ZXh0IG1hdGNoP1xuICAgIGNvbnN0IG5lZ09mZnNldCA9IDEgLSB2Y1NlZ21lbnRzLmxlbmd0aCB8fCB1bmRlZmluZWQ7XG4gICAgY29uc3QgZnFuVG9GaXJzdFNlZ21lbnQgPSB1aXZTZWdtZW50cy5zbGljZSgwLCBuZWdPZmZzZXQpLmpvaW4oJy4nKTtcbiAgICBjb25zdCB1aVZpZXdDb250ZXh0ID0gdWlWaWV3c0J5RnFuW2ZxblRvRmlyc3RTZWdtZW50XS5jcmVhdGlvbkNvbnRleHQ7XG4gICAgcmV0dXJuIHZjLiR1aVZpZXdDb250ZXh0QW5jaG9yID09PSAodWlWaWV3Q29udGV4dCAmJiB1aVZpZXdDb250ZXh0Lm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgdmlldydzIG5hbWUgZnJvbSBhIHN0YXRlLnZpZXdzIGNvbmZpZ3VyYXRpb24gYmxvY2suXG4gICAqXG4gICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgYnkgYSBmcmFtZXdvcmsgaW1wbGVtZW50YXRpb24gdG8gY2FsY3VsYXRlIHRoZSB2YWx1ZXMgZm9yXG4gICAqIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3TmFtZV1dIGFuZCBbW19WaWV3RGVjbGFyYXRpb24uJHVpVmlld0NvbnRleHRBbmNob3JdXS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRleHQgdGhlIGNvbnRleHQgb2JqZWN0IChzdGF0ZSBkZWNsYXJhdGlvbikgdGhhdCB0aGUgdmlldyBiZWxvbmdzIHRvXG4gICAqIEBwYXJhbSByYXdWaWV3TmFtZSB0aGUgbmFtZSBvZiB0aGUgdmlldywgYXMgZGVjbGFyZWQgaW4gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBub3JtYWxpemVkIHVpVmlld05hbWUgYW5kIHVpVmlld0NvbnRleHRBbmNob3IgdGhhdCB0aGUgdmlldyB0YXJnZXRzXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplVUlWaWV3VGFyZ2V0KGNvbnRleHQ6IFZpZXdDb250ZXh0LCByYXdWaWV3TmFtZSA9ICcnKSB7XG4gICAgLy8gVE9ETzogVmFsaWRhdGUgaW5jb21pbmcgdmlldyBuYW1lIHdpdGggYSByZWdleHAgdG8gYWxsb3c6XG4gICAgLy8gZXg6IFwidmlldy5uYW1lQGZvby5iYXJcIiAsIFwiXi5eLnZpZXcubmFtZVwiICwgXCJ2aWV3Lm5hbWVAXi5eXCIgLCBcIlwiICxcbiAgICAvLyBcIkBcIiAsIFwiJGRlZmF1bHRAXlwiICwgXCIhJGRlZmF1bHQuJGRlZmF1bHRcIiAsIFwiIWZvby5iYXJcIlxuICAgIGNvbnN0IHZpZXdBdENvbnRleHQ6IHN0cmluZ1tdID0gcmF3Vmlld05hbWUuc3BsaXQoJ0AnKTtcbiAgICBsZXQgdWlWaWV3TmFtZSA9IHZpZXdBdENvbnRleHRbMF0gfHwgJyRkZWZhdWx0JzsgLy8gZGVmYXVsdCB0byB1bm5hbWVkIHZpZXdcbiAgICBsZXQgdWlWaWV3Q29udGV4dEFuY2hvciA9IGlzU3RyaW5nKHZpZXdBdENvbnRleHRbMV0pID8gdmlld0F0Q29udGV4dFsxXSA6ICdeJzsgLy8gZGVmYXVsdCB0byBwYXJlbnQgY29udGV4dFxuXG4gICAgLy8gSGFuZGxlIHJlbGF0aXZlIHZpZXctbmFtZSBzdWdhciBzeW50YXguXG4gICAgLy8gTWF0Y2hlcyByYXdWaWV3TmFtZSBcIl4uXi5eLmZvby5iYXJcIiBpbnRvIGFycmF5OiBbXCJeLl4uXi5mb28uYmFyXCIsIFwiXi5eLl5cIiwgXCJmb28uYmFyXCJdLFxuICAgIGNvbnN0IHJlbGF0aXZlVmlld05hbWVTdWdhciA9IC9eKFxcXig/OlxcLlxcXikqKVxcLiguKiQpLy5leGVjKHVpVmlld05hbWUpO1xuICAgIGlmIChyZWxhdGl2ZVZpZXdOYW1lU3VnYXIpIHtcbiAgICAgIC8vIENsb2JiZXJzIGV4aXN0aW5nIGNvbnRleHRBbmNob3IgKHJhd1ZpZXdOYW1lIHZhbGlkYXRpb24gd2lsbCBmaXggdGhpcylcbiAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMV07IC8vIHNldCBhbmNob3IgdG8gXCJeLl4uXlwiXG4gICAgICB1aVZpZXdOYW1lID0gcmVsYXRpdmVWaWV3TmFtZVN1Z2FyWzJdOyAvLyBzZXQgdmlldy1uYW1lIHRvIFwiZm9vLmJhclwiXG4gICAgfVxuXG4gICAgaWYgKHVpVmlld05hbWUuY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgIHVpVmlld05hbWUgPSB1aVZpZXdOYW1lLnN1YnN0cigxKTtcbiAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSAnJzsgLy8gdGFyZ2V0IGFic29sdXRlbHkgZnJvbSByb290XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHBhcmVudCByZWxhdGl2ZSB0YXJnZXRpbmcgXCJeLl4uXlwiXG4gICAgY29uc3QgcmVsYXRpdmVNYXRjaCA9IC9eKFxcXig/OlxcLlxcXikqKSQvO1xuICAgIGlmIChyZWxhdGl2ZU1hdGNoLmV4ZWModWlWaWV3Q29udGV4dEFuY2hvcikpIHtcbiAgICAgIGNvbnN0IGFuY2hvclN0YXRlID0gdWlWaWV3Q29udGV4dEFuY2hvci5zcGxpdCgnLicpLnJlZHVjZSgoYW5jaG9yLCB4KSA9PiBhbmNob3IucGFyZW50LCBjb250ZXh0KTtcbiAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBhbmNob3JTdGF0ZS5uYW1lO1xuICAgIH0gZWxzZSBpZiAodWlWaWV3Q29udGV4dEFuY2hvciA9PT0gJy4nKSB7XG4gICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gY29udGV4dC5uYW1lO1xuICAgIH1cblxuICAgIHJldHVybiB7IHVpVmlld05hbWUsIHVpVmlld0NvbnRleHRBbmNob3IgfTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge31cblxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9yb290Vmlld0NvbnRleHQoY29udGV4dD86IFZpZXdDb250ZXh0KTogVmlld0NvbnRleHQge1xuICAgIHJldHVybiAodGhpcy5fcm9vdENvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuX3Jvb3RDb250ZXh0KTtcbiAgfVxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF92aWV3Q29uZmlnRmFjdG9yeSh2aWV3VHlwZTogc3RyaW5nLCBmYWN0b3J5OiBWaWV3Q29uZmlnRmFjdG9yeSkge1xuICAgIHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXNbdmlld1R5cGVdID0gZmFjdG9yeTtcbiAgfVxuXG4gIGNyZWF0ZVZpZXdDb25maWcocGF0aDogUGF0aE5vZGVbXSwgZGVjbDogX1ZpZXdEZWNsYXJhdGlvbik6IFZpZXdDb25maWdbXSB7XG4gICAgY29uc3QgY2ZnRmFjdG9yeSA9IHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXNbZGVjbC4kdHlwZV07XG4gICAgaWYgKCFjZmdGYWN0b3J5KSB0aHJvdyBuZXcgRXJyb3IoJ1ZpZXdTZXJ2aWNlOiBObyB2aWV3IGNvbmZpZyBmYWN0b3J5IHJlZ2lzdGVyZWQgZm9yIHR5cGUgJyArIGRlY2wuJHR5cGUpO1xuICAgIGNvbnN0IGNmZ3MgPSBjZmdGYWN0b3J5KHBhdGgsIGRlY2wpO1xuICAgIHJldHVybiBpc0FycmF5KGNmZ3MpID8gY2ZncyA6IFtjZmdzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyBhIFZpZXdDb25maWcuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgYSBgVmlld0NvbmZpZ2AuXG4gICAqIEFmdGVyIGNhbGxpbmcgW1tzeW5jXV0sIGl0IHdpbGwgdW4tcGFpciBmcm9tIGFueSBgdWktdmlld2Agd2l0aCB3aGljaCBpdCBpcyBjdXJyZW50bHkgcGFpcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gdmlld0NvbmZpZyBUaGUgVmlld0NvbmZpZyB2aWV3IHRvIGRlcmVnaXN0ZXIuXG4gICAqL1xuICBkZWFjdGl2YXRlVmlld0NvbmZpZyh2aWV3Q29uZmlnOiBWaWV3Q29uZmlnKSB7XG4gICAgdHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KCc8LSBSZW1vdmluZycsIHZpZXdDb25maWcpO1xuICAgIHJlbW92ZUZyb20odGhpcy5fdmlld0NvbmZpZ3MsIHZpZXdDb25maWcpO1xuICB9XG5cbiAgYWN0aXZhdGVWaWV3Q29uZmlnKHZpZXdDb25maWc6IFZpZXdDb25maWcpIHtcbiAgICB0cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoJy0+IFJlZ2lzdGVyaW5nJywgPGFueT52aWV3Q29uZmlnKTtcbiAgICB0aGlzLl92aWV3Q29uZmlncy5wdXNoKHZpZXdDb25maWcpO1xuICB9XG5cbiAgc3luYygpIHtcbiAgICBjb25zdCB1aVZpZXdzQnlGcW46IFR5cGVkTWFwPEFjdGl2ZVVJVmlldz4gPSB0aGlzLl91aVZpZXdzLm1hcCh1aXYgPT4gW3Vpdi5mcW4sIHVpdl0pLnJlZHVjZShhcHBseVBhaXJzLCA8YW55Pnt9KTtcblxuICAgIC8vIFJldHVybiBhIHdlaWdodGVkIGRlcHRoIHZhbHVlIGZvciBhIHVpVmlldy5cbiAgICAvLyBUaGUgZGVwdGggaXMgdGhlIG5lc3RpbmcgZGVwdGggb2YgdWktdmlld3MgKGJhc2VkIG9uIEZRTjsgdGltZXMgMTAsMDAwKVxuICAgIC8vIHBsdXMgdGhlIGRlcHRoIG9mIHRoZSBzdGF0ZSB0aGF0IGlzIHBvcHVsYXRpbmcgdGhlIHVpVmlld1xuICAgIGZ1bmN0aW9uIHVpVmlld0RlcHRoKHVpVmlldzogQWN0aXZlVUlWaWV3KSB7XG4gICAgICBjb25zdCBzdGF0ZURlcHRoID0gKGNvbnRleHQ6IFZpZXdDb250ZXh0KSA9PiAoY29udGV4dCAmJiBjb250ZXh0LnBhcmVudCA/IHN0YXRlRGVwdGgoY29udGV4dC5wYXJlbnQpICsgMSA6IDEpO1xuICAgICAgcmV0dXJuIHVpVmlldy5mcW4uc3BsaXQoJy4nKS5sZW5ndGggKiAxMDAwMCArIHN0YXRlRGVwdGgodWlWaWV3LmNyZWF0aW9uQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBWaWV3Q29uZmlnJ3MgY29udGV4dCdzIGRlcHRoIGluIHRoZSBjb250ZXh0IHRyZWUuXG4gICAgZnVuY3Rpb24gdmlld0NvbmZpZ0RlcHRoKGNvbmZpZzogVmlld0NvbmZpZykge1xuICAgICAgbGV0IGNvbnRleHQ6IFZpZXdDb250ZXh0ID0gY29uZmlnLnZpZXdEZWNsLiRjb250ZXh0LFxuICAgICAgICBjb3VudCA9IDA7XG4gICAgICB3aGlsZSAoKytjb3VudCAmJiBjb250ZXh0LnBhcmVudCkgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIC8vIEdpdmVuIGEgZGVwdGggZnVuY3Rpb24sIHJldHVybnMgYSBjb21wYXJlIGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gZWl0aGVyIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyXG4gICAgY29uc3QgZGVwdGhDb21wYXJlID0gY3VycnkoKGRlcHRoRm4sIHBvc05lZywgbGVmdCwgcmlnaHQpID0+IHBvc05lZyAqIChkZXB0aEZuKGxlZnQpIC0gZGVwdGhGbihyaWdodCkpKTtcblxuICAgIGNvbnN0IG1hdGNoaW5nQ29uZmlnUGFpciA9ICh1aVZpZXc6IEFjdGl2ZVVJVmlldyk6IFZpZXdUdXBsZSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZ3MgPSB0aGlzLl92aWV3Q29uZmlncy5maWx0ZXIoVmlld1NlcnZpY2UubWF0Y2hlcyh1aVZpZXdzQnlGcW4sIHVpVmlldykpO1xuICAgICAgaWYgKG1hdGNoaW5nQ29uZmlncy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgT0suICBDaGlsZCBzdGF0ZXMgY2FuIHRhcmdldCBhIHVpLXZpZXcgdGhhdCB0aGUgcGFyZW50IHN0YXRlIGFsc28gdGFyZ2V0cyAodGhlIGNoaWxkIHdpbnMpXG4gICAgICAgIC8vIFNvcnQgYnkgZGVwdGggYW5kIHJldHVybiB0aGUgbWF0Y2ggZnJvbSB0aGUgZGVlcGVzdCBjaGlsZFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgTXVsdGlwbGUgbWF0Y2hpbmcgdmlldyBjb25maWdzIGZvciAke3VpVmlldy5mcW59YCwgbWF0Y2hpbmdDb25maWdzKTtcbiAgICAgICAgbWF0Y2hpbmdDb25maWdzLnNvcnQoZGVwdGhDb21wYXJlKHZpZXdDb25maWdEZXB0aCwgLTEpKTsgLy8gZGVzY2VuZGluZ1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdWlWaWV3LCB2aWV3Q29uZmlnOiBtYXRjaGluZ0NvbmZpZ3NbMF0gfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY29uZmlndXJlVUlWaWV3ID0gKHR1cGxlOiBWaWV3VHVwbGUpID0+IHtcbiAgICAgIC8vIElmIGEgcGFyZW50IHVpLXZpZXcgaXMgcmVjb25maWd1cmVkLCBpdCBjb3VsZCBkZXN0cm95IGNoaWxkIHVpLXZpZXdzLlxuICAgICAgLy8gQmVmb3JlIGNvbmZpZ3VyaW5nIGEgY2hpbGQgdWktdmlldywgbWFrZSBzdXJlIGl0J3Mgc3RpbGwgaW4gdGhlIGFjdGl2ZSB1aVZpZXdzIGFycmF5LlxuICAgICAgaWYgKHRoaXMuX3VpVmlld3MuaW5kZXhPZih0dXBsZS51aVZpZXcpICE9PSAtMSkgdHVwbGUudWlWaWV3LmNvbmZpZ1VwZGF0ZWQodHVwbGUudmlld0NvbmZpZyk7XG4gICAgfTtcblxuICAgIC8vIFNvcnQgdmlld3MgYnkgRlFOIGFuZCBzdGF0ZSBkZXB0aC4gUHJvY2VzcyB1aXZpZXdzIG5lYXJlc3QgdGhlIHJvb3QgZmlyc3QuXG4gICAgY29uc3QgdWlWaWV3VHVwbGVzID0gdGhpcy5fdWlWaWV3cy5zb3J0KGRlcHRoQ29tcGFyZSh1aVZpZXdEZXB0aCwgMSkpLm1hcChtYXRjaGluZ0NvbmZpZ1BhaXIpO1xuICAgIGNvbnN0IG1hdGNoZWRWaWV3Q29uZmlncyA9IHVpVmlld1R1cGxlcy5tYXAodHVwbGUgPT4gdHVwbGUudmlld0NvbmZpZyk7XG4gICAgY29uc3QgdW5tYXRjaGVkQ29uZmlnVHVwbGVzID0gdGhpcy5fdmlld0NvbmZpZ3NcbiAgICAgIC5maWx0ZXIoY29uZmlnID0+ICFpbkFycmF5KG1hdGNoZWRWaWV3Q29uZmlncywgY29uZmlnKSlcbiAgICAgIC5tYXAodmlld0NvbmZpZyA9PiAoeyB1aVZpZXc6IHVuZGVmaW5lZCwgdmlld0NvbmZpZyB9KSk7XG5cbiAgICB1aVZpZXdUdXBsZXMuZm9yRWFjaChjb25maWd1cmVVSVZpZXcpO1xuXG4gICAgY29uc3QgYWxsVHVwbGVzOiBWaWV3VHVwbGVbXSA9IHVpVmlld1R1cGxlcy5jb25jYXQodW5tYXRjaGVkQ29uZmlnVHVwbGVzKTtcbiAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChjYiA9PiBjYihhbGxUdXBsZXMpKTtcbiAgICB0cmFjZS50cmFjZVZpZXdTeW5jKGFsbFR1cGxlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgYHVpLXZpZXdgIGNvbXBvbmVudFxuICAgKlxuICAgKiBXaGVuIGEgYHVpLXZpZXdgIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBpdCB1c2VzIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIGl0c2VsZi5cbiAgICogQWZ0ZXIgcmVnaXN0cmF0aW9uIHRoZSBbW3N5bmNdXSBtZXRob2QgaXMgdXNlZCB0byBlbnN1cmUgYWxsIGB1aS12aWV3YCBhcmUgY29uZmlndXJlZCB3aXRoIHRoZSBwcm9wZXIgW1tWaWV3Q29uZmlnXV0uXG4gICAqXG4gICAqIE5vdGU6IHRoZSBgdWktdmlld2AgY29tcG9uZW50IHVzZXMgdGhlIGBWaWV3Q29uZmlnYCB0byBkZXRlcm1pbmUgd2hhdCB2aWV3IHNob3VsZCBiZSBsb2FkZWQgaW5zaWRlIHRoZSBgdWktdmlld2AsXG4gICAqIGFuZCB3aGF0IHRoZSB2aWV3J3Mgc3RhdGUgY29udGV4dCBpcy5cbiAgICpcbiAgICogTm90ZTogVGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBgZGVyZWdpc3RlclVJVmlld2AuXG4gICAqICAgICAgIEEgYHVpLXZpZXdgIHNob3VsZCBoYW5nIG9uIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgYHJlZ2lzdGVyVUlWaWV3YCBhbmQgaW52b2tlIGl0IHRvIGRlcmVnaXN0ZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gdWlWaWV3IFRoZSBtZXRhZGF0YSBmb3IgYSBVSVZpZXdcbiAgICogQHJldHVybiBhIGRlLXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiB1c2VkIHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkLlxuICAgKi9cbiAgcmVnaXN0ZXJVSVZpZXcodWlWaWV3OiBBY3RpdmVVSVZpZXcpIHtcbiAgICB0cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoJy0+IFJlZ2lzdGVyaW5nJywgdWlWaWV3KTtcbiAgICBjb25zdCB1aVZpZXdzID0gdGhpcy5fdWlWaWV3cztcbiAgICBjb25zdCBmcW5BbmRUeXBlTWF0Y2hlcyA9ICh1aXY6IEFjdGl2ZVVJVmlldykgPT4gdWl2LmZxbiA9PT0gdWlWaWV3LmZxbiAmJiB1aXYuJHR5cGUgPT09IHVpVmlldy4kdHlwZTtcbiAgICBpZiAodWlWaWV3cy5maWx0ZXIoZnFuQW5kVHlwZU1hdGNoZXMpLmxlbmd0aClcbiAgICAgIHRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCgnISEhISBkdXBsaWNhdGUgdWlWaWV3IG5hbWVkOicsIHVpVmlldyk7XG5cbiAgICB1aVZpZXdzLnB1c2godWlWaWV3KTtcbiAgICB0aGlzLnN5bmMoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpZHggPSB1aVZpZXdzLmluZGV4T2YodWlWaWV3KTtcbiAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIHRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCgnVHJpZWQgcmVtb3Zpbmcgbm9uLXJlZ2lzdGVyZWQgdWlWaWV3JywgdWlWaWV3KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KCc8LSBEZXJlZ2lzdGVyaW5nJywgdWlWaWV3KTtcbiAgICAgIHJlbW92ZUZyb20odWlWaWV3cykodWlWaWV3KTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3MgY3VycmVudGx5IGF2YWlsYWJsZSBvbiB0aGUgcGFnZSwgYnkgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCB2aWV3IG5hbWVzLlxuICAgKi9cbiAgYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aVZpZXdzLm1hcChwcm9wKCdmcW4nKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2aWV3cyBvbiB0aGUgcGFnZSBjb250YWluaW5nIGxvYWRlZCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICovXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5maWx0ZXIocHJvcCgnJGNvbmZpZycpKS5tYXAocHJvcCgnbmFtZScpKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBjb3JlICovIC8qKiAqL1xuaW1wb3J0IHsgU3RhdGVQYXJhbXMgfSBmcm9tICcuL3BhcmFtcy9zdGF0ZVBhcmFtcyc7XG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi9zdGF0ZS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuL3N0YXRlL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBRdWV1ZSB9IGZyb20gJy4vY29tbW9uL3F1ZXVlJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbi8qKlxuICogR2xvYmFsIHJvdXRlciBzdGF0ZVxuICpcbiAqIFRoaXMgaXMgd2hlcmUgd2UgaG9sZCB0aGUgZ2xvYmFsIG11dGFibGUgc3RhdGUgc3VjaCBhcyBjdXJyZW50IHN0YXRlLCBjdXJyZW50XG4gKiBwYXJhbXMsIGN1cnJlbnQgdHJhbnNpdGlvbiwgZXRjLlxuICovXG5leHBvcnQgY2xhc3MgVUlSb3V0ZXJHbG9iYWxzIGltcGxlbWVudHMgRGlzcG9zYWJsZSB7XG4gIC8qKlxuICAgKiBDdXJyZW50IHBhcmFtZXRlciB2YWx1ZXNcbiAgICpcbiAgICogVGhlIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgKi9cbiAgcGFyYW1zOiBTdGF0ZVBhcmFtcyA9IG5ldyBTdGF0ZVBhcmFtcygpO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHN0YXRlXG4gICAqXG4gICAqIFRoZSB0by1zdGF0ZSBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gICAqL1xuICBjdXJyZW50OiBTdGF0ZURlY2xhcmF0aW9uO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHN0YXRlIChpbnRlcm5hbCBvYmplY3QpXG4gICAqXG4gICAqIFRoZSB0by1zdGF0ZSBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgJGN1cnJlbnQ6IFN0YXRlT2JqZWN0O1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGFydGVkL3J1bm5pbmcgdHJhbnNpdGlvbi5cbiAgICogVGhpcyB0cmFuc2l0aW9uIGhhcyByZWFjaGVkIGF0IGxlYXN0IHRoZSBvblN0YXJ0IHBoYXNlLCBidXQgaXMgbm90IHlldCBjb21wbGV0ZVxuICAgKi9cbiAgdHJhbnNpdGlvbjogVHJhbnNpdGlvbjtcblxuICAvKiogQGludGVybmFsYXBpICovXG4gIGxhc3RTdGFydGVkVHJhbnNpdGlvbklkID0gLTE7XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICB0cmFuc2l0aW9uSGlzdG9yeSA9IG5ldyBRdWV1ZTxUcmFuc2l0aW9uPihbXSwgMSk7XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBzdWNjZXNzZnVsVHJhbnNpdGlvbnMgPSBuZXcgUXVldWU8VHJhbnNpdGlvbj4oW10sIDEpO1xuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uSGlzdG9yeS5jbGVhcigpO1xuICAgIHRoaXMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gbnVsbDtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IE1hdGNoZXJVcmxSdWxlLCBVcmxSdWxlLCBVcmxSdWxlSGFuZGxlckZuLCBVcmxSdWxlTWF0Y2hGbiwgVXJsUnVsZXNBcGkgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSwgVGFyZ2V0U3RhdGVEZWYgfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQgeyBVcmxNYXRjaGVyIH0gZnJvbSAnLi91cmxNYXRjaGVyJztcbmltcG9ydCB7IGlzLCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCByZW1vdmVGcm9tLCB2YWwgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgVXJsUnVsZUZhY3RvcnkgfSBmcm9tICcuL3VybFJ1bGUnO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgcHJpb3JpdHlTb3J0ID0gKGE6IFVybFJ1bGUsIGI6IFVybFJ1bGUpID0+IChiLnByaW9yaXR5IHx8IDApIC0gKGEucHJpb3JpdHkgfHwgMCk7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCB0eXBlU29ydCA9IChhOiBVcmxSdWxlLCBiOiBVcmxSdWxlKSA9PiB7XG4gIGNvbnN0IHdlaWdodHMgPSB7IFNUQVRFOiA0LCBVUkxNQVRDSEVSOiA0LCBSRUdFWFA6IDMsIFJBVzogMiwgT1RIRVI6IDEgfTtcbiAgcmV0dXJuICh3ZWlnaHRzW2EudHlwZV0gfHwgMCkgLSAod2VpZ2h0c1tiLnR5cGVdIHx8IDApO1xufTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHVybE1hdGNoZXJTb3J0ID0gKGE6IE1hdGNoZXJVcmxSdWxlLCBiOiBNYXRjaGVyVXJsUnVsZSkgPT5cbiAgIWEudXJsTWF0Y2hlciB8fCAhYi51cmxNYXRjaGVyID8gMCA6IFVybE1hdGNoZXIuY29tcGFyZShhLnVybE1hdGNoZXIsIGIudXJsTWF0Y2hlcik7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBpZFNvcnQgPSAoYTogVXJsUnVsZSwgYjogVXJsUnVsZSkgPT4ge1xuICAvLyBJZGVudGljYWxseSBzb3J0ZWQgU1RBVEUgYW5kIFVSTE1BVENIRVIgYmVzdCBydWxlIHdpbGwgYmUgY2hvc2VuIGJ5IGBtYXRjaFByaW9yaXR5YCBhZnRlciBlYWNoIHJ1bGUgbWF0Y2hlcyB0aGUgVVJMXG4gIGNvbnN0IHVzZU1hdGNoUHJpb3JpdHkgPSB7IFNUQVRFOiB0cnVlLCBVUkxNQVRDSEVSOiB0cnVlIH07XG4gIGNvbnN0IGVxdWFsID0gdXNlTWF0Y2hQcmlvcml0eVthLnR5cGVdICYmIHVzZU1hdGNoUHJpb3JpdHlbYi50eXBlXTtcbiAgcmV0dXJuIGVxdWFsID8gMCA6IChhLiRpZCB8fCAwKSAtIChiLiRpZCB8fCAwKTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBydWxlIHByaW9yaXR5IHNvcnRpbmcgZnVuY3Rpb24uXG4gKlxuICogU29ydHMgcnVsZXMgYnk6XG4gKlxuICogLSBFeHBsaWNpdCBwcmlvcml0eSAoc2V0IHJ1bGUgcHJpb3JpdHkgdXNpbmcgW1tVcmxSdWxlcy53aGVuXV0pXG4gKiAtIFJ1bGUgdHlwZSAoU1RBVEU6IDQsIFVSTE1BVENIRVI6IDQsIFJFR0VYUDogMywgUkFXOiAyLCBPVEhFUjogMSlcbiAqIC0gYFVybE1hdGNoZXJgIHNwZWNpZmljaXR5IChbW1VybE1hdGNoZXIuY29tcGFyZV1dKTogd29ya3MgZm9yIFNUQVRFIGFuZCBVUkxNQVRDSEVSIHR5cGVzIHRvIHBpY2sgdGhlIG1vc3Qgc3BlY2lmaWMgcnVsZS5cbiAqIC0gUnVsZSByZWdpc3RyYXRpb24gb3JkZXIgKGZvciBydWxlIHR5cGVzIG90aGVyIHRoYW4gU1RBVEUgYW5kIFVSTE1BVENIRVIpXG4gKiAgIC0gRXF1YWxseSBzb3J0ZWQgU3RhdGUgYW5kIFVybE1hdGNoZXIgcnVsZXMgd2lsbCBlYWNoIG1hdGNoIHRoZSBVUkwuXG4gKiAgICAgVGhlbiwgdGhlICpiZXN0KiBtYXRjaCBpcyBjaG9zZW4gYmFzZWQgb24gaG93IG1hbnkgcGFyYW1ldGVyIHZhbHVlcyB3ZXJlIG1hdGNoZWQuXG4gKlxuICogQHB1YmxpY2FwaVxuICovXG5sZXQgZGVmYXVsdFJ1bGVTb3J0Rm46IChhOiBVcmxSdWxlLCBiOiBVcmxSdWxlKSA9PiBudW1iZXI7XG5kZWZhdWx0UnVsZVNvcnRGbiA9IChhLCBiKSA9PiB7XG4gIGxldCBjbXAgPSBwcmlvcml0eVNvcnQoYSwgYik7XG4gIGlmIChjbXAgIT09IDApIHJldHVybiBjbXA7XG5cbiAgY21wID0gdHlwZVNvcnQoYSwgYik7XG4gIGlmIChjbXAgIT09IDApIHJldHVybiBjbXA7XG5cbiAgY21wID0gdXJsTWF0Y2hlclNvcnQoYSBhcyBNYXRjaGVyVXJsUnVsZSwgYiBhcyBNYXRjaGVyVXJsUnVsZSk7XG4gIGlmIChjbXAgIT09IDApIHJldHVybiBjbXA7XG5cbiAgcmV0dXJuIGlkU29ydChhLCBiKTtcbn07XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBnZXRIYW5kbGVyRm4oaGFuZGxlcjogc3RyaW5nIHwgVXJsUnVsZUhhbmRsZXJGbiB8IFRhcmdldFN0YXRlIHwgVGFyZ2V0U3RhdGVEZWYpOiBVcmxSdWxlSGFuZGxlckZuIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGhhbmRsZXIpICYmICFpc1N0cmluZyhoYW5kbGVyKSAmJiAhaXMoVGFyZ2V0U3RhdGUpKGhhbmRsZXIpICYmICFUYXJnZXRTdGF0ZS5pc0RlZihoYW5kbGVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIidoYW5kbGVyJyBtdXN0IGJlIGEgc3RyaW5nLCBmdW5jdGlvbiwgVGFyZ2V0U3RhdGUsIG9yIGhhdmUgYSBzdGF0ZTogJ25ld3RhcmdldCcgcHJvcGVydHlcIik7XG4gIH1cbiAgcmV0dXJuIGlzRnVuY3Rpb24oaGFuZGxlcikgPyAoaGFuZGxlciBhcyBVcmxSdWxlSGFuZGxlckZuKSA6IHZhbChoYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBBUEkgZm9yIG1hbmFnaW5nIFVSTCBydWxlc1xuICpcbiAqIFRoaXMgQVBJIGlzIHVzZWQgdG8gY3JlYXRlIGFuZCBtYW5hZ2UgVVJMIHJ1bGVzLlxuICogVVJMIHJ1bGVzIGFyZSBhIG1lY2hhbmlzbSB0byByZXNwb25kIHRvIHNwZWNpZmljIFVSTCBwYXR0ZXJucy5cbiAqXG4gKiBUaGUgbW9zdCBjb21tb25seSB1c2VkIG1ldGhvZHMgYXJlIFtbb3RoZXJ3aXNlXV0gYW5kIFtbd2hlbl1dLlxuICpcbiAqIFRoaXMgQVBJIGlzIGEgcHJvcGVydHkgb2YgW1tVcmxTZXJ2aWNlXV0gYXMgW1tVcmxTZXJ2aWNlLnJ1bGVzXV1cbiAqXG4gKiBAcHVibGljYXBpXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxSdWxlcyBpbXBsZW1lbnRzIERpc3Bvc2FibGUge1xuICAvKiogdXNlZCB0byBjcmVhdGUgW1tVcmxSdWxlXV0gb2JqZWN0cyBmb3IgY29tbW9uIGNhc2VzICovXG4gIHB1YmxpYyB1cmxSdWxlRmFjdG9yeTogVXJsUnVsZUZhY3Rvcnk7XG5cbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfc29ydEZuID0gZGVmYXVsdFJ1bGVTb3J0Rm47XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX290aGVyd2lzZUZuOiBVcmxSdWxlO1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9zb3J0ZWQ6IGJvb2xlYW47XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3J1bGVzOiBVcmxSdWxlW10gPSBbXTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfaWQgPSAwO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge1xuICAgIHRoaXMudXJsUnVsZUZhY3RvcnkgPSBuZXcgVXJsUnVsZUZhY3Rvcnkocm91dGVyKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHB1YmxpYyBkaXNwb3NlKHJvdXRlcj86IFVJUm91dGVyKSB7XG4gICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICBkZWxldGUgdGhpcy5fb3RoZXJ3aXNlRm47XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgaW5pdGlhbCBzdGF0ZSwgcGF0aCwgb3IgYmVoYXZpb3IgdG8gdXNlIHdoZW4gdGhlIGFwcCBzdGFydHMuXG4gICAqXG4gICAqIFRoaXMgcnVsZSBkZWZpbmVzIHRoZSBpbml0aWFsL3N0YXJ0aW5nIHN0YXRlIGZvciB0aGUgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIFRoaXMgcnVsZSBpcyB0cmlnZ2VyZWQgdGhlIGZpcnN0IHRpbWUgdGhlIFVSTCBpcyBjaGVja2VkICh3aGVuIHRoZSBhcHAgaW5pdGlhbGx5IGxvYWRzKS5cbiAgICogVGhlIHJ1bGUgaXMgdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgdXJsIG1hdGNoZXMgZWl0aGVyIGBcIlwiYCBvciBgXCIvXCJgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgcnVsZSBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIHdoZW4gdGhlIHJvb3Qgb2YgdGhlIGFwcGxpY2F0aW9uIGlzIGRpcmVjdGx5IGxpbmtlZCB0by5cbiAgICogV2hlbiB0aGUgVVJMIGlzICpub3QqIGBcIlwiYCBvciBgXCIvXCJgIGFuZCBkb2Vzbid0IG1hdGNoIG90aGVyIHJ1bGVzLCB0aGUgW1tvdGhlcndpc2VdXSBydWxlIGlzIHRyaWdnZXJlZC5cbiAgICogVGhpcyBhbGxvd3MgNDA0LWxpa2UgYmVoYXZpb3Igd2hlbiBhbiB1bmtub3duIFVSTCBpcyBkZWVwLWxpbmtlZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBTdGFydCBhcHAgYXQgYGhvbWVgIHN0YXRlLlxuICAgKiBgYGBqc1xuICAgKiAuaW5pdGlhbCh7IHN0YXRlOiAnaG9tZScgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFN0YXJ0IGFwcCBhdCBgL2hvbWVgIChieSB1cmwpXG4gICAqIGBgYGpzXG4gICAqIC5pbml0aWFsKCcvaG9tZScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBXaGVuIG5vIG90aGVyIHVybCBydWxlIG1hdGNoZXMsIGdvIHRvIGBob21lYCBzdGF0ZVxuICAgKiBgYGBqc1xuICAgKiAuaW5pdGlhbCgobWF0Y2hWYWx1ZSwgdXJsLCByb3V0ZXIpID0+IHtcbiAgICogICBjb25zb2xlLmxvZygnaW5pdGlhbCBzdGF0ZScpO1xuICAgKiAgIHJldHVybiB7IHN0YXRlOiAnaG9tZScgfTtcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBpbml0aWFsIHN0YXRlIG9yIHVybCBwYXRoLCBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHN0YXRlIG9yIHVybCBwYXRoIChvciBwZXJmb3JtcyBjdXN0b20gbG9naWMpLlxuICAgKi9cbiAgcHVibGljIGluaXRpYWwoaGFuZGxlcjogc3RyaW5nIHwgVXJsUnVsZUhhbmRsZXJGbiB8IFRhcmdldFN0YXRlIHwgVGFyZ2V0U3RhdGVEZWYpIHtcbiAgICBjb25zdCBoYW5kbGVyRm46IFVybFJ1bGVIYW5kbGVyRm4gPSBnZXRIYW5kbGVyRm4oaGFuZGxlcik7XG4gICAgY29uc3QgbWF0Y2hGbjogVXJsUnVsZU1hdGNoRm4gPSAodXJsUGFydHMsIHJvdXRlcikgPT5cbiAgICAgIHJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb25IaXN0b3J5LnNpemUoKSA9PT0gMCAmJiAhIS9eXFwvPyQvLmV4ZWModXJsUGFydHMucGF0aCk7XG5cbiAgICB0aGlzLnJ1bGUodGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUobWF0Y2hGbiwgaGFuZGxlckZuKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgc3RhdGUsIHVybCwgb3IgYmVoYXZpb3IgdG8gdXNlIHdoZW4gbm8gb3RoZXIgcnVsZSBtYXRjaGVzIHRoZSBVUkwuXG4gICAqXG4gICAqIFRoaXMgcnVsZSBpcyBtYXRjaGVkIHdoZW4gKm5vIG90aGVyIHJ1bGUqIG1hdGNoZXMuXG4gICAqIEl0IGlzIGdlbmVyYWxseSB1c2VkIHRvIGhhbmRsZSB1bmtub3duIFVSTHMgKHNpbWlsYXIgdG8gXCI0MDRcIiBiZWhhdmlvciwgYnV0IG9uIHRoZSBjbGllbnQgc2lkZSkuXG4gICAqXG4gICAqIC0gSWYgYGhhbmRsZXJgIGEgc3RyaW5nLCBpdCBpcyB0cmVhdGVkIGFzIGEgdXJsIHJlZGlyZWN0XG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogV2hlbiBubyBvdGhlciB1cmwgcnVsZSBtYXRjaGVzLCByZWRpcmVjdCB0byBgL2luZGV4YFxuICAgKiBgYGBqc1xuICAgKiAub3RoZXJ3aXNlKCcvaW5kZXgnKTtcbiAgICogYGBgXG4gICAqXG4gICAqIC0gSWYgYGhhbmRsZXJgIGlzIGFuIG9iamVjdCB3aXRoIGEgYHN0YXRlYCBwcm9wZXJ0eSwgdGhlIHN0YXRlIGlzIGFjdGl2YXRlZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBXaGVuIG5vIG90aGVyIHVybCBydWxlIG1hdGNoZXMsIHJlZGlyZWN0IHRvIGBob21lYCBhbmQgcHJvdmlkZSBhIGBkYXNoYm9hcmRgIHBhcmFtZXRlciB2YWx1ZS5cbiAgICogYGBganNcbiAgICogLm90aGVyd2lzZSh7IHN0YXRlOiAnaG9tZScsIHBhcmFtczogeyBkYXNoYm9hcmQ6ICdkZWZhdWx0JyB9IH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogLSBJZiBgaGFuZGxlcmAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBjdXJyZW50IHVybCAoW1tVcmxQYXJ0c11dKSBhbmQgdGhlIFtbVUlSb3V0ZXJdXSBvYmplY3QuXG4gICAqICAgVGhlIGZ1bmN0aW9uIGNhbiBwZXJmb3JtIGFjdGlvbnMsIGFuZC9vciByZXR1cm4gYSB2YWx1ZS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBXaGVuIG5vIG90aGVyIHVybCBydWxlIG1hdGNoZXMsIG1hbnVhbGx5IHRyaWdnZXIgYSB0cmFuc2l0aW9uIHRvIHRoZSBgaG9tZWAgc3RhdGVcbiAgICogYGBganNcbiAgICogLm90aGVyd2lzZSgobWF0Y2hWYWx1ZSwgdXJsUGFydHMsIHJvdXRlcikgPT4ge1xuICAgKiAgIHJvdXRlci5zdGF0ZVNlcnZpY2UuZ28oJ2hvbWUnKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFdoZW4gbm8gb3RoZXIgdXJsIHJ1bGUgbWF0Y2hlcywgZ28gdG8gYGhvbWVgIHN0YXRlXG4gICAqIGBgYGpzXG4gICAqIC5vdGhlcndpc2UoKG1hdGNoVmFsdWUsIHVybFBhcnRzLCByb3V0ZXIpID0+IHtcbiAgICogICByZXR1cm4geyBzdGF0ZTogJ2hvbWUnIH07XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGhhbmRsZXIgVGhlIHVybCBwYXRoIHRvIHJlZGlyZWN0IHRvLCBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHVybCBwYXRoIChvciBwZXJmb3JtcyBjdXN0b20gbG9naWMpLlxuICAgKi9cbiAgcHVibGljIG90aGVyd2lzZShoYW5kbGVyOiBzdHJpbmcgfCBVcmxSdWxlSGFuZGxlckZuIHwgVGFyZ2V0U3RhdGUgfCBUYXJnZXRTdGF0ZURlZikge1xuICAgIGNvbnN0IGhhbmRsZXJGbjogVXJsUnVsZUhhbmRsZXJGbiA9IGdldEhhbmRsZXJGbihoYW5kbGVyKTtcblxuICAgIHRoaXMuX290aGVyd2lzZUZuID0gdGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUodmFsKHRydWUpLCBoYW5kbGVyRm4pO1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJ1bGUgcHJldmlvdXNseSByZWdpc3RlcmVkXG4gICAqXG4gICAqIEBwYXJhbSBydWxlIHRoZSBtYXRjaGVyIHJ1bGUgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nIFtbcnVsZV1dXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlUnVsZShydWxlKTogdm9pZCB7XG4gICAgcmVtb3ZlRnJvbSh0aGlzLl9ydWxlcywgcnVsZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgYWRkcyBhIFVSTCBSdWxlLlxuICAgKlxuICAgKiBVc3VhbGx5LCBhIHVybCBydWxlIGlzIGFkZGVkIHVzaW5nIFtbU3RhdGVEZWNsYXJhdGlvbi51cmxdXSBvciBbW3doZW5dXS5cbiAgICogVGhpcyBhcGkgY2FuIGJlIHVzZWQgZGlyZWN0bHkgZm9yIG1vcmUgY29udHJvbCAodG8gcmVnaXN0ZXIgYSBbW0Jhc2VVcmxSdWxlXV0sIGZvciBleGFtcGxlKS5cbiAgICogUnVsZXMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgW1t1cmxSdWxlRmFjdG9yeV1dLCBvciBjcmVhdGVkIG1hbnVhbGx5IGFzIHNpbXBsZSBvYmplY3RzLlxuICAgKlxuICAgKiBBIHJ1bGUgc2hvdWxkIGhhdmUgYSBgbWF0Y2hgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdHJ1dGh5IGlmIHRoZSBydWxlIG1hdGNoZWQuXG4gICAqIEl0IHNob3VsZCBhbHNvIGhhdmUgYSBgaGFuZGxlcmAgZnVuY3Rpb24gd2hpY2ggaXMgaW52b2tlZCBpZiB0aGUgcnVsZSBpcyB0aGUgYmVzdCBtYXRjaC5cbiAgICpcbiAgICogQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlcnMgdGhlIHJ1bGVcbiAgICovXG4gIHB1YmxpYyBydWxlKHJ1bGU6IFVybFJ1bGUpOiBGdW5jdGlvbiB7XG4gICAgaWYgKCFVcmxSdWxlRmFjdG9yeS5pc1VybFJ1bGUocnVsZSkpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBydWxlJyk7XG4gICAgcnVsZS4kaWQgPSB0aGlzLl9pZCsrO1xuICAgIHJ1bGUucHJpb3JpdHkgPSBydWxlLnByaW9yaXR5IHx8IDA7XG5cbiAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlUnVsZShydWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCByZWdpc3RlcmVkIHJ1bGVzXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgcmVnaXN0ZXJlZCBydWxlc1xuICAgKi9cbiAgcHVibGljIHJ1bGVzKCk6IFVybFJ1bGVbXSB7XG4gICAgdGhpcy5lbnN1cmVTb3J0ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fcnVsZXMuY29uY2F0KHRoaXMuX290aGVyd2lzZUZuID8gW3RoaXMuX290aGVyd2lzZUZuXSA6IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIFVSTCBSdWxlIHByaW9yaXRpZXNcbiAgICpcbiAgICogTW9yZSB0aGFuIG9uZSBydWxlIChbW1VybFJ1bGVdXSkgbWlnaHQgbWF0Y2ggYSBnaXZlbiBVUkwuXG4gICAqIFRoaXMgYGNvbXBhcmVGbmAgaXMgdXNlZCB0byBzb3J0IHRoZSBydWxlcyBieSBwcmlvcml0eS5cbiAgICogSGlnaGVyIHByaW9yaXR5IHJ1bGVzIHNob3VsZCBzb3J0IGVhcmxpZXIuXG4gICAqXG4gICAqIFRoZSBbW2RlZmF1bHRSdWxlU29ydEZuXV0gaXMgdXNlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBZb3Ugb25seSBuZWVkIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBvbmNlLlxuICAgKiBUaGUgYGNvbXBhcmVGbmAgd2lsbCBiZSB1c2VkIHRvIHNvcnQgdGhlIHJ1bGVzIGFzIGVhY2ggaXMgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSWYgY2FsbGVkIHdpdGhvdXQgYW55IHBhcmFtZXRlciwgaXQgd2lsbCByZS1zb3J0IHRoZSBydWxlcy5cbiAgICpcbiAgICogLS0tXG4gICAqXG4gICAqIFVybCBydWxlcyBtYXkgY29tZSBmcm9tIG11bHRpcGxlIHNvdXJjZXM6IHN0YXRlcydzIHVybHMgKFtbU3RhdGVEZWNsYXJhdGlvbi51cmxdXSksIFtbd2hlbl1dLCBhbmQgW1tydWxlXV0uXG4gICAqIEVhY2ggcnVsZSBoYXMgYSAodXNlci1wcm92aWRlZCkgW1tVcmxSdWxlLnByaW9yaXR5XV0sIGEgW1tVcmxSdWxlLnR5cGVdXSwgYW5kIGEgW1tVcmxSdWxlLiRpZF1dXG4gICAqIFRoZSBgJGlkYCBpcyBpcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIHJ1bGUgd2FzIHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIFRoZSBzb3J0IGZ1bmN0aW9uIHNob3VsZCB1c2UgdGhlc2UgZGF0YSwgb3IgZGF0YSBmb3VuZCBvbiBhIHNwZWNpZmljIHR5cGVcbiAgICogb2YgW1tVcmxSdWxlXV0gKHN1Y2ggYXMgW1tTdGF0ZVJ1bGUuc3RhdGVdXSksIHRvIG9yZGVyIHRoZSBydWxlcyBhcyBkZXNpcmVkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFRoaXMgY29tcGFyZSBmdW5jdGlvbiBwcmlvcml0aXplcyBydWxlcyBieSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIHJ1bGVzIHdlcmUgcmVnaXN0ZXJlZC5cbiAgICogQSBydWxlIHJlZ2lzdGVyZWQgZWFybGllciBoYXMgaGlnaGVyIHByaW9yaXR5LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBmdW5jdGlvbiBjb21wYXJlRm4oYSwgYikge1xuICAgKiAgIHJldHVybiBhLiRpZCAtIGIuJGlkO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY29tcGFyZUZuIGEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyB0byBbW1VybFJ1bGVdXSBvYmplY3RzLlxuICAgKiAgICBUaGUgYGNvbXBhcmVGbmAgc2hvdWxkIGFiaWRlIGJ5IHRoZSBgQXJyYXkuc29ydGAgY29tcGFyZSBmdW5jdGlvbiBydWxlcy5cbiAgICogICAgR2l2ZW4gdHdvIHJ1bGVzLCBgYWAgYW5kIGBiYCwgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyIGlmIGBhYCBzaG91bGQgYmUgaGlnaGVyIHByaW9yaXR5LlxuICAgKiAgICBSZXR1cm4gYSBwb3NpdGl2ZSBudW1iZXIgaWYgYGJgIHNob3VsZCBiZSBoaWdoZXIgcHJpb3JpdHkuXG4gICAqICAgIFJldHVybiBgMGAgaWYgdGhlIHJ1bGVzIGFyZSBpZGVudGljYWwuXG4gICAqXG4gICAqICAgIFNlZSB0aGUgW21vemlsbGEgcmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I0Rlc2NyaXB0aW9uKVxuICAgKiAgICBmb3IgZGV0YWlscy5cbiAgICovXG4gIHNvcnQoY29tcGFyZUZuPzogKGE6IFVybFJ1bGUsIGI6IFVybFJ1bGUpID0+IG51bWJlcikge1xuICAgIGNvbnN0IHNvcnRlZCA9IHRoaXMuc3RhYmxlU29ydCh0aGlzLl9ydWxlcywgKHRoaXMuX3NvcnRGbiA9IGNvbXBhcmVGbiB8fCB0aGlzLl9zb3J0Rm4pKTtcblxuICAgIC8vIHByZWNvbXB1dGUgX3NvcnRHcm91cCB2YWx1ZXMgYW5kIGFwcGx5IHRvIGVhY2ggcnVsZVxuICAgIGxldCBncm91cCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvcnRlZFtpXS5fZ3JvdXAgPSBncm91cDtcbiAgICAgIGlmIChpIDwgc29ydGVkLmxlbmd0aCAtIDEgJiYgdGhpcy5fc29ydEZuKHNvcnRlZFtpXSwgc29ydGVkW2kgKyAxXSkgIT09IDApIHtcbiAgICAgICAgZ3JvdXArKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9ydWxlcyA9IHNvcnRlZDtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBlbnN1cmVTb3J0ZWQoKSB7XG4gICAgdGhpcy5fc29ydGVkIHx8IHRoaXMuc29ydCgpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBzdGFibGVTb3J0KGFyciwgY29tcGFyZUZuKSB7XG4gICAgY29uc3QgYXJyT2ZXcmFwcGVyID0gYXJyLm1hcCgoZWxlbSwgaWR4KSA9PiAoeyBlbGVtLCBpZHggfSkpO1xuXG4gICAgYXJyT2ZXcmFwcGVyLnNvcnQoKHdyYXBwZXJBLCB3cmFwcGVyQikgPT4ge1xuICAgICAgY29uc3QgY21wRGlmZiA9IGNvbXBhcmVGbih3cmFwcGVyQS5lbGVtLCB3cmFwcGVyQi5lbGVtKTtcbiAgICAgIHJldHVybiBjbXBEaWZmID09PSAwID8gd3JhcHBlckEuaWR4IC0gd3JhcHBlckIuaWR4IDogY21wRGlmZjtcbiAgICB9KTtcblxuICAgIHJldHVybiBhcnJPZldyYXBwZXIubWFwKHdyYXBwZXIgPT4gd3JhcHBlci5lbGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBgbWF0Y2hlcmAgYW5kIGBoYW5kbGVyYCBmb3IgY3VzdG9tIFVSTHMgaGFuZGxpbmcuXG4gICAqXG4gICAqIFRoZSBgbWF0Y2hlcmAgY2FuIGJlOlxuICAgKlxuICAgKiAtIGEgW1tVcmxNYXRjaGVyXV06IFNlZTogW1tVcmxNYXRjaGVyRmFjdG9yeS5jb21waWxlXV1cbiAgICogLSBhIGBzdHJpbmdgOiBUaGUgc3RyaW5nIGlzIGNvbXBpbGVkIHRvIGEgW1tVcmxNYXRjaGVyXV1cbiAgICogLSBhIGBSZWdFeHBgOiBUaGUgcmVnZXhwIGlzIHVzZWQgdG8gbWF0Y2ggdGhlIHVybC5cbiAgICpcbiAgICogVGhlIGBoYW5kbGVyYCBjYW4gYmU6XG4gICAqXG4gICAqIC0gYSBzdHJpbmc6IFRoZSB1cmwgaXMgcmVkaXJlY3RlZCB0byB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbiAgICogLSBhIGZ1bmN0aW9uOiBUaGUgdXJsIGlzIHJlZGlyZWN0ZWQgdG8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIC0tLVxuICAgKlxuICAgKiBXaGVuIHRoZSBgaGFuZGxlcmAgaXMgYSBgc3RyaW5nYCBhbmQgdGhlIGBtYXRjaGVyYCBpcyBhIGBVcmxNYXRjaGVyYCAob3Igc3RyaW5nKSwgdGhlIHJlZGlyZWN0XG4gICAqIHN0cmluZyBpcyBpbnRlcnBvbGF0ZWQgd2l0aCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFdoZW4gdGhlIFVSTCBpcyBgL2Zvby8xMjNgIHRoZSBydWxlIHdpbGwgcmVkaXJlY3QgdG8gYC9iYXIvMTIzYC5cbiAgICogYGBganNcbiAgICogLndoZW4oXCIvZm9vLzpwYXJhbTFcIiwgXCIvYmFyLzpwYXJhbTFcIilcbiAgICogYGBgXG4gICAqXG4gICAqIC0tLVxuICAgKlxuICAgKiBXaGVuIHRoZSBgaGFuZGxlcmAgaXMgYSBzdHJpbmcgYW5kIHRoZSBgbWF0Y2hlcmAgaXMgYSBgUmVnRXhwYCwgdGhlIHJlZGlyZWN0IHN0cmluZyBpc1xuICAgKiBpbnRlcnBvbGF0ZWQgd2l0aCBjYXB0dXJlIGdyb3VwcyBmcm9tIHRoZSBSZWdFeHAuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogV2hlbiB0aGUgVVJMIGlzIGAvZm9vLzEyM2AgdGhlIHJ1bGUgd2lsbCByZWRpcmVjdCB0byBgL2Jhci8xMjNgLlxuICAgKiBgYGBqc1xuICAgKiAud2hlbihuZXcgUmVnRXhwKFwiXi9mb28vKC4qKSRcIiksIFwiL2Jhci8kMVwiKTtcbiAgICogYGBgXG4gICAqXG4gICAqIC0tLVxuICAgKlxuICAgKiBXaGVuIHRoZSBoYW5kbGVyIGlzIGEgZnVuY3Rpb24sIGl0IHJlY2VpdmVzIHRoZSBtYXRjaGVkIHZhbHVlLCB0aGUgY3VycmVudCBVUkwsIGFuZCB0aGUgYFVJUm91dGVyYCBvYmplY3QgKFNlZSBbW1VybFJ1bGVIYW5kbGVyRm5dXSkuXG4gICAqIFRoZSBcIm1hdGNoZWQgdmFsdWVcIiBkaWZmZXJzIGJhc2VkIG9uIHRoZSBgbWF0Y2hlcmAuXG4gICAqIEZvciBbW1VybE1hdGNoZXJdXXMsIGl0IHdpbGwgYmUgdGhlIG1hdGNoZWQgc3RhdGUgcGFyYW1zLlxuICAgKiBGb3IgYFJlZ0V4cGAsIGl0IHdpbGwgYmUgdGhlIG1hdGNoIGFycmF5IGZyb20gYHJlZ2V4cC5leGVjKClgLlxuICAgKlxuICAgKiBJZiB0aGUgaGFuZGxlciByZXR1cm5zIGEgc3RyaW5nLCB0aGUgVVJMIGlzIHJlZGlyZWN0ZWQgdG8gdGhlIHN0cmluZy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBXaGVuIHRoZSBVUkwgaXMgYC9mb28vMTIzYCB0aGUgcnVsZSB3aWxsIHJlZGlyZWN0IHRvIGAvYmFyLzEyM2AuXG4gICAqIGBgYGpzXG4gICAqIC53aGVuKG5ldyBSZWdFeHAoXCJeL2Zvby8oLiopJFwiKSwgbWF0Y2ggPT4gXCIvYmFyL1wiICsgbWF0Y2hbMV0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZTogdGhlIGBoYW5kbGVyYCBtYXkgYWxzbyBpbnZva2UgYXJiaXRyYXJ5IGNvZGUsIHN1Y2ggYXMgYCRzdGF0ZS5nbygpYFxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hlciBBIHBhdHRlcm4gYHN0cmluZ2AgdG8gbWF0Y2gsIGNvbXBpbGVkIGFzIGEgW1tVcmxNYXRjaGVyXV0sIG9yIGEgYFJlZ0V4cGAuXG4gICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBwYXRoIHRvIHJlZGlyZWN0IHRvLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcGF0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMgYHsgcHJpb3JpdHk6IG51bWJlciB9YFxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByZWdpc3RlcmVkIFtbVXJsUnVsZV1dXG4gICAqL1xuICBwdWJsaWMgd2hlbihcbiAgICBtYXRjaGVyOiBSZWdFeHAgfCBVcmxNYXRjaGVyIHwgc3RyaW5nLFxuICAgIGhhbmRsZXI6IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm4sXG4gICAgb3B0aW9ucz86IHsgcHJpb3JpdHk6IG51bWJlciB9XG4gICk6IFVybFJ1bGUge1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShtYXRjaGVyLCBoYW5kbGVyKTtcbiAgICBpZiAoaXNEZWZpbmVkKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkpIHJ1bGUucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5O1xuICAgIHRoaXMucnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IFBhcmFtVHlwZURlZmluaXRpb24sIFBhcmFtVHlwZXMgfSBmcm9tICcuLi9wYXJhbXMnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc1N0cmluZyB9IGZyb20gJy4uL2NvbW1vbic7XG5cbi8qKlxuICogQW4gQVBJIHRvIGN1c3RvbWl6ZSB0aGUgVVJMIGJlaGF2aW9yIGFuZCByZXRyaWV2ZSBVUkwgY29uZmlndXJhdGlvblxuICpcbiAqIFRoaXMgQVBJIGlzIHVzZWQgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiB0aGUgVVJMLlxuICogVGhpcyBpbmNsdWRlcyBvcHRpb25hbCB0cmFpbGluZyBzbGFzaGVzIChbW3N0cmljdE1vZGVdXSksIGNhc2Ugc2Vuc2l0aXZpdHkgKFtbY2FzZUluc2Vuc2l0aXZlXV0pLFxuICogYW5kIGN1c3RvbSBwYXJhbWV0ZXIgZW5jb2RpbmcgKGN1c3RvbSBbW3R5cGVdXSkuXG4gKlxuICogSXQgYWxzbyBoYXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvY2F0aW9uICh1cmwpIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBbW3BvcnRdXSBhbmQgW1tiYXNlSHJlZl1dLlxuICogVGhpcyBpbmZvcm1hdGlvbiBjYW4gYmUgdXNlZCB0byBidWlsZCBhYnNvbHV0ZSBVUkxzLCBzdWNoIGFzXG4gKiBgaHR0cHM6Ly9leGFtcGxlLmNvbTo0NDMvYmFzZXBhdGgvc3RhdGUvc3Vic3RhdGU/cGFyYW0xPWEjaGFzaHZhbHVlYDtcbiAqXG4gKiBUaGlzIEFQSSBpcyBhIHByb3BlcnR5IG9mIFtbVXJsU2VydmljZV1dIGFzIFtbVXJsU2VydmljZS5jb25maWddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIFVybENvbmZpZyBpbXBsZW1lbnRzIERpc3Bvc2FibGUge1xuICAvKiogQGhpZGRlbiAqLyBwYXJhbVR5cGVzID0gbmV3IFBhcmFtVHlwZXMoKTtcbiAgLyoqIEBoaWRkZW4gKi8gX2lzQ2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gIC8qKiBAaGlkZGVuICovIF9pc1N0cmljdE1vZGUgPSB0cnVlO1xuICAvKiogQGhpZGRlbiAqLyBfZGVmYXVsdFNxdWFzaFBvbGljeTogYm9vbGVhbiB8IHN0cmluZyA9IGZhbHNlO1xuXG4gIC8qKiBAaGlkZGVuICovIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge31cbiAgLyoqIEBpbnRlcm5hbGFwaSAqLyBwdWJsaWMgZGlzcG9zZSA9ICgpID0+IHRoaXMucGFyYW1UeXBlcy5kaXNwb3NlKCk7XG5cbiAgLy8gRGVsZWdhdGUgdGhlc2UgY2FsbHMgdG8gdGhlIGN1cnJlbnQgTG9jYXRpb25Db25maWcgaW1wbGVtZW50YXRpb25cblxuICAvKipcbiAgICogR2V0cyB0aGUgYmFzZSBIcmVmLCBlLmcuLCBgaHR0cDovL2xvY2FsaG9zdC9hcHByb290L2BcbiAgICpcbiAgICogQHJldHVybiB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWZcbiAgICovXG4gIHB1YmxpYyBiYXNlSHJlZiA9ICgpOiBzdHJpbmcgPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25Db25maWcuYmFzZUhyZWYoKTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBoYXNoUHJlZml4XG4gICAqXG4gICAqIFRoaXMgb25seSBhcHBsaWVzIHdoZW4gbm90IHJ1bm5pbmcgaW4gW1todG1sNU1vZGVdXSAocHVzaHN0YXRlIG1vZGUpXG4gICAqXG4gICAqIElmIHRoZSBjdXJyZW50IHVybCBpcyBgaHR0cDovL2xvY2FsaG9zdC9hcHAjIS91aXJvdXRlci9wYXRoLyNhbmNob3JgLCBpdCByZXR1cm5zIGAhYCB3aGljaCBpcyB0aGUgcHJlZml4IGZvciB0aGUgXCJoYXNoYmFuZ1wiIHBvcnRpb24uXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGhhc2ggcHJlZml4XG4gICAqL1xuXG4gIHB1YmxpYyBoYXNoUHJlZml4ID0gKG5ld3ByZWZpeD86IHN0cmluZyk6IHN0cmluZyA9PiB0aGlzLnJvdXRlci5sb2NhdGlvbkNvbmZpZy5oYXNoUHJlZml4KG5ld3ByZWZpeCk7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBob3N0LCBlLmcuLCBgbG9jYWxob3N0YFxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBwcm90b2NvbFxuICAgKi9cbiAgcHVibGljIGhvc3QgPSAoKTogc3RyaW5nID0+IHRoaXMucm91dGVyLmxvY2F0aW9uQ29uZmlnLmhvc3QoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gcnVubmluZyBpbiBwdXNoc3RhdGUgbW9kZVxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgd2hlbiBydW5uaW5nIGluIGh0bWw1IG1vZGUgKHB1c2hzdGF0ZSBtb2RlKS5cbiAgICovXG4gIHB1YmxpYyBodG1sNU1vZGUgPSAoKTogYm9vbGVhbiA9PiB0aGlzLnJvdXRlci5sb2NhdGlvbkNvbmZpZy5odG1sNU1vZGUoKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgcG9ydCwgZS5nLiwgYDgwYFxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBwb3J0IG51bWJlclxuICAgKi9cbiAgcHVibGljIHBvcnQgPSAoKTogbnVtYmVyID0+IHRoaXMucm91dGVyLmxvY2F0aW9uQ29uZmlnLnBvcnQoKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgcHJvdG9jb2wsIGUuZy4sIGBodHRwYFxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBwcm90b2NvbFxuICAgKi9cbiAgcHVibGljIHByb3RvY29sID0gKCk6IHN0cmluZyA9PiB0aGlzLnJvdXRlci5sb2NhdGlvbkNvbmZpZy5wcm90b2NvbCgpO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoZXRoZXIgVVJMIG1hdGNoaW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZSAodGhlIGRlZmF1bHQgYmVoYXZpb3IpLCBvciBub3QuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy8gQWxsb3cgY2FzZSBpbnNlbnNpdGl2ZSB1cmwgbWF0Y2hlc1xuICAgKiB1cmxTZXJ2aWNlLmNvbmZpZy5jYXNlSW5zZW5zaXRpdmUodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgYGZhbHNlYCB0byBtYXRjaCBVUkwgaW4gYSBjYXNlIHNlbnNpdGl2ZSBtYW5uZXI7IG90aGVyd2lzZSBgdHJ1ZWA7XG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGNhc2VJbnNlbnNpdGl2ZVxuICAgKi9cbiAgcHVibGljIGNhc2VJbnNlbnNpdGl2ZSh2YWx1ZT86IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlID0gaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBnZW5lcmF0aW5nIG9yIG1hdGNoaW5nIFVSTHMgd2l0aCBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy8gUmVtb3ZlIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSB1cmxcbiAgICogdXJsU2VydmljZS5jb25maWcuZGVmYXVsdFNxdWFzaFBvbGljeSh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIGRlZmF1bHQgcGFyYW1ldGVyIFVSTCBzcXVhc2hpbmcgYmVoYXZpb3IuXG4gICAqICAgIC0gYG5vc3F1YXNoYDogV2hlbiBnZW5lcmF0aW5nIGFuIGhyZWYgd2l0aCBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlLCBkbyBub3Qgc3F1YXNoIHRoZSBwYXJhbWV0ZXIgdmFsdWUgZnJvbSB0aGUgVVJMXG4gICAqICAgIC0gYHNsYXNoYDogV2hlbiBnZW5lcmF0aW5nIGFuIGhyZWYgd2l0aCBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlLCBzcXVhc2ggKHJlbW92ZSkgdGhlIHBhcmFtZXRlciB2YWx1ZSwgYW5kLCBpZiB0aGVcbiAgICogICAgICBwYXJhbWV0ZXIgaXMgc3Vycm91bmRlZCBieSBzbGFzaGVzLCBzcXVhc2ggKHJlbW92ZSkgb25lIHNsYXNoIGZyb20gdGhlIFVSTFxuICAgKiAgICAtIGFueSBvdGhlciBzdHJpbmcsIGUuZy4gXCJ+XCI6IFdoZW4gZ2VuZXJhdGluZyBhbiBocmVmIHdpdGggYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSwgc3F1YXNoIChyZW1vdmUpXG4gICAqICAgICAgdGhlIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZSBVUkwgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGlzIHN0cmluZy5cbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgZGVmYXVsdFNxdWFzaFBvbGljeVxuICAgKi9cbiAgcHVibGljIGRlZmF1bHRTcXVhc2hQb2xpY3kodmFsdWU/OiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlICYmICFpc1N0cmluZyh2YWx1ZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3F1YXNoIHBvbGljeTogJHt2YWx1ZX0uIFZhbGlkIHBvbGljaWVzOiBmYWxzZSwgdHJ1ZSwgYXJiaXRyYXJ5LXN0cmluZ2ApO1xuICAgIHJldHVybiAodGhpcy5fZGVmYXVsdFNxdWFzaFBvbGljeSA9IGlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgd2hldGhlciBVUkxzIHNob3VsZCBtYXRjaCB0cmFpbGluZyBzbGFzaGVzLCBvciBub3QgKHRoZSBkZWZhdWx0IGJlaGF2aW9yKS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAvLyBBbGxvdyBvcHRpb25hbCB0cmFpbGluZyBzbGFzaGVzXG4gICAqIHVybFNlcnZpY2UuY29uZmlnLnN0cmljdE1vZGUoZmFsc2UpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIGBmYWxzZWAgdG8gbWF0Y2ggdHJhaWxpbmcgc2xhc2hlcyBpbiBVUkxzLCBvdGhlcndpc2UgYHRydWVgLlxuICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBzdHJpY3RNb2RlXG4gICAqL1xuICBwdWJsaWMgc3RyaWN0TW9kZSh2YWx1ZT86IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuX2lzU3RyaWN0TW9kZSA9IGlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2lzU3RyaWN0TW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgY3VzdG9tIFtbUGFyYW1UeXBlXV0gb2JqZWN0XG4gICAqXG4gICAqIEEgY3VzdG9tIHBhcmFtZXRlciB0eXBlIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIFVSTHMgd2l0aCB0eXBlZCBwYXJhbWV0ZXJzIG9yIGN1c3RvbSBlbmNvZGluZy9kZWNvZGluZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOiBSZWdpc3RlciBjdXN0b20gdHlwZXMgKmJlZm9yZSB1c2luZyB0aGVtKiBpbiBhIHN0YXRlIGRlZmluaXRpb24uXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy8gRW5jb2RlIG9iamVjdCBwYXJhbWV0ZXIgYXMgSlNPTiBzdHJpbmdcbiAgICogdXJsU2VydmljZS5jb25maWcudHlwZSgnbXlqc29uJywge1xuICAgKiAgIGVuY29kZTogKG9iaikgPT4gSlNPTi5zdHJpbmdpZnkob2JqKSxcbiAgICogICBkZWNvZGU6IChzdHIpID0+IEpTT04ucGFyc2Uoc3RyKSxcbiAgICogICBpczogKHZhbCkgPT4gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnLFxuICAgKiAgIHBhdHRlcm46IC9bXi9dKy8sXG4gICAqICAgZXF1YWxzOiAoYSwgYikgPT4gXy5pc0VxdWFsKGEsIGIpLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBmb3IgbW9yZSBleGFtcGxlc1xuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgdHlwZSBuYW1lLlxuICAgKiBAcGFyYW0gZGVmaW5pdGlvbiBUaGUgdHlwZSBkZWZpbml0aW9uLiBTZWUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAqIEBwYXJhbSBkZWZpbml0aW9uRm4gQSBmdW5jdGlvbiB0aGF0IGlzIGluamVjdGVkIGJlZm9yZSB0aGUgYXBwIHJ1bnRpbWUgc3RhcnRzLlxuICAgKiAgICAgICAgVGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBhIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxuICAgKiAgICAgICAgVGhlIHJlc3VsdCBpcyBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgYGRlZmluaXRpb25gLlxuICAgKiAgICAgICAgU2VlIFtbUGFyYW1UeXBlXV0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGlmIG9ubHkgdGhlIGBuYW1lYCBwYXJhbWV0ZXIgd2FzIHNwZWNpZmllZDogdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIFtbUGFyYW1UeXBlXV0gb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICovXG4gIHR5cGUobmFtZTogc3RyaW5nLCBkZWZpbml0aW9uPzogUGFyYW1UeXBlRGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuPzogKCkgPT4gUGFyYW1UeXBlRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnBhcmFtVHlwZXMudHlwZShuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pO1xuICAgIHJldHVybiAhaXNEZWZpbmVkKGRlZmluaXRpb24pID8gdHlwZSA6IHRoaXM7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdXJsICovIC8qKiAqL1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgZXh0ZW5kLCBpcywgaXNTdHJpbmcsIExvY2F0aW9uU2VydmljZXMsIHBhdHRlcm4gfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgTWF0Y2hSZXN1bHQsIFVybFBhcnRzLCBVcmxSdWxlLCBVcmxTeW5jQXBpIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVXJsUnVsZXMgfSBmcm9tICcuL3VybFJ1bGVzJztcbmltcG9ydCB7IFVybENvbmZpZyB9IGZyb20gJy4vdXJsQ29uZmlnJztcbmltcG9ydCB7IFRhcmdldFN0YXRlLCBUYXJnZXRTdGF0ZURlZiB9IGZyb20gJy4uL3N0YXRlJztcblxuLyoqIEFQSSBmb3IgVVJMIG1hbmFnZW1lbnQgKi9cbmV4cG9ydCBjbGFzcyBVcmxTZXJ2aWNlIGltcGxlbWVudHMgTG9jYXRpb25TZXJ2aWNlcywgVXJsU3luY0FwaSB7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3N0b3BMaXN0ZW5pbmdGbjogRnVuY3Rpb247XG4gIC8qKiBAaGlkZGVuICovIGludGVyY2VwdERlZmVycmVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBuZXN0ZWQgW1tVcmxSdWxlc11dIEFQSSBmb3IgbWFuYWdpbmcgVVJMIHJ1bGVzIGFuZCByZXdyaXRlc1xuICAgKlxuICAgKiBTZWU6IFtbVXJsUnVsZXNdXSBmb3IgZGV0YWlsc1xuICAgKi9cbiAgcHVibGljIHJ1bGVzID0gbmV3IFVybFJ1bGVzKHRoaXMucm91dGVyKTtcblxuICAvKipcbiAgICogVGhlIG5lc3RlZCBbW1VybENvbmZpZ11dIEFQSSB0byBjb25maWd1cmUgdGhlIFVSTCBhbmQgcmV0cmlldmUgVVJMIGluZm9ybWF0aW9uXG4gICAqXG4gICAqIFNlZTogW1tVcmxDb25maWddXSBmb3IgZGV0YWlsc1xuICAgKi9cbiAgcHVibGljIGNvbmZpZyA9IG5ldyBVcmxDb25maWcodGhpcy5yb3V0ZXIpO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge31cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHVibGljIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5saXN0ZW4oZmFsc2UpO1xuICAgICh0aGlzLnJ1bGVzIGFzIFVybFJ1bGVzKS5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBVUkwgcGFydHNcbiAgICpcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZGlmZmVyZW50IHBhcnRzIG9mIHRoZSBjdXJyZW50IFVSTCAodGhlIFtbcGF0aF1dLCBbW3NlYXJjaF1dLCBhbmQgW1toYXNoXV0pIGFzIGEgW1tVcmxQYXJ0c11dIG9iamVjdC5cbiAgICovXG4gIHB1YmxpYyBwYXJ0cygpOiBVcmxQYXJ0cyB7XG4gICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoKCksIHNlYXJjaDogdGhpcy5zZWFyY2goKSwgaGFzaDogdGhpcy5oYXNoKCkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGJlc3QgcnVsZSBmb3IgdGhlIGN1cnJlbnQgVVJMXG4gICAqXG4gICAqIENoZWNrcyB0aGUgY3VycmVudCBVUkwgZm9yIGEgbWF0Y2hpbmcgW1tVcmxSdWxlXV0sIHRoZW4gaW52b2tlcyB0aGF0IHJ1bGUncyBoYW5kbGVyLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW50ZXJuYWxseSBhbnkgdGltZSB0aGUgVVJMIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBUaGlzIGVmZmVjdGl2ZWx5IGFjdGl2YXRlcyB0aGUgc3RhdGUgKG9yIHJlZGlyZWN0LCBldGMpIHdoaWNoIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHVybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHQoKTtcbiAgICpcbiAgICogZmV0Y2goJy9zdGF0ZXMuanNvbicpLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSkudGhlbihkYXRhID0+IHtcbiAgICogICBkYXRhLmZvckVhY2goc3RhdGUgPT4gJHN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoc3RhdGUpKTtcbiAgICogICB1cmxTZXJ2aWNlLmxpc3RlbigpO1xuICAgKiAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIFVSTCBhbmQgaW52b2tlIHRoZSBoYW5kbGVyLlxuICAgKiAgIHVybFNlcnZpY2Uuc3luYygpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgc3luYyhldnQ/KSB7XG4gICAgaWYgKGV2dCAmJiBldnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgdXJsU2VydmljZSwgc3RhdGVTZXJ2aWNlIH0gPSB0aGlzLnJvdXRlcjtcblxuICAgIGNvbnN0IHVybDogVXJsUGFydHMgPSB7IHBhdGg6IHVybFNlcnZpY2UucGF0aCgpLCBzZWFyY2g6IHVybFNlcnZpY2Uuc2VhcmNoKCksIGhhc2g6IHVybFNlcnZpY2UuaGFzaCgpIH07XG4gICAgY29uc3QgYmVzdCA9IHRoaXMubWF0Y2godXJsKTtcblxuICAgIGNvbnN0IGFwcGx5UmVzdWx0ID0gcGF0dGVybihbXG4gICAgICBbaXNTdHJpbmcsIChuZXd1cmw6IHN0cmluZykgPT4gdXJsU2VydmljZS51cmwobmV3dXJsLCB0cnVlKV0sXG4gICAgICBbVGFyZ2V0U3RhdGUuaXNEZWYsIChkZWY6IFRhcmdldFN0YXRlRGVmKSA9PiBzdGF0ZVNlcnZpY2UuZ28oZGVmLnN0YXRlLCBkZWYucGFyYW1zLCBkZWYub3B0aW9ucyldLFxuICAgICAgW2lzKFRhcmdldFN0YXRlKSwgKHRhcmdldDogVGFyZ2V0U3RhdGUpID0+IHN0YXRlU2VydmljZS5nbyh0YXJnZXQuc3RhdGUoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKV0sXG4gICAgXSk7XG5cbiAgICBhcHBseVJlc3VsdChiZXN0ICYmIGJlc3QucnVsZS5oYW5kbGVyKGJlc3QubWF0Y2gsIHVybCwgdGhpcy5yb3V0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgb3Igc3RvcHMgbGlzdGVuaW5nIGZvciBVUkwgY2hhbmdlc1xuICAgKlxuICAgKiBDYWxsIHRoaXMgc29tZXRpbWUgYWZ0ZXIgY2FsbGluZyBbW2RlZmVySW50ZXJjZXB0XV0gdG8gc3RhcnQgbW9uaXRvcmluZyB0aGUgdXJsLlxuICAgKiBUaGlzIGNhdXNlcyBVSS1Sb3V0ZXIgdG8gc3RhcnQgbGlzdGVuaW5nIGZvciBjaGFuZ2VzIHRvIHRoZSBVUkwsIGlmIGl0IHdhc24ndCBhbHJlYWR5IGxpc3RlbmluZy5cbiAgICpcbiAgICogSWYgY2FsbGVkIHdpdGggYGZhbHNlYCwgVUktUm91dGVyIHdpbGwgc3RvcCBsaXN0ZW5pbmcgKGNhbGwgbGlzdGVuKHRydWUpIHRvIHN0YXJ0IGxpc3RlbmluZyBhZ2FpbikuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdXJsU2VydmljZS5kZWZlckludGVyY2VwdCgpO1xuICAgKlxuICAgKiBmZXRjaCgnL3N0YXRlcy5qc29uJykudGhlbihyZXNwID0+IHJlc3AuanNvbigpKS50aGVuKGRhdGEgPT4ge1xuICAgKiAgIGRhdGEuZm9yRWFjaChzdGF0ZSA9PiAkc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihzdGF0ZSkpO1xuICAgKiAgIC8vIFN0YXJ0IHJlc3BvbmRpbmcgdG8gVVJMIGNoYW5nZXNcbiAgICogICB1cmxTZXJ2aWNlLmxpc3RlbigpO1xuICAgKiAgIHVybFNlcnZpY2Uuc3luYygpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBlbmFibGVkIGB0cnVlYCBvciBgZmFsc2VgIHRvIHN0YXJ0IG9yIHN0b3AgbGlzdGVuaW5nIHRvIFVSTCBjaGFuZ2VzXG4gICAqL1xuICBwdWJsaWMgbGlzdGVuKGVuYWJsZWQ/OiBib29sZWFuKTogRnVuY3Rpb24ge1xuICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fc3RvcExpc3RlbmluZ0ZuICYmIHRoaXMuX3N0b3BMaXN0ZW5pbmdGbigpO1xuICAgICAgZGVsZXRlIHRoaXMuX3N0b3BMaXN0ZW5pbmdGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh0aGlzLl9zdG9wTGlzdGVuaW5nRm4gPSB0aGlzLl9zdG9wTGlzdGVuaW5nRm4gfHwgdGhpcy5yb3V0ZXIudXJsU2VydmljZS5vbkNoYW5nZShldnQgPT4gdGhpcy5zeW5jKGV2dCkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgbW9uaXRvcmluZyBvZiB0aGUgVVJMLlxuICAgKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSBVSS1Sb3V0ZXIgaGFzIGJvb3RzdHJhcHBlZC5cbiAgICogSXQgd2lsbCBzdG9wIFVJLVJvdXRlciBmcm9tIHBlcmZvcm1pbmcgdGhlIGluaXRpYWwgdXJsIHN5bmMuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBwZXJmb3JtIHNvbWUgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGJlZm9yZSB0aGUgcm91dGVyIHN0YXJ0cy5cbiAgICogT25jZSB0aGUgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUsIGNhbGwgW1tsaXN0ZW5dXSB0byB0ZWxsIFVJLVJvdXRlciB0byBzdGFydCB3YXRjaGluZyBhbmQgc3luY2hyb25pemluZyB0aGUgVVJMLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vIFByZXZlbnQgVUktUm91dGVyIGZyb20gYXV0b21hdGljYWxseSBpbnRlcmNlcHRpbmcgVVJMIGNoYW5nZXMgd2hlbiBpdCBzdGFydHM7XG4gICAqIHVybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHQoKTtcbiAgICpcbiAgICogZmV0Y2goJy9zdGF0ZXMuanNvbicpLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSkudGhlbihkYXRhID0+IHtcbiAgICogICBkYXRhLmZvckVhY2goc3RhdGUgPT4gJHN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoc3RhdGUpKTtcbiAgICogICB1cmxTZXJ2aWNlLmxpc3RlbigpO1xuICAgKiAgIHVybFNlcnZpY2Uuc3luYygpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkZWZlciBJbmRpY2F0ZXMgd2hldGhlciB0byBkZWZlciBsb2NhdGlvbiBjaGFuZ2UgaW50ZXJjZXB0aW9uLlxuICAgKiAgICAgICAgUGFzc2luZyBubyBwYXJhbWV0ZXIgaXMgZXF1aXZhbGVudCB0byBgdHJ1ZWAuXG4gICAqL1xuICBwdWJsaWMgZGVmZXJJbnRlcmNlcHQoZGVmZXI/OiBib29sZWFuKSB7XG4gICAgaWYgKGRlZmVyID09PSB1bmRlZmluZWQpIGRlZmVyID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdERlZmVycmVkID0gZGVmZXI7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBhIFVSTFxuICAgKlxuICAgKiBHaXZlbiBhIFVSTCAoYXMgYSBbW1VybFBhcnRzXV0gb2JqZWN0KSwgY2hlY2sgYWxsIHJ1bGVzIGFuZCBkZXRlcm1pbmUgdGhlIGJlc3QgbWF0Y2hpbmcgcnVsZS5cbiAgICogUmV0dXJuIHRoZSByZXN1bHQgYXMgYSBbW01hdGNoUmVzdWx0XV0uXG4gICAqL1xuICBwdWJsaWMgbWF0Y2godXJsOiBVcmxQYXJ0cyk6IE1hdGNoUmVzdWx0IHtcbiAgICB1cmwgPSBleHRlbmQoeyBwYXRoOiAnJywgc2VhcmNoOiB7fSwgaGFzaDogJycgfSwgdXJsKTtcbiAgICBjb25zdCBydWxlcyA9IHRoaXMucnVsZXMucnVsZXMoKTtcblxuICAgIC8vIENoZWNrcyBhIHNpbmdsZSBydWxlLiBSZXR1cm5zIHsgcnVsZTogcnVsZSwgbWF0Y2g6IG1hdGNoLCB3ZWlnaHQ6IHdlaWdodCB9IGlmIGl0IG1hdGNoZWQsIG9yIHVuZGVmaW5lZFxuICAgIGNvbnN0IGNoZWNrUnVsZSA9IChydWxlOiBVcmxSdWxlKTogTWF0Y2hSZXN1bHQgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBydWxlLm1hdGNoKHVybCwgdGhpcy5yb3V0ZXIpO1xuICAgICAgcmV0dXJuIG1hdGNoICYmIHsgbWF0Y2gsIHJ1bGUsIHdlaWdodDogcnVsZS5tYXRjaFByaW9yaXR5KG1hdGNoKSB9O1xuICAgIH07XG5cbiAgICAvLyBUaGUgcnVsZXMgYXJlIHByZS1zb3J0ZWQuXG4gICAgLy8gLSBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyBydWxlLlxuICAgIC8vIC0gRmluZCBhbnkgb3RoZXIgbWF0Y2hpbmcgcnVsZSB0aGF0IHNvcnRlZCAqZXhhY3RseSB0aGUgc2FtZSosIGFjY29yZGluZyB0byBgLnNvcnQoKWAuXG4gICAgLy8gLSBDaG9vc2UgdGhlIHJ1bGUgd2l0aCB0aGUgaGlnaGVzdCBtYXRjaCB3ZWlnaHQuXG4gICAgbGV0IGJlc3Q6IE1hdGNoUmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFN0b3Agd2hlbiB0aGVyZSBpcyBhICdiZXN0JyBydWxlIGFuZCB0aGUgbmV4dCBydWxlIHNvcnRzIGRpZmZlcmVudGx5IHRoYW4gaXQuXG4gICAgICBpZiAoYmVzdCAmJiBiZXN0LnJ1bGUuX2dyb3VwICE9PSBydWxlc1tpXS5fZ3JvdXApIGJyZWFrO1xuXG4gICAgICBjb25zdCBjdXJyZW50ID0gY2hlY2tSdWxlKHJ1bGVzW2ldKTtcbiAgICAgIC8vIFBpY2sgdGhlIGJlc3QgTWF0Y2hSZXN1bHRcbiAgICAgIGJlc3QgPSAhYmVzdCB8fCAoY3VycmVudCAmJiBjdXJyZW50LndlaWdodCA+IGJlc3Qud2VpZ2h0KSA/IGN1cnJlbnQgOiBiZXN0O1xuICAgIH1cblxuICAgIHJldHVybiBiZXN0O1xuICB9XG5cbiAgLy8gRGVsZWdhdGUgdGhlc2UgY2FsbHMgdG8gdGhlIGN1cnJlbnQgTG9jYXRpb25TZXJ2aWNlcyBpbXBsZW1lbnRhdGlvblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB1cmwsIG9yIHVwZGF0ZXMgdGhlIHVybFxuICAgKlxuICAgKiAjIyMgR2V0dGluZyB0aGUgY3VycmVudCBVUkxcbiAgICpcbiAgICogV2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCwgcmV0dXJucyB0aGUgY3VycmVudCBVUkwuXG4gICAqIFRoZSBVUkwgaXMgbm9ybWFsaXplZCB1c2luZyB0aGUgaW50ZXJuYWwgW1twYXRoXV0vW1tzZWFyY2hdXS9bW2hhc2hdXSB2YWx1ZXMuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCB0aGUgVVJMIG1heSBiZSBzdG9yZWQgaW4gdGhlIGhhc2ggKFtbSGFzaExvY2F0aW9uU2VydmljZXNdXSkgb3JcbiAgICogaGF2ZSBhIGJhc2UgSFJFRiBwcmVwZW5kZWQgKFtbUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlc11dKS5cbiAgICpcbiAgICogVGhlIHJhdyBVUkwgaW4gdGhlIGJyb3dzZXIgbWlnaHQgYmU6XG4gICAqXG4gICAqIGBgYFxuICAgKiBodHRwOi8vbXlzaXRlLmNvbS9zb21lcGF0aC9pbmRleC5odG1sIy9pbnRlcm5hbC9wYXRoLzEyMz9wYXJhbTE9Zm9vI2FuY2hvclxuICAgKiBgYGBcbiAgICpcbiAgICogb3JcbiAgICpcbiAgICogYGBgXG4gICAqIGh0dHA6Ly9teXNpdGUuY29tL2Jhc2VwYXRoL2ludGVybmFsL3BhdGgvMTIzP3BhcmFtMT1mb28jYW5jaG9yXG4gICAqIGBgYFxuICAgKlxuICAgKiB0aGVuIHRoaXMgbWV0aG9kIHJldHVybnM6XG4gICAqXG4gICAqIGBgYFxuICAgKiAvaW50ZXJuYWwvcGF0aC8xMjM/cGFyYW0xPWZvbyNhbmNob3JcbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbG9jYXRpb25TZXJ2aWNlcy51cmwoKTsgLy8gXCIvc29tZS9wYXRoP3F1ZXJ5PXZhbHVlI2FuY2hvclwiXG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgVXBkYXRpbmcgdGhlIFVSTFxuICAgKlxuICAgKiBXaGVuIGBuZXd1cmxgIGFyZ3VtZW50cyBpcyBwcm92aWRlZCwgY2hhbmdlcyB0aGUgVVJMIHRvIHJlZmxlY3QgYG5ld3VybGBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBsb2NhdGlvblNlcnZpY2VzLnVybChcIi9zb21lL3BhdGg/cXVlcnk9dmFsdWUjYW5jaG9yXCIsIHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG5ld3VybCBUaGUgbmV3IHZhbHVlIGZvciB0aGUgVVJMLlxuICAgKiAgICAgICAgICAgICAgIFRoaXMgdXJsIHNob3VsZCByZWZsZWN0IG9ubHkgdGhlIG5ldyBpbnRlcm5hbCBbW3BhdGhdXSwgW1tzZWFyY2hdXSwgYW5kIFtbaGFzaF1dIHZhbHVlcy5cbiAgICogICAgICAgICAgICAgICBJdCBzaG91bGQgbm90IGluY2x1ZGUgdGhlIHByb3RvY29sLCBzaXRlLCBwb3J0LCBvciBiYXNlIHBhdGggb2YgYW4gYWJzb2x1dGUgSFJFRi5cbiAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiB0cnVlLCByZXBsYWNlcyB0aGUgY3VycmVudCBoaXN0b3J5IGVudHJ5IChpbnN0ZWFkIG9mIGFwcGVuZGluZyBpdCkgd2l0aCB0aGlzIG5ldyB1cmxcbiAgICogQHBhcmFtIHN0YXRlIFRoZSBoaXN0b3J5J3Mgc3RhdGUgb2JqZWN0LCBpLmUuLCBwdXNoU3RhdGUgKGlmIHRoZSBMb2NhdGlvblNlcnZpY2VzIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIGl0KVxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSB1cmwgKGFmdGVyIHBvdGVudGlhbGx5IGJlaW5nIHByb2Nlc3NlZClcbiAgICovXG4gIHB1YmxpYyB1cmwgPSAobmV3dXJsPzogc3RyaW5nLCByZXBsYWNlPzogYm9vbGVhbiwgc3RhdGU/OiBhbnkpOiBzdHJpbmcgPT5cbiAgICB0aGlzLnJvdXRlci5sb2NhdGlvblNlcnZpY2UudXJsKG5ld3VybCwgcmVwbGFjZSwgc3RhdGUpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXRoIHBhcnQgb2YgdGhlIGN1cnJlbnQgdXJsXG4gICAqXG4gICAqIElmIHRoZSBjdXJyZW50IFVSTCBpcyBgL3NvbWUvcGF0aD9xdWVyeT12YWx1ZSNhbmNob3JgLCB0aGlzIHJldHVybnMgYC9zb21lL3BhdGhgXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgdXJsXG4gICAqL1xuICBwdWJsaWMgcGF0aCA9ICgpOiBzdHJpbmcgPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25TZXJ2aWNlLnBhdGgoKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2VhcmNoIHBhcnQgb2YgdGhlIGN1cnJlbnQgdXJsIGFzIGFuIG9iamVjdFxuICAgKlxuICAgKiBJZiB0aGUgY3VycmVudCBVUkwgaXMgYC9zb21lL3BhdGg/cXVlcnk9dmFsdWUjYW5jaG9yYCwgdGhpcyByZXR1cm5zIGB7IHF1ZXJ5OiAndmFsdWUnIH1gXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHNlYXJjaCAocXVlcnkpIHBvcnRpb24gb2YgdGhlIHVybCwgYXMgYW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc2VhcmNoID0gKCk6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25TZXJ2aWNlLnNlYXJjaCgpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoYXNoIHBhcnQgb2YgdGhlIGN1cnJlbnQgdXJsXG4gICAqXG4gICAqIElmIHRoZSBjdXJyZW50IFVSTCBpcyBgL3NvbWUvcGF0aD9xdWVyeT12YWx1ZSNhbmNob3JgLCB0aGlzIHJldHVybnMgYGFuY2hvcmBcbiAgICpcbiAgICogQHJldHVybiB0aGUgaGFzaCAoYW5jaG9yKSBwb3J0aW9uIG9mIHRoZSB1cmxcbiAgICovXG4gIHB1YmxpYyBoYXNoID0gKCk6IHN0cmluZyA9PiB0aGlzLnJvdXRlci5sb2NhdGlvblNlcnZpY2UuaGFzaCgpO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgbG93IGxldmVsIHVybCBjaGFuZ2UgaGFuZGxlclxuICAgKlxuICAgKiBOb3RlOiBCZWNhdXNlIHRoaXMgaXMgYSBsb3cgbGV2ZWwgaGFuZGxlciwgaXQncyBub3QgcmVjb21tZW5kZWQgZm9yIGdlbmVyYWwgdXNlLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGxldCBkZXJlZ2lzdGVyRm4gPSBsb2NhdGlvblNlcnZpY2VzLm9uQ2hhbmdlKChldnQpID0+IGNvbnNvbGUubG9nKFwidXJsIGNoYW5nZVwiLCBldnQpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdXJsIGlzIGNoYW5naW5nXG4gICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlLXJlZ2lzdGVycyB0aGUgY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBvbkNoYW5nZSA9IChjYWxsYmFjazogRXZlbnRMaXN0ZW5lcik6IEZ1bmN0aW9uID0+IHRoaXMucm91dGVyLmxvY2F0aW9uU2VydmljZS5vbkNoYW5nZShjYWxsYmFjayk7XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIGNvcmUgKi8gLyoqICovXG5pbXBvcnQgeyBVcmxNYXRjaGVyRmFjdG9yeSB9IGZyb20gJy4vdXJsL3VybE1hdGNoZXJGYWN0b3J5JztcbmltcG9ydCB7IFVybFJvdXRlciB9IGZyb20gJy4vdXJsL3VybFJvdXRlcic7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU2VydmljZSB9IGZyb20gJy4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBWaWV3U2VydmljZSB9IGZyb20gJy4vdmlldy92aWV3JztcbmltcG9ydCB7IFN0YXRlUmVnaXN0cnkgfSBmcm9tICcuL3N0YXRlL3N0YXRlUmVnaXN0cnknO1xuaW1wb3J0IHsgU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi9zdGF0ZS9zdGF0ZVNlcnZpY2UnO1xuaW1wb3J0IHsgVUlSb3V0ZXJHbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzJztcbmltcG9ydCB7IFVJUm91dGVyUGx1Z2luLCBEaXNwb3NhYmxlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgdmFsdWVzLCByZW1vdmVGcm9tIH0gZnJvbSAnLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFVybFNlcnZpY2UgfSBmcm9tICcuL3VybC91cmxTZXJ2aWNlJztcbmltcG9ydCB7IExvY2F0aW9uU2VydmljZXMsIExvY2F0aW9uQ29uZmlnIH0gZnJvbSAnLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFRyYWNlLCB0cmFjZSB9IGZyb20gJy4vY29tbW9uL3RyYWNlJztcbmltcG9ydCB7IG1ha2VTdHViIH0gZnJvbSAnLi9jb21tb24nO1xuXG4vKiogQGhpZGRlbiAqL1xubGV0IF9yb3V0ZXJJbnN0YW5jZSA9IDA7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBsb2NTdmNGbnM6IChrZXlvZiBMb2NhdGlvblNlcnZpY2VzKVtdID0gWyd1cmwnLCAncGF0aCcsICdzZWFyY2gnLCAnaGFzaCcsICdvbkNoYW5nZSddO1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGxvY0NmZ0ZuczogKGtleW9mIExvY2F0aW9uQ29uZmlnKVtdID0gWydwb3J0JywgJ3Byb3RvY29sJywgJ2hvc3QnLCAnYmFzZUhyZWYnLCAnaHRtbDVNb2RlJywgJ2hhc2hQcmVmaXgnXTtcbi8qKiBAaGlkZGVuICovXG5jb25zdCBsb2NhdGlvblNlcnZpY2VTdHViID0gbWFrZVN0dWI8TG9jYXRpb25TZXJ2aWNlcz4oJ0xvY2F0aW9uU2VydmljZXMnLCBsb2NTdmNGbnMpO1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGxvY2F0aW9uQ29uZmlnU3R1YiA9IG1ha2VTdHViPExvY2F0aW9uQ29uZmlnPignTG9jYXRpb25Db25maWcnLCBsb2NDZmdGbnMpO1xuXG4vKipcbiAqIFRoZSBtYXN0ZXIgY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiBVSS1Sb3V0ZXIuXG4gKlxuICogVUktUm91dGVyIChmb3IgZWFjaCBzcGVjaWZpYyBmcmFtZXdvcmspIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZHVyaW5nIGJvb3RzdHJhcC5cbiAqIFRoaXMgY2xhc3MgaW5zdGFudGlhdGVzIGFuZCB3aXJlcyB0aGUgVUktUm91dGVyIHNlcnZpY2VzIHRvZ2V0aGVyLlxuICpcbiAqIEFmdGVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBVSVJvdXRlciBjbGFzcyBpcyBjcmVhdGVkLCBpdCBzaG91bGQgYmUgY29uZmlndXJlZCBmb3IgeW91ciBhcHAuXG4gKiBGb3IgaW5zdGFuY2UsIGFwcCBzdGF0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tVSVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogLS0tXG4gKlxuICogTm9ybWFsbHkgdGhlIGZyYW1ld29yayBjb2RlIHdpbGwgYm9vdHN0cmFwIFVJLVJvdXRlci5cbiAqIElmIHlvdSBhcmUgYm9vdHN0cmFwcGluZyBVSVJvdXRlciBtYW51YWxseSwgdGVsbCBpdCB0byBtb25pdG9yIHRoZSBVUkwgYnkgY2FsbGluZ1xuICogW1tVcmxTZXJ2aWNlLmxpc3Rlbl1dIHRoZW4gW1tVcmxTZXJ2aWNlLnN5bmNdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIFVJUm91dGVyIHtcbiAgLyoqIEBoaWRkZW4gKi8gJGlkID0gX3JvdXRlckluc3RhbmNlKys7XG4gIC8qKiBAaGlkZGVuICovIF9kaXNwb3NlZCA9IGZhbHNlO1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9kaXNwb3NhYmxlczogRGlzcG9zYWJsZVtdID0gW107XG5cbiAgLyoqIFByb3ZpZGVzIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlICovXG4gIHRyYWNlOiBUcmFjZSA9IHRyYWNlO1xuXG4gIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHVpLXZpZXcgc3luY2hyb25pemF0aW9uICovXG4gIHZpZXdTZXJ2aWNlID0gbmV3IFZpZXdTZXJ2aWNlKHRoaXMpO1xuXG4gIC8qKiBHbG9iYWwgcm91dGVyIHN0YXRlICovXG4gIGdsb2JhbHM6IFVJUm91dGVyR2xvYmFscyA9IG5ldyBVSVJvdXRlckdsb2JhbHMoKTtcblxuICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucyAqL1xuICB0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UgPSBuZXcgVHJhbnNpdGlvblNlcnZpY2UodGhpcyk7XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgZm9yIHB1YmxpYyB1c2UuIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZFxuICAgKi9cbiAgdXJsTWF0Y2hlckZhY3Rvcnk6IFVybE1hdGNoZXJGYWN0b3J5ID0gbmV3IFVybE1hdGNoZXJGYWN0b3J5KHRoaXMpO1xuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICovXG4gIHVybFJvdXRlcjogVXJsUm91dGVyID0gbmV3IFVybFJvdXRlcih0aGlzKTtcblxuICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB0aGUgVVJMICovXG4gIHVybFNlcnZpY2U6IFVybFNlcnZpY2UgPSBuZXcgVXJsU2VydmljZSh0aGlzKTtcblxuICAvKiogUHJvdmlkZXMgYSByZWdpc3RyeSBmb3Igc3RhdGVzLCBhbmQgcmVsYXRlZCByZWdpc3RyYXRpb24gc2VydmljZXMgKi9cbiAgc3RhdGVSZWdpc3RyeTogU3RhdGVSZWdpc3RyeSA9IG5ldyBTdGF0ZVJlZ2lzdHJ5KHRoaXMpO1xuXG4gIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHN0YXRlcyAqL1xuICBzdGF0ZVNlcnZpY2UgPSBuZXcgU3RhdGVTZXJ2aWNlKHRoaXMpO1xuXG4gIC8qKiBAaGlkZGVuIHBsdWdpbiBpbnN0YW5jZXMgYXJlIHJlZ2lzdGVyZWQgaGVyZSAqL1xuICBwcml2YXRlIF9wbHVnaW5zOiB7IFtrZXk6IHN0cmluZ106IFVJUm91dGVyUGx1Z2luIH0gPSB7fTtcblxuICAvKiogUmVnaXN0ZXJzIGFuIG9iamVjdCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSByb3V0ZXIgaXMgZGlzcG9zZWQgKi9cbiAgZGlzcG9zYWJsZShkaXNwb3NhYmxlOiBEaXNwb3NhYmxlKSB7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIHJvdXRlciBpbnN0YW5jZVxuICAgKlxuICAgKiBXaGVuIGNhbGxlZCwgY2xlYXJzIHJlc291cmNlcyByZXRhaW5lZCBieSB0aGUgcm91dGVyIGJ5IGNhbGxpbmcgYGRpc3Bvc2UodGhpcylgIG9uIGFsbFxuICAgKiByZWdpc3RlcmVkIFtbZGlzcG9zYWJsZV1dIG9iamVjdHMuXG4gICAqXG4gICAqIE9yLCBpZiBhIGBkaXNwb3NhYmxlYCBvYmplY3QgaXMgcHJvdmlkZWQsIGNhbGxzIGBkaXNwb3NlKHRoaXMpYCBvbiB0aGF0IG9iamVjdCBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0gZGlzcG9zYWJsZSAob3B0aW9uYWwpIHRoZSBkaXNwb3NhYmxlIHRvIGRpc3Bvc2VcbiAgICovXG4gIGRpc3Bvc2UoZGlzcG9zYWJsZT86IGFueSk6IHZvaWQge1xuICAgIGlmIChkaXNwb3NhYmxlICYmIGlzRnVuY3Rpb24oZGlzcG9zYWJsZS5kaXNwb3NlKSkge1xuICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKHRoaXMpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuc2xpY2UoKS5mb3JFYWNoKGQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHlwZW9mIGQuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkLmRpc3Bvc2UodGhpcyk7XG4gICAgICAgIHJlbW92ZUZyb20odGhpcy5fZGlzcG9zYWJsZXMsIGQpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge31cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBVSVJvdXRlcmAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBsb2NhdGlvblNlcnZpY2UgYSBbW0xvY2F0aW9uU2VydmljZXNdXSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gbG9jYXRpb25Db25maWcgYSBbW0xvY2F0aW9uQ29uZmlnXV0gaW1wbGVtZW50YXRpb25cbiAgICogQGludGVybmFsYXBpXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbG9jYXRpb25TZXJ2aWNlOiBMb2NhdGlvblNlcnZpY2VzID0gbG9jYXRpb25TZXJ2aWNlU3R1YixcbiAgICBwdWJsaWMgbG9jYXRpb25Db25maWc6IExvY2F0aW9uQ29uZmlnID0gbG9jYXRpb25Db25maWdTdHViXG4gICkge1xuICAgIHRoaXMudmlld1NlcnZpY2UuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCkpO1xuICAgIHRoaXMuZ2xvYmFscy4kY3VycmVudCA9IHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCk7XG4gICAgdGhpcy5nbG9iYWxzLmN1cnJlbnQgPSB0aGlzLmdsb2JhbHMuJGN1cnJlbnQuc2VsZjtcblxuICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLmdsb2JhbHMpO1xuICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnN0YXRlU2VydmljZSk7XG4gICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVSZWdpc3RyeSk7XG4gICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMudHJhbnNpdGlvblNlcnZpY2UpO1xuICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnVybFNlcnZpY2UpO1xuICAgIHRoaXMuZGlzcG9zYWJsZShsb2NhdGlvblNlcnZpY2UpO1xuICAgIHRoaXMuZGlzcG9zYWJsZShsb2NhdGlvbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQWRkIHBsdWdpbiAoYXMgRVM2IGNsYXNzKSAqL1xuICBwbHVnaW48VCBleHRlbmRzIFVJUm91dGVyUGx1Z2luPihwbHVnaW46IHsgbmV3IChyb3V0ZXI6IFVJUm91dGVyLCBvcHRpb25zPzogYW55KTogVCB9LCBvcHRpb25zPzogYW55KTogVDtcbiAgLyoqIEFkZCBwbHVnaW4gKGFzIGphdmFzY3JpcHQgY29uc3RydWN0b3IgZnVuY3Rpb24pICovXG4gIHBsdWdpbjxUIGV4dGVuZHMgVUlSb3V0ZXJQbHVnaW4+KHBsdWdpbjogeyAocm91dGVyOiBVSVJvdXRlciwgb3B0aW9ucz86IGFueSk6IHZvaWQgfSwgb3B0aW9ucz86IGFueSk6IFQ7XG4gIC8qKiBBZGQgcGx1Z2luIChhcyBqYXZhc2NyaXB0IGZhY3RvcnkgZnVuY3Rpb24pICovXG4gIHBsdWdpbjxUIGV4dGVuZHMgVUlSb3V0ZXJQbHVnaW4+KHBsdWdpbjogUGx1Z2luRmFjdG9yeTxUPiwgb3B0aW9ucz86IGFueSk6IFQ7XG4gIC8qKlxuICAgKiBBZGRzIGEgcGx1Z2luIHRvIFVJLVJvdXRlclxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGEgVUktUm91dGVyIFBsdWdpbi5cbiAgICogQSBwbHVnaW4gY2FuIGVuaGFuY2Ugb3IgY2hhbmdlIFVJLVJvdXRlciBiZWhhdmlvciB1c2luZyBhbnkgcHVibGljIEFQSS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBNeUNvb2xQbHVnaW4gfSBmcm9tIFwidWktcm91dGVyLWNvb2wtcGx1Z2luXCI7XG4gICAqXG4gICAqIHZhciBwbHVnaW4gPSByb3V0ZXIuYWRkUGx1Z2luKE15Q29vbFBsdWdpbik7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMgUGx1Z2luIGF1dGhvcmluZ1xuICAgKlxuICAgKiBBIHBsdWdpbiBpcyBzaW1wbHkgYSBjbGFzcyAob3IgY29uc3RydWN0b3IgZnVuY3Rpb24pIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2UgYW5kIChvcHRpb25hbGx5KSBhbiBvcHRpb25zIG9iamVjdC5cbiAgICpcbiAgICogVGhlIHBsdWdpbiBjYW4gaW1wbGVtZW50IGl0cyBmdW5jdGlvbmFsaXR5IHVzaW5nIGFueSBvZiB0aGUgcHVibGljIEFQSXMgb2YgW1tVSVJvdXRlcl1dLlxuICAgKiBGb3IgZXhhbXBsZSwgaXQgbWF5IGNvbmZpZ3VyZSByb3V0ZXIgb3B0aW9ucyBvciBhZGQgYSBUcmFuc2l0aW9uIEhvb2suXG4gICAqXG4gICAqIFRoZSBwbHVnaW4gY2FuIHRoZW4gYmUgcHVibGlzaGVkIGFzIGEgc2VwYXJhdGUgbW9kdWxlLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGV4cG9ydCBjbGFzcyBNeUF1dGhQbHVnaW4gaW1wbGVtZW50cyBVSVJvdXRlclBsdWdpbiB7XG4gICAqICAgY29uc3RydWN0b3Iocm91dGVyOiBVSVJvdXRlciwgb3B0aW9uczogYW55KSB7XG4gICAqICAgICB0aGlzLm5hbWUgPSBcIk15QXV0aFBsdWdpblwiO1xuICAgKiAgICAgbGV0ICR0cmFuc2l0aW9ucyA9IHJvdXRlci50cmFuc2l0aW9uU2VydmljZTtcbiAgICogICAgIGxldCAkc3RhdGUgPSByb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgKlxuICAgKiAgICAgbGV0IGF1dGhDcml0ZXJpYSA9IHtcbiAgICogICAgICAgdG86IChzdGF0ZSkgPT4gc3RhdGUuZGF0YSAmJiBzdGF0ZS5kYXRhLnJlcXVpcmVzQXV0aFxuICAgKiAgICAgfTtcbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIGF1dGhIb29rKHRyYW5zaXRpb246IFRyYW5zaXRpb24pIHtcbiAgICogICAgICAgbGV0IGF1dGhTZXJ2aWNlID0gdHJhbnNpdGlvbi5pbmplY3RvcigpLmdldCgnQXV0aFNlcnZpY2UnKTtcbiAgICogICAgICAgaWYgKCFhdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgKiAgICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KCdsb2dpbicpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICAkdHJhbnNpdGlvbnMub25TdGFydChhdXRoQ3JpdGVyaWEsIGF1dGhIb29rKTtcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBwbHVnaW4gb25lIG9mOlxuICAgKiAgICAgICAgLSBhIHBsdWdpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbVUlSb3V0ZXJQbHVnaW5dXVxuICAgKiAgICAgICAgLSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIFtbVUlSb3V0ZXJQbHVnaW5dXSB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAqICAgICAgICAtIGEgZmFjdG9yeSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlIGFuZCByZXR1cm5zIGEgW1tVSVJvdXRlclBsdWdpbl1dIGluc3RhbmNlXG4gICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcGx1Z2luIGNsYXNzL2ZhY3RvcnlcbiAgICogQHJldHVybnMgdGhlIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlXG4gICAqL1xuICBwbHVnaW48VCBleHRlbmRzIFVJUm91dGVyUGx1Z2luPihwbHVnaW46IGFueSwgb3B0aW9uczogYW55ID0ge30pOiBUIHtcbiAgICBjb25zdCBwbHVnaW5JbnN0YW5jZSA9IG5ldyBwbHVnaW4odGhpcywgb3B0aW9ucyk7XG4gICAgaWYgKCFwbHVnaW5JbnN0YW5jZS5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIHByb3BlcnR5IGBuYW1lYCBtaXNzaW5nIG9uIHBsdWdpbjogJyArIHBsdWdpbkluc3RhbmNlKTtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKHBsdWdpbkluc3RhbmNlKTtcbiAgICByZXR1cm4gKHRoaXMuX3BsdWdpbnNbcGx1Z2luSW5zdGFuY2UubmFtZV0gPSBwbHVnaW5JbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyByZWdpc3RlcmVkIHBsdWdpbnNcbiAgICpcbiAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBwbHVnaW4gb2YgdGhlIGdpdmVuIGBwbHVnaW5OYW1lYC5cbiAgICogSWYgbm8gYHBsdWdpbk5hbWVgIGlzIGdpdmVuLCByZXR1cm5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbnNcbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbk5hbWUgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGdldFxuICAgKiBAcmV0dXJuIHRoZSBuYW1lZCBwbHVnaW4gKHVuZGVmaW5lZCBpZiBub3QgZm91bmQpLCBvciBhbGwgcGx1Z2lucyAoaWYgYHBsdWdpbk5hbWVgIGlzIG9taXR0ZWQpXG4gICAqL1xuICBnZXRQbHVnaW4ocGx1Z2luTmFtZTogc3RyaW5nKTogVUlSb3V0ZXJQbHVnaW47XG4gIGdldFBsdWdpbigpOiBVSVJvdXRlclBsdWdpbltdO1xuICBnZXRQbHVnaW4ocGx1Z2luTmFtZT86IHN0cmluZyk6IFVJUm91dGVyUGx1Z2luIHwgVUlSb3V0ZXJQbHVnaW5bXSB7XG4gICAgcmV0dXJuIHBsdWdpbk5hbWUgPyB0aGlzLl9wbHVnaW5zW3BsdWdpbk5hbWVdIDogdmFsdWVzKHRoaXMuX3BsdWdpbnMpO1xuICB9XG59XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCB0eXBlIFBsdWdpbkZhY3Rvcnk8VD4gPSAocm91dGVyOiBVSVJvdXRlciwgb3B0aW9ucz86IGFueSkgPT4gVDtcbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuLi9yZXNvbHZlJztcbmltcG9ydCB7IGluQXJyYXksIHVuaXFSLCB1bm5lc3RSLCB2YWx1ZXMgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoJztcblxuZnVuY3Rpb24gYWRkQ29yZVJlc29sdmFibGVzKHRyYW5zOiBUcmFuc2l0aW9uKSB7XG4gIHRyYW5zLmFkZFJlc29sdmFibGUoUmVzb2x2YWJsZS5mcm9tRGF0YShVSVJvdXRlciwgdHJhbnMucm91dGVyKSwgJycpO1xuICB0cmFucy5hZGRSZXNvbHZhYmxlKFJlc29sdmFibGUuZnJvbURhdGEoVHJhbnNpdGlvbiwgdHJhbnMpLCAnJyk7XG4gIHRyYW5zLmFkZFJlc29sdmFibGUoUmVzb2x2YWJsZS5mcm9tRGF0YSgnJHRyYW5zaXRpb24kJywgdHJhbnMpLCAnJyk7XG4gIHRyYW5zLmFkZFJlc29sdmFibGUoUmVzb2x2YWJsZS5mcm9tRGF0YSgnJHN0YXRlUGFyYW1zJywgdHJhbnMucGFyYW1zKCkpLCAnJyk7XG5cbiAgdHJhbnMuZW50ZXJpbmcoKS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKFJlc29sdmFibGUuZnJvbURhdGEoJyRzdGF0ZSQnLCBzdGF0ZSksIHN0YXRlKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlckFkZENvcmVSZXNvbHZhYmxlcyA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCBhZGRDb3JlUmVzb2x2YWJsZXMpO1xuXG5jb25zdCBUUkFOU0lUSU9OX1RPS0VOUyA9IFsnJHRyYW5zaXRpb24kJywgVHJhbnNpdGlvbl07XG5jb25zdCBpc1RyYW5zaXRpb24gPSBpbkFycmF5KFRSQU5TSVRJT05fVE9LRU5TKTtcblxuLy8gUmVmZXJlbmNlcyB0byBUcmFuc2l0aW9uIGluIHRoZSB0cmVlQ2hhbmdlcyBwYXRobm9kZXMgbWFrZXMgYWxsXG4vLyBwcmV2aW91cyBUcmFuc2l0aW9ucyByZWFjaGFibGUgaW4gbWVtb3J5LCBjYXVzaW5nIGEgbWVtb3J5IGxlYWtcbi8vIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyByZXNvbHZlcyBmb3IgJyR0cmFuc2l0aW9uJCcgYW5kIGBUcmFuc2l0aW9uYCBmcm9tIHRoZSB0cmVlQ2hhbmdlcy5cbi8vIERvIG5vdCB1c2UgdGhpcyBvbiBjdXJyZW50IHRyYW5zaXRpb25zLCBvbmx5IG9uIG9sZCBvbmVzLlxuZXhwb3J0IGNvbnN0IHRyZWVDaGFuZ2VzQ2xlYW51cCA9ICh0cmFuczogVHJhbnNpdGlvbikgPT4ge1xuICBjb25zdCBub2RlcyA9IHZhbHVlcyh0cmFucy50cmVlQ2hhbmdlcygpKVxuICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgLnJlZHVjZSh1bmlxUiwgW10pO1xuXG4gIC8vIElmIHRoZSByZXNvbHZhYmxlIGlzIGEgVHJhbnNpdGlvbiwgcmV0dXJuIGEgbmV3IHJlc29sdmFibGUgd2l0aCBudWxsIGRhdGFcbiAgY29uc3QgcmVwbGFjZVRyYW5zaXRpb25XaXRoTnVsbCA9IChyOiBSZXNvbHZhYmxlKTogUmVzb2x2YWJsZSA9PiB7XG4gICAgcmV0dXJuIGlzVHJhbnNpdGlvbihyLnRva2VuKSA/IFJlc29sdmFibGUuZnJvbURhdGEoci50b2tlbiwgbnVsbCkgOiByO1xuICB9O1xuXG4gIG5vZGVzLmZvckVhY2goKG5vZGU6IFBhdGhOb2RlKSA9PiB7XG4gICAgbm9kZS5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMubWFwKHJlcGxhY2VUcmFuc2l0aW9uV2l0aE51bGwpO1xuICB9KTtcbn07XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFRhcmdldFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUvdGFyZ2V0U3RhdGUnO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rRm4gfSBmcm9tICcuLi90cmFuc2l0aW9uL2ludGVyZmFjZSc7XG5cbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB0aGF0IHJlZGlyZWN0cyB0byBhIGRpZmZlcmVudCBzdGF0ZSBvciBwYXJhbXNcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHsgdG86IChzdGF0ZSkgPT4gISFzdGF0ZS5yZWRpcmVjdFRvIH0sIHJlZGlyZWN0SG9vayk7YFxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ucmVkaXJlY3RUb11dXG4gKi9cbmNvbnN0IHJlZGlyZWN0VG9Ib29rOiBUcmFuc2l0aW9uSG9va0ZuID0gKHRyYW5zOiBUcmFuc2l0aW9uKSA9PiB7XG4gIGNvbnN0IHJlZGlyZWN0ID0gdHJhbnMudG8oKS5yZWRpcmVjdFRvO1xuICBpZiAoIXJlZGlyZWN0KSByZXR1cm47XG5cbiAgY29uc3QgJHN0YXRlID0gdHJhbnMucm91dGVyLnN0YXRlU2VydmljZTtcblxuICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQocmVzdWx0OiBhbnkpIHtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUYXJnZXRTdGF0ZSkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoaXNTdHJpbmcocmVzdWx0KSkgcmV0dXJuICRzdGF0ZS50YXJnZXQoPGFueT5yZXN1bHQsIHRyYW5zLnBhcmFtcygpLCB0cmFucy5vcHRpb25zKCkpO1xuICAgIGlmIChyZXN1bHRbJ3N0YXRlJ10gfHwgcmVzdWx0WydwYXJhbXMnXSlcbiAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KHJlc3VsdFsnc3RhdGUnXSB8fCB0cmFucy50bygpLCByZXN1bHRbJ3BhcmFtcyddIHx8IHRyYW5zLnBhcmFtcygpLCB0cmFucy5vcHRpb25zKCkpO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24ocmVkaXJlY3QpKSB7XG4gICAgcmV0dXJuIHNlcnZpY2VzLiRxLndoZW4ocmVkaXJlY3QodHJhbnMpKS50aGVuKGhhbmRsZVJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZVJlc3VsdChyZWRpcmVjdCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJSZWRpcmVjdFRvSG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoeyB0bzogc3RhdGUgPT4gISFzdGF0ZS5yZWRpcmVjdFRvIH0sIHJlZGlyZWN0VG9Ib29rKTtcbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbmltcG9ydCB7IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuLi9zdGF0ZS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5cbi8qKlxuICogQSBmYWN0b3J5IHdoaWNoIGNyZWF0ZXMgYW4gb25FbnRlciwgb25FeGl0IG9yIG9uUmV0YWluIHRyYW5zaXRpb24gaG9vayBmdW5jdGlvblxuICpcbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBpbnZva2VzIHRoZSAoZm9yIGluc3RhbmNlKSBzdGF0ZS5vbkVudGVyIGhvb2sgd2hlbiB0aGVcbiAqIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBtYWtlRW50ZXJFeGl0UmV0YWluSG9vayhob29rTmFtZTogc3RyaW5nKTogVHJhbnNpdGlvblN0YXRlSG9va0ZuIHtcbiAgcmV0dXJuICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uLCBzdGF0ZTogU3RhdGVEZWNsYXJhdGlvbikgPT4ge1xuICAgIGNvbnN0IF9zdGF0ZTogU3RhdGVPYmplY3QgPSBzdGF0ZS4kJHN0YXRlKCk7XG4gICAgY29uc3QgaG9va0ZuOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4gPSBfc3RhdGVbaG9va05hbWVdO1xuICAgIHJldHVybiBob29rRm4odHJhbnNpdGlvbiwgc3RhdGUpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvbkV4aXRcbiAqXG4gKiBXaGVuIHRoZSBzdGF0ZSBpcyBiZWluZyBleGl0ZWQsIHRoZSBzdGF0ZSdzIC5vbkV4aXQgZnVuY3Rpb24gaXMgaW52b2tlZC5cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkV4aXQoeyBleGl0aW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FeGl0IH0sIG9uRXhpdEhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vbkV4aXRdXVxuICovXG5jb25zdCBvbkV4aXRIb29rOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4gPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FeGl0Jyk7XG5leHBvcnQgY29uc3QgcmVnaXN0ZXJPbkV4aXRIb29rID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogc3RhdGUgPT4gISFzdGF0ZS5vbkV4aXQgfSwgb25FeGl0SG9vayk7XG5cbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uUmV0YWluXG4gKlxuICogV2hlbiB0aGUgc3RhdGUgd2FzIGFscmVhZHkgZW50ZXJlZCwgYW5kIGlzIG5vdCBiZWluZyBleGl0ZWQgb3IgcmUtZW50ZXJlZCwgdGhlIHN0YXRlJ3MgLm9uUmV0YWluIGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25SZXRhaW4oeyByZXRhaW5lZDogKHN0YXRlKSA9PiAhIXN0YXRlLm9uUmV0YWluIH0sIG9uUmV0YWluSG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uUmV0YWluXV1cbiAqL1xuY29uc3Qgb25SZXRhaW5Ib29rOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4gPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25SZXRhaW4nKTtcbmV4cG9ydCBjb25zdCByZWdpc3Rlck9uUmV0YWluSG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IHN0YXRlID0+ICEhc3RhdGUub25SZXRhaW4gfSwgb25SZXRhaW5Ib29rKTtcblxuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25FbnRlclxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vbkVudGVyIGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FbnRlciB9LCBvbkVudGVySG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRW50ZXJdXVxuICovXG5jb25zdCBvbkVudGVySG9vazogVHJhbnNpdGlvblN0YXRlSG9va0ZuID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRW50ZXInKTtcbmV4cG9ydCBjb25zdCByZWdpc3Rlck9uRW50ZXJIb29rID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiBzdGF0ZSA9PiAhIXN0YXRlLm9uRW50ZXIgfSwgb25FbnRlckhvb2spO1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBSZXNvbHZlQ29udGV4dCB9IGZyb20gJy4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQnO1xuaW1wb3J0IHsgVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBUcmFuc2l0aW9uSG9va0ZuIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IHZhbCB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBjb25zdCBSRVNPTFZFX0hPT0tfUFJJT1JJVFkgPSAxMDAwO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggcmVzb2x2ZXMgYWxsIEVBR0VSIFJlc29sdmFibGVzIGluIHRoZSBUbyBQYXRoXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogMTAwMCB9KTtgXG4gKlxuICogV2hlbiBhIFRyYW5zaXRpb24gc3RhcnRzLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBFQUdFUiBSZXNvbHZhYmxlcywgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xuY29uc3QgZWFnZXJSZXNvbHZlUGF0aDogVHJhbnNpdGlvbkhvb2tGbiA9ICh0cmFuczogVHJhbnNpdGlvbikgPT5cbiAgbmV3IFJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKCkudG8pLnJlc29sdmVQYXRoKCdFQUdFUicsIHRyYW5zKS50aGVuKG5vb3ApO1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogUkVTT0xWRV9IT09LX1BSSU9SSVRZIH0pO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggcmVzb2x2ZXMgYWxsIExBWlkgUmVzb2x2YWJsZXMgZm9yIHRoZSBzdGF0ZSAoYW5kIGFsbCBpdHMgYW5jZXN0b3JzKSBpbiB0aGUgVG8gUGF0aFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogKCkgPT4gdHJ1ZSB9LCBsYXp5UmVzb2x2ZVN0YXRlLCB7IHByaW9yaXR5OiAxMDAwIH0pO2BcbiAqXG4gKiBXaGVuIGEgU3RhdGUgaXMgYmVpbmcgZW50ZXJlZCwgdGhpcyBob29rIHJlc29sdmVzIGFsbCB0aGUgUmVzb2x2YWJsZXMgZm9yIHRoaXMgc3RhdGUsIHdoaWNoIHRoZSB0cmFuc2l0aW9uIHRoZW4gd2FpdHMgZm9yLlxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dXG4gKi9cbmNvbnN0IGxhenlSZXNvbHZlU3RhdGU6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiA9ICh0cmFuczogVHJhbnNpdGlvbiwgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pID0+XG4gIG5ldyBSZXNvbHZlQ29udGV4dCh0cmFucy50cmVlQ2hhbmdlcygpLnRvKVxuICAgIC5zdWJDb250ZXh0KHN0YXRlLiQkc3RhdGUoKSlcbiAgICAucmVzb2x2ZVBhdGgoJ0xBWlknLCB0cmFucylcbiAgICAudGhlbihub29wKTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyTGF6eVJlc29sdmVTdGF0ZSA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogdmFsKHRydWUpIH0sIGxhenlSZXNvbHZlU3RhdGUsIHsgcHJpb3JpdHk6IFJFU09MVkVfSE9PS19QUklPUklUWSB9KTtcblxuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFueSBkeW5hbWljYWxseSBhZGRlZCAoTEFaWSBvciBFQUdFUikgUmVzb2x2YWJsZXMuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25GaW5pc2goe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IDEwMDAgfSk7YFxuICpcbiAqIEFmdGVyIGFsbCBlbnRlcmluZyBzdGF0ZXMgaGF2ZSBiZWVuIGVudGVyZWQsIHRoaXMgaG9vayByZXNvbHZlcyBhbnkgcmVtYWluaW5nIFJlc29sdmFibGVzLlxuICogVGhlc2UgYXJlIHR5cGljYWxseSBkeW5hbWljIHJlc29sdmVzIHdoaWNoIHdlcmUgYWRkZWQgYnkgc29tZSBUcmFuc2l0aW9uIEhvb2sgdXNpbmcgW1tUcmFuc2l0aW9uLmFkZFJlc29sdmFibGVdXS5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG5jb25zdCByZXNvbHZlUmVtYWluaW5nOiBUcmFuc2l0aW9uSG9va0ZuID0gKHRyYW5zOiBUcmFuc2l0aW9uKSA9PlxuICBuZXcgUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bykucmVzb2x2ZVBhdGgoJ0xBWlknLCB0cmFucykudGhlbihub29wKTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyUmVzb2x2ZVJlbWFpbmluZyA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCByZXNvbHZlUmVtYWluaW5nLCB7IHByaW9yaXR5OiBSRVNPTFZFX0hPT0tfUFJJT1JJVFkgfSk7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBWaWV3U2VydmljZSB9IGZyb20gJy4uL3ZpZXcvdmlldyc7XG5pbXBvcnQgeyBWaWV3Q29uZmlnIH0gZnJvbSAnLi4vdmlldy9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2tGbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5cbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB3YWl0cyBmb3IgdGhlIHZpZXdzIHRvIGxvYWRcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7YFxuICpcbiAqIEFsbG93cyB0aGUgdmlld3MgdG8gZG8gYXN5bmMgd29yayBpbiBbW1ZpZXdDb25maWcubG9hZF1dIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBjb250aW51ZXMuXG4gKiBJbiBhbmd1bGFyIDEsIHRoaXMgaW5jbHVkZXMgbG9hZGluZyB0aGUgdGVtcGxhdGVzLlxuICovXG5jb25zdCBsb2FkRW50ZXJpbmdWaWV3czogVHJhbnNpdGlvbkhvb2tGbiA9ICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSA9PiB7XG4gIGNvbnN0ICRxID0gc2VydmljZXMuJHE7XG4gIGNvbnN0IGVudGVyaW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKCdlbnRlcmluZycpO1xuICBpZiAoIWVudGVyaW5nVmlld3MubGVuZ3RoKSByZXR1cm47XG4gIHJldHVybiAkcS5hbGwoZW50ZXJpbmdWaWV3cy5tYXAodmlldyA9PiAkcS53aGVuKHZpZXcubG9hZCgpKSkpLnRoZW4obm9vcCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJMb2FkRW50ZXJpbmdWaWV3cyA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7XG5cbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCBhY3RpdmF0ZXMgdGhlIG5ldyB2aWV3cyB3aGVuIGEgdHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgYWN0aXZhdGVWaWV3cyk7YFxuICpcbiAqIEFmdGVyIGEgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZSwgdGhpcyBob29rIGRlYWN0aXZhdGVzIHRoZSBvbGQgdmlld3MgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUsXG4gKiBhbmQgYWN0aXZhdGVzIHRoZSBuZXcgdmlld3MgZnJvbSB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKlxuICogU2VlIFtbVmlld1NlcnZpY2VdXVxuICovXG5jb25zdCBhY3RpdmF0ZVZpZXdzOiBUcmFuc2l0aW9uSG9va0ZuID0gKHRyYW5zaXRpb246IFRyYW5zaXRpb24pID0+IHtcbiAgY29uc3QgZW50ZXJpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoJ2VudGVyaW5nJyk7XG4gIGNvbnN0IGV4aXRpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoJ2V4aXRpbmcnKTtcbiAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aCAmJiAhZXhpdGluZ1ZpZXdzLmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNvbnN0ICR2aWV3OiBWaWV3U2VydmljZSA9IHRyYW5zaXRpb24ucm91dGVyLnZpZXdTZXJ2aWNlO1xuXG4gIGV4aXRpbmdWaWV3cy5mb3JFYWNoKCh2YzogVmlld0NvbmZpZykgPT4gJHZpZXcuZGVhY3RpdmF0ZVZpZXdDb25maWcodmMpKTtcbiAgZW50ZXJpbmdWaWV3cy5mb3JFYWNoKCh2YzogVmlld0NvbmZpZykgPT4gJHZpZXcuYWN0aXZhdGVWaWV3Q29uZmlnKHZjKSk7XG5cbiAgJHZpZXcuc3luYygpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQWN0aXZhdGVWaWV3cyA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgYWN0aXZhdGVWaWV3cyk7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IGNvcHkgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5cbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIGdsb2JhbCBVSS1Sb3V0ZXIgc3RhdGVcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdXBkYXRlR2xvYmFsU3RhdGUpO2BcbiAqXG4gKiBCZWZvcmUgYSBbW1RyYW5zaXRpb25dXSBzdGFydHMsIHVwZGF0ZXMgdGhlIGdsb2JhbCB2YWx1ZSBvZiBcInRoZSBjdXJyZW50IHRyYW5zaXRpb25cIiAoW1tHbG9iYWxzLnRyYW5zaXRpb25dXSkuXG4gKiBBZnRlciBhIHN1Y2Nlc3NmdWwgW1tUcmFuc2l0aW9uXV0sIHVwZGF0ZXMgdGhlIGdsb2JhbCB2YWx1ZXMgb2YgXCJ0aGUgY3VycmVudCBzdGF0ZVwiXG4gKiAoW1tHbG9iYWxzLmN1cnJlbnRdXSBhbmQgW1tHbG9iYWxzLiRjdXJyZW50XV0pIGFuZCBcInRoZSBjdXJyZW50IHBhcmFtIHZhbHVlc1wiIChbW0dsb2JhbHMucGFyYW1zXV0pLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkZXByZWNhdGVkIHByb3BlcnRpZXM6XG4gKiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uXV0sIFtbU3RhdGVTZXJ2aWNlLmN1cnJlbnRdXSwgW1tTdGF0ZVNlcnZpY2UucGFyYW1zXV1cbiAqL1xuY29uc3QgdXBkYXRlR2xvYmFsU3RhdGUgPSAodHJhbnM6IFRyYW5zaXRpb24pID0+IHtcbiAgY29uc3QgZ2xvYmFscyA9IHRyYW5zLnJvdXRlci5nbG9iYWxzO1xuXG4gIGNvbnN0IHRyYW5zaXRpb25TdWNjZXNzZnVsID0gKCkgPT4ge1xuICAgIGdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLmVucXVldWUodHJhbnMpO1xuICAgIGdsb2JhbHMuJGN1cnJlbnQgPSB0cmFucy4kdG8oKTtcbiAgICBnbG9iYWxzLmN1cnJlbnQgPSBnbG9iYWxzLiRjdXJyZW50LnNlbGY7XG5cbiAgICBjb3B5KHRyYW5zLnBhcmFtcygpLCBnbG9iYWxzLnBhcmFtcyk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDdXJyZW50VHJhbnNpdGlvbiA9ICgpID0+IHtcbiAgICAvLyBEbyBub3QgY2xlYXIgZ2xvYmFscy50cmFuc2l0aW9uIGlmIGEgZGlmZmVyZW50IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgaWYgKGdsb2JhbHMudHJhbnNpdGlvbiA9PT0gdHJhbnMpIGdsb2JhbHMudHJhbnNpdGlvbiA9IG51bGw7XG4gIH07XG5cbiAgdHJhbnMub25TdWNjZXNzKHt9LCB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCwgeyBwcmlvcml0eTogMTAwMDAgfSk7XG4gIHRyYW5zLnByb21pc2UudGhlbihjbGVhckN1cnJlbnRUcmFuc2l0aW9uLCBjbGVhckN1cnJlbnRUcmFuc2l0aW9uKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclVwZGF0ZUdsb2JhbFN0YXRlID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25DcmVhdGUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtcbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbmltcG9ydCB7IFVybFJvdXRlciB9IGZyb20gJy4uL3VybC91cmxSb3V0ZXInO1xuaW1wb3J0IHsgU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVTZXJ2aWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2tGbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5cbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIHRoZSBVUkwgYWZ0ZXIgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZVVybCk7YFxuICovXG5jb25zdCB1cGRhdGVVcmw6IFRyYW5zaXRpb25Ib29rRm4gPSAodHJhbnNpdGlvbjogVHJhbnNpdGlvbikgPT4ge1xuICBjb25zdCBvcHRpb25zID0gdHJhbnNpdGlvbi5vcHRpb25zKCk7XG4gIGNvbnN0ICRzdGF0ZTogU3RhdGVTZXJ2aWNlID0gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICBjb25zdCAkdXJsUm91dGVyOiBVcmxSb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlci51cmxSb3V0ZXI7XG5cbiAgLy8gRG9udCB1cGRhdGUgdGhlIHVybCBpbiB0aGVzZSBzaXR1YXRpb25zOlxuICAvLyBUaGUgdHJhbnNpdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgVVJMIHN5bmMgKG9wdGlvbnMuc291cmNlID09PSAndXJsJylcbiAgLy8gVGhlIHVzZXIgZG9lc24ndCB3YW50IHRoZSB1cmwgdG8gdXBkYXRlIChvcHRpb25zLmxvY2F0aW9uID09PSBmYWxzZSlcbiAgLy8gVGhlIGRlc3RpbmF0aW9uIHN0YXRlLCBhbmQgYWxsIHBhcmVudHMgaGF2ZSBubyBuYXZpZ2FibGUgdXJsXG4gIGlmIChvcHRpb25zLnNvdXJjZSAhPT0gJ3VybCcgJiYgb3B0aW9ucy5sb2NhdGlvbiAmJiAkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlKSB7XG4gICAgY29uc3QgdXJsT3B0aW9ucyA9IHsgcmVwbGFjZTogb3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3JlcGxhY2UnIH07XG4gICAgJHVybFJvdXRlci5wdXNoKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUudXJsLCAkc3RhdGUucGFyYW1zLCB1cmxPcHRpb25zKTtcbiAgfVxuXG4gICR1cmxSb3V0ZXIudXBkYXRlKHRydWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXBkYXRlVXJsID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGVVcmwsIHsgcHJpb3JpdHk6IDk5OTkgfSk7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uSG9va0ZuIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiwgTGF6eUxvYWRSZXN1bHQgfSBmcm9tICcuLi9zdGF0ZS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFN0YXRlUnVsZSB9IGZyb20gJy4uL3VybC9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBwZXJmb3JtcyBsYXp5IGxvYWRpbmdcbiAqXG4gKiBXaGVuIGVudGVyaW5nIGEgc3RhdGUgXCJhYmNcIiB3aGljaCBoYXMgYSBgbGF6eUxvYWRgIGZ1bmN0aW9uIGRlZmluZWQ6XG4gKiAtIEludm9rZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiAodW5sZXNzIGl0IGlzIGFscmVhZHkgaW4gcHJvY2VzcylcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwiaW4gcHJvY2Vzc1wiXG4gKiAgIC0gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBwcm9taXNlICh0aGF0IHJlc29sdmVzIHdoZW4gbGF6eSBsb2FkaW5nIGlzIGNvbXBsZXRlKVxuICogLSBXYWl0IGZvciB0aGUgcHJvbWlzZSB0byBzZXR0bGVcbiAqICAgLSBJZiB0aGUgcHJvbWlzZSByZXNvbHZlcyB0byBhIFtbTGF6eUxvYWRSZXN1bHRdXSwgdGhlbiByZWdpc3RlciB0aG9zZSBzdGF0ZXNcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwibm90IGluIHByb2Nlc3NcIlxuICogLSBJZiB0aGUgaG9vayB3YXMgc3VjY2Vzc2Z1bFxuICogICAtIFJlbW92ZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiBmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvblxuICogLSBJZiBhbGwgdGhlIGhvb2tzIHdlcmUgc3VjY2Vzc2Z1bFxuICogICAtIFJldHJ5IHRoZSB0cmFuc2l0aW9uIChieSByZXR1cm5pbmcgYSBUYXJnZXRTdGF0ZSlcbiAqXG4gKiBgYGBcbiAqIC5zdGF0ZSgnYWJjJywge1xuICogICBjb21wb25lbnQ6ICdmb29Db21wb25lbnQnLFxuICogICBsYXp5TG9hZDogKCkgPT4gaW1wb3J0KCcuL2Zvb0NvbXBvbmVudCcpXG4gKiAgIH0pO1xuICogYGBgXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5sYXp5TG9hZF1dXG4gKi9cbmNvbnN0IGxhenlMb2FkSG9vazogVHJhbnNpdGlvbkhvb2tGbiA9ICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHRyYW5zaXRpb24ucm91dGVyO1xuXG4gIGZ1bmN0aW9uIHJldHJ5VHJhbnNpdGlvbigpIHtcbiAgICBpZiAodHJhbnNpdGlvbi5vcmlnaW5hbFRyYW5zaXRpb24oKS5vcHRpb25zKCkuc291cmNlICE9PSAndXJsJykge1xuICAgICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIG5vdCB0cmlnZ2VyZWQgdmlhIHVybCBzeW5jXG4gICAgICAvLyBUaGUgbGF6eSBzdGF0ZSBzaG91bGQgYmUgbG9hZGVkIG5vdywgc28gcmUtdHJ5IHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uXG4gICAgICBjb25zdCBvcmlnID0gdHJhbnNpdGlvbi50YXJnZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHJvdXRlci5zdGF0ZVNlcnZpY2UudGFyZ2V0KG9yaWcuaWRlbnRpZmllcigpLCBvcmlnLnBhcmFtcygpLCBvcmlnLm9wdGlvbnMoKSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIHRyaWdnZXJlZCB2aWEgdXJsIHN5bmNcbiAgICAvLyBSdW4gdGhlIFVSTCBydWxlcyBhbmQgZmluZCB0aGUgYmVzdCBtYXRjaFxuICAgIGNvbnN0ICR1cmwgPSByb3V0ZXIudXJsU2VydmljZTtcbiAgICBjb25zdCByZXN1bHQgPSAkdXJsLm1hdGNoKCR1cmwucGFydHMoKSk7XG4gICAgY29uc3QgcnVsZSA9IHJlc3VsdCAmJiByZXN1bHQucnVsZTtcblxuICAgIC8vIElmIHRoZSBiZXN0IG1hdGNoIGlzIGEgc3RhdGUsIHJlZGlyZWN0IHRoZSB0cmFuc2l0aW9uIChpbnN0ZWFkXG4gICAgLy8gb2YgY2FsbGluZyBzeW5jKCkgd2hpY2ggc3VwZXJzZWRlcyB0aGUgY3VycmVudCB0cmFuc2l0aW9uKVxuICAgIGlmIChydWxlICYmIHJ1bGUudHlwZSA9PT0gJ1NUQVRFJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSAocnVsZSBhcyBTdGF0ZVJ1bGUpLnN0YXRlO1xuICAgICAgY29uc3QgcGFyYW1zID0gcmVzdWx0Lm1hdGNoO1xuICAgICAgcmV0dXJuIHJvdXRlci5zdGF0ZVNlcnZpY2UudGFyZ2V0KHN0YXRlLCBwYXJhbXMsIHRyYW5zaXRpb24ub3B0aW9ucygpKTtcbiAgICB9XG5cbiAgICAvLyBObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCwgc28gbGV0IC5zeW5jKCkgY2hvb3NlIHRoZSBiZXN0IG5vbi1zdGF0ZSBtYXRjaC9vdGhlcndpc2VcbiAgICByb3V0ZXIudXJsU2VydmljZS5zeW5jKCk7XG4gIH1cblxuICBjb25zdCBwcm9taXNlcyA9IHRyYW5zaXRpb25cbiAgICAuZW50ZXJpbmcoKVxuICAgIC5maWx0ZXIoc3RhdGUgPT4gISFzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQpXG4gICAgLm1hcChzdGF0ZSA9PiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKSk7XG5cbiAgcmV0dXJuIHNlcnZpY2VzLiRxLmFsbChwcm9taXNlcykudGhlbihyZXRyeVRyYW5zaXRpb24pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyTGF6eUxvYWRIb29rID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoeyBlbnRlcmluZzogc3RhdGUgPT4gISFzdGF0ZS5sYXp5TG9hZCB9LCBsYXp5TG9hZEhvb2spO1xuXG4vKipcbiAqIEludm9rZXMgYSBzdGF0ZSdzIGxhenkgbG9hZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIGEgVHJhbnNpdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIGxhenkgbG9hZFxuICogQHJldHVybnMgQSBwcm9taXNlIGZvciB0aGUgbGF6eSBsb2FkIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uLCBzdGF0ZTogU3RhdGVEZWNsYXJhdGlvbik6IFByb21pc2U8TGF6eUxvYWRSZXN1bHQ+IHtcbiAgY29uc3QgbGF6eUxvYWRGbiA9IHN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDtcblxuICAvLyBTdG9yZS9nZXQgdGhlIGxhenkgbG9hZCBwcm9taXNlIG9uL2Zyb20gdGhlIGhvb2tmbiBzbyBpdCBkb2Vzbid0IGdldCByZS1pbnZva2VkXG4gIGxldCBwcm9taXNlID0gbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgaWYgKCFwcm9taXNlKSB7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHJlc3VsdCA9PiB7XG4gICAgICBkZWxldGUgc3RhdGUubGF6eUxvYWQ7XG4gICAgICBkZWxldGUgc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xuICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBjb25zdCBlcnJvciA9IGVyciA9PiB7XG4gICAgICBkZWxldGUgbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICAgIHJldHVybiBzZXJ2aWNlcy4kcS5yZWplY3QoZXJyKTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ10gPSBzZXJ2aWNlcy4kcVxuICAgICAgLndoZW4obGF6eUxvYWRGbih0cmFuc2l0aW9uLCBzdGF0ZSkpXG4gICAgICAudGhlbih1cGRhdGVTdGF0ZVJlZ2lzdHJ5KVxuICAgICAgLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xuICB9XG5cbiAgLyoqIFJlZ2lzdGVyIGFueSBsYXp5IGxvYWRlZCBzdGF0ZSBkZWZpbml0aW9ucyAqL1xuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZVJlZ2lzdHJ5KHJlc3VsdDogTGF6eUxvYWRSZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LnN0YXRlcykpIHtcbiAgICAgIHJlc3VsdC5zdGF0ZXMuZm9yRWFjaChfc3RhdGUgPT4gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yZWdpc3Rlcihfc3RhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiAqL1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2tQaGFzZSwgUGF0aFR5cGUgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBHZXRFcnJvckhhbmRsZXIsIEdldFJlc3VsdEhhbmRsZXIsIFRyYW5zaXRpb25Ib29rIH0gZnJvbSAnLi90cmFuc2l0aW9uSG9vayc7XG4vKipcbiAqIFRoaXMgY2xhc3MgZGVmaW5lcyBhIHR5cGUgb2YgaG9vaywgc3VjaCBhcyBgb25CZWZvcmVgIG9yIGBvbkVudGVyYC5cbiAqIFBsdWdpbnMgY2FuIGRlZmluZSBjdXN0b20gaG9vayB0eXBlcywgc3VjaCBhcyBzdGlja3kgc3RhdGVzIGRvZXMgZm9yIGBvbkluYWN0aXZlYC5cbiAqXG4gKiBAaW50ZXJhbGFwaVxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNpdGlvbkV2ZW50VHlwZSB7XG4gIC8qIHRzbGludDpkaXNhYmxlOm5vLWluZmVycmFibGUtdHlwZXMgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyxcbiAgICBwdWJsaWMgaG9va1BoYXNlOiBUcmFuc2l0aW9uSG9va1BoYXNlLFxuICAgIHB1YmxpYyBob29rT3JkZXI6IG51bWJlcixcbiAgICBwdWJsaWMgY3JpdGVyaWFNYXRjaFBhdGg6IFBhdGhUeXBlLFxuICAgIHB1YmxpYyByZXZlcnNlU29ydDogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHB1YmxpYyBnZXRSZXN1bHRIYW5kbGVyOiBHZXRSZXN1bHRIYW5kbGVyID0gVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVCxcbiAgICBwdWJsaWMgZ2V0RXJyb3JIYW5kbGVyOiBHZXRFcnJvckhhbmRsZXIgPSBUcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1IsXG4gICAgcHVibGljIHN5bmNocm9ub3VzOiBib29sZWFuID0gZmFsc2VcbiAgKSB7fVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gJy4uL2NvbW1vbi90cmFjZSc7XG5pbXBvcnQgeyBSZWplY3Rpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnknO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBza2lwcyBhIHRyYW5zaXRpb24gaWYgaXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqXG4gKiBJZiB0aGUgdHJhbnNpdGlvbiBzaG91bGQgYmUgaWdub3JlZCAoYmVjYXVzZSBubyBwYXJhbWV0ZXIgb3Igc3RhdGVzIGNoYW5nZWQpXG4gKiB0aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQgYW5kIG5vdCBwcm9jZXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGlnbm9yZWRIb29rKHRyYW5zOiBUcmFuc2l0aW9uKSB7XG4gIGNvbnN0IGlnbm9yZWRSZWFzb24gPSB0cmFucy5faWdub3JlZFJlYXNvbigpO1xuICBpZiAoIWlnbm9yZWRSZWFzb24pIHJldHVybjtcblxuICB0cmFjZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkKHRyYW5zKTtcblxuICBjb25zdCBwZW5kaW5nID0gdHJhbnMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjtcblxuICAvLyBUaGUgdXNlciBjbGlja2VkIGEgbGluayBnb2luZyBiYWNrIHRvIHRoZSAqY3VycmVudCBzdGF0ZSogKCdBJylcbiAgLy8gSG93ZXZlciwgdGhlcmUgaXMgYWxzbyBhIHBlbmRpbmcgdHJhbnNpdGlvbiBpbiBmbGlnaHQgKHRvICdCJylcbiAgLy8gQWJvcnQgdGhlIHRyYW5zaXRpb24gdG8gJ0InIGJlY2F1c2UgdGhlIHVzZXIgbm93IHdhbnRzIHRvIGJlIGJhY2sgYXQgJ0EnLlxuICBpZiAoaWdub3JlZFJlYXNvbiA9PT0gJ1NhbWVBc0N1cnJlbnQnICYmIHBlbmRpbmcpIHtcbiAgICBwZW5kaW5nLmFib3J0KCk7XG4gIH1cblxuICByZXR1cm4gUmVqZWN0aW9uLmlnbm9yZWQoKS50b1Byb21pc2UoKTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVySWdub3JlZFRyYW5zaXRpb25Ib29rID0gKHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSkgPT5cbiAgdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIGlnbm9yZWRIb29rLCB7IHByaW9yaXR5OiAtOTk5OSB9KTtcbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBob29rcyAqLyAvKiogKi9cblxuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWplY3RzIHRoZSBUcmFuc2l0aW9uIGlmIGl0IGlzIGludmFsaWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGZvciBleGFtcGxlLCBwYXJhbSB2YWx1ZXMgZG8gbm90IHZhbGlkYXRlKVxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyByZWplY3RlZC5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZFRyYW5zaXRpb25Ib29rKHRyYW5zOiBUcmFuc2l0aW9uKSB7XG4gIGlmICghdHJhbnMudmFsaWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih0cmFucy5lcnJvcigpLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlckludmFsaWRUcmFuc2l0aW9uSG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpbnZhbGlkVHJhbnNpdGlvbkhvb2ssIHsgcHJpb3JpdHk6IC0xMDAwMCB9KTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdHJhbnNpdGlvbiAqLyAvKiogKi9cbmltcG9ydCB7XG4gIElIb29rUmVnaXN0cnksXG4gIFRyYW5zaXRpb25PcHRpb25zLFxuICBUcmFuc2l0aW9uSG9va1Njb3BlLFxuICBUcmFuc2l0aW9uSG9va1BoYXNlLFxuICBUcmFuc2l0aW9uQ3JlYXRlSG9va0ZuLFxuICBIb29rTWF0Y2hDcml0ZXJpYSxcbiAgSG9va1JlZ09wdGlvbnMsXG4gIFBhdGhUeXBlcyxcbiAgUGF0aFR5cGUsXG4gIFJlZ2lzdGVyZWRIb29rcyxcbiAgVHJhbnNpdGlvbkhvb2tGbixcbiAgVHJhbnNpdGlvblN0YXRlSG9va0ZuLFxufSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi90cmFuc2l0aW9uJztcbmltcG9ydCB7IG1ha2VFdmVudCwgUmVnaXN0ZXJlZEhvb2sgfSBmcm9tICcuL2hvb2tSZWdpc3RyeSc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL3RhcmdldFN0YXRlJztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5pbXBvcnQgeyBWaWV3U2VydmljZSB9IGZyb20gJy4uL3ZpZXcvdmlldyc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyByZWdpc3RlckFkZENvcmVSZXNvbHZhYmxlcywgdHJlZUNoYW5nZXNDbGVhbnVwIH0gZnJvbSAnLi4vaG9va3MvY29yZVJlc29sdmFibGVzJztcbmltcG9ydCB7IHJlZ2lzdGVyUmVkaXJlY3RUb0hvb2sgfSBmcm9tICcuLi9ob29rcy9yZWRpcmVjdFRvJztcbmltcG9ydCB7IHJlZ2lzdGVyT25FeGl0SG9vaywgcmVnaXN0ZXJPblJldGFpbkhvb2ssIHJlZ2lzdGVyT25FbnRlckhvb2sgfSBmcm9tICcuLi9ob29rcy9vbkVudGVyRXhpdFJldGFpbic7XG5pbXBvcnQgeyByZWdpc3RlckVhZ2VyUmVzb2x2ZVBhdGgsIHJlZ2lzdGVyTGF6eVJlc29sdmVTdGF0ZSwgcmVnaXN0ZXJSZXNvbHZlUmVtYWluaW5nIH0gZnJvbSAnLi4vaG9va3MvcmVzb2x2ZSc7XG5pbXBvcnQgeyByZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzLCByZWdpc3RlckFjdGl2YXRlVmlld3MgfSBmcm9tICcuLi9ob29rcy92aWV3cyc7XG5pbXBvcnQgeyByZWdpc3RlclVwZGF0ZUdsb2JhbFN0YXRlIH0gZnJvbSAnLi4vaG9va3MvdXBkYXRlR2xvYmFscyc7XG5pbXBvcnQgeyByZWdpc3RlclVwZGF0ZVVybCB9IGZyb20gJy4uL2hvb2tzL3VybCc7XG5pbXBvcnQgeyByZWdpc3RlckxhenlMb2FkSG9vayB9IGZyb20gJy4uL2hvb2tzL2xhenlMb2FkJztcbmltcG9ydCB7IFRyYW5zaXRpb25FdmVudFR5cGUgfSBmcm9tICcuL3RyYW5zaXRpb25FdmVudFR5cGUnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2ssIEdldFJlc3VsdEhhbmRsZXIsIEdldEVycm9ySGFuZGxlciB9IGZyb20gJy4vdHJhbnNpdGlvbkhvb2snO1xuaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgcmVtb3ZlRnJvbSwgdmFsdWVzLCBjcmVhdGVQcm94eUZ1bmN0aW9ucyB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL2ludGVyZmFjZSc7IC8vIGhhcyBvciBpcyB1c2luZ1xuaW1wb3J0IHsgdmFsIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyByZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayB9IGZyb20gJy4uL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uJztcbmltcG9ydCB7IHJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rIH0gZnJvbSAnLi4vaG9va3MvaW52YWxpZFRyYW5zaXRpb24nO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IFtbVHJhbnNpdGlvbl1dIG9wdGlvbnMuXG4gKlxuICogSW5jbHVkZSB0aGlzIG9iamVjdCB3aGVuIGFwcGx5aW5nIGN1c3RvbSBkZWZhdWx0czpcbiAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XG4gKiBsZXQgb3B0aW9ucyA9IGRlZmF1bHRzKHRoZWlyT3B0cywgY3VzdG9tRGVmYXVsdHMsIGRlZmF1bHRPcHRpb25zKTtcbiAqL1xuZXhwb3J0IGxldCBkZWZhdWx0VHJhbnNPcHRzOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHtcbiAgbG9jYXRpb246IHRydWUsXG4gIHJlbGF0aXZlOiBudWxsLFxuICBpbmhlcml0OiBmYWxzZSxcbiAgbm90aWZ5OiB0cnVlLFxuICByZWxvYWQ6IGZhbHNlLFxuICBzdXBlcmNlZGU6IHRydWUsXG4gIGN1c3RvbToge30sXG4gIGN1cnJlbnQ6ICgpID0+IG51bGwsXG4gIHNvdXJjZTogJ3Vua25vd24nLFxufTtcblxuLyoqXG4gKiBQbHVnaW4gQVBJIGZvciBUcmFuc2l0aW9uIFNlcnZpY2VcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zaXRpb25TZXJ2aWNlUGx1Z2luQVBJIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBQYXRoIHRvIGJlIHVzZWQgYXMgYSBjcml0ZXJpb24gYWdhaW5zdCBhIFRyZWVDaGFuZ2VzIHBhdGhcbiAgICpcbiAgICogRm9yIGV4YW1wbGU6IHRoZSBgZXhpdGluZ2AgcGF0aCBpbiBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgYSBTVEFURSBzY29wZWQgcGF0aC5cbiAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ2V4aXRpbmcnLCBUcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFKWBcbiAgICogRWFjaCBzdGF0ZSBpbiB0aGUgZXhpdGluZyBwYXRoIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgY3JpdGVyaWEgYW5kIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIG1hdGNoLlxuICAgKlxuICAgKiBBbm90aGVyIGV4YW1wbGU6IHRoZSBgdG9gIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgVFJBTlNJVElPTiBzY29wZWQgcGF0aC5cbiAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ3RvJywgVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OKWBcbiAgICogT25seSB0aGUgdGFpbCBvZiB0aGUgYHRvYCBwYXRoIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgY3JpdGVyaWEgYW5kIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIG1hdGNoLlxuICAgKi9cbiAgX2RlZmluZVBhdGhUeXBlKG5hbWU6IHN0cmluZywgaG9va1Njb3BlOiBUcmFuc2l0aW9uSG9va1Njb3BlKTtcblxuICAvKipcbiAgICogR2V0cyBhIFBhdGggZGVmaW5pdGlvbiB1c2VkIGFzIGEgY3JpdGVyaW9uIGFnYWluc3QgYSBUcmVlQ2hhbmdlcyBwYXRoXG4gICAqL1xuICBfZ2V0UGF0aFR5cGVzKCk6IFBhdGhUeXBlcztcblxuICAvKipcbiAgICogRGVmaW5lcyBhIHRyYW5zaXRpb24gaG9vayB0eXBlIGFuZCByZXR1cm5zIGEgdHJhbnNpdGlvbiBob29rIHJlZ2lzdHJhdGlvblxuICAgKiBmdW5jdGlvbiAod2hpY2ggY2FuIHRoZW4gYmUgdXNlZCB0byByZWdpc3RlciBob29rcyBvZiB0aGlzIHR5cGUpLlxuICAgKi9cbiAgX2RlZmluZUV2ZW50KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBob29rUGhhc2U6IFRyYW5zaXRpb25Ib29rUGhhc2UsXG4gICAgaG9va09yZGVyOiBudW1iZXIsXG4gICAgY3JpdGVyaWFNYXRjaFBhdGg6IFBhdGhUeXBlLFxuICAgIHJldmVyc2VTb3J0PzogYm9vbGVhbixcbiAgICBnZXRSZXN1bHRIYW5kbGVyPzogR2V0UmVzdWx0SGFuZGxlcixcbiAgICBnZXRFcnJvckhhbmRsZXI/OiBHZXRFcnJvckhhbmRsZXIsXG4gICAgcmVqZWN0SWZTdXBlcnNlZGVkPzogYm9vbGVhblxuICApO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrbm93biBldmVudCB0eXBlcywgc3VjaCBhcyBgb25CZWZvcmVgXG4gICAqIElmIGEgcGhhc2UgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHJldHVybnMgb25seSBldmVudHMgZm9yIHRoZSBnaXZlbiBwaGFzZS5cbiAgICovXG4gIF9nZXRFdmVudHMocGhhc2U/OiBUcmFuc2l0aW9uSG9va1BoYXNlKTogVHJhbnNpdGlvbkV2ZW50VHlwZVtdO1xuXG4gIC8qKiBSZXR1cm5zIHRoZSBob29rcyByZWdpc3RlcmVkIGZvciB0aGUgZ2l2ZW4gaG9vayBuYW1lICovXG4gIGdldEhvb2tzKGhvb2tOYW1lOiBzdHJpbmcpOiBSZWdpc3RlcmVkSG9va1tdO1xufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucy5cbiAqXG4gKiAtIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsbG93cyBnbG9iYWwgVHJhbnNpdGlvbiBIb29rcyB0byBiZSByZWdpc3RlcmVkLlxuICogLSBJdCBhbGxvd3MgdGhlIGRlZmF1bHQgdHJhbnNpdGlvbiBlcnJvciBoYW5kbGVyIHRvIGJlIHNldC5cbiAqIC0gSXQgYWxzbyBoYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgW1tUcmFuc2l0aW9uXV0gb2JqZWN0cywgKHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tTdGF0ZVNlcnZpY2VdXSkuXG4gKlxuICogQXQgYm9vdHN0cmFwLCBbW1VJUm91dGVyXV0gY3JlYXRlcyBhIHNpbmdsZSBpbnN0YW5jZSAoc2luZ2xldG9uKSBvZiB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNpdGlvblNlcnZpY2UgaW1wbGVtZW50cyBJSG9va1JlZ2lzdHJ5LCBEaXNwb3NhYmxlIHtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgX3RyYW5zaXRpb25Db3VudCA9IDA7XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHVibGljICR2aWV3OiBWaWV3U2VydmljZTtcblxuICAvKiogQGhpZGRlbiBUaGUgdHJhbnNpdGlvbiBob29rIHR5cGVzLCBzdWNoIGFzIGBvbkVudGVyYCwgYG9uU3RhcnRgLCBldGMgKi9cbiAgcHJpdmF0ZSBfZXZlbnRUeXBlczogVHJhbnNpdGlvbkV2ZW50VHlwZVtdID0gW107XG4gIC8qKiBAaGlkZGVuIFRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MgKi9cbiAgX3JlZ2lzdGVyZWRIb29rcyA9IHt9IGFzIFJlZ2lzdGVyZWRIb29rcztcbiAgLyoqIEBoaWRkZW4gVGhlICBwYXRocyBvbiBhIGNyaXRlcmlhIG9iamVjdCAqL1xuICBwcml2YXRlIF9jcml0ZXJpYVBhdGhzID0ge30gYXMgUGF0aFR5cGVzO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9yb3V0ZXI6IFVJUm91dGVyO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgX3BsdWdpbmFwaTogVHJhbnNpdGlvblNlcnZpY2VQbHVnaW5BUEk7XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGhhcyBob29rIGRlLXJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgZm9yIHRoZSBidWlsdC1pbiBob29rcy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBieSB0aGlyZCBwYXJ0aWVzIGxpYnJhcmllcyB0aGF0IHdpc2ggdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvcnNcbiAgICpcbiAgICogQGhpZGRlblxuICAgKi9cbiAgX2RlcmVnaXN0ZXJIb29rRm5zOiB7XG4gICAgYWRkQ29yZVJlc29sdmVzOiBGdW5jdGlvbjtcbiAgICBpZ25vcmVkOiBGdW5jdGlvbjtcbiAgICBpbnZhbGlkOiBGdW5jdGlvbjtcbiAgICByZWRpcmVjdFRvOiBGdW5jdGlvbjtcbiAgICBvbkV4aXQ6IEZ1bmN0aW9uO1xuICAgIG9uUmV0YWluOiBGdW5jdGlvbjtcbiAgICBvbkVudGVyOiBGdW5jdGlvbjtcbiAgICBlYWdlclJlc29sdmU6IEZ1bmN0aW9uO1xuICAgIGxhenlSZXNvbHZlOiBGdW5jdGlvbjtcbiAgICByZXNvbHZlQWxsOiBGdW5jdGlvbjtcbiAgICBsb2FkVmlld3M6IEZ1bmN0aW9uO1xuICAgIGFjdGl2YXRlVmlld3M6IEZ1bmN0aW9uO1xuICAgIHVwZGF0ZUdsb2JhbHM6IEZ1bmN0aW9uO1xuICAgIHVwZGF0ZVVybDogRnVuY3Rpb247XG4gICAgbGF6eUxvYWQ6IEZ1bmN0aW9uO1xuICB9O1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKF9yb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgdGhpcy5fcm91dGVyID0gX3JvdXRlcjtcbiAgICB0aGlzLiR2aWV3ID0gX3JvdXRlci52aWV3U2VydmljZTtcbiAgICB0aGlzLl9kZXJlZ2lzdGVySG9va0ZucyA9IDxhbnk+e307XG4gICAgdGhpcy5fcGx1Z2luYXBpID0gPFRyYW5zaXRpb25TZXJ2aWNlUGx1Z2luQVBJPihcbiAgICAgIGNyZWF0ZVByb3h5RnVuY3Rpb25zKHZhbCh0aGlzKSwge30sIHZhbCh0aGlzKSwgW1xuICAgICAgICAnX2RlZmluZVBhdGhUeXBlJyxcbiAgICAgICAgJ19kZWZpbmVFdmVudCcsXG4gICAgICAgICdfZ2V0UGF0aFR5cGVzJyxcbiAgICAgICAgJ19nZXRFdmVudHMnLFxuICAgICAgICAnZ2V0SG9va3MnLFxuICAgICAgXSlcbiAgICApO1xuXG4gICAgdGhpcy5fZGVmaW5lQ29yZVBhdGhzKCk7XG4gICAgdGhpcy5fZGVmaW5lQ29yZUV2ZW50cygpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcygpO1xuICAgIF9yb3V0ZXIuZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMub25FdmljdCh0cmVlQ2hhbmdlc0NsZWFudXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgZHVyaW5nIHRyYW5zaXRpb24gY29uc3RydWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGxvdyBsZXZlbCBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgcGx1Z2lucy5cbiAgICogVGhpcyBjYW4gYmUgYSB1c2VmdWwgdGltZSBmb3IgcGx1Z2lucyB0byBhZGQgcmVzb2x2ZXMgb3IgbXV0YXRlIHRoZSB0cmFuc2l0aW9uIGFzIG5lZWRlZC5cbiAgICogVGhlIFN0aWNreSBTdGF0ZXMgcGx1Z2luIHVzZXMgdGhpcyBob29rIHRvIG1vZGlmeSB0aGUgdHJlZWNoYW5nZXMuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogYG9uQ3JlYXRlYCBob29rcyBhcmUgaW52b2tlZCAqd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGJlaW5nIGNvbnN0cnVjdGVkKi5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKiBAcGFyYW0gY3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSByZWdpc3RyYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgKi9cbiAgb25DcmVhdGUoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkNyZWF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25CZWZvcmUoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25TdGFydChjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvbkV4aXQoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvblJldGFpbihjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uRW50ZXIoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvbkZpbmlzaChjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvblN1Y2Nlc3MoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25FcnJvcihjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2VcbiAgICogQGludGVybmFsYXBpXG4gICAqL1xuICBkaXNwb3NlKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICB2YWx1ZXModGhpcy5fcmVnaXN0ZXJlZEhvb2tzKS5mb3JFYWNoKChob29rc0FycmF5OiBSZWdpc3RlcmVkSG9va1tdKSA9PlxuICAgICAgaG9va3NBcnJheS5mb3JFYWNoKGhvb2sgPT4ge1xuICAgICAgICBob29rLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICByZW1vdmVGcm9tKGhvb2tzQXJyYXksIGhvb2spO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgW1tUcmFuc2l0aW9uXV0gb2JqZWN0XG4gICAqXG4gICAqIFRoaXMgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgVHJhbnNpdGlvbiBvYmplY3RzLlxuICAgKiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0gYW5kIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIGNhbGxlZCBieSBhcHBsaWNhdGlvbiBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbVBhdGggdGhlIHBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgKHRoZSBmcm9tIHN0YXRlKVxuICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIHRhcmdldCBzdGF0ZSAoZGVzdGluYXRpb24pXG4gICAqIEByZXR1cm5zIGEgVHJhbnNpdGlvblxuICAgKi9cbiAgY3JlYXRlKGZyb21QYXRoOiBQYXRoTm9kZVtdLCB0YXJnZXRTdGF0ZTogVGFyZ2V0U3RhdGUpOiBUcmFuc2l0aW9uIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZnJvbVBhdGgsIHRhcmdldFN0YXRlLCB0aGlzLl9yb3V0ZXIpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfZGVmaW5lQ29yZUV2ZW50cygpIHtcbiAgICBjb25zdCBQaGFzZSA9IFRyYW5zaXRpb25Ib29rUGhhc2U7XG4gICAgY29uc3QgVEggPSBUcmFuc2l0aW9uSG9vaztcbiAgICBjb25zdCBwYXRocyA9IHRoaXMuX2NyaXRlcmlhUGF0aHM7XG4gICAgY29uc3QgTk9STUFMX1NPUlQgPSBmYWxzZSxcbiAgICAgIFJFVkVSU0VfU09SVCA9IHRydWU7XG4gICAgY29uc3QgU1lOQ0hST05PVVMgPSB0cnVlO1xuXG4gICAgdGhpcy5fZGVmaW5lRXZlbnQoXG4gICAgICAnb25DcmVhdGUnLFxuICAgICAgUGhhc2UuQ1JFQVRFLFxuICAgICAgMCxcbiAgICAgIHBhdGhzLnRvLFxuICAgICAgTk9STUFMX1NPUlQsXG4gICAgICBUSC5MT0dfUkVKRUNURURfUkVTVUxULFxuICAgICAgVEguVEhST1dfRVJST1IsXG4gICAgICBTWU5DSFJPTk9VU1xuICAgICk7XG5cbiAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25CZWZvcmUnLCBQaGFzZS5CRUZPUkUsIDAsIHBhdGhzLnRvKTtcblxuICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvblN0YXJ0JywgUGhhc2UuUlVOLCAwLCBwYXRocy50byk7XG4gICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uRXhpdCcsIFBoYXNlLlJVTiwgMTAwLCBwYXRocy5leGl0aW5nLCBSRVZFUlNFX1NPUlQpO1xuICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvblJldGFpbicsIFBoYXNlLlJVTiwgMjAwLCBwYXRocy5yZXRhaW5lZCk7XG4gICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uRW50ZXInLCBQaGFzZS5SVU4sIDMwMCwgcGF0aHMuZW50ZXJpbmcpO1xuICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkZpbmlzaCcsIFBoYXNlLlJVTiwgNDAwLCBwYXRocy50byk7XG5cbiAgICB0aGlzLl9kZWZpbmVFdmVudChcbiAgICAgICdvblN1Y2Nlc3MnLFxuICAgICAgUGhhc2UuU1VDQ0VTUyxcbiAgICAgIDAsXG4gICAgICBwYXRocy50byxcbiAgICAgIE5PUk1BTF9TT1JULFxuICAgICAgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCxcbiAgICAgIFRILkxPR19FUlJPUixcbiAgICAgIFNZTkNIUk9OT1VTXG4gICAgKTtcbiAgICB0aGlzLl9kZWZpbmVFdmVudChcbiAgICAgICdvbkVycm9yJyxcbiAgICAgIFBoYXNlLkVSUk9SLFxuICAgICAgMCxcbiAgICAgIHBhdGhzLnRvLFxuICAgICAgTk9STUFMX1NPUlQsXG4gICAgICBUSC5MT0dfUkVKRUNURURfUkVTVUxULFxuICAgICAgVEguTE9HX0VSUk9SLFxuICAgICAgU1lOQ0hST05PVVNcbiAgICApO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfZGVmaW5lQ29yZVBhdGhzKCkge1xuICAgIGNvbnN0IHsgU1RBVEUsIFRSQU5TSVRJT04gfSA9IFRyYW5zaXRpb25Ib29rU2NvcGU7XG5cbiAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgndG8nLCBUUkFOU0lUSU9OKTtcbiAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgnZnJvbScsIFRSQU5TSVRJT04pO1xuICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKCdleGl0aW5nJywgU1RBVEUpO1xuICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKCdyZXRhaW5lZCcsIFNUQVRFKTtcbiAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgnZW50ZXJpbmcnLCBTVEFURSk7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBfZGVmaW5lRXZlbnQoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIGhvb2tQaGFzZTogVHJhbnNpdGlvbkhvb2tQaGFzZSxcbiAgICBob29rT3JkZXI6IG51bWJlcixcbiAgICBjcml0ZXJpYU1hdGNoUGF0aDogUGF0aFR5cGUsXG4gICAgcmV2ZXJzZVNvcnQgPSBmYWxzZSxcbiAgICBnZXRSZXN1bHRIYW5kbGVyOiBHZXRSZXN1bHRIYW5kbGVyID0gVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVCxcbiAgICBnZXRFcnJvckhhbmRsZXI6IEdldEVycm9ySGFuZGxlciA9IFRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUixcbiAgICBzeW5jaHJvbm91cyA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IG5ldyBUcmFuc2l0aW9uRXZlbnRUeXBlKFxuICAgICAgbmFtZSxcbiAgICAgIGhvb2tQaGFzZSxcbiAgICAgIGhvb2tPcmRlcixcbiAgICAgIGNyaXRlcmlhTWF0Y2hQYXRoLFxuICAgICAgcmV2ZXJzZVNvcnQsXG4gICAgICBnZXRSZXN1bHRIYW5kbGVyLFxuICAgICAgZ2V0RXJyb3JIYW5kbGVyLFxuICAgICAgc3luY2hyb25vdXNcbiAgICApO1xuXG4gICAgdGhpcy5fZXZlbnRUeXBlcy5wdXNoKGV2ZW50VHlwZSk7XG4gICAgbWFrZUV2ZW50KHRoaXMsIHRoaXMsIGV2ZW50VHlwZSk7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgcHJpdmF0ZSBfZ2V0RXZlbnRzKHBoYXNlPzogVHJhbnNpdGlvbkhvb2tQaGFzZSk6IFRyYW5zaXRpb25FdmVudFR5cGVbXSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbkhvb2tUeXBlcyA9IGlzRGVmaW5lZChwaGFzZSlcbiAgICAgID8gdGhpcy5fZXZlbnRUeXBlcy5maWx0ZXIodHlwZSA9PiB0eXBlLmhvb2tQaGFzZSA9PT0gcGhhc2UpXG4gICAgICA6IHRoaXMuX2V2ZW50VHlwZXMuc2xpY2UoKTtcblxuICAgIHJldHVybiB0cmFuc2l0aW9uSG9va1R5cGVzLnNvcnQoKGwsIHIpID0+IHtcbiAgICAgIGNvbnN0IGNtcEJ5UGhhc2UgPSBsLmhvb2tQaGFzZSAtIHIuaG9va1BoYXNlO1xuICAgICAgcmV0dXJuIGNtcEJ5UGhhc2UgPT09IDAgPyBsLmhvb2tPcmRlciAtIHIuaG9va09yZGVyIDogY21wQnlQaGFzZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgUGF0aCB0byBiZSB1c2VkIGFzIGEgY3JpdGVyaW9uIGFnYWluc3QgYSBUcmVlQ2hhbmdlcyBwYXRoXG4gICAqXG4gICAqIEZvciBleGFtcGxlOiB0aGUgYGV4aXRpbmdgIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgU1RBVEUgc2NvcGVkIHBhdGguXG4gICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCdleGl0aW5nJywgVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSlgXG4gICAqIEVhY2ggc3RhdGUgaW4gdGhlIGV4aXRpbmcgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cbiAgICpcbiAgICogQW5vdGhlciBleGFtcGxlOiB0aGUgYHRvYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFRSQU5TSVRJT04gc2NvcGVkIHBhdGguXG4gICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCd0bycsIFRyYW5zaXRpb25Ib29rU2NvcGUuVFJBTlNJVElPTilgXG4gICAqIE9ubHkgdGhlIHRhaWwgb2YgdGhlIGB0b2AgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cbiAgICpcbiAgICogQGhpZGRlblxuICAgKi9cbiAgcHJpdmF0ZSBfZGVmaW5lUGF0aFR5cGUobmFtZTogc3RyaW5nLCBob29rU2NvcGU6IFRyYW5zaXRpb25Ib29rU2NvcGUpIHtcbiAgICB0aGlzLl9jcml0ZXJpYVBhdGhzW25hbWVdID0geyBuYW1lLCBzY29wZTogaG9va1Njb3BlIH07XG4gIH1cblxuICAvKiogKiBAaGlkZGVuICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICBwcml2YXRlIF9nZXRQYXRoVHlwZXMoKTogUGF0aFR5cGVzIHtcbiAgICByZXR1cm4gdGhpcy5fY3JpdGVyaWFQYXRocztcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHB1YmxpYyBnZXRIb29rcyhob29rTmFtZTogc3RyaW5nKTogUmVnaXN0ZXJlZEhvb2tbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRIb29rc1tob29rTmFtZV07XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9yZWdpc3RlckNvcmVUcmFuc2l0aW9uSG9va3MoKSB7XG4gICAgY29uc3QgZm5zID0gdGhpcy5fZGVyZWdpc3Rlckhvb2tGbnM7XG5cbiAgICBmbnMuYWRkQ29yZVJlc29sdmVzID0gcmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXModGhpcyk7XG4gICAgZm5zLmlnbm9yZWQgPSByZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayh0aGlzKTtcbiAgICBmbnMuaW52YWxpZCA9IHJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xuXG4gICAgLy8gV2lyZSB1cCByZWRpcmVjdFRvIGhvb2tcbiAgICBmbnMucmVkaXJlY3RUbyA9IHJlZ2lzdGVyUmVkaXJlY3RUb0hvb2sodGhpcyk7XG5cbiAgICAvLyBXaXJlIHVwIG9uRXhpdC9SZXRhaW4vRW50ZXIgc3RhdGUgaG9va3NcbiAgICBmbnMub25FeGl0ID0gcmVnaXN0ZXJPbkV4aXRIb29rKHRoaXMpO1xuICAgIGZucy5vblJldGFpbiA9IHJlZ2lzdGVyT25SZXRhaW5Ib29rKHRoaXMpO1xuICAgIGZucy5vbkVudGVyID0gcmVnaXN0ZXJPbkVudGVySG9vayh0aGlzKTtcblxuICAgIC8vIFdpcmUgdXAgUmVzb2x2ZSBob29rc1xuICAgIGZucy5lYWdlclJlc29sdmUgPSByZWdpc3RlckVhZ2VyUmVzb2x2ZVBhdGgodGhpcyk7XG4gICAgZm5zLmxhenlSZXNvbHZlID0gcmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlKHRoaXMpO1xuICAgIGZucy5yZXNvbHZlQWxsID0gcmVnaXN0ZXJSZXNvbHZlUmVtYWluaW5nKHRoaXMpO1xuXG4gICAgLy8gV2lyZSB1cCB0aGUgVmlldyBtYW5hZ2VtZW50IGhvb2tzXG4gICAgZm5zLmxvYWRWaWV3cyA9IHJlZ2lzdGVyTG9hZEVudGVyaW5nVmlld3ModGhpcyk7XG4gICAgZm5zLmFjdGl2YXRlVmlld3MgPSByZWdpc3RlckFjdGl2YXRlVmlld3ModGhpcyk7XG5cbiAgICAvLyBVcGRhdGVzIGdsb2JhbCBzdGF0ZSBhZnRlciBhIHRyYW5zaXRpb25cbiAgICBmbnMudXBkYXRlR2xvYmFscyA9IHJlZ2lzdGVyVXBkYXRlR2xvYmFsU3RhdGUodGhpcyk7XG5cbiAgICAvLyBBZnRlciBnbG9iYWxzLmN1cnJlbnQgaXMgdXBkYXRlZCBhdCBwcmlvcml0eTogMTAwMDBcbiAgICBmbnMudXBkYXRlVXJsID0gcmVnaXN0ZXJVcGRhdGVVcmwodGhpcyk7XG5cbiAgICAvLyBMYXp5IGxvYWQgc3RhdGUgdHJlZXNcbiAgICBmbnMubGF6eUxvYWQgPSByZWdpc3RlckxhenlMb2FkSG9vayh0aGlzKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBzdGF0ZSAqLyAvKiogKi9cbmltcG9ydCB7XG4gIGNyZWF0ZVByb3h5RnVuY3Rpb25zLFxuICBkZWZhdWx0cyxcbiAgZXh0ZW5kLFxuICBpbkFycmF5LFxuICBub29wLFxuICByZW1vdmVGcm9tLFxuICBzaWxlbmNlVW5jYXVnaHRJblByb21pc2UsXG4gIHNpbGVudFJlamVjdGlvbixcbn0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1N0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFF1ZXVlIH0gZnJvbSAnLi4vY29tbW9uL3F1ZXVlJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5cbmltcG9ydCB7IFBhdGhVdGlscyB9IGZyb20gJy4uL3BhdGgvcGF0aFV0aWxzJztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5cbmltcG9ydCB7IEhvb2tSZXN1bHQsIFRyYW5zaXRpb25PcHRpb25zIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgZGVmYXVsdFRyYW5zT3B0cyB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgUmVqZWN0aW9uLCBSZWplY3RUeXBlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5JztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuXG5pbXBvcnQgeyBIcmVmT3B0aW9ucywgTGF6eUxvYWRSZXN1bHQsIFN0YXRlRGVjbGFyYXRpb24sIFN0YXRlT3JOYW1lLCBUcmFuc2l0aW9uUHJvbWlzZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4vdGFyZ2V0U3RhdGUnO1xuXG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMvaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhcmFtIH0gZnJvbSAnLi4vcGFyYW1zL3BhcmFtJztcbmltcG9ydCB7IEdsb2IgfSBmcm9tICcuLi9jb21tb24vZ2xvYic7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBVSUluamVjdG9yIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFJlc29sdmVDb250ZXh0IH0gZnJvbSAnLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dCc7XG5pbXBvcnQgeyBsYXp5TG9hZFN0YXRlIH0gZnJvbSAnLi4vaG9va3MvbGF6eUxvYWQnO1xuaW1wb3J0IHsgbm90LCB2YWwgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IFN0YXRlUGFyYW1zIH0gZnJvbSAnLi4vcGFyYW1zL3N0YXRlUGFyYW1zJztcblxuZXhwb3J0IHR5cGUgT25JbnZhbGlkQ2FsbGJhY2sgPSAodG9TdGF0ZT86IFRhcmdldFN0YXRlLCBmcm9tU3RhdGU/OiBUYXJnZXRTdGF0ZSwgaW5qZWN0b3I/OiBVSUluamVjdG9yKSA9PiBIb29rUmVzdWx0O1xuXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRlIHJlbGF0ZWQgc2VydmljZSBmdW5jdGlvbnNcbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdWktcm91dGVyIHN0YXRlcy5cbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgbG9jYXRlZCBvbiB0aGUgZ2xvYmFsIFtbVUlSb3V0ZXJdXSBvYmplY3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0ZVNlcnZpY2Uge1xuICAvKiogQGludGVybmFsYXBpICovXG4gIGludmFsaWRDYWxsYmFja3M6IE9uSW52YWxpZENhbGxiYWNrW10gPSBbXTtcblxuICAvKipcbiAgICogVGhlIFtbVHJhbnNpdGlvbl1dIGN1cnJlbnRseSBpbiBwcm9ncmVzcyAob3IgbnVsbClcbiAgICpcbiAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMudHJhbnNpdGlvbl1dXG4gICAqL1xuICBnZXQgdHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgc3RhdGUgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy5wYXJhbXNdXVxuICAgKi9cbiAgZ2V0IHBhcmFtcygpOiBTdGF0ZVBhcmFtcyB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMucGFyYW1zO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBbW1N0YXRlRGVjbGFyYXRpb25dXVxuICAgKlxuICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy5jdXJyZW50XV1cbiAgICovXG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IFtbU3RhdGVPYmplY3RdXVxuICAgKlxuICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy4kY3VycmVudF1dXG4gICAqL1xuICBnZXQgJGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMuJGN1cnJlbnQ7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge1xuICAgIGNvbnN0IGdldHRlcnMgPSBbJ2N1cnJlbnQnLCAnJGN1cnJlbnQnLCAncGFyYW1zJywgJ3RyYW5zaXRpb24nXTtcbiAgICBjb25zdCBib3VuZEZucyA9IE9iamVjdC5rZXlzKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLmZpbHRlcihub3QoaW5BcnJheShnZXR0ZXJzKSkpO1xuICAgIGNyZWF0ZVByb3h5RnVuY3Rpb25zKHZhbChTdGF0ZVNlcnZpY2UucHJvdG90eXBlKSwgdGhpcywgdmFsKHRoaXMpLCBib3VuZEZucyk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKG5vb3ApO1xuICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIHdoZW4gW1t0cmFuc2l0aW9uVG9dXSBpcyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXRlLlxuICAgKlxuICAgKiBJbnZva2VzIHRoZSBbW29uSW52YWxpZF1dIGNhbGxiYWNrcywgaW4gbmF0dXJhbCBvcmRlci5cbiAgICogRWFjaCBjYWxsYmFjaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkIGluIHNlcXVlbmNlIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFyZ2V0U3RhdGUuXG4gICAqIFRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFja3MgYXJlIHdyYXBwZWQgaW4gJHEud2hlbigpLCBzbyB0aGUgY2FsbGJhY2tzIG1heSByZXR1cm4gcHJvbWlzZXMuXG4gICAqXG4gICAqIElmIGEgY2FsbGJhY2sgcmV0dXJucyBhbiBUYXJnZXRTdGF0ZSwgdGhlbiBpdCBpcyB1c2VkIGFzIGFyZ3VtZW50cyB0byAkc3RhdGUudHJhbnNpdGlvblRvKCkgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgcHJpdmF0ZSBfaGFuZGxlSW52YWxpZFRhcmdldFN0YXRlKGZyb21QYXRoOiBQYXRoTm9kZVtdLCB0b1N0YXRlOiBUYXJnZXRTdGF0ZSkge1xuICAgIGNvbnN0IGZyb21TdGF0ZSA9IFBhdGhVdGlscy5tYWtlVGFyZ2V0U3RhdGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeSwgZnJvbVBhdGgpO1xuICAgIGNvbnN0IGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgIGNvbnN0IGxhdGVzdFRoaW5nID0gKCkgPT4gZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5wZWVrVGFpbCgpO1xuICAgIGNvbnN0IGxhdGVzdCA9IGxhdGVzdFRoaW5nKCk7XG4gICAgY29uc3QgY2FsbGJhY2tRdWV1ZSA9IG5ldyBRdWV1ZTxPbkludmFsaWRDYWxsYmFjaz4odGhpcy5pbnZhbGlkQ2FsbGJhY2tzLnNsaWNlKCkpO1xuICAgIGNvbnN0IGluamVjdG9yID0gbmV3IFJlc29sdmVDb250ZXh0KGZyb21QYXRoKS5pbmplY3RvcigpO1xuXG4gICAgY29uc3QgY2hlY2tGb3JSZWRpcmVjdCA9IChyZXN1bHQ6IEhvb2tSZXN1bHQpID0+IHtcbiAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFRhcmdldFN0YXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB0YXJnZXQgPSA8VGFyZ2V0U3RhdGU+cmVzdWx0O1xuICAgICAgLy8gUmVjcmVhdGUgdGhlIFRhcmdldFN0YXRlLCBpbiBjYXNlIHRoZSBzdGF0ZSBpcyBub3cgZGVmaW5lZC5cbiAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0KHRhcmdldC5pZGVudGlmaWVyKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7XG5cbiAgICAgIGlmICghdGFyZ2V0LnZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIFJlamVjdGlvbi5pbnZhbGlkKHRhcmdldC5lcnJvcigpKS50b1Byb21pc2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhdGVzdFRoaW5nKCkgIT09IGxhdGVzdCkge1xuICAgICAgICByZXR1cm4gUmVqZWN0aW9uLnN1cGVyc2VkZWQoKS50b1Byb21pc2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRhcmdldC5pZGVudGlmaWVyKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGludm9rZU5leHRDYWxsYmFjaygpIHtcbiAgICAgIGNvbnN0IG5leHRDYWxsYmFjayA9IGNhbGxiYWNrUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgaWYgKG5leHRDYWxsYmFjayA9PT0gdW5kZWZpbmVkKSByZXR1cm4gUmVqZWN0aW9uLmludmFsaWQodG9TdGF0ZS5lcnJvcigpKS50b1Byb21pc2UoKTtcblxuICAgICAgY29uc3QgY2FsbGJhY2tSZXN1bHQgPSBzZXJ2aWNlcy4kcS53aGVuKG5leHRDYWxsYmFjayh0b1N0YXRlLCBmcm9tU3RhdGUsIGluamVjdG9yKSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2tSZXN1bHQudGhlbihjaGVja0ZvclJlZGlyZWN0KS50aGVuKHJlc3VsdCA9PiByZXN1bHQgfHwgaW52b2tlTmV4dENhbGxiYWNrKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnZva2VOZXh0Q2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gSW52YWxpZCBTdGF0ZSBoYW5kbGVyXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIFtbT25JbnZhbGlkQ2FsbGJhY2tdXSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cbiAgICogaGFzIGJlZW4gY2FsbGVkIHdpdGggYW4gaW52YWxpZCBzdGF0ZSByZWZlcmVuY2UgcGFyYW1ldGVyXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHN0YXRlU2VydmljZS5vbkludmFsaWQoZnVuY3Rpb24odG8sIGZyb20sIGluamVjdG9yKSB7XG4gICAqICAgaWYgKHRvLm5hbWUoKSA9PT0gJ2ZvbycpIHtcbiAgICogICAgIGxldCBsYXp5TG9hZGVyID0gaW5qZWN0b3IuZ2V0KCdMYXp5TG9hZFNlcnZpY2UnKTtcbiAgICogICAgIHJldHVybiBsYXp5TG9hZGVyLmxvYWQoJ2ZvbycpXG4gICAqICAgICAgICAgLnRoZW4oKCkgPT4gc3RhdGVTZXJ2aWNlLnRhcmdldCgnZm9vJykpO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIHRvU3RhdGUgaXMgaW52YWxpZFxuICAgKiAgIFRoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIChpbnZhbGlkKSB0b1N0YXRlLCB0aGUgZnJvbVN0YXRlLCBhbmQgYW4gaW5qZWN0b3IuXG4gICAqICAgVGhlIGZ1bmN0aW9uIG1heSBvcHRpb25hbGx5IHJldHVybiBhIFtbVGFyZ2V0U3RhdGVdXSBvciBhIFByb21pc2UgZm9yIGEgVGFyZ2V0U3RhdGUuXG4gICAqICAgSWYgb25lIGlzIHJldHVybmVkLCBpdCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBvbkludmFsaWQoY2FsbGJhY2s6IE9uSW52YWxpZENhbGxiYWNrKTogRnVuY3Rpb24ge1xuICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgcmVtb3ZlRnJvbSh0aGlzLmludmFsaWRDYWxsYmFja3MpKGNhbGxiYWNrKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKlxuICAgKiBBIG1ldGhvZCB0aGF0IGZvcmNlIHJlbG9hZHMgdGhlIGN1cnJlbnQgc3RhdGUsIG9yIGEgcGFydGlhbCBzdGF0ZSBoaWVyYXJjaHkuXG4gICAqIEFsbCByZXNvbHZlcyBhcmUgcmUtcmVzb2x2ZWQsIGFuZCBjb21wb25lbnRzIHJlaW5zdGFudGlhdGVkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGxldCBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgKiAgICAgJHN0YXRlLnJlbG9hZCgpO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlOiBgcmVsb2FkKClgIGlzIGp1c3QgYW4gYWxpYXMgZm9yOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUudHJhbnNpdGlvblRvKCRzdGF0ZS5jdXJyZW50LCAkc3RhdGUucGFyYW1zLCB7XG4gICAqICAgcmVsb2FkOiB0cnVlLCBpbmhlcml0OiBmYWxzZVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByZWxvYWRTdGF0ZSBBIHN0YXRlIG5hbWUgb3IgYSBzdGF0ZSBvYmplY3QuXG4gICAqICAgIElmIHByZXNlbnQsIHRoaXMgc3RhdGUgYW5kIGFsbCBpdHMgY2hpbGRyZW4gd2lsbCBiZSByZWxvYWRlZCwgYnV0IGFuY2VzdG9ycyB3aWxsIG5vdCByZWxvYWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy9hc3N1bWluZyBhcHAgYXBwbGljYXRpb24gY29uc2lzdHMgb2YgMyBzdGF0ZXM6ICdjb250YWN0cycsICdjb250YWN0cy5kZXRhaWwnLCAnY29udGFjdHMuZGV0YWlsLml0ZW0nXG4gICAqIC8vYW5kIGN1cnJlbnQgc3RhdGUgaXMgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgKiBsZXQgYXBwIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICogICAkc2NvcGUucmVsb2FkID0gZnVuY3Rpb24oKXtcbiAgICogICAgIC8vd2lsbCByZWxvYWQgJ2NvbnRhY3QuZGV0YWlsJyBhbmQgbmVzdGVkICdjb250YWN0LmRldGFpbC5pdGVtJyBzdGF0ZXNcbiAgICogICAgICRzdGF0ZS5yZWxvYWQoJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlIFtbU3RhdGVTZXJ2aWNlLmdvXV1cbiAgICovXG4gIHJlbG9hZChyZWxvYWRTdGF0ZT86IFN0YXRlT3JOYW1lKTogUHJvbWlzZTxTdGF0ZU9iamVjdD4ge1xuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLmN1cnJlbnQsIHRoaXMucGFyYW1zLCB7XG4gICAgICByZWxvYWQ6IGlzRGVmaW5lZChyZWxvYWRTdGF0ZSkgPyByZWxvYWRTdGF0ZSA6IHRydWUsXG4gICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgIG5vdGlmeTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNpdGlvbiB0byBhIGRpZmZlcmVudCBzdGF0ZSBhbmQvb3IgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgc3RhdGUuXG4gICAqXG4gICAqIGAkc3RhdGUuZ29gIGNhbGxzIGAkc3RhdGUudHJhbnNpdGlvblRvYCBpbnRlcm5hbGx5IGJ1dCBhdXRvbWF0aWNhbGx5IHNldHMgb3B0aW9ucyB0b1xuICAgKiBgeyBsb2NhdGlvbjogdHJ1ZSwgaW5oZXJpdDogdHJ1ZSwgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50LCBub3RpZnk6IHRydWUgfWAuXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgZWl0aGVyIGFuIGFic29sdXRlIG9yIHJlbGF0aXZlIGB0b2AgYXJndW1lbnQgKGJlY2F1c2Ugb2YgYHJlbGF0aXZlOiByb3V0ZXIuZ2xvYmFscy4kY3VycmVudGApLlxuICAgKiBJdCBhbHNvIGFsbG93cyB5b3UgdG8gc3BlY2lmeSAqIG9ubHkgdGhlIHBhcmFtZXRlcnMgeW91J2QgbGlrZSB0byB1cGRhdGUsIHdoaWxlIGxldHRpbmcgdW5zcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAgKiBpbmhlcml0IGZyb20gdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyAoYmVjYXVzZSBvZiBgaW5oZXJpdDogdHJ1ZWApLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgKiAgICAgJHN0YXRlLmdvKCdjb250YWN0LmRldGFpbCcpO1xuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRvIEFic29sdXRlIHN0YXRlIG5hbWUsIHN0YXRlIG9iamVjdCwgb3IgcmVsYXRpdmUgc3RhdGUgcGF0aCAocmVsYXRpdmUgdG8gY3VycmVudCBzdGF0ZSkuXG4gICAqXG4gICAqIFNvbWUgZXhhbXBsZXM6XG4gICAqXG4gICAqIC0gYCRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKWAgLSB3aWxsIGdvIHRvIHRoZSBgY29udGFjdC5kZXRhaWxgIHN0YXRlXG4gICAqIC0gYCRzdGF0ZS5nbygnXicpYCAtIHdpbGwgZ28gdG8gdGhlIHBhcmVudCBzdGF0ZVxuICAgKiAtIGAkc3RhdGUuZ28oJ14uc2libGluZycpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgYGhvbWUuY2hpbGRgLCB3aWxsIGdvIHRvIHRoZSBgaG9tZS5zaWJsaW5nYCBzdGF0ZVxuICAgKiAtIGAkc3RhdGUuZ28oJy5jaGlsZC5ncmFuZGNoaWxkJylgIC0gaWYgY3VycmVudCBzdGF0ZSBpcyBob21lLCB3aWxsIGdvIHRvIHRoZSBgaG9tZS5jaGlsZC5ncmFuZGNoaWxkYCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIEEgbWFwIG9mIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBzdGF0ZSwgd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXG4gICAqXG4gICAqICAgIEFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgKGJlY2F1c2Ugb2YgYGluaGVyaXQ6IHRydWVgKS5cbiAgICogICAgVGhpcyBhbGxvd3MsIGZvciBleGFtcGxlLCBnb2luZyB0byBhIHNpYmxpbmcgc3RhdGUgdGhhdCBzaGFyZXMgcGFyYW1ldGVycyBkZWZpbmVkIGJ5IGEgcGFyZW50IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge3Byb21pc2V9IEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi5cbiAgICovXG4gIGdvKHRvOiBTdGF0ZU9yTmFtZSwgcGFyYW1zPzogUmF3UGFyYW1zLCBvcHRpb25zPzogVHJhbnNpdGlvbk9wdGlvbnMpOiBUcmFuc2l0aW9uUHJvbWlzZSB7XG4gICAgY29uc3QgZGVmYXV0R29PcHRzID0geyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCwgaW5oZXJpdDogdHJ1ZSB9O1xuICAgIGNvbnN0IHRyYW5zT3B0cyA9IGRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1dEdvT3B0cywgZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRvLCBwYXJhbXMsIHRyYW5zT3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFtbVGFyZ2V0U3RhdGVdXVxuICAgKlxuICAgKiBUaGlzIGlzIGEgZmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgVGFyZ2V0U3RhdGVcbiAgICpcbiAgICogVGhpcyBtYXkgYmUgcmV0dXJuZWQgZnJvbSBhIFRyYW5zaXRpb24gSG9vayB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24sIGZvciBleGFtcGxlLlxuICAgKi9cbiAgdGFyZ2V0KGlkZW50aWZpZXI6IFN0YXRlT3JOYW1lLCBwYXJhbXM/OiBSYXdQYXJhbXMsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pOiBUYXJnZXRTdGF0ZSB7XG4gICAgLy8gSWYgd2UncmUgcmVsb2FkaW5nLCBmaW5kIHRoZSBzdGF0ZSBvYmplY3QgdG8gcmVsb2FkIGZyb21cbiAgICBpZiAoaXNPYmplY3Qob3B0aW9ucy5yZWxvYWQpICYmICEoPGFueT5vcHRpb25zLnJlbG9hZCkubmFtZSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbG9hZCBzdGF0ZSBvYmplY3QnKTtcbiAgICBjb25zdCByZWcgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xuICAgIG9wdGlvbnMucmVsb2FkU3RhdGUgPVxuICAgICAgb3B0aW9ucy5yZWxvYWQgPT09IHRydWUgPyByZWcucm9vdCgpIDogcmVnLm1hdGNoZXIuZmluZCg8YW55Pm9wdGlvbnMucmVsb2FkLCBvcHRpb25zLnJlbGF0aXZlKTtcblxuICAgIGlmIChvcHRpb25zLnJlbG9hZCAmJiAhb3B0aW9ucy5yZWxvYWRTdGF0ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIHN1Y2ggcmVsb2FkIHN0YXRlICcke2lzU3RyaW5nKG9wdGlvbnMucmVsb2FkKSA/IG9wdGlvbnMucmVsb2FkIDogKDxhbnk+b3B0aW9ucy5yZWxvYWQpLm5hbWV9J2BcbiAgICAgICk7XG5cbiAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGdldEN1cnJlbnRQYXRoKCk6IFBhdGhOb2RlW10ge1xuICAgIGNvbnN0IGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgIGNvbnN0IGxhdGVzdFN1Y2Nlc3M6IFRyYW5zaXRpb24gPSBnbG9iYWxzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5wZWVrVGFpbCgpO1xuICAgIGNvbnN0IHJvb3RQYXRoID0gKCkgPT4gW25ldyBQYXRoTm9kZSh0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSldO1xuICAgIHJldHVybiBsYXRlc3RTdWNjZXNzID8gbGF0ZXN0U3VjY2Vzcy50cmVlQ2hhbmdlcygpLnRvIDogcm9vdFBhdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb3ctbGV2ZWwgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLlxuICAgKlxuICAgKiBUaGUgW1tnb11dIG1ldGhvZCAod2hpY2ggdXNlcyBgdHJhbnNpdGlvblRvYCBpbnRlcm5hbGx5KSBpcyByZWNvbW1lbmRlZCBpbiBtb3N0IHNpdHVhdGlvbnMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAkc3RhdGUudHJhbnNpdGlvblRvKCdjb250YWN0LmRldGFpbCcpO1xuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRvIFN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gdG9QYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLFxuICAgKiAgICAgIHdpbGwgcG9wdWxhdGUgJHN0YXRlUGFyYW1zLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLiBTZWUgW1tnb11dXG4gICAqL1xuICB0cmFuc2l0aW9uVG8odG86IFN0YXRlT3JOYW1lLCB0b1BhcmFtczogUmF3UGFyYW1zID0ge30sIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pOiBUcmFuc2l0aW9uUHJvbWlzZSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgY29uc3QgZ2xvYmFscyA9IHJvdXRlci5nbG9iYWxzO1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0VHJhbnNPcHRzKTtcbiAgICBjb25zdCBnZXRDdXJyZW50ID0gKCkgPT4gZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgIG9wdGlvbnMgPSBleHRlbmQob3B0aW9ucywgeyBjdXJyZW50OiBnZXRDdXJyZW50IH0pO1xuXG4gICAgY29uc3QgcmVmOiBUYXJnZXRTdGF0ZSA9IHRoaXMudGFyZ2V0KHRvLCB0b1BhcmFtcywgb3B0aW9ucyk7XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0aGlzLmdldEN1cnJlbnRQYXRoKCk7XG5cbiAgICBpZiAoIXJlZi5leGlzdHMoKSkgcmV0dXJuIHRoaXMuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZShjdXJyZW50UGF0aCwgcmVmKTtcblxuICAgIGlmICghcmVmLnZhbGlkKCkpIHJldHVybiA8VHJhbnNpdGlvblByb21pc2U+c2lsZW50UmVqZWN0aW9uKHJlZi5lcnJvcigpKTtcblxuICAgIGlmIChvcHRpb25zLnN1cGVyY2VkZSA9PT0gZmFsc2UgJiYgZ2V0Q3VycmVudCgpKSB7XG4gICAgICByZXR1cm4gPFRyYW5zaXRpb25Qcm9taXNlPlJlamVjdGlvbi5pZ25vcmVkKCdBbm90aGVyIHRyYW5zaXRpb24gaXMgaW4gcHJvZ3Jlc3MgYW5kIHN1cGVyY2VkZSBoYXMgYmVlbiBzZXQgdG8gZmFsc2UgaW4gVHJhbnNpdGlvbk9wdGlvbnMgZm9yIHRoZSB0cmFuc2l0aW9uLiBTbyB0aGUgdHJhbnNpdGlvbiB3YXMgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIGV4aXN0aW5nIG9uZSBpbiBwcm9ncmVzcy4nKS50b1Byb21pc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGhhbmRsaW5nIGZvciBJZ25vcmVkLCBBYm9ydGVkLCBhbmQgUmVkaXJlY3RlZCB0cmFuc2l0aW9uc1xuICAgICAqXG4gICAgICogVGhlIHNlbWFudGljcyBmb3IgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBhbmQgdGhlIFN0YXRlU2VydmljZS50cmFuc2l0aW9uVG8oKVxuICAgICAqIHByb21pc2UgZGlmZmVyLiBGb3IgaW5zdGFuY2UsIHRoZSBydW4oKSBwcm9taXNlIG1heSBiZSByZWplY3RlZCBiZWNhdXNlIGl0IHdhc1xuICAgICAqIElHTk9SRUQsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyByZXNvbHZlZCBiZWNhdXNlIGZyb20gdGhlIHVzZXIgcGVyc3BlY3RpdmVcbiAgICAgKiBubyBlcnJvciBvY2N1cnJlZC4gIExpa2V3aXNlLCB0aGUgdHJhbnNpdGlvbi5ydW4oKSBwcm9taXNlIG1heSBiZSByZWplY3RlZCBiZWNhdXNlIG9mXG4gICAgICogYSBSZWRpcmVjdCwgYnV0IHRoZSB0cmFuc2l0aW9uVG8oKSBwcm9taXNlIGlzIGNoYWluZWQgdG8gdGhlIG5ldyBUcmFuc2l0aW9uJ3MgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBjb25zdCByZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyID0gKHRyYW5zOiBUcmFuc2l0aW9uKSA9PiAoZXJyb3I6IGFueSk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZWplY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaXNMYXRlc3QgPSByb3V0ZXIuZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA8PSB0cmFucy4kaWQ7XG5cbiAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IFJlamVjdFR5cGUuSUdOT1JFRCkge1xuICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgLy8gQ29uc2lkZXIgaWdub3JlZCBgVHJhbnNpdGlvbi5ydW4oKWAgYXMgYSBzdWNjZXNzZnVsIGB0cmFuc2l0aW9uVG9gXG4gICAgICAgICAgcmV0dXJuIHNlcnZpY2VzLiRxLndoZW4oZ2xvYmFscy5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRldGFpbDogYW55ID0gZXJyb3IuZGV0YWlsO1xuICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gUmVqZWN0VHlwZS5TVVBFUlNFREVEICYmIGVycm9yLnJlZGlyZWN0ZWQgJiYgZGV0YWlsIGluc3RhbmNlb2YgVGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAvLyBJZiBgVHJhbnNpdGlvbi5ydW4oKWAgd2FzIHJlZGlyZWN0ZWQsIGFsbG93IHRoZSBgdHJhbnNpdGlvblRvKClgIHByb21pc2UgdG8gcmVzb2x2ZSBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAvLyBieSByZXR1cm5pbmcgdGhlIHByb21pc2UgZm9yIHRoZSBuZXcgKHJlZGlyZWN0KSBgVHJhbnNpdGlvbi5ydW4oKWAuXG4gICAgICAgICAgY29uc3QgcmVkaXJlY3Q6IFRyYW5zaXRpb24gPSB0cmFucy5yZWRpcmVjdChkZXRhaWwpO1xuICAgICAgICAgIHJldHVybiByZWRpcmVjdC5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHJlZGlyZWN0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gUmVqZWN0VHlwZS5BQk9SVEVEKSB7XG4gICAgICAgICAgaXNMYXRlc3QgJiYgcm91dGVyLnVybFJvdXRlci51cGRhdGUoKTtcbiAgICAgICAgICByZXR1cm4gc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSB0aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoKTtcbiAgICAgIGVycm9ySGFuZGxlcihlcnJvcik7XG5cbiAgICAgIHJldHVybiBzZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKGN1cnJlbnRQYXRoLCByZWYpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25Ub1Byb21pc2UgPSB0cmFuc2l0aW9uLnJ1bigpLmNhdGNoKHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIodHJhbnNpdGlvbikpO1xuICAgIHNpbGVuY2VVbmNhdWdodEluUHJvbWlzZSh0cmFuc2l0aW9uVG9Qcm9taXNlKTsgLy8gaXNzdWUgIzI2NzZcblxuICAgIC8vIFJldHVybiBhIHByb21pc2UgZm9yIHRoZSB0cmFuc2l0aW9uLCB3aGljaCBhbHNvIGhhcyB0aGUgdHJhbnNpdGlvbiBvYmplY3Qgb24gaXQuXG4gICAgcmV0dXJuIGV4dGVuZCh0cmFuc2l0aW9uVG9Qcm9taXNlLCB7IHRyYW5zaXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAqXG4gICAqIFNpbWlsYXIgdG8gW1tpbmNsdWRlc11dIGJ1dCBvbmx5IGNoZWNrcyBmb3IgdGhlIGZ1bGwgc3RhdGUgbmFtZS5cbiAgICogSWYgcGFyYW1zIGlzIHN1cHBsaWVkIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgZm9yIHN0cmljdCBlcXVhbGl0eSBhZ2FpbnN0IHRoZSBjdXJyZW50XG4gICAqIGFjdGl2ZSBwYXJhbXMgb2JqZWN0LCBzbyBhbGwgcGFyYW1zIG11c3QgbWF0Y2ggd2l0aCBub25lIG1pc3NpbmcgYW5kIG5vIGV4dHJhcy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nO1xuICAgKlxuICAgKiAvLyBhYnNvbHV0ZSBuYW1lXG4gICAqICRzdGF0ZS5pcygnY29udGFjdC5kZXRhaWxzLml0ZW0nKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICRzdGF0ZS5pcyhjb250YWN0RGV0YWlsSXRlbVN0YXRlT2JqZWN0KTsgLy8gcmV0dXJucyB0cnVlXG4gICAqIGBgYFxuICAgKlxuICAgKiAvLyByZWxhdGl2ZSBuYW1lICguIGFuZCBeKSwgdHlwaWNhbGx5IGZyb20gYSB0ZW1wbGF0ZVxuICAgKiAvLyBFLmcuIGZyb20gdGhlICdjb250YWN0cy5kZXRhaWxzJyB0ZW1wbGF0ZVxuICAgKiBgYGBodG1sXG4gICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgKGFic29sdXRlIG9yIHJlbGF0aXZlKSBvciBzdGF0ZSBvYmplY3QgeW91J2QgbGlrZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLCB0aGF0IHlvdSdkIGxpa2VcbiAgICogdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICogICAtIGByZWxhdGl2ZWA6IElmIGBzdGF0ZU9yTmFtZWAgaXMgYSByZWxhdGl2ZSBzdGF0ZSBuYW1lIGFuZCBgb3B0aW9ucy5yZWxhdGl2ZWAgaXMgc2V0LCAuaXMgd2lsbFxuICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxuICAgKlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgaXQgaXMgdGhlIHN0YXRlLlxuICAgKi9cbiAgaXMoc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lLCBwYXJhbXM/OiBSYXdQYXJhbXMsIG9wdGlvbnM/OiB7IHJlbGF0aXZlPzogU3RhdGVPck5hbWUgfSk6IGJvb2xlYW4ge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuICAgIGlmICghaXNEZWZpbmVkKHN0YXRlKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy4kY3VycmVudCAhPT0gc3RhdGUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXBhcmFtcykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBzY2hlbWE6IFBhcmFtW10gPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBwYXJhbXMgfSk7XG4gICAgcmV0dXJuIFBhcmFtLmVxdWFscyhzY2hlbWEsIFBhcmFtLnZhbHVlcyhzY2hlbWEsIHBhcmFtcyksIHRoaXMucGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgc3RhdGUgKmluY2x1ZGVzKiB0aGUgcHJvdmlkZWQgc3RhdGVcbiAgICpcbiAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXG4gICAqIHN0YXRlIHN0YXRlTmFtZS4gSWYgYW55IHBhcmFtcyBhcmUgcGFzc2VkIHRoZW4gdGhleSB3aWxsIGJlIHRlc3RlZCBmb3IgYSBtYXRjaCBhcyB3ZWxsLlxuICAgKiBOb3QgYWxsIHRoZSBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgcGFzc2VkLCBqdXN0IHRoZSBvbmVzIHlvdSdkIGxpa2UgdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZSB3aGVuIGAkc3RhdGUuJGN1cnJlbnQubmFtZSA9PT0gJ2NvbnRhY3RzLmRldGFpbHMuaXRlbSdgXG4gICAqIGBgYGpzXG4gICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHNcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5kZXRhaWxzXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMubGlzdFwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJhYm91dFwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBHbG9iIEV4YW1wbGVzIHdoZW4gYCogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0udXJsJ2A6XG4gICAqIGBgYGpzXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qLipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqKi5pdGVtLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLml0ZW0udXJsXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioudXJsXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiaXRlbS4qKlwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JOYW1lIEEgcGFydGlhbCBuYW1lLCByZWxhdGl2ZSBuYW1lLCBnbG9iIHBhdHRlcm4sXG4gICAqICAgb3Igc3RhdGUgb2JqZWN0IHRvIGJlIHNlYXJjaGVkIGZvciB3aXRoaW4gdGhlIGN1cnJlbnQgc3RhdGUgbmFtZS5cbiAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLFxuICAgKiAgIHRoYXQgeW91J2QgbGlrZSB0byB0ZXN0IGFnYWluc3QgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAqICAgICB0ZXN0IHJlbGF0aXZlIHRvIGBvcHRpb25zLnJlbGF0aXZlYCBzdGF0ZSAob3IgbmFtZSkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgZG9lcyBpbmNsdWRlIHRoZSBzdGF0ZVxuICAgKi9cbiAgaW5jbHVkZXMoc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lLCBwYXJhbXM/OiBSYXdQYXJhbXMsIG9wdGlvbnM/OiBUcmFuc2l0aW9uT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgIGNvbnN0IGdsb2IgPSBpc1N0cmluZyhzdGF0ZU9yTmFtZSkgJiYgR2xvYi5mcm9tU3RyaW5nKDxzdHJpbmc+c3RhdGVPck5hbWUpO1xuXG4gICAgaWYgKGdsb2IpIHtcbiAgICAgIGlmICghZ2xvYi5tYXRjaGVzKHRoaXMuJGN1cnJlbnQubmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHN0YXRlT3JOYW1lID0gdGhpcy4kY3VycmVudC5uYW1lO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKSxcbiAgICAgIGluY2x1ZGUgPSB0aGlzLiRjdXJyZW50LmluY2x1ZGVzO1xuXG4gICAgaWYgKCFpc0RlZmluZWQoc3RhdGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghaXNEZWZpbmVkKGluY2x1ZGVbc3RhdGUubmFtZV0pKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwYXJhbXMpIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3Qgc2NoZW1hOiBQYXJhbVtdID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xuICAgIHJldHVybiBQYXJhbS5lcXVhbHMoc2NoZW1hLCBQYXJhbS52YWx1ZXMoc2NoZW1hLCBwYXJhbXMpLCB0aGlzLnBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgVVJMIGZvciBhIHN0YXRlIGFuZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHVybCBmb3IgdGhlIGdpdmVuIHN0YXRlIHBvcHVsYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogZXhwZWN0KCRzdGF0ZS5ocmVmKFwiYWJvdXQucGVyc29uXCIsIHsgcGVyc29uOiBcImJvYlwiIH0pKS50b0VxdWFsKFwiL2Fib3V0L2JvYlwiKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBUaGUgc3RhdGUgbmFtZSBvciBzdGF0ZSBvYmplY3QgeW91J2QgbGlrZSB0byBnZW5lcmF0ZSBhIHVybCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIHN0YXRlJ3MgcmVxdWlyZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gY29tcGlsZWQgc3RhdGUgdXJsXG4gICAqL1xuICBocmVmKHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSwgcGFyYW1zPzogUmF3UGFyYW1zLCBvcHRpb25zPzogSHJlZk9wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRlZmF1bHRIcmVmT3B0cyA9IHtcbiAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgaW5oZXJpdDogdHJ1ZSxcbiAgICAgIGFic29sdXRlOiBmYWxzZSxcbiAgICAgIHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LFxuICAgIH07XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRIcmVmT3B0cyk7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG5cbiAgICBpZiAoIWlzRGVmaW5lZChzdGF0ZSkpIHJldHVybiBudWxsO1xuICAgIGlmIChvcHRpb25zLmluaGVyaXQpIHBhcmFtcyA9IDxhbnk+dGhpcy5wYXJhbXMuJGluaGVyaXQocGFyYW1zLCB0aGlzLiRjdXJyZW50LCBzdGF0ZSk7XG5cbiAgICBjb25zdCBuYXYgPSBzdGF0ZSAmJiBvcHRpb25zLmxvc3N5ID8gc3RhdGUubmF2aWdhYmxlIDogc3RhdGU7XG5cbiAgICBpZiAoIW5hdiB8fCBuYXYudXJsID09PSB1bmRlZmluZWQgfHwgbmF2LnVybCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucm91dGVyLnVybFJvdXRlci5ocmVmKG5hdi51cmwsIHBhcmFtcywgeyBhYnNvbHV0ZTogb3B0aW9ucy5hYnNvbHV0ZSB9KTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2RlZmF1bHRFcnJvckhhbmRsZXI6ICgoX2Vycm9yOiBhbnkpID0+IHZvaWQpID0gZnVuY3Rpb24gJGRlZmF1bHRFcnJvckhhbmRsZXIoJGVycm9yJCkge1xuICAgIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgRXJyb3IgJiYgJGVycm9yJC5zdGFjaykge1xuICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJC5zdGFjayk7XG4gICAgfSBlbHNlIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgUmVqZWN0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQudG9TdHJpbmcoKSk7XG4gICAgICBpZiAoJGVycm9yJC5kZXRhaWwgJiYgJGVycm9yJC5kZXRhaWwuc3RhY2spIGNvbnNvbGUuZXJyb3IoJGVycm9yJC5kZXRhaWwuc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBvciBnZXRzIHRoZSBkZWZhdWx0IFtbdHJhbnNpdGlvblRvXV0gZXJyb3IgaGFuZGxlci5cbiAgICpcbiAgICogVGhlIGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkIHdoZW4gYSBbW1RyYW5zaXRpb25dXSBpcyByZWplY3RlZCBvciB3aGVuIGFueSBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIFRyYW5zaXRpb24uXG4gICAqIFRoaXMgaW5jbHVkZXMgZXJyb3JzIGNhdXNlZCBieSByZXNvbHZlcyBhbmQgdHJhbnNpdGlvbiBob29rcy5cbiAgICpcbiAgICogTm90ZTpcbiAgICogVGhpcyBoYW5kbGVyIGRvZXMgbm90IHJlY2VpdmUgY2VydGFpbiBUcmFuc2l0aW9uIHJlamVjdGlvbnMuXG4gICAqIFJlZGlyZWN0ZWQgYW5kIElnbm9yZWQgVHJhbnNpdGlvbnMgYXJlIG5vdCBjb25zaWRlcmVkIHRvIGJlIGVycm9ycyBieSBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXS5cbiAgICpcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBsb2dzIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGN1c3RvbSBoYW5kbGVyLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHN0YXRlU2VydmljZS5kZWZhdWx0RXJyb3JIYW5kbGVyKGZ1bmN0aW9uKCkge1xuICAgKiAgIC8vIERvIG5vdCBsb2cgdHJhbnNpdGlvblRvIGVycm9yc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGVyIGEgZ2xvYmFsIGVycm9yIGhhbmRsZXIgZnVuY3Rpb25cbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgZ2xvYmFsIGVycm9yIGhhbmRsZXJcbiAgICovXG4gIGRlZmF1bHRFcnJvckhhbmRsZXIoaGFuZGxlcj86IChlcnJvcjogYW55KSA9PiB2b2lkKTogKGVycm9yOiBhbnkpID0+IHZvaWQge1xuICAgIHJldHVybiAodGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlciA9IGhhbmRsZXIgfHwgdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZ2lzdGVyZWQgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb2JqZWN0XG4gICAqXG4gICAqIFJldHVybnMgdGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgYW55IHNwZWNpZmljIHN0YXRlLCBvciBmb3IgYWxsIHJlZ2lzdGVyZWQgc3RhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgKGFic29sdXRlIG9yIHJlbGF0aXZlKSBJZiBwcm92aWRlZCwgd2lsbCBvbmx5IGdldCB0aGUgZGVjbGFyYXRpb24gb2JqZWN0IGZvciB0aGUgcmVxdWVzdGVkIHN0YXRlLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHJldHVybnMgYW4gYXJyYXkgb2YgQUxMIHN0YXRlcy5cbiAgICogQHBhcmFtIGJhc2UgV2hlbiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgcmVmZXJlbmNlIChzdWNoIGFzIGAuYmFyLmJhemApLCB0aGUgc3RhdGUgd2lsbCBiZSByZXRyaWV2ZWQgcmVsYXRpdmUgdG8gdGhpcyBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMgYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvYmplY3QgKG9yIGFycmF5IG9mIGFsbCByZWdpc3RlcmVkIFtbU3RhdGVEZWNsYXJhdGlvbl1dIG9iamVjdHMuKVxuICAgKi9cbiAgZ2V0KHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSwgYmFzZTogU3RhdGVPck5hbWUpOiBTdGF0ZURlY2xhcmF0aW9uO1xuICBnZXQoc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lKTogU3RhdGVEZWNsYXJhdGlvbjtcbiAgZ2V0KCk6IFN0YXRlRGVjbGFyYXRpb25bXTtcbiAgZ2V0KHN0YXRlT3JOYW1lPzogU3RhdGVPck5hbWUsIGJhc2U/OiBTdGF0ZU9yTmFtZSk6IGFueSB7XG4gICAgY29uc3QgcmVnID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlZy5nZXQoKTtcbiAgICByZXR1cm4gcmVnLmdldChzdGF0ZU9yTmFtZSwgYmFzZSB8fCB0aGlzLiRjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMYXp5IGxvYWRzIGEgc3RhdGVcbiAgICpcbiAgICogRXhwbGljaXRseSBydW5zIGEgc3RhdGUncyBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JOYW1lIHRoZSBzdGF0ZSB0aGF0IHNob3VsZCBiZSBsYXp5IGxvYWRlZFxuICAgKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgb3B0aW9uYWwgVHJhbnNpdGlvbiBjb250ZXh0IHRvIHVzZSAoaWYgdGhlIGxhenlMb2FkIGZ1bmN0aW9uIHJlcXVpcmVzIGFuIGluamVjdG9yLCBldGMpXG4gICAqIE5vdGU6IElmIG5vIHRyYW5zaXRpb24gaXMgcHJvdmlkZWQsIGEgbm9vcCB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIFRoaXMgbm9vcCB0cmFuc2l0aW9uIGlzIG5vdCBhY3R1YWxseSBydW4uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0byBsYXp5IGxvYWRcbiAgICovXG4gIGxhenlMb2FkKHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSwgdHJhbnNpdGlvbj86IFRyYW5zaXRpb24pOiBQcm9taXNlPExhenlMb2FkUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24gPSB0aGlzLmdldChzdGF0ZU9yTmFtZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUubGF6eUxvYWQpIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBsYXp5IGxvYWQgJyArIHN0YXRlT3JOYW1lKTtcblxuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5nZXRDdXJyZW50UGF0aCgpO1xuICAgIGNvbnN0IHRhcmdldCA9IFBhdGhVdGlscy5tYWtlVGFyZ2V0U3RhdGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeSwgY3VycmVudFBhdGgpO1xuICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHx8IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZShjdXJyZW50UGF0aCwgdGFyZ2V0KTtcblxuICAgIHJldHVybiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKTtcbiAgfVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQgeyBpc0FycmF5LCBpc09iamVjdCwgJFFMaWtlIH0gZnJvbSAnLi4vY29tbW9uL2luZGV4JztcblxuLyoqXG4gKiBBbiBhbmd1bGFyMS1saWtlIHByb21pc2UgYXBpXG4gKlxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcbiAqIFthbmd1bGFyIDEgcHJvbWlzZSBhcGldKGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy9zZXJ2aWNlLyRxKVxuICpcbiAqIFVJLVJvdXRlciBldm9sdmVkIGZyb20gYW4gYW5ndWxhciAxIGxpYnJhcnkgdG8gYSBmcmFtZXdvcmsgYWdub3N0aWMgbGlicmFyeS5cbiAqIEhvd2V2ZXIsIHNvbWUgb2YgdGhlIGBAdWlyb3V0ZXIvY29yZWAgY29kZSB1c2VzIHRoZXNlIG5nMSBzdHlsZSBBUElzIHRvIHN1cHBvcnQgbmcxIHN0eWxlIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIFRoaXMgQVBJIHByb3ZpZGVzIG5hdGl2ZSBFUzYgcHJvbWlzZSBzdXBwb3J0IHdyYXBwZWQgYXMgYSAkcS1saWtlIEFQSS5cbiAqIEludGVybmFsbHksIFVJLVJvdXRlciB1c2VzIHRoaXMgJHEgb2JqZWN0IHRvIHBlcmZvcm0gcHJvbWlzZSBvcGVyYXRpb25zLlxuICogVGhlIGBhbmd1bGFyLXVpLXJvdXRlcmAgKHVpLXJvdXRlciBmb3IgYW5ndWxhciAxKSB1c2VzIHRoZSAkcSBBUEkgcHJvdmlkZWQgYnkgYW5ndWxhci5cbiAqXG4gKiAkcS1saWtlIHByb21pc2UgYXBpXG4gKi9cbmV4cG9ydCBjb25zdCAkcSA9IHtcbiAgLyoqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIHByb21pc2UgKi9cbiAgd2hlbjogdmFsID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHJlc29sdmUodmFsKSksXG5cbiAgLyoqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIHByb21pc2UgcmVqZWN0aW9uICovXG4gIHJlamVjdDogdmFsID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVqZWN0KHZhbCk7XG4gICAgfSksXG5cbiAgLyoqIEByZXR1cm5zIGEgZGVmZXJyZWQgb2JqZWN0LCB3aGljaCBoYXMgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMgKi9cbiAgZGVmZXI6ICgpID0+IHtcbiAgICBjb25zdCBkZWZlcnJlZDogYW55ID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfSxcblxuICAvKiogTGlrZSBQcm9taXNlLmFsbCgpLCBidXQgYWxzbyBzdXBwb3J0cyBvYmplY3Qga2V5L3Byb21pc2Ugbm90YXRpb24gbGlrZSAkcSAqL1xuICBhbGw6IChwcm9taXNlczogeyBba2V5OiBzdHJpbmddOiBQcm9taXNlPGFueT4gfSB8IFByb21pc2U8YW55PltdKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdChwcm9taXNlcykpIHtcbiAgICAgIC8vIENvbnZlcnQgcHJvbWlzZXMgbWFwIHRvIHByb21pc2VzIGFycmF5LlxuICAgICAgLy8gV2hlbiBlYWNoIHByb21pc2UgcmVzb2x2ZXMsIG1hcCBpdCB0byBhIHR1cGxlIHsga2V5OiBrZXksIHZhbDogdmFsIH1cbiAgICAgIGNvbnN0IGNoYWluID0gT2JqZWN0LmtleXMocHJvbWlzZXMpLm1hcChrZXkgPT4gcHJvbWlzZXNba2V5XS50aGVuKHZhbCA9PiAoeyBrZXksIHZhbCB9KSkpO1xuXG4gICAgICAvLyBUaGVuIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byByZXNvbHZlLCBhbmQgY29udmVydCB0aGVtIGJhY2sgdG8gYW4gb2JqZWN0XG4gICAgICByZXR1cm4gJHEuYWxsKGNoYWluKS50aGVuKHZhbHVlcyA9PlxuICAgICAgICB2YWx1ZXMucmVkdWNlKChhY2MsIHR1cGxlKSA9PiB7XG4gICAgICAgICAgYWNjW3R1cGxlLmtleV0gPSB0dXBsZS52YWw7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pXG4gICAgICApO1xuICAgIH1cbiAgfSxcbn0gYXMgJFFMaWtlO1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQge1xuICBleHRlbmQsXG4gIGFzc2VydFByZWRpY2F0ZSxcbiAgaXNGdW5jdGlvbixcbiAgaXNBcnJheSxcbiAgaXNJbmplY3RhYmxlLFxuICAkSW5qZWN0b3JMaWtlLFxuICBJSW5qZWN0YWJsZSxcbn0gZnJvbSAnLi4vY29tbW9uL2luZGV4JztcblxuLy8gZ2xvYmFsbHkgYXZhaWxhYmxlIGluamVjdGFibGVzXG5jb25zdCBnbG9iYWxzID0ge307XG5jb25zdCBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9nbTtcbmNvbnN0IEFSR1VNRU5UX05BTUVTID0gLyhbXlxccyxdKykvZztcblxuLyoqXG4gKiBBIGJhc2ljIGFuZ3VsYXIxLWxpa2UgaW5qZWN0b3IgYXBpXG4gKlxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcbiAqIFthbmd1bGFyIDEgZGVwZW5kZW5jeSBpbmplY3Rvcl0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL2F1dG8vc2VydmljZS8kaW5qZWN0b3IpXG4gKlxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gKlxuICogVGhpcyBvYmplY3QgcHJvdmlkZXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGdsb2JhbGx5IHNjb3BlZCBkZXBlbmRlbmN5IGluamVjdGlvbiBzeXN0ZW0uXG4gKiBJdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIERJIGFwcHJvYWNoZXM6XG4gKlxuICogIyMjIEZ1bmN0aW9uIHBhcmFtZXRlciBuYW1lc1xuICpcbiAqIEEgZnVuY3Rpb24ncyBgLnRvU3RyaW5nKClgIGlzIGNhbGxlZCwgYW5kIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlIHBhcnNlZC5cbiAqIFRoaXMgb25seSB3b3JrcyB3aGVuIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlbid0IFwibWFuZ2xlZFwiIGJ5IGEgbWluaWZpZXIgc3VjaCBhcyBVZ2xpZnlKUy5cbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihGb29TZXJ2aWNlLCBCYXJTZXJ2aWNlKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgRnVuY3Rpb24gYW5ub3RhdGlvblxuICpcbiAqIEEgZnVuY3Rpb24gbWF5IGJlIGFubm90YXRlZCB3aXRoIGFuIGFycmF5IG9mIGRlcGVuZGVuY3kgbmFtZXMgYXMgdGhlIGAkaW5qZWN0YCBwcm9wZXJ0eS5cbiAqXG4gKiBgYGBqc1xuICogaW5qZWN0ZWRGdW5jdGlvbi4kaW5qZWN0ID0gWyAnRm9vU2VydmljZScsICdCYXJTZXJ2aWNlJyBdO1xuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihmcywgYnMpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBBcnJheSBub3RhdGlvblxuICpcbiAqIEFuIGFycmF5IHByb3ZpZGVzIHRoZSBuYW1lcyBvZiB0aGUgZGVwZW5kZW5jaWVzIHRvIGluamVjdCAoYXMgc3RyaW5ncykuXG4gKiBUaGUgZnVuY3Rpb24gaXMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gKlxuICogYGBganNcbiAqIFsgJ0Zvb1NlcnZpY2UnLCAnQmFyU2VydmljZScsIGZ1bmN0aW9uIChmcywgYnMpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcbiAqIH1dXG4gKiBgYGBcbiAqXG4gKiBAdHlwZSB7JEluamVjdG9yTGlrZX1cbiAqL1xuZXhwb3J0IGNvbnN0ICRpbmplY3RvciA9IHtcbiAgLyoqIEdldHMgYW4gb2JqZWN0IGZyb20gREkgYmFzZWQgb24gYSBzdHJpbmcgdG9rZW4gKi9cbiAgZ2V0OiBuYW1lID0+IGdsb2JhbHNbbmFtZV0sXG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgbmFtZWQgYG5hbWVgIGV4aXN0cyBpbiBnbG9iYWwgREkgKi9cbiAgaGFzOiBuYW1lID0+ICRpbmplY3Rvci5nZXQobmFtZSkgIT0gbnVsbCxcblxuICAvKipcbiAgICogSW5qZWN0cyBhIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBmbiB0aGUgZnVuY3Rpb24gdG8gaW5qZWN0XG4gICAqIEBwYXJhbSBjb250ZXh0IHRoZSBmdW5jdGlvbidzIGB0aGlzYCBiaW5kaW5nXG4gICAqIEBwYXJhbSBsb2NhbHMgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCBESSB0b2tlbnMgYW5kIHZhbHVlcywgc3VjaCBhcyBgeyBzb21lVG9rZW46IHsgZm9vOiAxIH0gfWBcbiAgICovXG4gIGludm9rZTogKGZuOiBJSW5qZWN0YWJsZSwgY29udGV4dD8sIGxvY2Fscz8pID0+IHtcbiAgICBjb25zdCBhbGwgPSBleHRlbmQoe30sIGdsb2JhbHMsIGxvY2FscyB8fCB7fSk7XG4gICAgY29uc3QgcGFyYW1zID0gJGluamVjdG9yLmFubm90YXRlKGZuKTtcbiAgICBjb25zdCBlbnN1cmVFeGlzdCA9IGFzc2VydFByZWRpY2F0ZShcbiAgICAgIChrZXk6IHN0cmluZykgPT4gYWxsLmhhc093blByb3BlcnR5KGtleSksXG4gICAgICBrZXkgPT4gYERJIGNhbid0IGZpbmQgaW5qZWN0YWJsZTogJyR7a2V5fSdgXG4gICAgKTtcbiAgICBjb25zdCBhcmdzID0gcGFyYW1zLmZpbHRlcihlbnN1cmVFeGlzdCkubWFwKHggPT4gYWxsW3hdKTtcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICBlbHNlIHJldHVybiAoZm4gYXMgYW55W10pLnNsaWNlKC0xKVswXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uJ3MgZGVwZW5kZW5jaWVzXG4gICAqXG4gICAqIEFuYWx5emVzIGEgZnVuY3Rpb24gKG9yIGFycmF5KSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBESSB0b2tlbnMgdGhhdCB0aGUgZnVuY3Rpb24gcmVxdWlyZXMuXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYHN0cmluZ2BzXG4gICAqL1xuICBhbm5vdGF0ZTogKGZuOiBJSW5qZWN0YWJsZSk6IGFueVtdID0+IHtcbiAgICBpZiAoIWlzSW5qZWN0YWJsZShmbikpIHRocm93IG5ldyBFcnJvcihgTm90IGFuIGluamVjdGFibGUgZnVuY3Rpb246ICR7Zm59YCk7XG4gICAgaWYgKGZuICYmIChmbiBhcyBhbnkpLiRpbmplY3QpIHJldHVybiAoZm4gYXMgYW55KS4kaW5qZWN0O1xuICAgIGlmIChpc0FycmF5KGZuKSkgcmV0dXJuIGZuLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCBmblN0ciA9IGZuLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuU3RyLnNsaWNlKGZuU3RyLmluZGV4T2YoJygnKSArIDEsIGZuU3RyLmluZGV4T2YoJyknKSkubWF0Y2goQVJHVU1FTlRfTkFNRVMpO1xuICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gIH0sXG59IGFzICRJbmplY3Rvckxpa2U7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgdmFuaWxsYSAqLyAvKiogKi9cbmltcG9ydCB7XG4gIExvY2F0aW9uQ29uZmlnLFxuICBMb2NhdGlvblNlcnZpY2VzLFxuICBpZGVudGl0eSxcbiAgdW5uZXN0UixcbiAgaXNBcnJheSxcbiAgc3BsaXRFcXVhbCxcbiAgc3BsaXRIYXNoLFxuICBzcGxpdFF1ZXJ5LFxufSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuXG5leHBvcnQgY29uc3Qga2V5VmFsc1RvT2JqZWN0UiA9IChhY2N1bSwgW2tleSwgdmFsXSkgPT4ge1xuICBpZiAoIWFjY3VtLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBhY2N1bVtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoYWNjdW1ba2V5XSkpIHtcbiAgICBhY2N1bVtrZXldLnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBhY2N1bVtrZXldID0gW2FjY3VtW2tleV0sIHZhbF07XG4gIH1cbiAgcmV0dXJuIGFjY3VtO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFBhcmFtcyA9IChxdWVyeVN0cmluZzogc3RyaW5nKTogYW55ID0+XG4gIHF1ZXJ5U3RyaW5nXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZmlsdGVyKGlkZW50aXR5KVxuICAgIC5tYXAoc3BsaXRFcXVhbClcbiAgICAucmVkdWNlKGtleVZhbHNUb09iamVjdFIsIHt9KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXJsKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IG9yRW1wdHlTdHJpbmcgPSB4ID0+IHggfHwgJyc7XG4gIGNvbnN0IFtiZWZvcmVoYXNoLCBoYXNoXSA9IHNwbGl0SGFzaCh1cmwpLm1hcChvckVtcHR5U3RyaW5nKTtcbiAgY29uc3QgW3BhdGgsIHNlYXJjaF0gPSBzcGxpdFF1ZXJ5KGJlZm9yZWhhc2gpLm1hcChvckVtcHR5U3RyaW5nKTtcblxuICByZXR1cm4geyBwYXRoLCBzZWFyY2gsIGhhc2gsIHVybCB9O1xufVxuXG5leHBvcnQgY29uc3QgYnVpbGRVcmwgPSAobG9jOiBMb2NhdGlvblNlcnZpY2VzKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBsb2MucGF0aCgpO1xuICBjb25zdCBzZWFyY2hPYmplY3QgPSBsb2Muc2VhcmNoKCk7XG4gIGNvbnN0IGhhc2ggPSBsb2MuaGFzaCgpO1xuXG4gIGNvbnN0IHNlYXJjaCA9IE9iamVjdC5rZXlzKHNlYXJjaE9iamVjdClcbiAgICAubWFwKGtleSA9PiB7XG4gICAgICBjb25zdCBwYXJhbSA9IHNlYXJjaE9iamVjdFtrZXldO1xuICAgICAgY29uc3QgdmFscyA9IGlzQXJyYXkocGFyYW0pID8gcGFyYW0gOiBbcGFyYW1dO1xuICAgICAgcmV0dXJuIHZhbHMubWFwKHZhbCA9PiBrZXkgKyAnPScgKyB2YWwpO1xuICAgIH0pXG4gICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAuam9pbignJicpO1xuXG4gIHJldHVybiBwYXRoICsgKHNlYXJjaCA/ICc/JyArIHNlYXJjaCA6ICcnKSArIChoYXNoID8gJyMnICsgaGFzaCA6ICcnKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhdGlvblBsdWdpbkZhY3RvcnkoXG4gIG5hbWU6IHN0cmluZyxcbiAgaXNIdG1sNTogYm9vbGVhbixcbiAgc2VydmljZUNsYXNzOiB7IG5ldyAodWlSb3V0ZXI/OiBVSVJvdXRlcik6IExvY2F0aW9uU2VydmljZXMgfSxcbiAgY29uZmlndXJhdGlvbkNsYXNzOiB7IG5ldyAodWlSb3V0ZXI/OiBVSVJvdXRlciwgaXNIdG1sNT86IGJvb2xlYW4pOiBMb2NhdGlvbkNvbmZpZyB9XG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVpUm91dGVyOiBVSVJvdXRlcikge1xuICAgIGNvbnN0IHNlcnZpY2UgPSAodWlSb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gbmV3IHNlcnZpY2VDbGFzcyh1aVJvdXRlcikpO1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSAodWlSb3V0ZXIubG9jYXRpb25Db25maWcgPSBuZXcgY29uZmlndXJhdGlvbkNsYXNzKHVpUm91dGVyLCBpc0h0bWw1KSk7XG5cbiAgICBmdW5jdGlvbiBkaXNwb3NlKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICAgIHJvdXRlci5kaXNwb3NlKHNlcnZpY2UpO1xuICAgICAgcm91dGVyLmRpc3Bvc2UoY29uZmlndXJhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmFtZSwgc2VydmljZSwgY29uZmlndXJhdGlvbiwgZGlzcG9zZSB9O1xuICB9O1xufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQgeyBkZXJlZ0FsbCwgaXNEZWZpbmVkLCBMb2NhdGlvblNlcnZpY2VzLCByZW1vdmVGcm9tLCByb290IH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgSGlzdG9yeUxpa2UsIExvY2F0aW9uTGlrZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGJ1aWxkVXJsLCBnZXRQYXJhbXMsIHBhcnNlVXJsIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKiBBIGJhc2UgYExvY2F0aW9uU2VydmljZXNgICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUxvY2F0aW9uU2VydmljZXMgaW1wbGVtZW50cyBMb2NhdGlvblNlcnZpY2VzLCBEaXNwb3NhYmxlIHtcbiAgcHJpdmF0ZSBfbGlzdGVuZXJzOiBGdW5jdGlvbltdID0gW107XG4gIF9sb2NhdGlvbjogTG9jYXRpb25MaWtlO1xuICBfaGlzdG9yeTogSGlzdG9yeUxpa2U7XG5cbiAgX2xpc3RlbmVyID0gZXZ0ID0+IHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGNiID0+IGNiKGV2dCkpO1xuXG4gIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIsIHB1YmxpYyBmaXJlQWZ0ZXJVcGRhdGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9sb2NhdGlvbiA9IHJvb3QubG9jYXRpb247XG4gICAgdGhpcy5faGlzdG9yeSA9IHJvb3QuaGlzdG9yeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCByZXR1cm4gdGhlIGN1cnJlbnQgaW50ZXJuYWwgVVJMIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBUaGUgaW50ZXJuYWwgVVJMIGluY2x1ZGVzIG9ubHkgdGhlIHBvcnRpb24gdGhhdCBVSS1Sb3V0ZXIgbWF0Y2hlcy5cbiAgICogSXQgZG9lcyBub3QgaW5jbHVkZTpcbiAgICogLSBwcm90b2NvbFxuICAgKiAtIHNlcnZlclxuICAgKiAtIHBvcnRcbiAgICogLSBiYXNlIGhyZWYgb3IgaGFzaFxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXQoKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBzZXQgdGhlIGN1cnJlbnQgVVJMLlxuICAgKlxuICAgKiBUaGUgYHVybGAgcGFyYW0gc2hvdWxkIGluY2x1ZGUgb25seSB0aGUgcG9ydGlvbiB0aGF0IFVJLVJvdXRlciBtYXRjaGVzIG9uLlxuICAgKiBJdCBzaG91bGQgbm90IGluY2x1ZGU6XG4gICAqIC0gcHJvdG9jb2xcbiAgICogLSBzZXJ2ZXJcbiAgICogLSBwb3J0XG4gICAqIC0gYmFzZSBocmVmIG9yIGhhc2hcbiAgICpcbiAgICogSG93ZXZlciwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiBjb21wbGV0ZXMsIHRoZSBicm93c2VyIFVSTCBzaG91bGQgcmVmbGVjdCB0aGUgZW50aXJlIChmdWxseSBxdWFsaWZpZWQpXG4gICAqIEhSRUYgaW5jbHVkaW5nIHRob3NlIGRhdGEuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX3NldChzdGF0ZTogYW55LCB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZywgcmVwbGFjZTogYm9vbGVhbik7XG5cbiAgaGFzaCA9ICgpID0+IHBhcnNlVXJsKHRoaXMuX2dldCgpKS5oYXNoO1xuICBwYXRoID0gKCkgPT4gcGFyc2VVcmwodGhpcy5fZ2V0KCkpLnBhdGg7XG4gIHNlYXJjaCA9ICgpID0+IGdldFBhcmFtcyhwYXJzZVVybCh0aGlzLl9nZXQoKSkuc2VhcmNoKTtcblxuICB1cmwodXJsPzogc3RyaW5nLCByZXBsYWNlID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgaWYgKGlzRGVmaW5lZCh1cmwpICYmIHVybCAhPT0gdGhpcy5fZ2V0KCkpIHtcbiAgICAgIHRoaXMuX3NldChudWxsLCBudWxsLCB1cmwsIHJlcGxhY2UpO1xuXG4gICAgICBpZiAodGhpcy5maXJlQWZ0ZXJVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goY2IgPT4gY2IoeyB1cmwgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWlsZFVybCh0aGlzKTtcbiAgfVxuXG4gIG9uQ2hhbmdlKGNiOiBFdmVudExpc3RlbmVyKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goY2IpO1xuICAgIHJldHVybiAoKSA9PiByZW1vdmVGcm9tKHRoaXMuX2xpc3RlbmVycywgY2IpO1xuICB9XG5cbiAgZGlzcG9zZShyb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgZGVyZWdBbGwodGhpcy5fbGlzdGVuZXJzKTtcbiAgfVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQgeyByb290LCB0cmltSGFzaFZhbCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBCYXNlTG9jYXRpb25TZXJ2aWNlcyB9IGZyb20gJy4vYmFzZUxvY2F0aW9uU2VydmljZSc7XG5cbi8qKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IHVzZXMgdGhlIGJyb3dzZXIgaGFzaCBcIiNcIiB0byBnZXQvc2V0IHRoZSBjdXJyZW50IGxvY2F0aW9uICovXG5leHBvcnQgY2xhc3MgSGFzaExvY2F0aW9uU2VydmljZSBleHRlbmRzIEJhc2VMb2NhdGlvblNlcnZpY2VzIHtcbiAgY29uc3RydWN0b3Iocm91dGVyOiBVSVJvdXRlcikge1xuICAgIHN1cGVyKHJvdXRlciwgZmFsc2UpO1xuICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuX2xpc3RlbmVyLCBmYWxzZSk7XG4gIH1cblxuICBfZ2V0KCkge1xuICAgIHJldHVybiB0cmltSGFzaFZhbCh0aGlzLl9sb2NhdGlvbi5oYXNoKTtcbiAgfVxuICBfc2V0KHN0YXRlOiBhbnksIHRpdGxlOiBzdHJpbmcsIHVybDogc3RyaW5nLCByZXBsYWNlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fbG9jYXRpb24uaGFzaCA9IHVybDtcbiAgfVxuXG4gIGRpc3Bvc2Uocm91dGVyOiBVSVJvdXRlcikge1xuICAgIHN1cGVyLmRpc3Bvc2Uocm91dGVyKTtcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lcik7XG4gIH1cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSB2YW5pbGxhICovIC8qKiAqL1xuaW1wb3J0IHsgQmFzZUxvY2F0aW9uU2VydmljZXMgfSBmcm9tICcuL2Jhc2VMb2NhdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuXG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG5leHBvcnQgY2xhc3MgTWVtb3J5TG9jYXRpb25TZXJ2aWNlIGV4dGVuZHMgQmFzZUxvY2F0aW9uU2VydmljZXMge1xuICBfdXJsOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Iocm91dGVyOiBVSVJvdXRlcikge1xuICAgIHN1cGVyKHJvdXRlciwgdHJ1ZSk7XG4gIH1cblxuICBfZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBfc2V0KHN0YXRlOiBhbnksIHRpdGxlOiBzdHJpbmcsIHVybDogc3RyaW5nLCByZXBsYWNlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICB9XG59XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgdmFuaWxsYSAqLyAvKiogKi9cbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IEJhc2VMb2NhdGlvblNlcnZpY2VzIH0gZnJvbSAnLi9iYXNlTG9jYXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IExvY2F0aW9uQ29uZmlnLCByb290LCBzcGxpdEhhc2gsIHNwbGl0UXVlcnksIHN0cmlwTGFzdFBhdGhFbGVtZW50IH0gZnJvbSAnLi4vY29tbW9uJztcblxuLyoqXG4gKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiB1c2luZyB0aGUgYnJvd3NlcidzIGBsb2NhdGlvbmAgYW5kIGBoaXN0b3J5YCBhcGlzXG4gKlxuICogVXNlcyBgaGlzdG9yeS5wdXNoU3RhdGVgIGFuZCBgaGlzdG9yeS5yZXBsYWNlU3RhdGVgXG4gKi9cbmV4cG9ydCBjbGFzcyBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UgZXh0ZW5kcyBCYXNlTG9jYXRpb25TZXJ2aWNlcyB7XG4gIF9jb25maWc6IExvY2F0aW9uQ29uZmlnO1xuXG4gIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBzdXBlcihyb3V0ZXIsIHRydWUpO1xuICAgIHRoaXMuX2NvbmZpZyA9IHJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fbGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBiYXNlIHByZWZpeCB3aXRob3V0OlxuICAgKiAtIHRyYWlsaW5nIHNsYXNoXG4gICAqIC0gdHJhaWxpbmcgZmlsZW5hbWVcbiAgICogLSBwcm90b2NvbCBhbmQgaG9zdG5hbWVcbiAgICpcbiAgICogSWYgPGJhc2UgaHJlZj0nL2Jhc2UvJz4sIHRoaXMgcmV0dXJucyAnL2Jhc2UnLlxuICAgKiBJZiA8YmFzZSBocmVmPScvZm9vL2Jhc2UvJz4sIHRoaXMgcmV0dXJucyAnL2Zvby9iYXNlJy5cbiAgICogSWYgPGJhc2UgaHJlZj0nL2Jhc2UvaW5kZXguaHRtbCc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICogSWYgPGJhc2UgaHJlZj0naHR0cDovL2xvY2FsaG9zdDo4MDgwL2Jhc2UvaW5kZXguaHRtbCc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICogSWYgPGJhc2UgaHJlZj0nL2Jhc2UnPiwgdGhpcyByZXR1cm5zICcnLlxuICAgKiBJZiA8YmFzZSBocmVmPSdodHRwOi8vbG9jYWxob3N0OjgwODAnPiwgdGhpcyByZXR1cm5zICcnLlxuICAgKiBJZiA8YmFzZSBocmVmPSdodHRwOi8vbG9jYWxob3N0OjgwODAvJz4sIHRoaXMgcmV0dXJucyAnJy5cbiAgICpcbiAgICogU2VlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL2Rldi9zZW1hbnRpY3MuaHRtbCN0aGUtYmFzZS1lbGVtZW50XG4gICAqL1xuICBwcml2YXRlIF9nZXRCYXNlUHJlZml4KCkge1xuICAgIHJldHVybiBzdHJpcExhc3RQYXRoRWxlbWVudCh0aGlzLl9jb25maWcuYmFzZUhyZWYoKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldCgpIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgaGFzaCwgc2VhcmNoIH0gPSB0aGlzLl9sb2NhdGlvbjtcbiAgICBzZWFyY2ggPSBzcGxpdFF1ZXJ5KHNlYXJjaClbMV07IC8vIHN0cmlwID8gaWYgZm91bmRcbiAgICBoYXNoID0gc3BsaXRIYXNoKGhhc2gpWzFdOyAvLyBzdHJpcCAjIGlmIGZvdW5kXG5cbiAgICBjb25zdCBiYXNlUHJlZml4ID0gdGhpcy5fZ2V0QmFzZVByZWZpeCgpO1xuICAgIGNvbnN0IGV4YWN0QmFzZUhyZWZNYXRjaCA9IHBhdGhuYW1lID09PSB0aGlzLl9jb25maWcuYmFzZUhyZWYoKTtcbiAgICBjb25zdCBzdGFydHNXaXRoQmFzZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBiYXNlUHJlZml4Lmxlbmd0aCkgPT09IGJhc2VQcmVmaXg7XG4gICAgcGF0aG5hbWUgPSBleGFjdEJhc2VIcmVmTWF0Y2ggPyAnLycgOiBzdGFydHNXaXRoQmFzZSA/IHBhdGhuYW1lLnN1YnN0cmluZyhiYXNlUHJlZml4Lmxlbmd0aCkgOiBwYXRobmFtZTtcblxuICAgIHJldHVybiBwYXRobmFtZSArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyAoaGFzaCA/ICcjJyArIGhhc2ggOiAnJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldChzdGF0ZTogYW55LCB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZywgcmVwbGFjZTogYm9vbGVhbikge1xuICAgIGNvbnN0IGJhc2VQcmVmaXggPSB0aGlzLl9nZXRCYXNlUHJlZml4KCk7XG4gICAgY29uc3Qgc2xhc2ggPSB1cmwgJiYgdXJsWzBdICE9PSAnLycgPyAnLycgOiAnJztcbiAgICBjb25zdCBmdWxsVXJsID0gdXJsID09PSAnJyB8fCB1cmwgPT09ICcvJyA/IHRoaXMuX2NvbmZpZy5iYXNlSHJlZigpIDogYmFzZVByZWZpeCArIHNsYXNoICsgdXJsO1xuXG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIHRoaXMuX2hpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgZnVsbFVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgZnVsbFVybCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2Uocm91dGVyOiBVSVJvdXRlcikge1xuICAgIHN1cGVyLmRpc3Bvc2Uocm91dGVyKTtcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fbGlzdGVuZXIpO1xuICB9XG59XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgdmFuaWxsYSAqLyAvKiogKi9cbmltcG9ydCB7IExvY2F0aW9uQ29uZmlnIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBpc0RlZmluZWQgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5cbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgbW9jayB0aGF0IGdldHMvc2V0cyBhbGwgY29uZmlnIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xuZXhwb3J0IGNsYXNzIE1lbW9yeUxvY2F0aW9uQ29uZmlnIGltcGxlbWVudHMgTG9jYXRpb25Db25maWcge1xuICBkaXNwb3NlID0gbm9vcDtcblxuICBfYmFzZUhyZWYgPSAnJztcbiAgX3BvcnQgPSA4MDtcbiAgX3Byb3RvY29sID0gJ2h0dHAnO1xuICBfaG9zdCA9ICdsb2NhbGhvc3QnO1xuICBfaGFzaFByZWZpeCA9ICcnO1xuXG4gIHBvcnQgPSAoKSA9PiB0aGlzLl9wb3J0O1xuICBwcm90b2NvbCA9ICgpID0+IHRoaXMuX3Byb3RvY29sO1xuICBob3N0ID0gKCkgPT4gdGhpcy5faG9zdDtcbiAgYmFzZUhyZWYgPSAoKSA9PiB0aGlzLl9iYXNlSHJlZjtcbiAgaHRtbDVNb2RlID0gKCkgPT4gZmFsc2U7XG4gIGhhc2hQcmVmaXggPSAobmV3dmFsPykgPT4gKGlzRGVmaW5lZChuZXd2YWwpID8gKHRoaXMuX2hhc2hQcmVmaXggPSBuZXd2YWwpIDogdGhpcy5faGFzaFByZWZpeCk7XG59XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgdmFuaWxsYSAqL1xuLyoqICovXG5pbXBvcnQgeyBpc0RlZmluZWQsIGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgTG9jYXRpb25Db25maWcgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcblxuLyoqIEEgYExvY2F0aW9uQ29uZmlnYCB0aGF0IGRlbGVnYXRlcyB0byB0aGUgYnJvd3NlcidzIGBsb2NhdGlvbmAgb2JqZWN0ICovXG5leHBvcnQgY2xhc3MgQnJvd3NlckxvY2F0aW9uQ29uZmlnIGltcGxlbWVudHMgTG9jYXRpb25Db25maWcge1xuICBwcml2YXRlIF9iYXNlSHJlZiA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBfaGFzaFByZWZpeCA9ICcnO1xuXG4gIGNvbnN0cnVjdG9yKHJvdXRlcj8sIHByaXZhdGUgX2lzSHRtbDUgPSBmYWxzZSkge31cblxuICBwb3J0KCk6IG51bWJlciB7XG4gICAgaWYgKGxvY2F0aW9uLnBvcnQpIHtcbiAgICAgIHJldHVybiBOdW1iZXIobG9jYXRpb24ucG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvdG9jb2woKSA9PT0gJ2h0dHBzJyA/IDQ0MyA6IDgwO1xuICB9XG5cbiAgcHJvdG9jb2woKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgvOi9nLCAnJyk7XG4gIH1cblxuICBob3N0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG5cbiAgaHRtbDVNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc0h0bWw1O1xuICB9XG5cbiAgaGFzaFByZWZpeCgpOiBzdHJpbmc7XG4gIGhhc2hQcmVmaXgobmV3cHJlZml4Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKG5ld3ByZWZpeCkgPyAodGhpcy5faGFzaFByZWZpeCA9IG5ld3ByZWZpeCkgOiB0aGlzLl9oYXNoUHJlZml4O1xuICB9XG5cbiAgYmFzZUhyZWYoaHJlZj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGlzRGVmaW5lZChocmVmKSkgdGhpcy5fYmFzZUhyZWYgPSBocmVmO1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLl9iYXNlSHJlZikpIHRoaXMuX2Jhc2VIcmVmID0gdGhpcy5nZXRCYXNlSHJlZigpO1xuICAgIHJldHVybiB0aGlzLl9iYXNlSHJlZjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QmFzZUhyZWYoKSB7XG4gICAgY29uc3QgYmFzZVRhZzogSFRNTEJhc2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICBpZiAoYmFzZVRhZyAmJiBiYXNlVGFnLmhyZWYpIHtcbiAgICAgIHJldHVybiBiYXNlVGFnLmhyZWYucmVwbGFjZSgvXihbXi86XSo6KT9cXC9cXC9bXi9dKi8sICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNIdG1sNSA/ICcvJyA6IGxvY2F0aW9uLnBhdGhuYW1lIHx8ICcvJztcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7fVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQgeyBCcm93c2VyTG9jYXRpb25Db25maWcgfSBmcm9tICcuL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZyc7XG5pbXBvcnQgeyBIYXNoTG9jYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9oYXNoTG9jYXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IGxvY2F0aW9uUGx1Z2luRmFjdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgTG9jYXRpb25QbHVnaW4sIFNlcnZpY2VzUGx1Z2luIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgTWVtb3J5TG9jYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9tZW1vcnlMb2NhdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgTWVtb3J5TG9jYXRpb25Db25maWcgfSBmcm9tICcuL21lbW9yeUxvY2F0aW9uQ29uZmlnJztcbmltcG9ydCB7ICRpbmplY3RvciB9IGZyb20gJy4vaW5qZWN0b3InO1xuaW1wb3J0IHsgJHEgfSBmcm9tICcuL3EnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcnZpY2VzUGx1Z2luKHJvdXRlcjogVUlSb3V0ZXIpOiBTZXJ2aWNlc1BsdWdpbiB7XG4gIHNlcnZpY2VzLiRpbmplY3RvciA9ICRpbmplY3RvcjtcbiAgc2VydmljZXMuJHEgPSAkcTtcblxuICByZXR1cm4geyBuYW1lOiAndmFuaWxsYS5zZXJ2aWNlcycsICRxLCAkaW5qZWN0b3IsIGRpc3Bvc2U6ICgpID0+IG51bGwgfTtcbn1cblxuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB1c2VzIHRoZSBicm93c2VyIGhhc2ggdG8gZ2V0L3NldCB0aGUgY3VycmVudCBsb2NhdGlvbiAqL1xuZXhwb3J0IGNvbnN0IGhhc2hMb2NhdGlvblBsdWdpbjogKHJvdXRlcjogVUlSb3V0ZXIpID0+IExvY2F0aW9uUGx1Z2luID0gbG9jYXRpb25QbHVnaW5GYWN0b3J5KFxuICAndmFuaWxsYS5oYXNoQmFuZ0xvY2F0aW9uJyxcbiAgZmFsc2UsXG4gIEhhc2hMb2NhdGlvblNlcnZpY2UsXG4gIEJyb3dzZXJMb2NhdGlvbkNvbmZpZ1xuKTtcblxuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiB1c2luZyB0aGUgYnJvd3NlcidzIGBsb2NhdGlvbmAgYW5kIGBoaXN0b3J5YCBhcGlzICovXG5leHBvcnQgY29uc3QgcHVzaFN0YXRlTG9jYXRpb25QbHVnaW46IChyb3V0ZXI6IFVJUm91dGVyKSA9PiBMb2NhdGlvblBsdWdpbiA9IGxvY2F0aW9uUGx1Z2luRmFjdG9yeShcbiAgJ3ZhbmlsbGEucHVzaFN0YXRlTG9jYXRpb24nLFxuICB0cnVlLFxuICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsXG4gIEJyb3dzZXJMb2NhdGlvbkNvbmZpZ1xuKTtcblxuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBmcm9tIGFuIGluLW1lbW9yeSBvYmplY3QgKi9cbmV4cG9ydCBjb25zdCBtZW1vcnlMb2NhdGlvblBsdWdpbjogKHJvdXRlcjogVUlSb3V0ZXIpID0+IExvY2F0aW9uUGx1Z2luID0gbG9jYXRpb25QbHVnaW5GYWN0b3J5KFxuICAndmFuaWxsYS5tZW1vcnlMb2NhdGlvbicsXG4gIGZhbHNlLFxuICBNZW1vcnlMb2NhdGlvblNlcnZpY2UsXG4gIE1lbW9yeUxvY2F0aW9uQ29uZmlnXG4pO1xuIiwiLyoqXG4gKiAjIENvcmUgY2xhc3NlcyBhbmQgaW50ZXJmYWNlc1xuICpcbiAqIFRoZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHRoYXQgYXJlIGNvcmUgdG8gdWktcm91dGVyIGFuZCBkbyBub3QgYmVsb25nXG4gKiB0byBhIG1vcmUgc3BlY2lmaWMgc3Vic3lzdGVtIChzdWNoIGFzIHJlc29sdmUpLlxuICpcbiAqIEBwcmVmZXJyZWQgQHB1YmxpY2FwaSBAbW9kdWxlIGNvcmVcbiAqLyAvKiogKi9cblxuLy8gTmVlZCB0byBpbXBvcnQgb3IgZXhwb3J0IGF0IGxlYXN0IG9uZSBjb25jcmV0ZSBzb21ldGhpbmdcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcic7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gZ2V0IHJlc29sdmUgdmFsdWVzIGZvciBhIGdpdmVuIHRva2VuLlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIGBVSUluamVjdG9yYCBjYW4gYmUgcmV0cmlldmVkIGZyb20gdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiB1c2luZyBbW1RyYW5zaXRpb24uaW5qZWN0b3JdXS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBJZiBubyByZXNvbHZlIGlzIGZvdW5kIGZvciBhIHRva2VuLCB0aGVuIGl0IHdpbGwgZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBpbmplY3Rvci5cbiAqIFRoZSBuYXRpdmUgaW5qZWN0b3IgbWF5IGJlIEFuZ3VsYXIgMSBgJGluamVjdG9yYCwgQW5ndWxhciAyIGBJbmplY3RvcmAsIG9yIGEgc2ltcGxlIHBvbHlmaWxsLlxuICpcbiAqIEluIEFuZ3VsYXIgMiwgdGhlIG5hdGl2ZSBpbmplY3RvciBtaWdodCBiZSB0aGUgcm9vdCBJbmplY3RvcixcbiAqIG9yIGl0IG1pZ2h0IGJlIGEgbGF6eSBsb2FkZWQgYE5nTW9kdWxlYCBpbmplY3RvciBzY29wZWQgdG8gYSBsYXp5IGxvYWQgc3RhdGUgdHJlZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVSUluamVjdG9yIHtcbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSBpbmplY3Rvci5cbiAgICpcbiAgICogRm9yIGEgZ2l2ZW4gdG9rZW4sIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIGluamVjdG9yIHRoYXQgbWF0Y2hlcyB0aGUgdG9rZW4uXG4gICAqIElmIHRoZSB0b2tlbiBpcyBmb3IgYSByZXNvbHZlIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBmZXRjaGVkLCB0aGlzIHRocm93cyBhbiBlcnJvci5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlSZXNvbHZlID0gaW5qZWN0b3IuZ2V0KCdteVJlc29sdmUnKTtcbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgbmcxIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vIEZldGNoIFN0YXRlU2VydmljZVxuICAgKiBpbmplY3Rvci5nZXQoJyRzdGF0ZScpLmdvKCdob21lJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIG5nMiBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQge1N0YXRlU2VydmljZX0gZnJvbSBcInVpLXJvdXRlci1uZzJcIjtcbiAgICogLy8gRmV0Y2ggU3RhdGVTZXJ2aWNlXG4gICAqIGluamVjdG9yLmdldChTdGF0ZVNlcnZpY2UpLmdvKCdob21lJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIFR5cGVzY3JpcHQgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHN0cmluZ0FycmF5ID0gaW5qZWN0b3IuZ2V0PHN0cmluZ1tdPignbXlTdHJpbmdBcnJheScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIGBOT1dBSVRgIHBvbGljeVxuICAgKlxuICAgKiBXaGVuIHVzaW5nIFtbUmVzb2x2ZVBvbGljeS5hc3luY11dID09PSBgTk9XQUlUYCwgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gYGdldCgpYCBpcyBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQuXG4gICAqIFRoZSBwcm9taXNlIGlzIG5vdCBhdXRvbWF0aWNhbGx5IHVud3JhcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHRva2VuIHRoZSBrZXkgZm9yIHRoZSB2YWx1ZSB0byBnZXQuICBNYXkgYmUgYSBzdHJpbmcsIGEgY2xhc3MsIG9yIGFueSBhcmJpdHJhcnkgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHRoZSBEZXBlbmRlbmN5IEluamVjdGlvbiB2YWx1ZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuXG4gICAqL1xuICBnZXQodG9rZW46IGFueSk6IGFueTtcbiAgLyoqIEdldHMgYSB2YWx1ZSBhcyB0eXBlIGBUYCAoZ2VuZXJpY3MgcGFyYW1ldGVyKSAqL1xuICBnZXQ8VD4odG9rZW46IGFueSk6IFQ7XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGdldHMgYSB2YWx1ZSBmcm9tIHRoZSBpbmplY3RvclxuICAgKlxuICAgKiBGb3IgYSBnaXZlbiB0b2tlbiwgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBmcm9tIHRoZSBpbmplY3RvciB0aGF0IG1hdGNoZXMgdGhlIHRva2VuLlxuICAgKiBJZiB0aGUgdG9rZW4gaXMgZm9yIGEgcmVzb2x2ZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gZmV0Y2hlZCwgdGhpcyB0cmlnZ2VycyB0aGUgcmVzb2x2ZSB0byBsb2FkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHJldHVybiBpbmplY3Rvci5nZXRBc3luYygnbXlSZXNvbHZlJykudGhlbih2YWx1ZSA9PiB7XG4gICAqICAgaWYgKHZhbHVlID09PSAnZGVjbGluZWQnKSByZXR1cm4gZmFsc2U7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRva2VuIHRoZSBrZXkgZm9yIHRoZSB2YWx1ZSB0byBnZXQuICBNYXkgYmUgYSBzdHJpbmcgb3IgYXJiaXRyYXJ5IG9iamVjdC5cbiAgICogQHJldHVybiBhIFByb21pc2UgZm9yIHRoZSBEZXBlbmRlbmN5IEluamVjdGlvbiB2YWx1ZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuXG4gICAqL1xuICBnZXRBc3luYyh0b2tlbjogYW55KTogUHJvbWlzZTxhbnk+O1xuICAvKiogQXN5bmNocm9ub3VzbHkgZ2V0cyBhIHZhbHVlIGFzIHR5cGUgYFRgIChnZW5lcmljcyBwYXJhbWV0ZXIpICovXG4gIGdldEFzeW5jPFQ+KHRva2VuOiBhbnkpOiBQcm9taXNlPFQ+O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgZnJvbSB0aGUgbmF0aXZlIGluamVjdG9yXG4gICAqXG4gICAqIFJldHVybnMgYSB2YWx1ZSBmcm9tIHRoZSBuYXRpdmUgaW5qZWN0b3IsIGJ5cGFzc2luZyBhbnl0aGluZyBpbiB0aGUgW1tSZXNvbHZlQ29udGV4dF1dLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBsZXQgc29tZVRoaW5nID0gaW5qZWN0b3IuZ2V0TmF0aXZlKFNvbWVUb2tlbik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW4gdGhlIGtleSBmb3IgdGhlIHZhbHVlIHRvIGdldC4gIE1heSBiZSBhIHN0cmluZyBvciBhcmJpdHJhcnkgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHRoZSBEZXBlbmRlbmN5IEluamVjdGlvbiB2YWx1ZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuXG4gICAqL1xuICBnZXROYXRpdmUodG9rZW46IGFueSk6IGFueTtcbiAgZ2V0TmF0aXZlPFQ+KHRva2VuOiBhbnkpOiBUO1xufVxuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgaW50ZXJmYWNlIFVJUm91dGVyUGx1Z2luIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVJUm91dGVyUGx1Z2luQmFzZSBpbXBsZW1lbnRzIFVJUm91dGVyUGx1Z2luLCBEaXNwb3NhYmxlIHtcbiAgYWJzdHJhY3QgbmFtZTogc3RyaW5nO1xuICBkaXNwb3NlKHJvdXRlcjogVUlSb3V0ZXIpIHt9XG59XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGlzcG9zYWJsZSB7XG4gIC8qKiBJbnN0cnVjdHMgdGhlIERpc3Bvc2FibGUgdG8gY2xlYW4gdXAgYW55IHJlc291cmNlcyAqL1xuICBkaXNwb3NlKHJvdXRlcj86IFVJUm91dGVyKTtcbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgY29tbW9uICovIC8qKiAqL1xuXG5leHBvcnQgKiBmcm9tICcuL2NvbW1vbi9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3BhcmFtcy9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3BhdGgvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXNvbHZlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vc3RhdGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFuc2l0aW9uL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdXJsL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmlldy9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL2dsb2JhbHMnO1xuXG5leHBvcnQgKiBmcm9tICcuL3JvdXRlcic7XG5leHBvcnQgKiBmcm9tICcuL3ZhbmlsbGEnO1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2UnO1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5pbXBvcnQgeyBuZyBhcyBhbmd1bGFyIH0gZnJvbSAnLi4vYW5ndWxhcic7XG5pbXBvcnQge1xuICBTdGF0ZU9iamVjdCxcbiAgcGljayxcbiAgZm9yRWFjaCxcbiAgdGFpbCxcbiAgZXh0ZW5kLFxuICBpc0FycmF5LFxuICBpc0luamVjdGFibGUsXG4gIGlzRGVmaW5lZCxcbiAgaXNTdHJpbmcsXG4gIHNlcnZpY2VzLFxuICB0cmFjZSxcbiAgVmlld0NvbmZpZyxcbiAgVmlld1NlcnZpY2UsXG4gIFZpZXdDb25maWdGYWN0b3J5LFxuICBQYXRoTm9kZSxcbiAgUmVzb2x2ZUNvbnRleHQsXG4gIFJlc29sdmFibGUsXG4gIElJbmplY3RhYmxlLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBOZzFWaWV3RGVjbGFyYXRpb24gfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnLi4vdGVtcGxhdGVGYWN0b3J5JztcbmltcG9ydCBJSW5qZWN0b3JTZXJ2aWNlID0gYW5ndWxhci5hdXRvLklJbmplY3RvclNlcnZpY2U7XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeSgpOiBWaWV3Q29uZmlnRmFjdG9yeSB7XG4gIGxldCB0ZW1wbGF0ZUZhY3Rvcnk6IFRlbXBsYXRlRmFjdG9yeSA9IG51bGw7XG4gIHJldHVybiAocGF0aCwgdmlldykgPT4ge1xuICAgIHRlbXBsYXRlRmFjdG9yeSA9IHRlbXBsYXRlRmFjdG9yeSB8fCBzZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0KCckdGVtcGxhdGVGYWN0b3J5Jyk7XG4gICAgcmV0dXJuIFtuZXcgTmcxVmlld0NvbmZpZyhwYXRoLCB2aWV3LCB0ZW1wbGF0ZUZhY3RvcnkpXTtcbiAgfTtcbn1cblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuY29uc3QgaGFzQW55S2V5ID0gKGtleXMsIG9iaikgPT4ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2MgfHwgaXNEZWZpbmVkKG9ialtrZXldKSwgZmFsc2UpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGB2aWV3c2AuXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogaGFuZGxlcyB0aGUgYHZpZXdzYCBwcm9wZXJ0eSB3aXRoIGxvZ2ljIHNwZWNpZmljIHRvIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXG4gKlxuICogSWYgbm8gYHZpZXdzOiB7fWAgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhlbiBpdCBjcmVhdGVzIHRoZSBgdmlld3NgIG9iamVjdFxuICogYW5kIGFwcGxpZXMgdGhlIHN0YXRlLWxldmVsIGNvbmZpZ3VyYXRpb24gdG8gYSB2aWV3IG5hbWVkIGAkZGVmYXVsdGAuXG4gKlxuICogQGludGVybmFsYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZzFWaWV3c0J1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gIC8vIERvIG5vdCBwcm9jZXNzIHJvb3Qgc3RhdGVcbiAgaWYgKCFzdGF0ZS5wYXJlbnQpIHJldHVybiB7fTtcblxuICBjb25zdCB0cGxLZXlzID0gWyd0ZW1wbGF0ZVByb3ZpZGVyJywgJ3RlbXBsYXRlVXJsJywgJ3RlbXBsYXRlJywgJ25vdGlmeScsICdhc3luYyddLFxuICAgIGN0cmxLZXlzID0gWydjb250cm9sbGVyJywgJ2NvbnRyb2xsZXJQcm92aWRlcicsICdjb250cm9sbGVyQXMnLCAncmVzb2x2ZUFzJ10sXG4gICAgY29tcEtleXMgPSBbJ2NvbXBvbmVudCcsICdiaW5kaW5ncycsICdjb21wb25lbnRQcm92aWRlciddLFxuICAgIG5vbkNvbXBLZXlzID0gdHBsS2V5cy5jb25jYXQoY3RybEtleXMpLFxuICAgIGFsbFZpZXdLZXlzID0gY29tcEtleXMuY29uY2F0KG5vbkNvbXBLZXlzKTtcblxuICAvLyBEbyBub3QgYWxsb3cgYSBzdGF0ZSB0byBoYXZlIGJvdGggc3RhdGUtbGV2ZWwgcHJvcHMgYW5kIGFsc28gYSBgdmlld3M6IHt9YCBwcm9wZXJ0eS5cbiAgLy8gQSBzdGF0ZSB3aXRob3V0IGEgYHZpZXdzOiB7fWAgcHJvcGVydHkgY2FuIGRlY2xhcmUgcHJvcGVydGllcyBmb3IgdGhlIGAkZGVmYXVsdGAgdmlldyBhcyBwcm9wZXJ0aWVzIG9mIHRoZSBzdGF0ZS5cbiAgLy8gSG93ZXZlciwgdGhlIGAkZGVmYXVsdGAgYXBwcm9hY2ggc2hvdWxkIG5vdCBiZSBtaXhlZCB3aXRoIGEgc2VwYXJhdGUgYHZpZXdzOiBgIGJsb2NrLlxuICBpZiAoaXNEZWZpbmVkKHN0YXRlLnZpZXdzKSAmJiBoYXNBbnlLZXkoYWxsVmlld0tleXMsIHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTdGF0ZSAnJHtzdGF0ZS5uYW1lfScgaGFzIGEgJ3ZpZXdzJyBvYmplY3QuIGAgK1xuICAgICAgICBgSXQgY2Fubm90IGFsc28gaGF2ZSBcInZpZXcgcHJvcGVydGllc1wiIGF0IHRoZSBzdGF0ZSBsZXZlbC4gIGAgK1xuICAgICAgICBgTW92ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW50byBhIHZpZXcgKGluIHRoZSAndmlld3MnIG9iamVjdCk6IGAgK1xuICAgICAgICBgICR7YWxsVmlld0tleXMuZmlsdGVyKGtleSA9PiBpc0RlZmluZWQoc3RhdGVba2V5XSkpLmpvaW4oJywgJyl9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCB2aWV3czogeyBba2V5OiBzdHJpbmddOiBOZzFWaWV3RGVjbGFyYXRpb24gfSA9IHt9LFxuICAgIHZpZXdzT2JqZWN0ID0gc3RhdGUudmlld3MgfHwgeyAkZGVmYXVsdDogcGljayhzdGF0ZSwgYWxsVmlld0tleXMpIH07XG5cbiAgZm9yRWFjaCh2aWV3c09iamVjdCwgZnVuY3Rpb24oY29uZmlnOiBOZzFWaWV3RGVjbGFyYXRpb24sIG5hbWU6IHN0cmluZykge1xuICAgIC8vIEFjY291bnQgZm9yIHZpZXdzOiB7IFwiXCI6IHsgdGVtcGxhdGUuLi4gfSB9XG4gICAgbmFtZSA9IG5hbWUgfHwgJyRkZWZhdWx0JztcbiAgICAvLyBBY2NvdW50IGZvciB2aWV3czogeyBoZWFkZXI6IFwiaGVhZGVyQ29tcG9uZW50XCIgfVxuICAgIGlmIChpc1N0cmluZyhjb25maWcpKSBjb25maWcgPSB7IGNvbXBvbmVudDogPHN0cmluZz5jb25maWcgfTtcblxuICAgIC8vIE1ha2UgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGNvbmZpZyBvYmplY3RcbiAgICBjb25maWcgPSBleHRlbmQoe30sIGNvbmZpZyk7XG5cbiAgICAvLyBEbyBub3QgYWxsb3cgYSB2aWV3IHRvIG1peCBwcm9wcyBmb3IgY29tcG9uZW50LXN0eWxlIHZpZXcgd2l0aCBwcm9wcyBmb3IgdGVtcGxhdGUvY29udHJvbGxlci1zdHlsZSB2aWV3XG4gICAgaWYgKGhhc0FueUtleShjb21wS2V5cywgY29uZmlnKSAmJiBoYXNBbnlLZXkobm9uQ29tcEtleXMsIGNvbmZpZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjb21iaW5lOiAke2NvbXBLZXlzLmpvaW4oJ3wnKX0gd2l0aDogJHtub25Db21wS2V5cy5qb2luKCd8Jyl9IGluIHN0YXRldmlldzogJyR7bmFtZX1AJHtzdGF0ZS5uYW1lfSdgXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbmZpZy5yZXNvbHZlQXMgPSBjb25maWcucmVzb2x2ZUFzIHx8ICckcmVzb2x2ZSc7XG4gICAgY29uZmlnLiR0eXBlID0gJ25nMSc7XG4gICAgY29uZmlnLiRjb250ZXh0ID0gc3RhdGU7XG4gICAgY29uZmlnLiRuYW1lID0gbmFtZTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBWaWV3U2VydmljZS5ub3JtYWxpemVVSVZpZXdUYXJnZXQoY29uZmlnLiRjb250ZXh0LCBjb25maWcuJG5hbWUpO1xuICAgIGNvbmZpZy4kdWlWaWV3TmFtZSA9IG5vcm1hbGl6ZWQudWlWaWV3TmFtZTtcbiAgICBjb25maWcuJHVpVmlld0NvbnRleHRBbmNob3IgPSBub3JtYWxpemVkLnVpVmlld0NvbnRleHRBbmNob3I7XG5cbiAgICB2aWV3c1tuYW1lXSA9IGNvbmZpZztcbiAgfSk7XG4gIHJldHVybiB2aWV3cztcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmxldCBpZCA9IDA7XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBjbGFzcyBOZzFWaWV3Q29uZmlnIGltcGxlbWVudHMgVmlld0NvbmZpZyB7XG4gICRpZCA9IGlkKys7XG4gIGxvYWRlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyOiBGdW5jdGlvbjsgLy8gYWN0dWFsbHkgSUluamVjdGFibGV8c3RyaW5nXG4gIHRlbXBsYXRlOiBzdHJpbmc7XG4gIGNvbXBvbmVudDogc3RyaW5nO1xuICBsb2NhbHM6IGFueTsgLy8gVE9ETzogZGVsZXRlIG1lXG5cbiAgY29uc3RydWN0b3IocHVibGljIHBhdGg6IFBhdGhOb2RlW10sIHB1YmxpYyB2aWV3RGVjbDogTmcxVmlld0RlY2xhcmF0aW9uLCBwdWJsaWMgZmFjdG9yeTogVGVtcGxhdGVGYWN0b3J5KSB7fVxuXG4gIGxvYWQoKSB7XG4gICAgY29uc3QgJHEgPSBzZXJ2aWNlcy4kcTtcbiAgICBjb25zdCBjb250ZXh0ID0gbmV3IFJlc29sdmVDb250ZXh0KHRoaXMucGF0aCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXRoLnJlZHVjZSgoYWNjLCBub2RlKSA9PiBleHRlbmQoYWNjLCBub2RlLnBhcmFtVmFsdWVzKSwge30pO1xuXG4gICAgY29uc3QgcHJvbWlzZXM6IGFueSA9IHtcbiAgICAgIHRlbXBsYXRlOiAkcS53aGVuKHRoaXMuZmFjdG9yeS5mcm9tQ29uZmlnKHRoaXMudmlld0RlY2wsIHBhcmFtcywgY29udGV4dCkpLFxuICAgICAgY29udHJvbGxlcjogJHEud2hlbih0aGlzLmdldENvbnRyb2xsZXIoY29udGV4dCkpLFxuICAgIH07XG5cbiAgICByZXR1cm4gJHEuYWxsKHByb21pc2VzKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgdHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KCdMb2FkZWQnLCB0aGlzKTtcbiAgICAgIHRoaXMuY29udHJvbGxlciA9IHJlc3VsdHMuY29udHJvbGxlcjtcbiAgICAgIGV4dGVuZCh0aGlzLCByZXN1bHRzLnRlbXBsYXRlKTsgLy8gRWl0aGVyIHsgdGVtcGxhdGU6IFwidHBsXCIgfSBvciB7IGNvbXBvbmVudDogXCJjbXBOYW1lXCIgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxuICBnZXRUZW1wbGF0ZSA9ICh1aVZpZXcsIGNvbnRleHQ6IFJlc29sdmVDb250ZXh0KSA9PlxuICAgIHRoaXMuY29tcG9uZW50XG4gICAgICA/IHRoaXMuZmFjdG9yeS5tYWtlQ29tcG9uZW50VGVtcGxhdGUodWlWaWV3LCBjb250ZXh0LCB0aGlzLmNvbXBvbmVudCwgdGhpcy52aWV3RGVjbC5iaW5kaW5ncylcbiAgICAgIDogdGhpcy50ZW1wbGF0ZTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udHJvbGxlciBmb3IgYSB2aWV3IGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbnxQcm9taXNlLjxGdW5jdGlvbj59IFJldHVybnMgYSBjb250cm9sbGVyLCBvciBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGNvbnRyb2xsZXIuXG4gICAqL1xuICBnZXRDb250cm9sbGVyKGNvbnRleHQ6IFJlc29sdmVDb250ZXh0KTogSUluamVjdGFibGUgfCBzdHJpbmcgfCBQcm9taXNlPElJbmplY3RhYmxlIHwgc3RyaW5nPiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnZpZXdEZWNsLmNvbnRyb2xsZXJQcm92aWRlcjtcbiAgICBpZiAoIWlzSW5qZWN0YWJsZShwcm92aWRlcikpIHJldHVybiB0aGlzLnZpZXdEZWNsLmNvbnRyb2xsZXI7XG4gICAgY29uc3QgZGVwcyA9IHNlcnZpY2VzLiRpbmplY3Rvci5hbm5vdGF0ZShwcm92aWRlcik7XG4gICAgY29uc3QgcHJvdmlkZXJGbiA9IGlzQXJyYXkocHJvdmlkZXIpID8gdGFpbCg8YW55PnByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSBuZXcgUmVzb2x2YWJsZSgnJywgPGFueT5wcm92aWRlckZuLCBkZXBzKTtcbiAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQoY29udGV4dCk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdmlldyAqLyAvKiogKi9cbmltcG9ydCB7IG5nIGFzIGFuZ3VsYXIgfSBmcm9tICcuL2FuZ3VsYXInO1xuaW1wb3J0IHsgSUF1Z21lbnRlZEpRdWVyeSB9IGZyb20gJ2FuZ3VsYXInO1xuaW1wb3J0IHtcbiAgaXNBcnJheSxcbiAgaXNEZWZpbmVkLFxuICBpc0Z1bmN0aW9uLFxuICBpc09iamVjdCxcbiAgc2VydmljZXMsXG4gIE9iaixcbiAgSUluamVjdGFibGUsXG4gIHRhaWwsXG4gIGtlYm9iU3RyaW5nLFxuICB1bm5lc3RSLFxuICBSZXNvbHZlQ29udGV4dCxcbiAgUmVzb2x2YWJsZSxcbiAgUmF3UGFyYW1zLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBOZzFWaWV3RGVjbGFyYXRpb24sIFRlbXBsYXRlRmFjdG9yeVByb3ZpZGVyIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIFNlcnZpY2Ugd2hpY2ggbWFuYWdlcyBsb2FkaW5nIG9mIHRlbXBsYXRlcyBmcm9tIGEgVmlld0NvbmZpZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlRmFjdG9yeSBpbXBsZW1lbnRzIFRlbXBsYXRlRmFjdG9yeVByb3ZpZGVyIHtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfdXNlSHR0cCA9IGFuZ3VsYXIudmVyc2lvbi5taW5vciA8IDM7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgJHRlbXBsYXRlUmVxdWVzdDtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSAkdGVtcGxhdGVDYWNoZTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSAkaHR0cDtcblxuICAvKiogQGhpZGRlbiAqLyAkZ2V0ID0gW1xuICAgICckaHR0cCcsXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAnJGluamVjdG9yJyxcbiAgICAoJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkaW5qZWN0b3IpID0+IHtcbiAgICAgIHRoaXMuJHRlbXBsYXRlUmVxdWVzdCA9ICRpbmplY3Rvci5oYXMgJiYgJGluamVjdG9yLmhhcygnJHRlbXBsYXRlUmVxdWVzdCcpICYmICRpbmplY3Rvci5nZXQoJyR0ZW1wbGF0ZVJlcXVlc3QnKTtcbiAgICAgIHRoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgIHRoaXMuJHRlbXBsYXRlQ2FjaGUgPSAkdGVtcGxhdGVDYWNoZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIF07XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgdXNlSHR0cFNlcnZpY2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl91c2VIdHRwID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3Igd2hpY2ggdG8gbG9hZCBhIHRlbXBsYXRlLlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNlYXJjaCBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZVxuICAgKiB0aGF0IGlzIGRlZmluZWQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRlbXBsYXRlOlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcmVzb2x2ZSBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCB0aGUgdGVtcGxhdGUncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvclxuICAgKiB0aGF0IHN0cmluZyxvciBgbnVsbGAgaWYgbm8gdGVtcGxhdGUgaXMgY29uZmlndXJlZC5cbiAgICovXG4gIGZyb21Db25maWcoXG4gICAgY29uZmlnOiBOZzFWaWV3RGVjbGFyYXRpb24sXG4gICAgcGFyYW1zOiBhbnksXG4gICAgY29udGV4dDogUmVzb2x2ZUNvbnRleHRcbiAgKTogUHJvbWlzZTx7IHRlbXBsYXRlPzogc3RyaW5nOyBjb21wb25lbnQ/OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IGRlZmF1bHRUZW1wbGF0ZSA9ICc8dWktdmlldz48L3VpLXZpZXc+JztcblxuICAgIGNvbnN0IGFzVGVtcGxhdGUgPSByZXN1bHQgPT4gc2VydmljZXMuJHEud2hlbihyZXN1bHQpLnRoZW4oc3RyID0+ICh7IHRlbXBsYXRlOiBzdHIgfSkpO1xuICAgIGNvbnN0IGFzQ29tcG9uZW50ID0gcmVzdWx0ID0+IHNlcnZpY2VzLiRxLndoZW4ocmVzdWx0KS50aGVuKHN0ciA9PiAoeyBjb21wb25lbnQ6IHN0ciB9KSk7XG5cbiAgICByZXR1cm4gaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZSlcbiAgICAgID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21TdHJpbmcoY29uZmlnLnRlbXBsYXRlLCBwYXJhbXMpKVxuICAgICAgOiBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlVXJsKVxuICAgICAgPyBhc1RlbXBsYXRlKHRoaXMuZnJvbVVybChjb25maWcudGVtcGxhdGVVcmwsIHBhcmFtcykpXG4gICAgICA6IGlzRGVmaW5lZChjb25maWcudGVtcGxhdGVQcm92aWRlcilcbiAgICAgID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21Qcm92aWRlcihjb25maWcudGVtcGxhdGVQcm92aWRlciwgcGFyYW1zLCBjb250ZXh0KSlcbiAgICAgIDogaXNEZWZpbmVkKGNvbmZpZy5jb21wb25lbnQpXG4gICAgICA/IGFzQ29tcG9uZW50KGNvbmZpZy5jb21wb25lbnQpXG4gICAgICA6IGlzRGVmaW5lZChjb25maWcuY29tcG9uZW50UHJvdmlkZXIpXG4gICAgICA/IGFzQ29tcG9uZW50KHRoaXMuZnJvbUNvbXBvbmVudFByb3ZpZGVyKGNvbmZpZy5jb21wb25lbnRQcm92aWRlciwgcGFyYW1zLCBjb250ZXh0KSlcbiAgICAgIDogYXNUZW1wbGF0ZShkZWZhdWx0VGVtcGxhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gdGVtcGxhdGUgaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZyBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZy5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvciB0aGF0XG4gICAqIHN0cmluZy5cbiAgICovXG4gIGZyb21TdHJpbmcodGVtcGxhdGU6IHN0cmluZyB8IEZ1bmN0aW9uLCBwYXJhbXM/OiBSYXdQYXJhbXMpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbih0ZW1wbGF0ZSkgPyAoPGFueT50ZW1wbGF0ZSkocGFyYW1zKSA6IHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgdGVtcGxhdGUgZnJvbSB0aGUgYSBVUkwgdmlhIGAkaHR0cGAgYW5kIGAkdGVtcGxhdGVDYWNoZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSB1cmwgdXJsIG9mIHRoZSB0ZW1wbGF0ZSB0byBsb2FkLCBvciBhIGZ1bmN0aW9uXG4gICAqIHRoYXQgcmV0dXJucyBhIHVybC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHVybCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2VcbiAgICogZm9yIHRoYXQgc3RyaW5nLlxuICAgKi9cbiAgZnJvbVVybCh1cmw6IHN0cmluZyB8IEZ1bmN0aW9uLCBwYXJhbXM6IGFueSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHVybCkpIHVybCA9ICg8YW55PnVybCkocGFyYW1zKTtcbiAgICBpZiAodXJsID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3VzZUh0dHApIHtcbiAgICAgIHJldHVybiB0aGlzLiRodHRwXG4gICAgICAgIC5nZXQodXJsLCB7IGNhY2hlOiB0aGlzLiR0ZW1wbGF0ZUNhY2hlLCBoZWFkZXJzOiB7IEFjY2VwdDogJ3RleHQvaHRtbCcgfSB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4kdGVtcGxhdGVSZXF1ZXN0KHVybCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlciBGdW5jdGlvbiB0byBpbnZva2UgdmlhIGBsb2NhbHNgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZuIGEgZnVuY3Rpb24gdXNlZCB0byBpbnZva2UgdGhlIHRlbXBsYXRlIHByb3ZpZGVyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlXG4gICAqIGZvciB0aGF0IHN0cmluZy5cbiAgICovXG4gIGZyb21Qcm92aWRlcihwcm92aWRlcjogSUluamVjdGFibGUsIHBhcmFtczogYW55LCBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCkge1xuICAgIGNvbnN0IGRlcHMgPSBzZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVyRm4gPSBpc0FycmF5KHByb3ZpZGVyKSA/IHRhaWwoPGFueVtdPnByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSBuZXcgUmVzb2x2YWJsZSgnJywgPEZ1bmN0aW9uPnByb3ZpZGVyRm4sIGRlcHMpO1xuICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9uZW50J3MgdGVtcGxhdGUgYnkgaW52b2tpbmcgYW4gaW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYGxvY2Fsc2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0Rm4gYSBmdW5jdGlvbiB1c2VkIHRvIGludm9rZSB0aGUgdGVtcGxhdGUgcHJvdmlkZXJcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZzogXCI8Y29tcG9uZW50LW5hbWUgaW5wdXQxPSc6OiRyZXNvbHZlLmZvbyc+PC9jb21wb25lbnQtbmFtZT5cIi5cbiAgICovXG4gIGZyb21Db21wb25lbnRQcm92aWRlcihwcm92aWRlcjogSUluamVjdGFibGUsIHBhcmFtczogYW55LCBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCkge1xuICAgIGNvbnN0IGRlcHMgPSBzZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVyRm4gPSBpc0FycmF5KHByb3ZpZGVyKSA/IHRhaWwoPGFueVtdPnByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSBuZXcgUmVzb2x2YWJsZSgnJywgPEZ1bmN0aW9uPnByb3ZpZGVyRm4sIGRlcHMpO1xuICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZnJvbSBhIGNvbXBvbmVudCdzIG5hbWVcbiAgICpcbiAgICogVGhpcyBpbXBsZW1lbnRzIHJvdXRlLXRvLWNvbXBvbmVudC5cbiAgICogSXQgd29ya3MgYnkgcmV0cmlldmluZyB0aGUgY29tcG9uZW50IChkaXJlY3RpdmUpIG1ldGFkYXRhIGZyb20gdGhlIGluamVjdG9yLlxuICAgKiBJdCBhbmFseXNlcyB0aGUgY29tcG9uZW50J3MgYmluZGluZ3MsIHRoZW4gY29uc3RydWN0cyBhIHRlbXBsYXRlIHRoYXQgaW5zdGFudGlhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqIFRoZSB0ZW1wbGF0ZSB3aXJlcyBpbnB1dCBhbmQgb3V0cHV0IGJpbmRpbmdzIHRvIHJlc29sdmVzIG9yIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB1aVZpZXcge29iamVjdH0gVGhlIHBhcmVudCB1aS12aWV3IChmb3IgYmluZGluZyBvdXRwdXRzIHRvIGNhbGxiYWNrcylcbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIFJlc29sdmVDb250ZXh0IChmb3IgYmluZGluZyBvdXRwdXRzIHRvIGNhbGxiYWNrcyByZXR1cm5lZCBmcm9tIHJlc29sdmVzKVxuICAgKiBAcGFyYW0gY29tcG9uZW50IHtzdHJpbmd9IENvbXBvbmVudCdzIG5hbWUgaW4gY2FtZWwgY2FzZS5cbiAgICogQHBhcmFtIGJpbmRpbmdzIEFuIG9iamVjdCBkZWZpbmluZyB0aGUgY29tcG9uZW50J3MgYmluZGluZ3M6IHtmb286ICc8J31cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGVtcGxhdGUgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAqL1xuICBtYWtlQ29tcG9uZW50VGVtcGxhdGUodWlWaWV3OiBJQXVnbWVudGVkSlF1ZXJ5LCBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCwgY29tcG9uZW50OiBzdHJpbmcsIGJpbmRpbmdzPzogYW55KSB7XG4gICAgYmluZGluZ3MgPSBiaW5kaW5ncyB8fCB7fTtcblxuICAgIC8vIEJpbmQgb25jZSBwcmVmaXhcbiAgICBjb25zdCBwcmVmaXggPSBhbmd1bGFyLnZlcnNpb24ubWlub3IgPj0gMyA/ICc6OicgOiAnJztcbiAgICAvLyBDb252ZXJ0IHRvIGtlYm9iIG5hbWUuIEFkZCB4LSBwcmVmaXggaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBgeC1gIG9yIGBkYXRhLWBcbiAgICBjb25zdCBrZWJvYiA9IChjYW1lbENhc2U6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3Qga2Vib2JlZCA9IGtlYm9iU3RyaW5nKGNhbWVsQ2FzZSk7XG4gICAgICByZXR1cm4gL14oeHxkYXRhKS0vLmV4ZWMoa2Vib2JlZCkgPyBgeC0ke2tlYm9iZWR9YCA6IGtlYm9iZWQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZVRwbCA9IChpbnB1dDogQmluZGluZ1R1cGxlKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICAgICAgY29uc3QgYXR0ck5hbWUgPSBrZWJvYihuYW1lKTtcbiAgICAgIC8vIElmIHRoZSB1aS12aWV3IGhhcyBhbiBhdHRyaWJ1dGUgd2hpY2ggbWF0Y2hlcyBhIGJpbmRpbmcgb24gdGhlIHJvdXRlZCBjb21wb25lbnRcbiAgICAgIC8vIHRoZW4gcGFzcyB0aGF0IGF0dHJpYnV0ZSB0aHJvdWdoIHRvIHRoZSByb3V0ZWQgY29tcG9uZW50IHRlbXBsYXRlLlxuICAgICAgLy8gUHJlZmVyIHVpLXZpZXcgd2lyZWQgbWFwcGluZ3MgdG8gcmVzb2x2ZSBkYXRhLCB1bmxlc3MgdGhlIHJlc29sdmUgd2FzIGV4cGxpY2l0bHkgYm91bmQgdXNpbmcgYGJpbmRpbmdzOmBcbiAgICAgIGlmICh1aVZpZXcuYXR0cihhdHRyTmFtZSkgJiYgIWJpbmRpbmdzW25hbWVdKSByZXR1cm4gYCR7YXR0ck5hbWV9PScke3VpVmlldy5hdHRyKGF0dHJOYW1lKX0nYDtcblxuICAgICAgY29uc3QgcmVzb2x2ZU5hbWUgPSBiaW5kaW5nc1tuYW1lXSB8fCBuYW1lO1xuICAgICAgLy8gUHJlLWV2YWx1YXRlIHRoZSBleHByZXNzaW9uIGZvciBcIkBcIiBiaW5kaW5ncyBieSBlbmNsb3NpbmcgaW4ge3sgfX1cbiAgICAgIC8vIHNvbWUtYXR0cj1cInt7IDo6JHJlc29sdmUuc29tZVJlc29sdmVOYW1lIH19XCJcbiAgICAgIGlmICh0eXBlID09PSAnQCcpIHJldHVybiBgJHthdHRyTmFtZX09J3t7JHtwcmVmaXh9JHJlc29sdmUuJHtyZXNvbHZlTmFtZX19fSdgO1xuXG4gICAgICAvLyBXaXJlIFwiJlwiIGNhbGxiYWNrcyB0byByZXNvbHZlcyB0aGF0IHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAvLyBHZXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZSAoc2hvdWxkIGJlIGEgZnVuY3Rpb24pIGFuZCBhbm5vdGF0ZSBpdCB0byBnZXQgaXRzIGFyZ3VtZW50cy5cbiAgICAgIC8vIHNvbWUtYXR0cj1cIiRyZXNvbHZlLnNvbWVSZXNvbHZlUmVzdWx0TmFtZShmb28sIGJhcilcIlxuICAgICAgaWYgKHR5cGUgPT09ICcmJykge1xuICAgICAgICBjb25zdCByZXMgPSBjb250ZXh0LmdldFJlc29sdmFibGUocmVzb2x2ZU5hbWUpO1xuICAgICAgICBjb25zdCBmbiA9IHJlcyAmJiByZXMuZGF0YTtcbiAgICAgICAgY29uc3QgYXJncyA9IChmbiAmJiBzZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUoZm4pKSB8fCBbXTtcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgYXJyYXkgc3R5bGUgaW5qZWN0aW9uLCBpLmUuLCBbJ2ZvbycsIGZ1bmN0aW9uKGZvbykge31dXG4gICAgICAgIGNvbnN0IGFycmF5SWR4U3RyID0gaXNBcnJheShmbikgPyBgWyR7Zm4ubGVuZ3RoIC0gMX1dYCA6ICcnO1xuICAgICAgICByZXR1cm4gYCR7YXR0ck5hbWV9PSckcmVzb2x2ZS4ke3Jlc29sdmVOYW1lfSR7YXJyYXlJZHhTdHJ9KCR7YXJncy5qb2luKCcsJyl9KSdgO1xuICAgICAgfVxuXG4gICAgICAvLyBzb21lLWF0dHI9XCI6OiRyZXNvbHZlLnNvbWVSZXNvbHZlTmFtZVwiXG4gICAgICByZXR1cm4gYCR7YXR0ck5hbWV9PScke3ByZWZpeH0kcmVzb2x2ZS4ke3Jlc29sdmVOYW1lfSdgO1xuICAgIH07XG5cbiAgICBjb25zdCBhdHRycyA9IGdldENvbXBvbmVudEJpbmRpbmdzKGNvbXBvbmVudClcbiAgICAgIC5tYXAoYXR0cmlidXRlVHBsKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgICBjb25zdCBrZWJvYk5hbWUgPSBrZWJvYihjb21wb25lbnQpO1xuICAgIHJldHVybiBgPCR7a2Vib2JOYW1lfSAke2F0dHJzfT48LyR7a2Vib2JOYW1lfT5gO1xuICB9XG59XG5cbi8vIEdldHMgYWxsIHRoZSBkaXJlY3RpdmUocyknIGlucHV0cyAoJ0AnLCAnPScsIGFuZCAnPCcpIGFuZCBvdXRwdXRzICgnJicpXG5mdW5jdGlvbiBnZXRDb21wb25lbnRCaW5kaW5ncyhuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgY21wRGVmcyA9IDxhbnlbXT5zZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0KG5hbWUgKyAnRGlyZWN0aXZlJyk7IC8vIGNvdWxkIGJlIG11bHRpcGxlXG4gIGlmICghY21wRGVmcyB8fCAhY21wRGVmcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgY29tcG9uZW50IG5hbWVkICcke25hbWV9J2ApO1xuICByZXR1cm4gY21wRGVmcy5tYXAoZ2V0QmluZGluZ3MpLnJlZHVjZSh1bm5lc3RSLCBbXSk7XG59XG5cbi8vIEdpdmVuIGEgZGlyZWN0aXZlIGRlZmluaXRpb24sIGZpbmQgaXRzIG9iamVjdCBpbnB1dCBhdHRyaWJ1dGVzXG4vLyBVc2UgZGlmZmVyZW50IHByb3BlcnRpZXMsIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBkaXJlY3RpdmUgKGNvbXBvbmVudCwgYmluZFRvQ29udHJvbGxlciwgbm9ybWFsKVxuY29uc3QgZ2V0QmluZGluZ3MgPSAoZGVmOiBhbnkpID0+IHtcbiAgaWYgKGlzT2JqZWN0KGRlZi5iaW5kVG9Db250cm9sbGVyKSkgcmV0dXJuIHNjb3BlQmluZGluZ3MoZGVmLmJpbmRUb0NvbnRyb2xsZXIpO1xuICByZXR1cm4gc2NvcGVCaW5kaW5ncyhkZWYuc2NvcGUpO1xufTtcblxuaW50ZXJmYWNlIEJpbmRpbmdUdXBsZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xufVxuXG4vLyBmb3IgbmcgMS4yIHN0eWxlLCBwcm9jZXNzIHRoZSBzY29wZTogeyBpbnB1dDogXCI9Zm9vXCIgfVxuLy8gZm9yIG5nIDEuMyB0aHJvdWdoIG5nIDEuNSwgcHJvY2VzcyB0aGUgY29tcG9uZW50J3MgYmluZFRvQ29udHJvbGxlcjogeyBpbnB1dDogXCI9Zm9vXCIgfSBvYmplY3RcbmNvbnN0IHNjb3BlQmluZGluZ3MgPSAoYmluZGluZ3NPYmo6IE9iaikgPT5cbiAgT2JqZWN0LmtleXMoYmluZGluZ3NPYmogfHwge30pXG4gICAgLy8gWyAnaW5wdXQnLCBbICc9Zm9vJywgJz0nLCAnZm9vJyBdIF1cbiAgICAubWFwKGtleSA9PiBba2V5LCAvXihbPTxAJl0pWz9dPyguKikvLmV4ZWMoYmluZGluZ3NPYmpba2V5XSldKVxuICAgIC8vIHNraXAgbWFsZm9ybWVkIHZhbHVlc1xuICAgIC5maWx0ZXIodHVwbGUgPT4gaXNEZWZpbmVkKHR1cGxlKSAmJiBpc0FycmF5KHR1cGxlWzFdKSlcbiAgICAvLyB7IG5hbWU6ICgnZm9vJyB8fCAnaW5wdXQnKSwgdHlwZTogJz0nIH1cbiAgICAubWFwKHR1cGxlID0+ICh7IG5hbWU6IHR1cGxlWzFdWzJdIHx8IHR1cGxlWzBdLCB0eXBlOiB0dXBsZVsxXVsxXSB9IGFzIEJpbmRpbmdUdXBsZSkpO1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5pbXBvcnQge1xuICB2YWwsXG4gIGlzT2JqZWN0LFxuICBjcmVhdGVQcm94eUZ1bmN0aW9ucyxcbiAgQnVpbGRlckZ1bmN0aW9uLFxuICBTdGF0ZVJlZ2lzdHJ5LFxuICBTdGF0ZVNlcnZpY2UsXG4gIE9uSW52YWxpZENhbGxiYWNrLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBOZzFTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIFRoZSBBbmd1bGFyIDEgYFN0YXRlUHJvdmlkZXJgXG4gKlxuICogVGhlIGAkc3RhdGVQcm92aWRlcmAgd29ya3Mgc2ltaWxhciB0byBBbmd1bGFyJ3MgdjEgcm91dGVyLCBidXQgaXQgZm9jdXNlcyBwdXJlbHlcbiAqIG9uIHN0YXRlLlxuICpcbiAqIEEgc3RhdGUgY29ycmVzcG9uZHMgdG8gYSBcInBsYWNlXCIgaW4gdGhlIGFwcGxpY2F0aW9uIGluIHRlcm1zIG9mIHRoZSBvdmVyYWxsIFVJIGFuZFxuICogbmF2aWdhdGlvbi4gQSBzdGF0ZSBkZXNjcmliZXMgKHZpYSB0aGUgY29udHJvbGxlciAvIHRlbXBsYXRlIC8gdmlldyBwcm9wZXJ0aWVzKSB3aGF0XG4gKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxuICpcbiAqIFN0YXRlcyBvZnRlbiBoYXZlIHRoaW5ncyBpbiBjb21tb24sIGFuZCB0aGUgcHJpbWFyeSB3YXkgb2YgZmFjdG9yaW5nIG91dCB0aGVzZVxuICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXG4gKiBuZXN0ZWQgc3RhdGVzLlxuICpcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RhdGVSZWdpc3RyeTogU3RhdGVSZWdpc3RyeSwgcHJpdmF0ZSBzdGF0ZVNlcnZpY2U6IFN0YXRlU2VydmljZSkge1xuICAgIGNyZWF0ZVByb3h5RnVuY3Rpb25zKHZhbChTdGF0ZVByb3ZpZGVyLnByb3RvdHlwZSksIHRoaXMsIHZhbCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb3JhdGVzIHN0YXRlcyB3aGVuIHRoZXkgYXJlIHJlZ2lzdGVyZWRcbiAgICpcbiAgICogQWxsb3dzIHlvdSB0byBleHRlbmQgKGNhcmVmdWxseSkgb3Igb3ZlcnJpZGUgKGF0IHlvdXIgb3duIHBlcmlsKSB0aGVcbiAgICogYHN0YXRlQnVpbGRlcmAgb2JqZWN0IHVzZWQgaW50ZXJuYWxseSBieSBbW1N0YXRlUmVnaXN0cnldXS5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBhZGQgY3VzdG9tIGZ1bmN0aW9uYWxpdHkgdG8gdWktcm91dGVyLFxuICAgKiBmb3IgZXhhbXBsZSBpbmZlcnJpbmcgdGVtcGxhdGVVcmwgYmFzZWQgb24gdGhlIHN0YXRlIG5hbWUuXG4gICAqXG4gICAqIFdoZW4gcGFzc2luZyBvbmx5IGEgbmFtZSwgaXQgcmV0dXJucyB0aGUgY3VycmVudCAob3JpZ2luYWwgb3IgZGVjb3JhdGVkKSBidWlsZGVyXG4gICAqIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyBgbmFtZWAuXG4gICAqXG4gICAqIFRoZSBidWlsZGVyIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBkZWNvcmF0ZWQgYXJlIGxpc3RlZCBiZWxvdy4gVGhvdWdoIG5vdCBhbGxcbiAgICogbmVjZXNzYXJpbHkgaGF2ZSBhIGdvb2QgdXNlIGNhc2UgZm9yIGRlY29yYXRpb24sIHRoYXQgaXMgdXAgdG8geW91IHRvIGRlY2lkZS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24sIHVzZXJzIGNhbiBhdHRhY2ggY3VzdG9tIGRlY29yYXRvcnMsIHdoaWNoIHdpbGwgZ2VuZXJhdGUgbmV3XG4gICAqIHByb3BlcnRpZXMgd2l0aGluIHRoZSBzdGF0ZSdzIGludGVybmFsIGRlZmluaXRpb24uIFRoZXJlIGlzIGN1cnJlbnRseSBubyBjbGVhclxuICAgKiB1c2UtY2FzZSBmb3IgdGhpcyBiZXlvbmQgYWNjZXNzaW5nIGludGVybmFsIHN0YXRlcyAoaS5lLiAkc3RhdGUuJGN1cnJlbnQpLFxuICAgKiBob3dldmVyLCBleHBlY3QgdGhpcyB0byBiZWNvbWUgaW5jcmVhc2luZ2x5IHJlbGV2YW50IGFzIHdlIGludHJvZHVjZSBhZGRpdGlvbmFsXG4gICAqIG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMuXG4gICAqXG4gICAqICoqV2FybmluZyoqOiBEZWNvcmF0b3JzIHNob3VsZCBub3QgYmUgaW50ZXJkZXBlbmRlbnQgYmVjYXVzZSB0aGUgb3JkZXIgb2ZcbiAgICogZXhlY3V0aW9uIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9ucyBpbiBub24tZGV0ZXJtaW5pc3RpYy4gQnVpbGRlciBmdW5jdGlvbnNcbiAgICogc2hvdWxkIG9ubHkgYmUgZGVwZW5kZW50IG9uIHRoZSBzdGF0ZSBkZWZpbml0aW9uIG9iamVjdCBhbmQgc3VwZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqXG4gICAqIEV4aXN0aW5nIGJ1aWxkZXIgZnVuY3Rpb25zIGFuZCBjdXJyZW50IHJldHVybiB2YWx1ZXM6XG4gICAqXG4gICAqIC0gKipwYXJlbnQqKiBge29iamVjdH1gIC0gcmV0dXJucyB0aGUgcGFyZW50IHN0YXRlIG9iamVjdC5cbiAgICogLSAqKmRhdGEqKiBge29iamVjdH1gIC0gcmV0dXJucyBzdGF0ZSBkYXRhLCBpbmNsdWRpbmcgYW55IGluaGVyaXRlZCBkYXRhIHRoYXQgaXMgbm90XG4gICAqICAgb3ZlcnJpZGRlbiBieSBvd24gdmFsdWVzIChpZiBhbnkpLlxuICAgKiAtICoqdXJsKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIFVybE1hdGNoZXJ9XG4gICAqICAgb3IgYG51bGxgLlxuICAgKiAtICoqbmF2aWdhYmxlKiogYHtvYmplY3R9YCAtIHJldHVybnMgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoYWthIGlzXG4gICAqICAgbmF2aWdhYmxlKS5cbiAgICogLSAqKnBhcmFtcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIHBhcmFtcyB0aGF0IGFyZSBlbnN1cmVkIHRvXG4gICAqICAgYmUgYSBzdXBlci1zZXQgb2YgcGFyZW50J3MgcGFyYW1zLlxuICAgKiAtICoqdmlld3MqKiBge29iamVjdH1gIC0gcmV0dXJucyBhIHZpZXdzIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhbiBhYnNvbHV0ZSB2aWV3XG4gICAqICAgbmFtZSAoaS5lLiBcInZpZXdOYW1lQHN0YXRlTmFtZVwiKSBhbmQgZWFjaCB2YWx1ZSBpcyB0aGUgY29uZmlnIG9iamVjdFxuICAgKiAgICh0ZW1wbGF0ZSwgY29udHJvbGxlcikgZm9yIHRoZSB2aWV3LiBFdmVuIHdoZW4geW91IGRvbid0IHVzZSB0aGUgdmlld3Mgb2JqZWN0XG4gICAqICAgZXhwbGljaXRseSBvbiBhIHN0YXRlIGNvbmZpZywgb25lIGlzIHN0aWxsIGNyZWF0ZWQgZm9yIHlvdSBpbnRlcm5hbGx5LlxuICAgKiAgIFNvIGJ5IGRlY29yYXRpbmcgdGhpcyBidWlsZGVyIGZ1bmN0aW9uIHlvdSBoYXZlIGFjY2VzcyB0byBkZWNvcmF0aW5nIHRlbXBsYXRlXG4gICAqICAgYW5kIGNvbnRyb2xsZXIgcHJvcGVydGllcy5cbiAgICogLSAqKm93blBhcmFtcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtcyB0aGF0IGJlbG9uZyB0byB0aGUgc3RhdGUsXG4gICAqICAgbm90IGluY2x1ZGluZyBhbnkgcGFyYW1zIGRlZmluZWQgYnkgYW5jZXN0b3Igc3RhdGVzLlxuICAgKiAtICoqcGF0aCoqIGB7c3RyaW5nfWAgLSByZXR1cm5zIHRoZSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUuXG4gICAqICAgTmVlZGVkIGZvciBzdGF0ZSBhY3RpdmF0aW9uLlxuICAgKiAtICoqaW5jbHVkZXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBldmVyeSBzdGF0ZSB0aGF0XG4gICAqICAgd291bGQgcGFzcyBhIGAkc3RhdGUuaW5jbHVkZXMoKWAgdGVzdC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBPdmVycmlkZSB0aGUgaW50ZXJuYWwgJ3ZpZXdzJyBidWlsZGVyIHdpdGggYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzdGF0ZVxuICAgKiBkZWZpbml0aW9uLCBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIGJlaW5nIG92ZXJyaWRkZW46XG4gICAqIGBgYGpzXG4gICAqICRzdGF0ZVByb3ZpZGVyLmRlY29yYXRvcigndmlld3MnLCBmdW5jdGlvbiAoc3RhdGUsIHBhcmVudCkge1xuICAgKiAgIGxldCByZXN1bHQgPSB7fSxcbiAgICogICAgICAgdmlld3MgPSBwYXJlbnQoc3RhdGUpO1xuICAgKlxuICAgKiAgIGFuZ3VsYXIuZm9yRWFjaCh2aWV3cywgZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgKiAgICAgbGV0IGF1dG9OYW1lID0gKHN0YXRlLm5hbWUgKyAnLicgKyBuYW1lKS5yZXBsYWNlKCcuJywgJy8nKTtcbiAgICogICAgIGNvbmZpZy50ZW1wbGF0ZVVybCA9IGNvbmZpZy50ZW1wbGF0ZVVybCB8fCAnL3BhcnRpYWxzLycgKyBhdXRvTmFtZSArICcuaHRtbCc7XG4gICAqICAgICByZXN1bHRbbmFtZV0gPSBjb25maWc7XG4gICAqICAgfSk7XG4gICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICogfSk7XG4gICAqXG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCdob21lJywge1xuICAgKiAgIHZpZXdzOiB7XG4gICAqICAgICAnY29udGFjdC5saXN0JzogeyBjb250cm9sbGVyOiAnTGlzdENvbnRyb2xsZXInIH0sXG4gICAqICAgICAnY29udGFjdC5pdGVtJzogeyBjb250cm9sbGVyOiAnSXRlbUNvbnRyb2xsZXInIH1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gQXV0by1wb3B1bGF0ZXMgbGlzdCBhbmQgaXRlbSB2aWV3cyB3aXRoIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvbGlzdC5odG1sLFxuICAgKiAvLyBhbmQgL3BhcnRpYWxzL2hvbWUvY29udGFjdC9pdGVtLmh0bWwsIHJlc3BlY3RpdmVseS5cbiAgICogJHN0YXRlLmdvKCdob21lJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbiB0byBkZWNvcmF0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGZ1bmMgQSBmdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkZWNvcmF0aW5nIHRoZSBvcmlnaW5hbFxuICAgKiBidWlsZGVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgLSBge29iamVjdH1gIC0gc3RhdGUgLSBUaGUgc3RhdGUgY29uZmlnIG9iamVjdC5cbiAgICogICAtIGB7b2JqZWN0fWAgLSBzdXBlciAtIFRoZSBvcmlnaW5hbCBidWlsZGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICRzdGF0ZVByb3ZpZGVyIC0gJHN0YXRlUHJvdmlkZXIgaW5zdGFuY2VcbiAgICovXG4gIGRlY29yYXRvcihuYW1lOiBzdHJpbmcsIGZ1bmM6IEJ1aWxkZXJGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKG5hbWUsIGZ1bmMpIHx8IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgc3RhdGVcbiAgICpcbiAgICogIyMjIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0byBbW1N0YXRlUmVnaXN0cnkucmVnaXN0ZXJdXS5cbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgc3RhdGUgY29uZmlndXJhdGlvbiB1bmRlciBhIGdpdmVuIHN0YXRlIG5hbWUuXG4gICAqIFRoZSBzdGF0ZUNvbmZpZyBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgYWNjZXB0YWJsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiA8YSBpZD0ndGVtcGxhdGUnPjwvYT5cbiAgICpcbiAgICogLSAqKmB0ZW1wbGF0ZWAqKiAtIHtzdHJpbmd8ZnVuY3Rpb249fSAtIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICogICBhbiBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSB1c2VkIGJ5IHRoZSB1aVZpZXcgZGlyZWN0aXZlcy4gVGhpcyBwcm9wZXJ0eVxuICAgKiAgIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0ZW1wbGF0ZVVybC5cbiAgICpcbiAgICogICBJZiBgdGVtcGxhdGVgIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgIC0ge2FycmF5LiZsdDtvYmplY3QmZ3Q7fSAtIHN0YXRlIHBhcmFtZXRlcnMgZXh0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnQgJGxvY2F0aW9uLnBhdGgoKSBieVxuICAgKiAgICAgYXBwbHlpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICpcbiAgICogPGEgaWQ9J3RlbXBsYXRlVXJsJz48L2E+XG4gICAqXG4gICAqIC0gKipgdGVtcGxhdGVVcmxgKiogLSB7c3RyaW5nfGZ1bmN0aW9uPX0gLSBwYXRoIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGggdG8gYW4gaHRtbFxuICAgKiAgIHRlbXBsYXRlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgdWlWaWV3LlxuICAgKlxuICAgKiAgIElmIGB0ZW1wbGF0ZVVybGAgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgLSB7YXJyYXkuJmx0O29iamVjdCZndDt9IC0gc3RhdGUgcGFyYW1ldGVycyBleHRyYWN0ZWQgZnJvbSB0aGUgY3VycmVudCAkbG9jYXRpb24ucGF0aCgpIGJ5XG4gICAqICAgICBhcHBseWluZyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKlxuICAgKiA8YSBpZD0ndGVtcGxhdGVQcm92aWRlcic+PC9hPlxuICAgKlxuICAgKiAtICoqYHRlbXBsYXRlUHJvdmlkZXJgKiogLSB7ZnVuY3Rpb249fSAtIFByb3ZpZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBIVE1MIGNvbnRlbnRcbiAgICogICBzdHJpbmcuXG4gICAqXG4gICAqIDxhIGlkPSdjb250cm9sbGVyJz48L2E+XG4gICAqXG4gICAqIC0gKipgY29udHJvbGxlcmAqKiAtIHtzdHJpbmd8ZnVuY3Rpb249fSAtICBDb250cm9sbGVyIGZuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBuZXdseVxuICAgKiAgIHJlbGF0ZWQgc2NvcGUgb3IgdGhlIG5hbWUgb2YgYSByZWdpc3RlcmVkIGNvbnRyb2xsZXIgaWYgcGFzc2VkIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiA8YSBpZD0nY29udHJvbGxlclByb3ZpZGVyJz48L2E+XG4gICAqXG4gICAqIC0gKipgY29udHJvbGxlclByb3ZpZGVyYCoqIC0ge2Z1bmN0aW9uPX0gLSBJbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgKiAgIHRoZSBhY3R1YWwgY29udHJvbGxlciBvciBzdHJpbmcuXG4gICAqXG4gICAqIDxhIGlkPSdjb250cm9sbGVyQXMnPjwvYT5cbiAgICpcbiAgICogLSAqKmBjb250cm9sbGVyQXNgKiog4oCTIHtzdHJpbmc9fSDigJMgQSBjb250cm9sbGVyIGFsaWFzIG5hbWUuIElmIHByZXNlbnQgdGhlIGNvbnRyb2xsZXIgd2lsbCBiZVxuICAgKiAgIHB1Ymxpc2hlZCB0byBzY29wZSB1bmRlciB0aGUgY29udHJvbGxlckFzIG5hbWUuXG4gICAqXG4gICAqIDxhIGlkPSdyZXNvbHZlJz48L2E+XG4gICAqXG4gICAqIC0gKipgcmVzb2x2ZWAqKiAtIHtvYmplY3QuJmx0O3N0cmluZywgZnVuY3Rpb24mZ3Q7PX0gLSBBbiBvcHRpb25hbCBtYXAgb2YgZGVwZW5kZW5jaWVzIHdoaWNoXG4gICAqICAgc2hvdWxkIGJlIGluamVjdGVkIGludG8gdGhlIGNvbnRyb2xsZXIuIElmIGFueSBvZiB0aGVzZSBkZXBlbmRlbmNpZXMgYXJlIHByb21pc2VzLFxuICAgKiAgIHRoZSByb3V0ZXIgd2lsbCB3YWl0IGZvciB0aGVtIGFsbCB0byBiZSByZXNvbHZlZCBvciBvbmUgdG8gYmUgcmVqZWN0ZWQgYmVmb3JlIHRoZVxuICAgKiAgIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiBJZiBhbGwgdGhlIHByb21pc2VzIGFyZSByZXNvbHZlZCBzdWNjZXNzZnVsbHksIHRoZSB2YWx1ZXNcbiAgICogICBvZiB0aGUgcmVzb2x2ZWQgcHJvbWlzZXMgYXJlIGluamVjdGVkIGFuZCAkc3RhdGVDaGFuZ2VTdWNjZXNzIGV2ZW50IGlzIGZpcmVkLiBJZiBhbnlcbiAgICogICBvZiB0aGUgcHJvbWlzZXMgYXJlIHJlamVjdGVkIHRoZSAkc3RhdGVDaGFuZ2VFcnJvciBldmVudCBpcyBmaXJlZC4gVGhlIG1hcCBvYmplY3QgaXM6XG4gICAqXG4gICAqICAgLSBrZXkgLSB7c3RyaW5nfTogbmFtZSBvZiBkZXBlbmRlbmN5IHRvIGJlIGluamVjdGVkIGludG8gY29udHJvbGxlclxuICAgKiAgIC0gZmFjdG9yeSAtIHtzdHJpbmd8ZnVuY3Rpb259OiBJZiBzdHJpbmcgdGhlbiBpdCBpcyBhbGlhcyBmb3Igc2VydmljZS4gT3RoZXJ3aXNlIGlmIGZ1bmN0aW9uLFxuICAgKiAgICAgaXQgaXMgaW5qZWN0ZWQgYW5kIHJldHVybiB2YWx1ZSBpdCB0cmVhdGVkIGFzIGRlcGVuZGVuY3kuIElmIHJlc3VsdCBpcyBhIHByb21pc2UsIGl0IGlzXG4gICAqICAgICByZXNvbHZlZCBiZWZvcmUgaXRzIHZhbHVlIGlzIGluamVjdGVkIGludG8gY29udHJvbGxlci5cbiAgICpcbiAgICogPGEgaWQ9J3VybCc+PC9hPlxuICAgKlxuICAgKiAtICoqYHVybGAqKiAtIHtzdHJpbmc9fSAtIEEgdXJsIHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycy4gV2hlbiBhIHN0YXRlIGlzIG5hdmlnYXRlZCBvclxuICAgKiAgIHRyYW5zaXRpb25lZCB0bywgdGhlIGAkc3RhdGVQYXJhbXNgIHNlcnZpY2Ugd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBhbnlcbiAgICogICBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQuXG4gICAqXG4gICAqIDxhIGlkPSdwYXJhbXMnPjwvYT5cbiAgICpcbiAgICogLSAqKmBwYXJhbXNgKiogLSB7b2JqZWN0PX0gLSBBbiBhcnJheSBvZiBwYXJhbWV0ZXIgbmFtZXMgb3IgcmVndWxhciBleHByZXNzaW9ucy4gT25seVxuICAgKiAgIHVzZSB0aGlzIHdpdGhpbiBhIHN0YXRlIGlmIHlvdSBhcmUgbm90IHVzaW5nIHVybC4gT3RoZXJ3aXNlIHlvdSBjYW4gc3BlY2lmeSB5b3VyXG4gICAqICAgcGFyYW1ldGVycyB3aXRoaW4gdGhlIHVybC4gV2hlbiBhIHN0YXRlIGlzIG5hdmlnYXRlZCBvciB0cmFuc2l0aW9uZWQgdG8sIHRoZVxuICAgKiAgICRzdGF0ZVBhcmFtcyBzZXJ2aWNlIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggYW55IHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZC5cbiAgICpcbiAgICogPGEgaWQ9J3ZpZXdzJz48L2E+XG4gICAqXG4gICAqIC0gKipgdmlld3NgKiogLSB7b2JqZWN0PX0gLSBVc2UgdGhlIHZpZXdzIHByb3BlcnR5IHRvIHNldCB1cCBtdWx0aXBsZSB2aWV3cyBvciB0byB0YXJnZXQgdmlld3NcbiAgICogICBtYW51YWxseS9leHBsaWNpdGx5LlxuICAgKlxuICAgKiA8YSBpZD0nYWJzdHJhY3QnPjwvYT5cbiAgICpcbiAgICogLSAqKmBhYnN0cmFjdGAqKiAtIHtib29sZWFuPX0gLSBBbiBhYnN0cmFjdCBzdGF0ZSB3aWxsIG5ldmVyIGJlIGRpcmVjdGx5IGFjdGl2YXRlZCxcbiAgICogICBidXQgY2FuIHByb3ZpZGUgaW5oZXJpdGVkIHByb3BlcnRpZXMgdG8gaXRzIGNvbW1vbiBjaGlsZHJlbiBzdGF0ZXMuXG4gICAqXG4gICAqIDxhIGlkPSdvbkVudGVyJz48L2E+XG4gICAqXG4gICAqIC0gKipgb25FbnRlcmAqKiAtIHtvYmplY3Q9fSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIGEgc3RhdGUgaXMgZW50ZXJlZC4gR29vZCB3YXlcbiAgICogICB0byB0cmlnZ2VyIGFuIGFjdGlvbiBvciBkaXNwYXRjaCBhbiBldmVudCwgc3VjaCBhcyBvcGVuaW5nIGEgZGlhbG9nLlxuICAgKiBJZiBtaW5pZnlpbmcgeW91ciBzY3JpcHRzLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBgWydpbmplY3Rpb24xJywgJ2luamVjdGlvbjInLCBmdW5jdGlvbihpbmplY3Rpb24xLCBpbmplY3Rpb24yKXt9XWAgc3ludGF4LlxuICAgKlxuICAgKiA8YSBpZD0nb25FeGl0Jz48L2E+XG4gICAqXG4gICAqIC0gKipgb25FeGl0YCoqIC0ge29iamVjdD19IC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gYSBzdGF0ZSBpcyBleGl0ZWQuIEdvb2Qgd2F5IHRvXG4gICAqICAgdHJpZ2dlciBhbiBhY3Rpb24gb3IgZGlzcGF0Y2ggYW4gZXZlbnQsIHN1Y2ggYXMgb3BlbmluZyBhIGRpYWxvZy5cbiAgICogSWYgbWluaWZ5aW5nIHlvdXIgc2NyaXB0cywgbWFrZSBzdXJlIHRvIHVzZSB0aGUgYFsnaW5qZWN0aW9uMScsICdpbmplY3Rpb24yJywgZnVuY3Rpb24oaW5qZWN0aW9uMSwgaW5qZWN0aW9uMil7fV1gIHN5bnRheC5cbiAgICpcbiAgICogPGEgaWQ9J3JlbG9hZE9uU2VhcmNoJz48L2E+XG4gICAqXG4gICAqIC0gKipgcmVsb2FkT25TZWFyY2ggPSB0cnVlYCoqIC0ge2Jvb2xlYW49fSAtIElmIGBmYWxzZWAsIHdpbGwgbm90IHJldHJpZ2dlciB0aGUgc2FtZSBzdGF0ZVxuICAgKiAgIGp1c3QgYmVjYXVzZSBhIHNlYXJjaC9xdWVyeSBwYXJhbWV0ZXIgaGFzIGNoYW5nZWQgKHZpYSAkbG9jYXRpb24uc2VhcmNoKCkgb3IgJGxvY2F0aW9uLmhhc2goKSkuXG4gICAqICAgVXNlZnVsIGZvciB3aGVuIHlvdSdkIGxpa2UgdG8gbW9kaWZ5ICRsb2NhdGlvbi5zZWFyY2goKSB3aXRob3V0IHRyaWdnZXJpbmcgYSByZWxvYWQuXG4gICAqXG4gICAqIDxhIGlkPSdkYXRhJz48L2E+XG4gICAqXG4gICAqIC0gKipgZGF0YWAqKiAtIHtvYmplY3Q9fSAtIEFyYml0cmFyeSBkYXRhIG9iamVjdCwgdXNlZnVsIGZvciBjdXN0b20gY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBTb21lIHN0YXRlIG5hbWUgZXhhbXBsZXNcbiAgICogYGBganNcbiAgICogLy8gc3RhdGVOYW1lIGNhbiBiZSBhIHNpbmdsZSB0b3AtbGV2ZWwgbmFtZSAobXVzdCBiZSB1bmlxdWUpLlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge30pO1xuICAgKlxuICAgKiAvLyBPciBpdCBjYW4gYmUgYSBuZXN0ZWQgc3RhdGUgbmFtZS4gVGhpcyBzdGF0ZSBpcyBhIGNoaWxkIG9mIHRoZVxuICAgKiAvLyBhYm92ZSBcImhvbWVcIiBzdGF0ZS5cbiAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lLm5ld2VzdFwiLCB7fSk7XG4gICAqXG4gICAqIC8vIE5lc3Qgc3RhdGVzIGFzIGRlZXBseSBhcyBuZWVkZWQuXG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZS5uZXdlc3QuYWJjLnh5ei5pbmNlcHRpb25cIiwge30pO1xuICAgKlxuICAgKiAvLyBzdGF0ZSgpIHJldHVybnMgJHN0YXRlUHJvdmlkZXIsIHNvIHlvdSBjYW4gY2hhaW4gc3RhdGUgZGVjbGFyYXRpb25zLlxuICAgKiAkc3RhdGVQcm92aWRlclxuICAgKiAgIC5zdGF0ZShcImhvbWVcIiwge30pXG4gICAqICAgLnN0YXRlKFwiYWJvdXRcIiwge30pXG4gICAqICAgLnN0YXRlKFwiY29udGFjdHNcIiwge30pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB1bmlxdWUgc3RhdGUgbmFtZSwgZS5nLiBcImhvbWVcIiwgXCJhYm91dFwiLCBcImNvbnRhY3RzXCIuXG4gICAqIFRvIGNyZWF0ZSBhIHBhcmVudC9jaGlsZCBzdGF0ZSB1c2UgYSBkb3QsIGUuZy4gXCJhYm91dC5zYWxlc1wiLCBcImhvbWUubmV3ZXN0XCIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZpbml0aW9uIFN0YXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgc3RhdGUobmFtZTogc3RyaW5nLCBkZWZpbml0aW9uOiBOZzFTdGF0ZURlY2xhcmF0aW9uKTogU3RhdGVQcm92aWRlcjtcbiAgc3RhdGUoZGVmaW5pdGlvbjogTmcxU3RhdGVEZWNsYXJhdGlvbik6IFN0YXRlUHJvdmlkZXI7XG4gIHN0YXRlKG5hbWU6IGFueSwgZGVmaW5pdGlvbj86IGFueSkge1xuICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgZGVmaW5pdGlvbiA9IG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluaXRpb24ubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihkZWZpbml0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gaW52YWxpZCBzdGF0ZSBoYW5kbGVyXG4gICAqXG4gICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0byBbW1N0YXRlU2VydmljZS5vbkludmFsaWRdXSBmb3IgbmcxLlxuICAgKi9cblxuICBvbkludmFsaWQoY2FsbGJhY2s6IE9uSW52YWxpZENhbGxiYWNrKTogRnVuY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlU2VydmljZS5vbkludmFsaWQoY2FsbGJhY2spO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIG5nMSAqLyAvKiogKi9cbmltcG9ydCB7XG4gIFN0YXRlT2JqZWN0LFxuICBUcmFuc2l0aW9uU3RhdGVIb29rRm4sXG4gIEhvb2tSZXN1bHQsXG4gIFRyYW5zaXRpb24sXG4gIHNlcnZpY2VzLFxuICBSZXNvbHZlQ29udGV4dCxcbiAgZXh0ZW5kLFxuICBCdWlsZGVyRnVuY3Rpb24sXG59IGZyb20gJ0B1aXJvdXRlci9jb3JlJztcbmltcG9ydCB7IGdldExvY2FscyB9IGZyb20gJy4uL3NlcnZpY2VzJztcbmltcG9ydCB7IE5nMVN0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGBvbkVudGVyYCwgYG9uRXhpdGAsXG4gKiBgb25SZXRhaW5gIGNhbGxiYWNrIGhvb2tzIG9uIGEgW1tOZzFTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogZW5zdXJlcyB0aGF0IHRob3NlIGhvb2tzIGFyZSBpbmplY3RhYmxlIGZvciBAdWlyb3V0ZXIvYW5ndWxhcmpzIChuZzEpLlxuICpcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5leHBvcnQgY29uc3QgZ2V0U3RhdGVIb29rQnVpbGRlciA9IChob29rTmFtZTogJ29uRW50ZXInIHwgJ29uRXhpdCcgfCAnb25SZXRhaW4nKSA9PlxuICBmdW5jdGlvbiBzdGF0ZUhvb2tCdWlsZGVyKHN0YXRlT2JqZWN0OiBTdGF0ZU9iamVjdCwgcGFyZW50Rm46IEJ1aWxkZXJGdW5jdGlvbik6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiB7XG4gICAgY29uc3QgaG9vayA9IHN0YXRlT2JqZWN0W2hvb2tOYW1lXTtcbiAgICBjb25zdCBwYXRobmFtZSA9IGhvb2tOYW1lID09PSAnb25FeGl0JyA/ICdmcm9tJyA6ICd0byc7XG5cbiAgICBmdW5jdGlvbiBkZWNvcmF0ZWROZzFIb29rKHRyYW5zOiBUcmFuc2l0aW9uLCBzdGF0ZTogTmcxU3RhdGVEZWNsYXJhdGlvbik6IEhvb2tSZXN1bHQge1xuICAgICAgY29uc3QgcmVzb2x2ZUNvbnRleHQgPSBuZXcgUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMocGF0aG5hbWUpKTtcbiAgICAgIGNvbnN0IHN1YkNvbnRleHQgPSByZXNvbHZlQ29udGV4dC5zdWJDb250ZXh0KHN0YXRlLiQkc3RhdGUoKSk7XG4gICAgICBjb25zdCBsb2NhbHMgPSBleHRlbmQoZ2V0TG9jYWxzKHN1YkNvbnRleHQpLCB7ICRzdGF0ZSQ6IHN0YXRlLCAkdHJhbnNpdGlvbiQ6IHRyYW5zIH0pO1xuICAgICAgcmV0dXJuIHNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UoaG9vaywgdGhpcywgbG9jYWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9vayA/IGRlY29yYXRlZE5nMUhvb2sgOiB1bmRlZmluZWQ7XG4gIH07XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIG5nMSAqLyAvKiogKi9cbmltcG9ydCB7IExvY2F0aW9uQ29uZmlnLCBMb2NhdGlvblNlcnZpY2VzLCBVSVJvdXRlciwgUGFyYW1UeXBlLCBpc0RlZmluZWQgfSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyB2YWwsIGNyZWF0ZVByb3h5RnVuY3Rpb25zLCByZW1vdmVGcm9tLCBpc09iamVjdCB9IGZyb20gJ0B1aXJvdXRlci9jb3JlJztcbmltcG9ydCB7IElMb2NhdGlvblNlcnZpY2UsIElMb2NhdGlvblByb3ZpZGVyLCBJV2luZG93U2VydmljZSB9IGZyb20gJ2FuZ3VsYXInO1xuXG4vKipcbiAqIEltcGxlbWVudHMgVUktUm91dGVyIExvY2F0aW9uU2VydmljZXMgYW5kIExvY2F0aW9uQ29uZmlnIHVzaW5nIEFuZ3VsYXIgMSdzICRsb2NhdGlvbiBzZXJ2aWNlXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIE5nMUxvY2F0aW9uU2VydmljZXMgaW1wbGVtZW50cyBMb2NhdGlvbkNvbmZpZywgTG9jYXRpb25TZXJ2aWNlcyB7XG4gIHByaXZhdGUgJGxvY2F0aW9uUHJvdmlkZXI6IElMb2NhdGlvblByb3ZpZGVyO1xuICBwcml2YXRlICRsb2NhdGlvbjogSUxvY2F0aW9uU2VydmljZTtcbiAgcHJpdmF0ZSAkc25pZmZlcjogYW55O1xuICBwcml2YXRlICRicm93c2VyOiBhbnk7XG4gIHByaXZhdGUgJHdpbmRvdzogSVdpbmRvd1NlcnZpY2U7XG5cbiAgcGF0aDtcbiAgc2VhcmNoO1xuICBoYXNoO1xuICBoYXNoUHJlZml4O1xuICBwb3J0O1xuICBwcm90b2NvbDtcbiAgaG9zdDtcblxuICBwcml2YXRlIF9iYXNlSHJlZjogc3RyaW5nO1xuXG4gIC8vIC5vbkNoYW5nZSgpIHJlZ2lzdHJ5XG4gIHByaXZhdGUgX3VybExpc3RlbmVyczogRnVuY3Rpb25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBcHBseXMgbmcxLXNwZWNpZmljIHBhdGggcGFyYW1ldGVyIGVuY29kaW5nXG4gICAqXG4gICAqIFRoZSBBbmd1bGFyIDEgYCRsb2NhdGlvbmAgc2VydmljZSBpcyBhIGJpdCB3ZWlyZC5cbiAgICogSXQgZG9lc24ndCBhbGxvdyBzbGFzaGVzIHRvIGJlIGVuY29kZWQvZGVjb2RlZCBiaS1kaXJlY3Rpb25hbGx5LlxuICAgKlxuICAgKiBTZWUgdGhlIHdyaXRldXAgYXQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8yNTk4XG4gICAqXG4gICAqIFRoaXMgY29kZSBwYXRjaGVzIHRoZSBgcGF0aGAgcGFyYW1ldGVyIHR5cGUgc28gaXQgZW5jb2RlZC9kZWNvZGVzIHNsYXNoZXMgYXMgfjJGXG4gICAqXG4gICAqIEBwYXJhbSByb3V0ZXJcbiAgICovXG4gIHN0YXRpYyBtb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBjb25zdCBwYXRoVHlwZTogUGFyYW1UeXBlID0gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LnR5cGUoJ3BhdGgnKTtcblxuICAgIHBhdGhUeXBlLmVuY29kZSA9ICh4OiBhbnkpID0+XG4gICAgICB4ICE9IG51bGwgPyB4LnRvU3RyaW5nKCkucmVwbGFjZSgvKH58XFwvKS9nLCBtID0+ICh7ICd+JzogJ35+JywgJy8nOiAnfjJGJyB9W21dKSkgOiB4O1xuXG4gICAgcGF0aFR5cGUuZGVjb2RlID0gKHg6IHN0cmluZykgPT5cbiAgICAgIHggIT0gbnVsbCA/IHgudG9TdHJpbmcoKS5yZXBsYWNlKC8ofn58fjJGKS9nLCBtID0+ICh7ICd+fic6ICd+JywgJ34yRic6ICcvJyB9W21dKSkgOiB4O1xuICB9XG5cbiAgZGlzcG9zZSgpIHt9XG5cbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uUHJvdmlkZXI6IElMb2NhdGlvblByb3ZpZGVyKSB7XG4gICAgdGhpcy4kbG9jYXRpb25Qcm92aWRlciA9ICRsb2NhdGlvblByb3ZpZGVyO1xuICAgIGNvbnN0IF9scCA9IHZhbCgkbG9jYXRpb25Qcm92aWRlcik7XG4gICAgY3JlYXRlUHJveHlGdW5jdGlvbnMoX2xwLCB0aGlzLCBfbHAsIFsnaGFzaFByZWZpeCddKTtcbiAgfVxuXG4gIG9uQ2hhbmdlKGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX3VybExpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gcmVtb3ZlRnJvbSh0aGlzLl91cmxMaXN0ZW5lcnMpKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGh0bWw1TW9kZSgpIHtcbiAgICBsZXQgaHRtbDVNb2RlOiBhbnkgPSB0aGlzLiRsb2NhdGlvblByb3ZpZGVyLmh0bWw1TW9kZSgpO1xuICAgIGh0bWw1TW9kZSA9IGlzT2JqZWN0KGh0bWw1TW9kZSkgPyBodG1sNU1vZGUuZW5hYmxlZCA6IGh0bWw1TW9kZTtcbiAgICByZXR1cm4gaHRtbDVNb2RlICYmIHRoaXMuJHNuaWZmZXIuaGlzdG9yeTtcbiAgfVxuXG4gIGJhc2VIcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlSHJlZiB8fCAodGhpcy5fYmFzZUhyZWYgPSB0aGlzLiRicm93c2VyLmJhc2VIcmVmKCkgfHwgdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIHVybChuZXdVcmw/OiBzdHJpbmcsIHJlcGxhY2UgPSBmYWxzZSwgc3RhdGU/KSB7XG4gICAgaWYgKGlzRGVmaW5lZChuZXdVcmwpKSB0aGlzLiRsb2NhdGlvbi51cmwobmV3VXJsKTtcbiAgICBpZiAocmVwbGFjZSkgdGhpcy4kbG9jYXRpb24ucmVwbGFjZSgpO1xuICAgIGlmIChzdGF0ZSkgdGhpcy4kbG9jYXRpb24uc3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB0aGlzLiRsb2NhdGlvbi51cmwoKTtcbiAgfVxuXG4gIF9ydW50aW1lU2VydmljZXMoJHJvb3RTY29wZSwgJGxvY2F0aW9uOiBJTG9jYXRpb25TZXJ2aWNlLCAkc25pZmZlciwgJGJyb3dzZXIsICR3aW5kb3c6IElXaW5kb3dTZXJ2aWNlKSB7XG4gICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XG4gICAgdGhpcy4kc25pZmZlciA9ICRzbmlmZmVyO1xuICAgIHRoaXMuJGJyb3dzZXIgPSAkYnJvd3NlcjtcbiAgICB0aGlzLiR3aW5kb3cgPSAkd2luZG93O1xuXG4gICAgLy8gQmluZCAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzIHRvIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiBMb2NhdGlvblNlcnZpY2Uub25DaGFuZ2VcbiAgICAkcm9vdFNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGV2dCA9PiB0aGlzLl91cmxMaXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihldnQpKSk7XG4gICAgY29uc3QgX2xvYyA9IHZhbCgkbG9jYXRpb24pO1xuXG4gICAgLy8gQmluZCB0aGVzZSBMb2NhdGlvblNlcnZpY2UgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgIGNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFsncmVwbGFjZScsICdwYXRoJywgJ3NlYXJjaCcsICdoYXNoJ10pO1xuICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgIGNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFsncG9ydCcsICdwcm90b2NvbCcsICdob3N0J10pO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHVybCAqLyAvKiogKi9cbmltcG9ydCB7XG4gIFVJUm91dGVyLFxuICBMb2NhdGlvblNlcnZpY2VzLFxuICAkSW5qZWN0b3JMaWtlLFxuICBCYXNlVXJsUnVsZSxcbiAgVXJsUnVsZUhhbmRsZXJGbixcbiAgVXJsTWF0Y2hlcixcbiAgSUluamVjdGFibGUsXG4gIFVybFJvdXRlcixcbn0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgc2VydmljZXMsIGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc0FycmF5LCBpZGVudGl0eSB9IGZyb20gJ0B1aXJvdXRlci9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBSYXdOZzFSdWxlRnVuY3Rpb24ge1xuICAoJGluamVjdG9yOiAkSW5qZWN0b3JMaWtlLCAkbG9jYXRpb246IExvY2F0aW9uU2VydmljZXMpOiBzdHJpbmcgfCB2b2lkO1xufVxuXG4vKipcbiAqIE1hbmFnZXMgcnVsZXMgZm9yIGNsaWVudC1zaWRlIFVSTFxuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICogVGhpcyBjbGFzcyBpcyBub3cgY29uc2lkZXJlZCB0byBiZSBhbiBpbnRlcm5hbCBBUElcbiAqIFVzZSB0aGUgW1tVcmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAqIEZvciBjb25maWd1cmluZyBVUkwgcnVsZXMsIHVzZSB0aGUgW1tVcmxSdWxlc0FwaV1dIHdoaWNoIGNhbiBiZSBmb3VuZCBhcyBbW1VybFNlcnZpY2UucnVsZXNdXS5cbiAqXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMgdGhlIHJvdXRlciBydWxlcyBmb3Igd2hhdCB0byBkbyB3aGVuIHRoZSBVUkwgY2hhbmdlcy5cbiAqXG4gKiBUaGlzIHByb3ZpZGVyIHJlbWFpbnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICpcbiAqIEBpbnRlcm5hbGFwaVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIFVybFJvdXRlclByb3ZpZGVyIHtcbiAgc3RhdGljIGluamVjdGFibGVIYW5kbGVyKHJvdXRlcjogVUlSb3V0ZXIsIGhhbmRsZXIpOiBVcmxSdWxlSGFuZGxlckZuIHtcbiAgICByZXR1cm4gbWF0Y2ggPT4gc2VydmljZXMuJGluamVjdG9yLmludm9rZShoYW5kbGVyLCBudWxsLCB7ICRtYXRjaDogbWF0Y2gsICRzdGF0ZVBhcmFtczogcm91dGVyLmdsb2JhbHMucGFyYW1zIH0pO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgY29uc3RydWN0b3IoLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSByb3V0ZXI6IFVJUm91dGVyKSB7fVxuXG4gIC8qKiBAaGlkZGVuICovXG4gICRnZXQoKTogVXJsUm91dGVyIHtcbiAgICBjb25zdCB1cmxTZXJ2aWNlID0gdGhpcy5yb3V0ZXIudXJsU2VydmljZTtcbiAgICB0aGlzLnJvdXRlci51cmxSb3V0ZXIudXBkYXRlKHRydWUpO1xuICAgIGlmICghdXJsU2VydmljZS5pbnRlcmNlcHREZWZlcnJlZCkgdXJsU2VydmljZS5saXN0ZW4oKTtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsUm91dGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHVybCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSBsb3cgbGV2ZWwgdXJsIGhhbmRsZXIgKGEgYHJ1bGVgKS5cbiAgICogQSBydWxlIGRldGVjdHMgc3BlY2lmaWMgVVJMIHBhdHRlcm5zIGFuZCByZXR1cm5zIGEgcmVkaXJlY3QsIG9yIHBlcmZvcm1zIHNvbWUgYWN0aW9uLlxuICAgKlxuICAgKiBJZiBhIHJ1bGUgcmV0dXJucyBhIHN0cmluZywgdGhlIFVSTCBpcyByZXBsYWNlZCB3aXRoIHRoZSBzdHJpbmcsIGFuZCBhbGwgcnVsZXMgYXJlIGZpcmVkIGFnYWluLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICogICAvLyBIZXJlJ3MgYW4gZXhhbXBsZSBvZiBob3cgeW91IG1pZ2h0IGFsbG93IGNhc2UgaW5zZW5zaXRpdmUgdXJsc1xuICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5ydWxlKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgKiAgICAgdmFyIHBhdGggPSAkbG9jYXRpb24ucGF0aCgpLFxuICAgKiAgICAgICAgIG5vcm1hbGl6ZWQgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAqXG4gICAqICAgICBpZiAocGF0aCAhPT0gbm9ybWFsaXplZCkge1xuICAgKiAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcnVsZUZuXG4gICAqIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMgYXMgYXJndW1lbnRzLlxuICAgKiBZb3UgY2FuIHVzZSB0aGVtIHRvIGRldGVjdCBhIHVybCBhbmQgcmV0dXJuIGEgZGlmZmVyZW50IHVybCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiBbW1VybFJvdXRlclByb3ZpZGVyXV0gKGB0aGlzYClcbiAgICovXG4gIHJ1bGUocnVsZUZuOiBSYXdOZzFSdWxlRnVuY3Rpb24pOiBVcmxSb3V0ZXJQcm92aWRlciB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJ1bGVGbikpIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICBjb25zdCBtYXRjaCA9ICgpID0+IHJ1bGVGbihzZXJ2aWNlcy4kaW5qZWN0b3IsIHRoaXMucm91dGVyLmxvY2F0aW9uU2VydmljZSk7XG5cbiAgICBjb25zdCBydWxlID0gbmV3IEJhc2VVcmxSdWxlKG1hdGNoLCBpZGVudGl0eSk7XG4gICAgdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5ydWxlKHJ1bGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIHBhdGggb3IgYmVoYXZpb3IgdG8gdXNlIHdoZW4gbm8gdXJsIGNhbiBiZSBtYXRjaGVkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICogICAvLyBpZiB0aGUgcGF0aCBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgdXJscyB5b3UgY29uZmlndXJlZFxuICAgKiAgIC8vIG90aGVyd2lzZSB3aWxsIHRha2UgY2FyZSBvZiByb3V0aW5nIHRoZSB1c2VyIHRvIHRoZVxuICAgKiAgIC8vIHNwZWNpZmllZCB1cmxcbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKCcvaW5kZXgnKTtcbiAgICpcbiAgICogICAvLyBFeGFtcGxlIG9mIHVzaW5nIGZ1bmN0aW9uIHJ1bGUgYXMgcGFyYW1cbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgKiAgICAgcmV0dXJuICcvYS92YWxpZC91cmwnO1xuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBydWxlXG4gICAqIFRoZSB1cmwgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB0byBvciBhIGZ1bmN0aW9uIHJ1bGUgdGhhdCByZXR1cm5zIHRoZSB1cmwgcGF0aCBvciBwZXJmb3JtcyBhIGAkc3RhdGUuZ28oKWAuXG4gICAqIFRoZSBmdW5jdGlvbiB2ZXJzaW9uIGlzIHBhc3NlZCB0d28gcGFyYW1zOiBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMsIGFuZCBzaG91bGQgcmV0dXJuIGEgdXJsIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBgJHVybFJvdXRlclByb3ZpZGVyYCAtIGAkdXJsUm91dGVyUHJvdmlkZXJgIGluc3RhbmNlXG4gICAqL1xuICBvdGhlcndpc2UocnVsZTogc3RyaW5nIHwgUmF3TmcxUnVsZUZ1bmN0aW9uKTogVXJsUm91dGVyUHJvdmlkZXIge1xuICAgIGNvbnN0IHVybFJ1bGVzID0gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcztcbiAgICBpZiAoaXNTdHJpbmcocnVsZSkpIHtcbiAgICAgIHVybFJ1bGVzLm90aGVyd2lzZShydWxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocnVsZSkpIHtcbiAgICAgIHVybFJ1bGVzLm90aGVyd2lzZSgoKSA9PiBydWxlKHNlcnZpY2VzLiRpbmplY3RvciwgdGhpcy5yb3V0ZXIubG9jYXRpb25TZXJ2aWNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgZm9yIGEgZ2l2ZW4gdXJsIG1hdGNoaW5nLlxuICAgKlxuICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIHN0cmluZywgaXQgaXNcbiAgICogdHJlYXRlZCBhcyBhIHJlZGlyZWN0LCBhbmQgaXMgaW50ZXJwb2xhdGVkIGFjY29yZGluZyB0byB0aGUgc3ludGF4IG9mIG1hdGNoXG4gICAqIChpLmUuIGxpa2UgYFN0cmluZy5yZXBsYWNlKClgIGZvciBgUmVnRXhwYCwgb3IgbGlrZSBhIGBVcmxNYXRjaGVyYCBwYXR0ZXJuIG90aGVyd2lzZSkuXG4gICAqXG4gICAqIElmIHRoZSBoYW5kbGVyIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGluamVjdGFibGUuXG4gICAqIEl0IGdldHMgaW52b2tlZCBpZiBgJGxvY2F0aW9uYCBtYXRjaGVzLlxuICAgKiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuICAgKlxuICAgKiBUaGUgaGFuZGxlciBjYW4gcmV0dXJuXG4gICAqXG4gICAqIC0gKipmYWxzeSoqIHRvIGluZGljYXRlIHRoYXQgdGhlIHJ1bGUgZGlkbid0IG1hdGNoIGFmdGVyIGFsbCwgdGhlbiBgJHVybFJvdXRlcmBcbiAgICogICB3aWxsIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFub3RoZXIgb25lIHRoYXQgbWF0Y2hlcy5cbiAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG4gICAqIC0gKip2b2lkKiogb3IgYW55ICoqdHJ1dGh5KiogdmFsdWUgdGVsbHMgYCR1cmxSb3V0ZXJgIHRoYXQgdGhlIHVybCB3YXMgaGFuZGxlZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oJHN0YXRlLnVybCwgZnVuY3Rpb24gKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XG4gICAqICAgICBpZiAoJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSAhPT0gc3RhdGUgfHxcbiAgICogICAgICAgICAhZXF1YWxGb3JLZXlzKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XG4gICAqICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgJG1hdGNoLCBmYWxzZSk7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHdoYXQgQSBwYXR0ZXJuIHN0cmluZyB0byBtYXRjaCwgY29tcGlsZWQgYXMgYSBbW1VybE1hdGNoZXJdXS5cbiAgICogQHBhcmFtIGhhbmRsZXIgVGhlIHBhdGggKG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGgpIHRoYXQgeW91IHdhbnQgdG8gcmVkaXJlY3QgeW91ciB1c2VyIHRvLlxuICAgKiBAcGFyYW0gcnVsZUNhbGxiYWNrIFtvcHRpb25hbF0gQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBgcnVsZWAgcmVnaXN0ZXJlZCB3aXRoIFtbVXJsTWF0Y2hlci5ydWxlXV1cbiAgICpcbiAgICogTm90ZTogdGhlIGhhbmRsZXIgbWF5IGFsc28gaW52b2tlIGFyYml0cmFyeSBjb2RlLCBzdWNoIGFzIGAkc3RhdGUuZ28oKWBcbiAgICovXG4gIHdoZW4od2hhdDogUmVnRXhwIHwgVXJsTWF0Y2hlciB8IHN0cmluZywgaGFuZGxlcjogc3RyaW5nIHwgSUluamVjdGFibGUpIHtcbiAgICBpZiAoaXNBcnJheShoYW5kbGVyKSB8fCBpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICBoYW5kbGVyID0gVXJsUm91dGVyUHJvdmlkZXIuaW5qZWN0YWJsZUhhbmRsZXIodGhpcy5yb3V0ZXIsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMud2hlbih3aGF0LCBoYW5kbGVyIGFzIGFueSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgbW9uaXRvcmluZyBvZiB0aGUgVVJMLlxuICAgKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSBVSS1Sb3V0ZXIgaGFzIGJvb3RzdHJhcHBlZC5cbiAgICogSXQgd2lsbCBzdG9wIFVJLVJvdXRlciBmcm9tIHBlcmZvcm1pbmcgdGhlIGluaXRpYWwgdXJsIHN5bmMuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBwZXJmb3JtIHNvbWUgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGJlZm9yZSB0aGUgcm91dGVyIHN0YXJ0cy5cbiAgICogT25jZSB0aGUgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUsIGNhbGwgW1tsaXN0ZW5dXSB0byB0ZWxsIFVJLVJvdXRlciB0byBzdGFydCB3YXRjaGluZyBhbmQgc3luY2hyb25pemluZyB0aGUgVVJMLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgKiAgIC8vIFByZXZlbnQgJHVybFJvdXRlciBmcm9tIGF1dG9tYXRpY2FsbHkgaW50ZXJjZXB0aW5nIFVSTCBjaGFuZ2VzO1xuICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5kZWZlckludGVyY2VwdCgpO1xuICAgKiB9KVxuICAgKlxuICAgKiBhcHAucnVuKGZ1bmN0aW9uIChNeVNlcnZpY2UsICR1cmxSb3V0ZXIsICRodHRwKSB7XG4gICAqICAgJGh0dHAuZ2V0KFwiL3N0dWZmXCIpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgKiAgICAgTXlTZXJ2aWNlLmRvU3R1ZmYocmVzcC5kYXRhKTtcbiAgICogICAgICR1cmxSb3V0ZXIubGlzdGVuKCk7XG4gICAqICAgICAkdXJsUm91dGVyLnN5bmMoKTtcbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZGVmZXIgSW5kaWNhdGVzIHdoZXRoZXIgdG8gZGVmZXIgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi5cbiAgICogICAgICAgIFBhc3Npbmcgbm8gcGFyYW1ldGVyIGlzIGVxdWl2YWxlbnQgdG8gYHRydWVgLlxuICAgKi9cbiAgZGVmZXJJbnRlcmNlcHQoZGVmZXI/OiBib29sZWFuKSB7XG4gICAgdGhpcy5yb3V0ZXIudXJsU2VydmljZS5kZWZlckludGVyY2VwdChkZWZlcik7XG4gIH1cbn1cbiIsIi8qKlxuICogIyBBbmd1bGFyIDEgdHlwZXNcbiAqXG4gKiBVSS1Sb3V0ZXIgY29yZSBwcm92aWRlcyB2YXJpb3VzIFR5cGVzY3JpcHQgdHlwZXMgd2hpY2ggeW91IGNhbiB1c2UgZm9yIGNvZGUgY29tcGxldGlvbiBhbmQgdmFsaWRhdGluZyBwYXJhbWV0ZXIgdmFsdWVzLCBldGMuXG4gKiBUaGUgY3VzdG9taXphdGlvbnMgdG8gdGhlIGNvcmUgdHlwZXMgZm9yIEFuZ3VsYXIgVUktUm91dGVyIGFyZSBkb2N1bWVudGVkIGhlcmUuXG4gKlxuICogVGhlIG9wdGlvbmFsIFtbJHJlc29sdmVdXSBzZXJ2aWNlIGlzIGFsc28gZG9jdW1lbnRlZCBoZXJlLlxuICpcbiAqIEBwcmVmZXJyZWQgQHB1YmxpY2FwaSBAbW9kdWxlIG5nMVxuICovIC8qKiAqL1xuaW1wb3J0IHsgbmcgYXMgYW5ndWxhciB9IGZyb20gJy4vYW5ndWxhcic7XG5pbXBvcnQge1xuICBJUm9vdFNjb3BlU2VydmljZSxcbiAgSVFTZXJ2aWNlLFxuICBJTG9jYXRpb25TZXJ2aWNlLFxuICBJTG9jYXRpb25Qcm92aWRlcixcbiAgSUh0dHBTZXJ2aWNlLFxuICBJVGVtcGxhdGVDYWNoZVNlcnZpY2UsXG59IGZyb20gJ2FuZ3VsYXInO1xuaW1wb3J0IHtcbiAgc2VydmljZXMsXG4gIGFwcGx5UGFpcnMsXG4gIGlzU3RyaW5nLFxuICB0cmFjZSxcbiAgZXh0ZW5kLFxuICBVSVJvdXRlcixcbiAgU3RhdGVTZXJ2aWNlLFxuICBVcmxSb3V0ZXIsXG4gIFVybE1hdGNoZXJGYWN0b3J5LFxuICBSZXNvbHZlQ29udGV4dCxcbiAgdW5uZXN0UixcbiAgVHlwZWRNYXAsXG59IGZyb20gJ0B1aXJvdXRlci9jb3JlJztcbmltcG9ydCB7IG5nMVZpZXdzQnVpbGRlciwgZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkgfSBmcm9tICcuL3N0YXRlYnVpbGRlcnMvdmlld3MnO1xuaW1wb3J0IHsgVGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnLi90ZW1wbGF0ZUZhY3RvcnknO1xuaW1wb3J0IHsgU3RhdGVQcm92aWRlciB9IGZyb20gJy4vc3RhdGVQcm92aWRlcic7XG5pbXBvcnQgeyBnZXRTdGF0ZUhvb2tCdWlsZGVyIH0gZnJvbSAnLi9zdGF0ZWJ1aWxkZXJzL29uRW50ZXJFeGl0UmV0YWluJztcbmltcG9ydCB7IE5nMUxvY2F0aW9uU2VydmljZXMgfSBmcm9tICcuL2xvY2F0aW9uU2VydmljZXMnO1xuaW1wb3J0IHsgVXJsUm91dGVyUHJvdmlkZXIgfSBmcm9tICcuL3VybFJvdXRlclByb3ZpZGVyJztcbmltcG9ydCBJSW5qZWN0b3JTZXJ2aWNlID0gYW5ndWxhci5hdXRvLklJbmplY3RvclNlcnZpY2U7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5hbmd1bGFyMScsIFtdKTtcbmNvbnN0IG1vZF9pbml0ID0gYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5pbml0JywgWyduZyddKTtcbmNvbnN0IG1vZF91dGlsID0gYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJywgWyd1aS5yb3V0ZXIuaW5pdCddKTtcbmNvbnN0IG1vZF9ydHIgPSBhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicsIFsndWkucm91dGVyLnV0aWwnXSk7XG5jb25zdCBtb2Rfc3RhdGUgPSBhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcbmNvbnN0IG1vZF9tYWluID0gYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlcicsIFsndWkucm91dGVyLmluaXQnLCAndWkucm91dGVyLnN0YXRlJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcbmNvbnN0IG1vZF9jbXB0ID0gYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5jb21wYXQnLCBbJ3VpLnJvdXRlciddKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuXG5kZWNsYXJlIG1vZHVsZSAnQHVpcm91dGVyL2NvcmUvbGliL3JvdXRlcicge1xuICBpbnRlcmZhY2UgVUlSb3V0ZXIge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tc2hhZG93ZWQtdmFyaWFibGVcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHN0YXRlUHJvdmlkZXI6IFN0YXRlUHJvdmlkZXI7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICB1cmxSb3V0ZXJQcm92aWRlcjogVXJsUm91dGVyUHJvdmlkZXI7XG4gIH1cbn1cblxubGV0IHJvdXRlcjogVUlSb3V0ZXIgPSBudWxsO1xuXG4kdWlSb3V0ZXJQcm92aWRlci4kaW5qZWN0ID0gWyckbG9jYXRpb25Qcm92aWRlciddO1xuLyoqIFRoaXMgYW5ndWxhciAxIHByb3ZpZGVyIGluc3RhbnRpYXRlcyBhIFJvdXRlciBhbmQgZXhwb3NlcyBpdHMgc2VydmljZXMgdmlhIHRoZSBhbmd1bGFyIGluamVjdG9yICovXG5mdW5jdGlvbiAkdWlSb3V0ZXJQcm92aWRlcigkbG9jYXRpb25Qcm92aWRlcjogSUxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSb3V0ZXIgd2hlbiB0aGUgJHVpUm91dGVyUHJvdmlkZXIgaXMgaW5pdGlhbGl6ZWRcbiAgcm91dGVyID0gdGhpcy5yb3V0ZXIgPSBuZXcgVUlSb3V0ZXIoKTtcbiAgcm91dGVyLnN0YXRlUHJvdmlkZXIgPSBuZXcgU3RhdGVQcm92aWRlcihyb3V0ZXIuc3RhdGVSZWdpc3RyeSwgcm91dGVyLnN0YXRlU2VydmljZSk7XG5cbiAgLy8gQXBwbHkgbmcxIHNwZWNpZmljIFN0YXRlQnVpbGRlciBjb2RlIGZvciBgdmlld3NgLCBgcmVzb2x2ZWAsIGFuZCBgb25FeGl0L1JldGFpbi9FbnRlcmAgcHJvcGVydGllc1xuICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoJ3ZpZXdzJywgbmcxVmlld3NCdWlsZGVyKTtcbiAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCdvbkV4aXQnLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKCdvbkV4aXQnKSk7XG4gIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcignb25SZXRhaW4nLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKCdvblJldGFpbicpKTtcbiAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCdvbkVudGVyJywgZ2V0U3RhdGVIb29rQnVpbGRlcignb25FbnRlcicpKTtcblxuICByb3V0ZXIudmlld1NlcnZpY2UuX3BsdWdpbmFwaS5fdmlld0NvbmZpZ0ZhY3RvcnkoJ25nMScsIGdldE5nMVZpZXdDb25maWdGYWN0b3J5KCkpO1xuXG4gIGNvbnN0IG5nMUxvY2F0aW9uU2VydmljZSA9IChyb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uQ29uZmlnID0gbmV3IE5nMUxvY2F0aW9uU2VydmljZXMoXG4gICAgJGxvY2F0aW9uUHJvdmlkZXJcbiAgKSk7XG5cbiAgTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlKHJvdXRlcik7XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdDogYWxzbyBleHBvc2Ugcm91dGVyIGluc3RhbmNlIGFzICR1aVJvdXRlclByb3ZpZGVyLnJvdXRlclxuICByb3V0ZXJbJ3JvdXRlciddID0gcm91dGVyO1xuICByb3V0ZXJbJyRnZXQnXSA9ICRnZXQ7XG4gICRnZXQuJGluamVjdCA9IFsnJGxvY2F0aW9uJywgJyRicm93c2VyJywgJyR3aW5kb3cnLCAnJHNuaWZmZXInLCAnJHJvb3RTY29wZScsICckaHR0cCcsICckdGVtcGxhdGVDYWNoZSddO1xuICBmdW5jdGlvbiAkZ2V0KFxuICAgICRsb2NhdGlvbjogSUxvY2F0aW9uU2VydmljZSxcbiAgICAkYnJvd3NlcjogYW55LFxuICAgICR3aW5kb3c6IGFueSxcbiAgICAkc25pZmZlcjogYW55LFxuICAgICRyb290U2NvcGU6IG5nLklTY29wZSxcbiAgICAkaHR0cDogSUh0dHBTZXJ2aWNlLFxuICAgICR0ZW1wbGF0ZUNhY2hlOiBJVGVtcGxhdGVDYWNoZVNlcnZpY2VcbiAgKSB7XG4gICAgbmcxTG9jYXRpb25TZXJ2aWNlLl9ydW50aW1lU2VydmljZXMoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIsICR3aW5kb3cpO1xuICAgIGRlbGV0ZSByb3V0ZXJbJ3JvdXRlciddO1xuICAgIGRlbGV0ZSByb3V0ZXJbJyRnZXQnXTtcbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIHJldHVybiByb3V0ZXI7XG59XG5cbmNvbnN0IGdldFByb3ZpZGVyRm9yID0gc2VydmljZU5hbWUgPT4gW1xuICAnJHVpUm91dGVyUHJvdmlkZXInLFxuICAkdXJwID0+IHtcbiAgICBjb25zdCBzZXJ2aWNlID0gJHVycC5yb3V0ZXJbc2VydmljZU5hbWVdO1xuICAgIHNlcnZpY2VbJyRnZXQnXSA9ICgpID0+IHNlcnZpY2U7XG4gICAgcmV0dXJuIHNlcnZpY2U7XG4gIH0sXG5dO1xuXG4vLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSBvbiBgJHVpUm91dGVyUHJvdmlkZXJgIHRvIHRyaWdnZXIgaW5pdCAod2hlbiBuZyBlbnRlcnMgcnVudGltZSlcbnJ1bkJsb2NrLiRpbmplY3QgPSBbJyRpbmplY3RvcicsICckcScsICckdWlSb3V0ZXInXTtcbmZ1bmN0aW9uIHJ1bkJsb2NrKCRpbmplY3RvcjogSUluamVjdG9yU2VydmljZSwgJHE6IElRU2VydmljZSwgJHVpUm91dGVyOiBVSVJvdXRlcikge1xuICBzZXJ2aWNlcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XG4gIHNlcnZpY2VzLiRxID0gPGFueT4kcTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzM2NzhcbiAgaWYgKCEkaW5qZWN0b3IuaGFzT3duUHJvcGVydHkoJ3N0cmljdERpJykpIHtcbiAgICB0cnkge1xuICAgICAgJGluamVjdG9yLmludm9rZShmdW5jdGlvbihjaGVja1N0cmljdERpKSB7fSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICRpbmplY3Rvci5zdHJpY3REaSA9ICEhL3N0cmljdCBtb2RlLy5leGVjKGVycm9yICYmIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSAkaW5qZWN0b3IgaXMgbm93IGF2YWlsYWJsZS5cbiAgLy8gRmluZCBhbnkgcmVzb2x2YWJsZXMgdGhhdCBoYWQgZGVwZW5kZW5jeSBhbm5vdGF0aW9uIGRlZmVycmVkXG4gICR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XG4gICAgLmdldCgpXG4gICAgLm1hcCh4ID0+IHguJCRzdGF0ZSgpLnJlc29sdmFibGVzKVxuICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgLmZpbHRlcih4ID0+IHguZGVwcyA9PT0gJ2RlZmVycmVkJylcbiAgICAuZm9yRWFjaChyZXNvbHZhYmxlID0+IChyZXNvbHZhYmxlLmRlcHMgPSAkaW5qZWN0b3IuYW5ub3RhdGUocmVzb2x2YWJsZS5yZXNvbHZlRm4sICRpbmplY3Rvci5zdHJpY3REaSkpKTtcbn1cblxuLy8gJHVybFJvdXRlciBzZXJ2aWNlIGFuZCAkdXJsUm91dGVyUHJvdmlkZXJcbmNvbnN0IGdldFVybFJvdXRlclByb3ZpZGVyID0gKHVpUm91dGVyOiBVSVJvdXRlcikgPT4gKHVpUm91dGVyLnVybFJvdXRlclByb3ZpZGVyID0gbmV3IFVybFJvdXRlclByb3ZpZGVyKHVpUm91dGVyKSk7XG5cbi8vICRzdGF0ZSBzZXJ2aWNlIGFuZCAkc3RhdGVQcm92aWRlclxuLy8gJHVybFJvdXRlciBzZXJ2aWNlIGFuZCAkdXJsUm91dGVyUHJvdmlkZXJcbmNvbnN0IGdldFN0YXRlUHJvdmlkZXIgPSAoKSA9PiBleHRlbmQocm91dGVyLnN0YXRlUHJvdmlkZXIsIHsgJGdldDogKCkgPT4gcm91dGVyLnN0YXRlU2VydmljZSB9KTtcblxud2F0Y2hEaWdlc3RzLiRpbmplY3QgPSBbJyRyb290U2NvcGUnXTtcbmV4cG9ydCBmdW5jdGlvbiB3YXRjaERpZ2VzdHMoJHJvb3RTY29wZTogSVJvb3RTY29wZVNlcnZpY2UpIHtcbiAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgdHJhY2UuYXBwcm94aW1hdGVEaWdlc3RzKys7XG4gIH0pO1xufVxuXG5tb2RfaW5pdC5wcm92aWRlcignJHVpUm91dGVyJywgPGFueT4kdWlSb3V0ZXJQcm92aWRlcik7XG5tb2RfcnRyLnByb3ZpZGVyKCckdXJsUm91dGVyJywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGdldFVybFJvdXRlclByb3ZpZGVyXSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHVybFNlcnZpY2UnLCBnZXRQcm92aWRlckZvcigndXJsU2VydmljZScpKTtcbm1vZF91dGlsLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgKCkgPT4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5XSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHRlbXBsYXRlRmFjdG9yeScsICgpID0+IG5ldyBUZW1wbGF0ZUZhY3RvcnkoKSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyRzdGF0ZVJlZ2lzdHJ5JywgZ2V0UHJvdmlkZXJGb3IoJ3N0YXRlUmVnaXN0cnknKSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyR1aVJvdXRlckdsb2JhbHMnLCBnZXRQcm92aWRlckZvcignZ2xvYmFscycpKTtcbm1vZF9zdGF0ZS5wcm92aWRlcignJHRyYW5zaXRpb25zJywgZ2V0UHJvdmlkZXJGb3IoJ3RyYW5zaXRpb25TZXJ2aWNlJykpO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckc3RhdGUnLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZ2V0U3RhdGVQcm92aWRlcl0pO1xuXG5tb2Rfc3RhdGUuZmFjdG9yeSgnJHN0YXRlUGFyYW1zJywgWyckdWlSb3V0ZXInLCAoJHVpUm91dGVyOiBVSVJvdXRlcikgPT4gJHVpUm91dGVyLmdsb2JhbHMucGFyYW1zXSk7XG5tb2RfbWFpbi5mYWN0b3J5KCckdmlldycsICgpID0+IHJvdXRlci52aWV3U2VydmljZSk7XG5tb2RfbWFpbi5zZXJ2aWNlKCckdHJhY2UnLCAoKSA9PiB0cmFjZSk7XG5cbm1vZF9tYWluLnJ1bih3YXRjaERpZ2VzdHMpO1xubW9kX3V0aWwucnVuKFsnJHVybE1hdGNoZXJGYWN0b3J5JywgZnVuY3Rpb24oJHVybE1hdGNoZXJGYWN0b3J5OiBVcmxNYXRjaGVyRmFjdG9yeSkge31dKTtcbm1vZF9zdGF0ZS5ydW4oWyckc3RhdGUnLCBmdW5jdGlvbigkc3RhdGU6IFN0YXRlU2VydmljZSkge31dKTtcbm1vZF9ydHIucnVuKFsnJHVybFJvdXRlcicsIGZ1bmN0aW9uKCR1cmxSb3V0ZXI6IFVybFJvdXRlcikge31dKTtcbm1vZF9pbml0LnJ1bihydW5CbG9jayk7XG5cbi8qKiBAaGlkZGVuIFRPRE86IGZpbmQgYSBwbGFjZSB0byBtb3ZlIHRoaXMgKi9cbmV4cG9ydCBjb25zdCBnZXRMb2NhbHMgPSAoY3R4OiBSZXNvbHZlQ29udGV4dCk6IFR5cGVkTWFwPGFueT4gPT4ge1xuICBjb25zdCB0b2tlbnMgPSBjdHguZ2V0VG9rZW5zKCkuZmlsdGVyKGlzU3RyaW5nKTtcblxuICBjb25zdCB0dXBsZXMgPSB0b2tlbnMubWFwKGtleSA9PiB7XG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IGN0eC5nZXRSZXNvbHZhYmxlKGtleSk7XG4gICAgY29uc3Qgd2FpdFBvbGljeSA9IGN0eC5nZXRQb2xpY3kocmVzb2x2YWJsZSkuYXN5bmM7XG4gICAgcmV0dXJuIFtrZXksIHdhaXRQb2xpY3kgPT09ICdOT1dBSVQnID8gcmVzb2x2YWJsZS5wcm9taXNlIDogcmVzb2x2YWJsZS5kYXRhXTtcbiAgfSk7XG5cbiAgcmV0dXJuIHR1cGxlcy5yZWR1Y2UoYXBwbHlQYWlycywge30pO1xufTtcbiIsIi8qKlxuICogIyBBbmd1bGFyIDEgRGlyZWN0aXZlc1xuICpcbiAqIFRoZXNlIGFyZSB0aGUgZGlyZWN0aXZlcyBpbmNsdWRlZCBpbiBVSS1Sb3V0ZXIgZm9yIEFuZ3VsYXIgMS5cbiAqIFRoZXNlIGRpcmVjdGl2ZXMgYXJlIHVzZWQgaW4gdGVtcGxhdGVzIHRvIGNyZWF0ZSB2aWV3cG9ydHMgYW5kIGxpbmsvbmF2aWdhdGUgdG8gc3RhdGVzLlxuICpcbiAqIEBwcmVmZXJyZWQgQHB1YmxpY2FwaSBAbW9kdWxlIGRpcmVjdGl2ZXNcbiAqLyAvKiogKi9cbmltcG9ydCB7IG5nIGFzIGFuZ3VsYXIgfSBmcm9tICcuLi9hbmd1bGFyJztcbmltcG9ydCB7IElBdWdtZW50ZWRKUXVlcnksIElUaW1lb3V0U2VydmljZSwgSVNjb3BlLCBJSW50ZXJwb2xhdGVTZXJ2aWNlIH0gZnJvbSAnYW5ndWxhcic7XG5cbmltcG9ydCB7XG4gIE9iaixcbiAgZXh0ZW5kLFxuICBmb3JFYWNoLFxuICB0YWlsLFxuICBpc1N0cmluZyxcbiAgaXNPYmplY3QsXG4gIGlzQXJyYXksXG4gIHBhcnNlLFxuICBub29wLFxuICB1bm5lc3RSLFxuICBpZGVudGl0eSxcbiAgdW5pcVIsXG4gIGluQXJyYXksXG4gIHJlbW92ZUZyb20sXG4gIFJhd1BhcmFtcyxcbiAgUGF0aE5vZGUsXG4gIFN0YXRlT3JOYW1lLFxuICBTdGF0ZVNlcnZpY2UsXG4gIFN0YXRlRGVjbGFyYXRpb24sXG4gIFVJUm91dGVyLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBVSVZpZXdEYXRhIH0gZnJvbSAnLi92aWV3RGlyZWN0aXZlJztcblxuLyoqIEBoaWRkZW4gVXNlZCBmb3IgdHlwZWRvYyAqL1xuZXhwb3J0IGludGVyZmFjZSBuZzFfZGlyZWN0aXZlIHt9IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y2xhc3MtbmFtZVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcGFyc2VTdGF0ZVJlZihyZWY6IHN0cmluZykge1xuICBsZXQgcGFyc2VkO1xuICBjb25zdCBwYXJhbXNPbmx5ID0gcmVmLm1hdGNoKC9eXFxzKih7W159XSp9KVxccyokLyk7XG4gIGlmIChwYXJhbXNPbmx5KSByZWYgPSAnKCcgKyBwYXJhbXNPbmx5WzFdICsgJyknO1xuXG4gIHBhcnNlZCA9IHJlZi5yZXBsYWNlKC9cXG4vZywgJyAnKS5tYXRjaCgvXlxccyooW14oXSo/KVxccyooXFwoKC4qKVxcKSk/XFxzKiQvKTtcbiAgaWYgKCFwYXJzZWQgfHwgcGFyc2VkLmxlbmd0aCAhPT0gNCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSByZWYgJ1wiICsgcmVmICsgXCInXCIpO1xuICByZXR1cm4geyBzdGF0ZTogcGFyc2VkWzFdIHx8IG51bGwsIHBhcmFtRXhwcjogcGFyc2VkWzNdIHx8IG51bGwgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHN0YXRlQ29udGV4dChlbDogSUF1Z21lbnRlZEpRdWVyeSkge1xuICBjb25zdCAkdWlWaWV3OiBVSVZpZXdEYXRhID0gKGVsLnBhcmVudCgpIGFzIElBdWdtZW50ZWRKUXVlcnkpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcbiAgY29uc3QgcGF0aDogUGF0aE5vZGVbXSA9IHBhcnNlKCckY2ZnLnBhdGgnKSgkdWlWaWV3KTtcbiAgcmV0dXJuIHBhdGggPyB0YWlsKHBhdGgpLnN0YXRlLm5hbWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBwcm9jZXNzZWREZWYoJHN0YXRlOiBTdGF0ZVNlcnZpY2UsICRlbGVtZW50OiBJQXVnbWVudGVkSlF1ZXJ5LCBkZWY6IERlZik6IERlZiB7XG4gIGNvbnN0IHVpU3RhdGUgPSBkZWYudWlTdGF0ZSB8fCAkc3RhdGUuY3VycmVudC5uYW1lO1xuICBjb25zdCB1aVN0YXRlT3B0cyA9IGV4dGVuZChkZWZhdWx0T3B0cygkZWxlbWVudCwgJHN0YXRlKSwgZGVmLnVpU3RhdGVPcHRzIHx8IHt9KTtcbiAgY29uc3QgaHJlZiA9ICRzdGF0ZS5ocmVmKHVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zLCB1aVN0YXRlT3B0cyk7XG4gIHJldHVybiB7IHVpU3RhdGUsIHVpU3RhdGVQYXJhbXM6IGRlZi51aVN0YXRlUGFyYW1zLCB1aVN0YXRlT3B0cywgaHJlZiB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuaW50ZXJmYWNlIFR5cGVJbmZvIHtcbiAgYXR0cjogc3RyaW5nO1xuICBpc0FuY2hvcjogYm9vbGVhbjtcbiAgY2xpY2thYmxlOiBib29sZWFuO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZUluZm8oZWw6IElBdWdtZW50ZWRKUXVlcnkpOiBUeXBlSW5mbyB7XG4gIC8vIFNWR0FFbGVtZW50IGRvZXMgbm90IHVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUsIGJ1dCByYXRoZXIgdGhlICd4bGlua0hyZWYnIGF0dHJpYnV0ZS5cbiAgY29uc3QgaXNTdmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwucHJvcCgnaHJlZicpKSA9PT0gJ1tvYmplY3QgU1ZHQW5pbWF0ZWRTdHJpbmddJztcbiAgY29uc3QgaXNGb3JtID0gZWxbMF0ubm9kZU5hbWUgPT09ICdGT1JNJztcblxuICByZXR1cm4ge1xuICAgIGF0dHI6IGlzRm9ybSA/ICdhY3Rpb24nIDogaXNTdmcgPyAneGxpbms6aHJlZicgOiAnaHJlZicsXG4gICAgaXNBbmNob3I6IGVsLnByb3AoJ3RhZ05hbWUnKS50b1VwcGVyQ2FzZSgpID09PSAnQScsXG4gICAgY2xpY2thYmxlOiAhaXNGb3JtLFxuICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gY2xpY2tIb29rKFxuICBlbDogSUF1Z21lbnRlZEpRdWVyeSxcbiAgJHN0YXRlOiBTdGF0ZVNlcnZpY2UsXG4gICR0aW1lb3V0OiBJVGltZW91dFNlcnZpY2UsXG4gIHR5cGU6IFR5cGVJbmZvLFxuICBnZXREZWY6ICgpID0+IERlZlxuKSB7XG4gIHJldHVybiBmdW5jdGlvbihlOiBKUXVlcnlNb3VzZUV2ZW50T2JqZWN0KSB7XG4gICAgY29uc3QgYnV0dG9uID0gZS53aGljaCB8fCBlLmJ1dHRvbixcbiAgICAgIHRhcmdldCA9IGdldERlZigpO1xuXG4gICAgaWYgKCEoYnV0dG9uID4gMSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZWwuYXR0cigndGFyZ2V0JykpKSB7XG4gICAgICAvLyBIQUNLOiBUaGlzIGlzIHRvIGFsbG93IG5nLWNsaWNrcyB0byBiZSBwcm9jZXNzZWQgYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGlzIGluaXRpYXRlZDpcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFlbC5hdHRyKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgJHN0YXRlLmdvKHRhcmdldC51aVN0YXRlLCB0YXJnZXQudWlTdGF0ZVBhcmFtcywgdGFyZ2V0LnVpU3RhdGVPcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIGlmIHRoZSBzdGF0ZSBoYXMgbm8gVVJMLCBpZ25vcmUgb25lIHByZXZlbnREZWZhdWx0IGZyb20gdGhlIDxhPiBkaXJlY3RpdmUuXG4gICAgICBsZXQgaWdub3JlUHJldmVudERlZmF1bHRDb3VudCA9IHR5cGUuaXNBbmNob3IgJiYgIXRhcmdldC5ocmVmID8gMSA6IDA7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnQtLSA8PSAwKSAkdGltZW91dC5jYW5jZWwodHJhbnNpdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPcHRzKGVsOiBJQXVnbWVudGVkSlF1ZXJ5LCAkc3RhdGU6IFN0YXRlU2VydmljZSkge1xuICByZXR1cm4ge1xuICAgIHJlbGF0aXZlOiBzdGF0ZUNvbnRleHQoZWwpIHx8ICRzdGF0ZS4kY3VycmVudCxcbiAgICBpbmhlcml0OiB0cnVlLFxuICAgIHNvdXJjZTogJ3NyZWYnLFxuICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYmluZEV2ZW50cyhlbGVtZW50OiBJQXVnbWVudGVkSlF1ZXJ5LCBzY29wZTogSVNjb3BlLCBob29rRm46IEV2ZW50TGlzdGVuZXIsIHVpU3RhdGVPcHRzOiBhbnkpOiB2b2lkIHtcbiAgbGV0IGV2ZW50cztcblxuICBpZiAodWlTdGF0ZU9wdHMpIHtcbiAgICBldmVudHMgPSB1aVN0YXRlT3B0cy5ldmVudHM7XG4gIH1cblxuICBpZiAoIWlzQXJyYXkoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IFsnY2xpY2snXTtcbiAgfVxuXG4gIGNvbnN0IG9uID0gZWxlbWVudC5vbiA/ICdvbicgOiAnYmluZCc7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgZWxlbWVudFtvbl0oZXZlbnQsIGhvb2tGbik7XG4gIH1cblxuICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgb2ZmID0gZWxlbWVudC5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnO1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBlbGVtZW50W29mZl0oZXZlbnQsIGhvb2tGbiBhcyBhbnkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogYHVpLXNyZWZgOiBBIGRpcmVjdGl2ZSBmb3IgbGlua2luZyB0byBhIHN0YXRlXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyBMaW5rZWQgU3RhdGVcbiAqIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGB1aS1zcmVmYCBpcyB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gbGluayB0by5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIHdpbGwgYWN0aXZhdGUgdGhlIGBob21lYCBzdGF0ZSB3aGVuIHRoZSBsaW5rIGlzIGNsaWNrZWQuXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgUmVsYXRpdmUgTGlua3NcbiAqIFlvdSBjYW4gYWxzbyB1c2UgcmVsYXRpdmUgc3RhdGUgcGF0aHMgd2l0aGluIGB1aS1zcmVmYCwganVzdCBsaWtlIGEgcmVsYXRpdmUgcGF0aCBwYXNzZWQgdG8gYCRzdGF0ZS5nbygpYCAoW1tTdGF0ZVNlcnZpY2UuZ29dXSkuXG4gKiBZb3UganVzdCBuZWVkIHRvIGJlIGF3YXJlIHRoYXQgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIHN0YXRlIHRoYXQgKmNyZWF0ZWQqIHRoZSBsaW5rLlxuICogVGhpcyBhbGxvd3MgYSBzdGF0ZSB0byBjcmVhdGUgYSByZWxhdGl2ZSBgdWktc3JlZmAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQm90aCB0aGVzZSBsaW5rcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBzdGF0ZSwgZXZlbiB3aGVuIGEgY2hpbGQgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCIuY2hpbGQxXCI+Y2hpbGQgMSBzdGF0ZTwvYT5cbiAqIDxhIHVpLXNyZWY9XCIuY2hpbGQyXCI+Y2hpbGQgMiBzdGF0ZTwvYT5cbiAqIGBgYFxuICpcbiAqIFRoaXMgbGluayBhY3RpdmF0ZXMgdGhlIHBhcmVudCBzdGF0ZS5cbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJeXCI+UmV0dXJuPC9hPlxuICogYGBgXG4gKlxuICogIyMjIGhyZWZzXG4gKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXG4gKiB1cGRhdGUgdGhlIGBocmVmYCBhdHRyaWJ1dGUgKHVzaW5nIHRoZSBbW1N0YXRlU2VydmljZS5ocmVmXV0gIG1ldGhvZCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQXNzdW1pbmcgdGhlIGB1c2Vyc2Agc3RhdGUgaGFzIGEgdXJsIG9mIGAvdXNlcnMvYFxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cInVzZXJzXCIgaHJlZj1cIi91c2Vycy9cIj5Vc2VyczwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBQYXJhbWV0ZXIgVmFsdWVzXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhdGUgbmFtZSwgYSBgdWktc3JlZmAgY2FuIGluY2x1ZGUgcGFyYW1ldGVyIHZhbHVlcyB3aGljaCBhcmUgYXBwbGllZCB3aGVuIGFjdGl2YXRpbmcgdGhlIHN0YXRlLlxuICogUGFyYW0gdmFsdWVzIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHVpLXNyZWZgIHZhbHVlIGFmdGVyIHRoZSBzdGF0ZSBuYW1lLCBlbmNsb3NlZCBieSBwYXJlbnRoZXNlcy5cbiAqIFRoZSBjb250ZW50IGluc2lkZSB0aGUgcGFyZW50aGVzZXMgaXMgYW4gZXhwcmVzc2lvbiwgZXZhbHVhdGVkIHRvIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB0byB1c2Vycy5cbiAqIFRoZSBzdGF0ZSdzIGB1c2VySWRgIHBhcmFtZXRlciB2YWx1ZSBjb21lcyBmcm9tIGVhY2ggdXNlcidzIGB1c2VyLmlkYCBwcm9wZXJ0eS5cbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJ1c2VyIGluIHVzZXJzXCI+XG4gKiAgIDxhIHVpLXNyZWY9XCJ1c2Vycy5kZXRhaWwoeyB1c2VySWQ6IHVzZXIuaWQgfSlcIj57eyB1c2VyLmRpc3BsYXlOYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqIE5vdGU6XG4gKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBleHByZXNzaW9uIGlzIGAkd2F0Y2hgZWQgZm9yIHVwZGF0ZXMuXG4gKlxuICogIyMjIFRyYW5zaXRpb24gT3B0aW9uc1xuICogWW91IGNhbiBzcGVjaWZ5IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0gYnkgdXNpbmcgdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cbiAqIE9wdGlvbnMgYXJlIHJlc3RyaWN0ZWQgdG8gYGxvY2F0aW9uYCwgYGluaGVyaXRgLCBhbmQgYHJlbG9hZGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7IHJlbG9hZDogdHJ1ZSB9XCI+SG9tZTwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBPdGhlciBET00gRXZlbnRzXG4gKlxuICogWW91IGNhbiBhbHNvIGN1c3RvbWl6ZSB3aGljaCBET00gZXZlbnRzIHRvIHJlc3BvbmQgdG8gKGluc3RlYWQgb2YgYGNsaWNrYCkgYnlcbiAqIHByb3ZpZGluZyBhbiBgZXZlbnRzYCBhcnJheSBpbiB0aGUgYHVpLXNyZWYtb3B0c2AgYXR0cmlidXRlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiIHVpLXNyZWY9XCJjb250YWN0c1wiIHVpLXNyZWYtb3B0cz1cInsgZXZlbnRzOiBbJ2NoYW5nZScsICdibHVyJ10gfVwiPlxuICogYGBgXG4gKlxuICogIyMjIEhpZ2hsaWdodGluZyB0aGUgYWN0aXZlIGxpbmtcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1t1aVNyZWZBY3RpdmVdXSB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rLlxuICpcbiAqICMjIyBFeGFtcGxlc1xuICogSWYgeW91IGhhdmUgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XG4gKiA8YSB1aS1zcmVmPVwiYWJvdXRcIj5BYm91dDwvYT5cbiAqIDxhIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XG4gKlxuICogPHVsPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPnt7IGNvbnRhY3QubmFtZSB9fTwvYT5cbiAqICAgICA8L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIFRoZW4gKGFzc3VtaW5nIHRoZSBjdXJyZW50IHN0YXRlIGlzIGBjb250YWN0c2ApIHRoZSByZW5kZXJlZCBodG1sIGluY2x1ZGluZyBocmVmcyB3b3VsZCBiZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICogPGEgaHJlZj1cIiMvYWJvdXRcIiB1aS1zcmVmPVwiYWJvdXRcIj5BYm91dDwvYT5cbiAqIDxhIGhyZWY9XCIjL2NvbnRhY3RzP3BhZ2U9MlwiIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XG4gKlxuICogPHVsPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzFcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Kb2U8L2E+XG4gKiAgICAgPC9saT5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8yXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+QWxpY2U8L2E+XG4gKiAgICAgPC9saT5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8zXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Qm9iPC9hPlxuICogICAgIDwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxhIGhyZWY9XCIjL2hvbWVcIiB1aS1zcmVmPVwiaG9tZVwiIHVpLXNyZWYtb3B0cz1cIntyZWxvYWQ6IHRydWV9XCI+SG9tZTwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBOb3Rlc1xuICpcbiAqIC0gWW91IGNhbiB1c2UgYHVpLXNyZWZgIHRvIGNoYW5nZSAqKm9ubHkgdGhlIHBhcmFtZXRlciB2YWx1ZXMqKiBieSBvbWl0dGluZyB0aGUgc3RhdGUgbmFtZSBhbmQgcGFyZW50aGVzZXMuXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBTZXRzIHRoZSBgbGFuZ2AgcGFyYW1ldGVyIHRvIGBlbmAgYW5kIHJlbWFpbnMgb24gdGhlIHNhbWUgc3RhdGUuXG4gKlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cInsgbGFuZzogJ2VuJyB9XCI+RW5nbGlzaDwvYT5cbiAqIGBgYFxuICpcbiAqIC0gQSBtaWRkbGUtY2xpY2ssIHJpZ2h0LWNsaWNrLCBvciBjdHJsLWNsaWNrIGlzIGhhbmRsZWQgKG5hdGl2ZWx5KSBieSB0aGUgYnJvd3NlciB0byBvcGVuIHRoZSBocmVmIGluIGEgbmV3IHdpbmRvdywgZm9yIGV4YW1wbGUuXG4gKlxuICogLSBVbmxpa2UgdGhlIHBhcmFtZXRlciB2YWx1ZXMgZXhwcmVzc2lvbiwgdGhlIHN0YXRlIG5hbWUgaXMgbm90IGAkd2F0Y2hgZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKS5cbiAqIElmIHlvdSBuZWVkIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgc3RhdGUgYmVpbmcgbGlua2VkIHRvLCB1c2UgdGhlIGZ1bGx5IGR5bmFtaWMgW1t1aVN0YXRlXV0gZGlyZWN0aXZlLlxuICovXG5sZXQgdWlTcmVmRGlyZWN0aXZlOiBuZzFfZGlyZWN0aXZlO1xudWlTcmVmRGlyZWN0aXZlID0gW1xuICAnJHVpUm91dGVyJyxcbiAgJyR0aW1lb3V0JyxcbiAgZnVuY3Rpb24gJFN0YXRlUmVmRGlyZWN0aXZlKCR1aVJvdXRlcjogVUlSb3V0ZXIsICR0aW1lb3V0OiBJVGltZW91dFNlcnZpY2UpIHtcbiAgICBjb25zdCAkc3RhdGUgPSAkdWlSb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlOiBJU2NvcGUsIGVsZW1lbnQ6IElBdWdtZW50ZWRKUXVlcnksIGF0dHJzOiBhbnksIHVpU3JlZkFjdGl2ZTogYW55KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdWlTcmVmQWN0aXZlWzFdIHx8IHVpU3JlZkFjdGl2ZVswXTtcbiAgICAgICAgbGV0IHVubGlua0luZm9GbjogRnVuY3Rpb24gPSBudWxsO1xuICAgICAgICBsZXQgaG9va0ZuO1xuXG4gICAgICAgIGNvbnN0IHJhd0RlZiA9IHt9IGFzIERlZjtcbiAgICAgICAgY29uc3QgZ2V0RGVmID0gKCkgPT4gcHJvY2Vzc2VkRGVmKCRzdGF0ZSwgZWxlbWVudCwgcmF3RGVmKTtcblxuICAgICAgICBjb25zdCByZWYgPSBwYXJzZVN0YXRlUmVmKGF0dHJzLnVpU3JlZik7XG4gICAgICAgIHJhd0RlZi51aVN0YXRlID0gcmVmLnN0YXRlO1xuICAgICAgICByYXdEZWYudWlTdGF0ZU9wdHMgPSBhdHRycy51aVNyZWZPcHRzID8gc2NvcGUuJGV2YWwoYXR0cnMudWlTcmVmT3B0cykgOiB7fTtcblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gZ2V0RGVmKCk7XG4gICAgICAgICAgaWYgKHVubGlua0luZm9GbikgdW5saW5rSW5mb0ZuKCk7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkgdW5saW5rSW5mb0ZuID0gYWN0aXZlLiQkYWRkU3RhdGVJbmZvKGRlZi51aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcyk7XG4gICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmLnBhcmFtRXhwcikge1xuICAgICAgICAgIHNjb3BlLiR3YXRjaChcbiAgICAgICAgICAgIHJlZi5wYXJhbUV4cHIsXG4gICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVQYXJhbXMgPSBleHRlbmQoe30sIHZhbCk7XG4gICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJhd0RlZi51aVN0YXRlUGFyYW1zID0gZXh0ZW5kKHt9LCBzY29wZS4kZXZhbChyZWYucGFyYW1FeHByKSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoKTtcblxuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgPGFueT4kdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQodXBkYXRlKSk7XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCA8YW55PiR1aVJvdXRlci50cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZSkpO1xuXG4gICAgICAgIGlmICghdHlwZS5jbGlja2FibGUpIHJldHVybjtcbiAgICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZik7XG4gICAgICAgIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgcmF3RGVmLnVpU3RhdGVPcHRzKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbl07XG5cbi8qKlxuICogYHVpLXN0YXRlYDogQSBmdWxseSBkeW5hbWljIGRpcmVjdGl2ZSBmb3IgbGlua2luZyB0byBhIHN0YXRlXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICoqVGhpcyBkaXJlY3RpdmUgaXMgdmVyeSBzaW1pbGFyIHRvIFtbdWlTcmVmXV0sIGJ1dCBpdCBgJG9ic2VydmVgcyBhbmQgYCR3YXRjaGBlcy9ldmFsdWF0ZXMgYWxsIGl0cyBpbnB1dHMuKipcbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBsaW5rcyB0byBhIHN0YXRlIChhbmQgb3B0aW9uYWxseSwgcGFyYW1ldGVycykuXG4gKiBXaGVuIGNsaWNrZWQsIHRoaXMgZGlyZWN0aXZlIGFjdGl2YXRlcyB0aGUgbGlua2VkIHN0YXRlIHdpdGggdGhlIHN1cHBsaWVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogIyMjIExpbmtlZCBTdGF0ZVxuICogVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBgdWktc3RhdGVgIGlzIGFuIGV4cHJlc3Npb24gd2hpY2ggaXMgYCR3YXRjaGBlZCBhbmQgZXZhbHVhdGVkIGFzIHRoZSBzdGF0ZSB0byBsaW5rIHRvLlxuICogKipUaGlzIGlzIGluIGNvbnRyYXN0IHdpdGggYHVpLXNyZWZgLCB3aGljaCB0YWtlcyBhIHN0YXRlIG5hbWUgYXMgYSBzdHJpbmcgbGl0ZXJhbC4qKlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIENyZWF0ZSBhIGxpc3Qgb2YgbGlua3MuXG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwibGluayBpbiBuYXZsaW5rc1wiPlxuICogICA8YSB1aS1zdGF0ZT1cImxpbmsuc3RhdGVcIj57eyBsaW5rLmRpc3BsYXlOYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqICMjIyBSZWxhdGl2ZSBMaW5rc1xuICogSWYgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgcmVsYXRpdmUgcGF0aCwgaXQgaXMgcHJvY2Vzc2VkIGxpa2UgW1t1aVNyZWZdXS5cbiAqIFlvdSBqdXN0IG5lZWQgdG8gYmUgYXdhcmUgdGhhdCB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgc3RhdGUgdGhhdCAqY3JlYXRlZCogdGhlIGxpbmsuXG4gKiBUaGlzIGFsbG93cyBhIHN0YXRlIHRvIGNyZWF0ZSByZWxhdGl2ZSBgdWktc3RhdGVgIHdoaWNoIGFsd2F5cyB0YXJnZXRzIHRoZSBzYW1lIGRlc3RpbmF0aW9uLlxuICpcbiAqICMjIyBocmVmc1xuICogSWYgdGhlIGxpbmtlZCBzdGF0ZSBoYXMgYSBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGFuZFxuICogdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlICh1c2luZyB0aGUgW1tTdGF0ZVNlcnZpY2UuaHJlZl1dICBtZXRob2QpLlxuICpcbiAqICMjIyBQYXJhbWV0ZXIgVmFsdWVzXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhdGUgbmFtZSBleHByZXNzaW9uLCBhIGB1aS1zdGF0ZWAgY2FuIGluY2x1ZGUgcGFyYW1ldGVyIHZhbHVlcyB3aGljaCBhcmUgYXBwbGllZCB3aGVuIGFjdGl2YXRpbmcgdGhlIHN0YXRlLlxuICogUGFyYW0gdmFsdWVzIHNob3VsZCBiZSBwcm92aWRlZCB1c2luZyB0aGUgYHVpLXN0YXRlLXBhcmFtc2AgYXR0cmlidXRlLlxuICogVGhlIGB1aS1zdGF0ZS1wYXJhbXNgIGF0dHJpYnV0ZSB2YWx1ZSBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgcmVuZGVycyBhIGxpc3Qgb2YgbGlua3Mgd2l0aCBwYXJhbSB2YWx1ZXMuXG4gKiBUaGUgc3RhdGUncyBgdXNlcklkYCBwYXJhbWV0ZXIgdmFsdWUgY29tZXMgZnJvbSBlYWNoIHVzZXIncyBgdXNlci5pZGAgcHJvcGVydHkuXG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwibGluayBpbiBuYXZsaW5rc1wiPlxuICogICA8YSB1aS1zdGF0ZT1cImxpbmsuc3RhdGVcIiB1aS1zdGF0ZS1wYXJhbXM9XCJsaW5rLnBhcmFtc1wiPnt7IGxpbmsuZGlzcGxheU5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogIyMjIFRyYW5zaXRpb24gT3B0aW9uc1xuICogWW91IGNhbiBzcGVjaWZ5IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0gYnkgdXNpbmcgdGhlIGB1aS1zdGF0ZS1vcHRzYCBhdHRyaWJ1dGUuXG4gKiBPcHRpb25zIGFyZSByZXN0cmljdGVkIHRvIGBsb2NhdGlvbmAsIGBpbmhlcml0YCwgYW5kIGByZWxvYWRgLlxuICogVGhlIHZhbHVlIG9mIHRoZSBgdWktc3RhdGUtb3B0c2AgaXMgYCR3YXRjaGBlZCBhbmQgZXZhbHVhdGVkIGFzIGFuIGV4cHJlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGEgdWktc3RhdGU9XCJyZXR1cm50by5zdGF0ZVwiIHVpLXN0YXRlLW9wdHM9XCJ7IHJlbG9hZDogdHJ1ZSB9XCI+SG9tZTwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBPdGhlciBET00gRXZlbnRzXG4gKlxuICogWW91IGNhbiBhbHNvIGN1c3RvbWl6ZSB3aGljaCBET00gZXZlbnRzIHRvIHJlc3BvbmQgdG8gKGluc3RlYWQgb2YgYGNsaWNrYCkgYnlcbiAqIHByb3ZpZGluZyBhbiBgZXZlbnRzYCBhcnJheSBpbiB0aGUgYHVpLXN0YXRlLW9wdHNgIGF0dHJpYnV0ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgdHlwZT1cInRleHRcIiB1aS1zdGF0ZT1cImNvbnRhY3RzXCIgdWktc3RhdGUtb3B0cz1cInsgZXZlbnRzOiBbJ2NoYW5nZScsICdibHVyJ10gfVwiPlxuICogYGBgXG4gKlxuICogIyMjIEhpZ2hsaWdodGluZyB0aGUgYWN0aXZlIGxpbmtcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1t1aVNyZWZBY3RpdmVdXSB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rLlxuICpcbiAqICMjIyBOb3Rlc1xuICpcbiAqIC0gWW91IGNhbiB1c2UgYHVpLXBhcmFtc2AgdG8gY2hhbmdlICoqb25seSB0aGUgcGFyYW1ldGVyIHZhbHVlcyoqIGJ5IG9taXR0aW5nIHRoZSBzdGF0ZSBuYW1lIGFuZCBzdXBwbHlpbmcgb25seSBgdWktc3RhdGUtcGFyYW1zYC5cbiAqICAgSG93ZXZlciwgaXQgbWlnaHQgYmUgc2ltcGxlciB0byB1c2UgW1t1aVNyZWZdXSBwYXJhbWV0ZXItb25seSBsaW5rcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBTZXRzIHRoZSBgbGFuZ2AgcGFyYW1ldGVyIHRvIGBlbmAgYW5kIHJlbWFpbnMgb24gdGhlIHNhbWUgc3RhdGUuXG4gKlxuICogYGBgaHRtbFxuICogPGEgdWktc3RhdGU9XCJcIiB1aS1zdGF0ZS1wYXJhbXM9XCJ7IGxhbmc6ICdlbicgfVwiPkVuZ2xpc2g8L2E+XG4gKiBgYGBcbiAqXG4gKiAtIEEgbWlkZGxlLWNsaWNrLCByaWdodC1jbGljaywgb3IgY3RybC1jbGljayBpcyBoYW5kbGVkIChuYXRpdmVseSkgYnkgdGhlIGJyb3dzZXIgdG8gb3BlbiB0aGUgaHJlZiBpbiBhIG5ldyB3aW5kb3csIGZvciBleGFtcGxlLlxuICogYGBgXG4gKi9cbmxldCB1aVN0YXRlRGlyZWN0aXZlOiBuZzFfZGlyZWN0aXZlO1xudWlTdGF0ZURpcmVjdGl2ZSA9IFtcbiAgJyR1aVJvdXRlcicsXG4gICckdGltZW91dCcsXG4gIGZ1bmN0aW9uICRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUoJHVpUm91dGVyOiBVSVJvdXRlciwgJHRpbWVvdXQ6IElUaW1lb3V0U2VydmljZSkge1xuICAgIGNvbnN0ICRzdGF0ZSA9ICR1aVJvdXRlci5zdGF0ZVNlcnZpY2U7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6IFsnP151aVNyZWZBY3RpdmUnLCAnP151aVNyZWZBY3RpdmVFcSddLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGU6IElTY29wZSwgZWxlbWVudDogSUF1Z21lbnRlZEpRdWVyeSwgYXR0cnM6IGFueSwgdWlTcmVmQWN0aXZlOiBhbnkpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGVJbmZvKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB1aVNyZWZBY3RpdmVbMV0gfHwgdWlTcmVmQWN0aXZlWzBdO1xuICAgICAgICBsZXQgdW5saW5rSW5mb0ZuOiBGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIGxldCBob29rRm47XG5cbiAgICAgICAgY29uc3QgcmF3RGVmID0ge30gYXMgRGVmO1xuICAgICAgICBjb25zdCBnZXREZWYgPSAoKSA9PiBwcm9jZXNzZWREZWYoJHN0YXRlLCBlbGVtZW50LCByYXdEZWYpO1xuXG4gICAgICAgIGNvbnN0IGlucHV0QXR0cnMgPSBbJ3VpU3RhdGUnLCAndWlTdGF0ZVBhcmFtcycsICd1aVN0YXRlT3B0cyddO1xuICAgICAgICBjb25zdCB3YXRjaERlcmVnRm5zID0gaW5wdXRBdHRycy5yZWR1Y2UoKGFjYywgYXR0cikgPT4gKChhY2NbYXR0cl0gPSBub29wKSwgYWNjKSwge30pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICBjb25zdCBkZWYgPSBnZXREZWYoKTtcbiAgICAgICAgICBpZiAodW5saW5rSW5mb0ZuKSB1bmxpbmtJbmZvRm4oKTtcbiAgICAgICAgICBpZiAoYWN0aXZlKSB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8oZGVmLnVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zKTtcbiAgICAgICAgICBpZiAoZGVmLmhyZWYgIT0gbnVsbCkgYXR0cnMuJHNldCh0eXBlLmF0dHIsIGRlZi5ocmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0QXR0cnMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IGF0dHJzW2ZpZWxkXSA/IHNjb3BlLiRldmFsKGF0dHJzW2ZpZWxkXSkgOiBudWxsO1xuXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoZmllbGQsIGV4cHIgPT4ge1xuICAgICAgICAgICAgd2F0Y2hEZXJlZ0Zuc1tmaWVsZF0oKTtcbiAgICAgICAgICAgIHdhdGNoRGVyZWdGbnNbZmllbGRdID0gc2NvcGUuJHdhdGNoKFxuICAgICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgICBuZXd2YWwgPT4ge1xuICAgICAgICAgICAgICAgIHJhd0RlZltmaWVsZF0gPSBuZXd2YWw7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVwZGF0ZSgpO1xuXG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCA8YW55PiR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZCh1cGRhdGUpKTtcbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIDxhbnk+JHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XG5cbiAgICAgICAgaWYgKCF0eXBlLmNsaWNrYWJsZSkgcmV0dXJuO1xuICAgICAgICBob29rRm4gPSBjbGlja0hvb2soZWxlbWVudCwgJHN0YXRlLCAkdGltZW91dCwgdHlwZSwgZ2V0RGVmKTtcbiAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuXTtcblxuLyoqXG4gKiBgdWktc3JlZi1hY3RpdmVgIGFuZCBgdWktc3JlZi1hY3RpdmUtZXFgOiBBIGRpcmVjdGl2ZSB0aGF0IGFkZHMgYSBDU1MgY2xhc3Mgd2hlbiBhIGB1aS1zcmVmYCBpcyBhY3RpdmVcbiAqXG4gKiBBIGRpcmVjdGl2ZSB3b3JraW5nIGFsb25nc2lkZSBbW3VpU3JlZl1dIGFuZCBbW3VpU3RhdGVdXSB0byBhZGQgY2xhc3NlcyB0byBhbiBlbGVtZW50IHdoZW4gdGhlXG4gKiByZWxhdGVkIGRpcmVjdGl2ZSdzIHN0YXRlIGlzIGFjdGl2ZSAoYW5kIHJlbW92ZSB0aGVtIHdoZW4gaXQgaXMgaW5hY3RpdmUpLlxuICpcbiAqIFRoZSBwcmltYXJ5IHVzZS1jYXNlIGlzIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsgaW4gbmF2aWdhdGlvbiBtZW51cyxcbiAqIGRpc3Rpbmd1aXNoaW5nIGl0IGZyb20gdGhlIGluYWN0aXZlIG1lbnUgaXRlbXMuXG4gKlxuICogIyMjIExpbmtpbmcgdG8gYSBgdWktc3JlZmAgb3IgYHVpLXN0YXRlYFxuICogYHVpLXNyZWYtYWN0aXZlYCBjYW4gbGl2ZSBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIGB1aS1zcmVmYC9gdWktc3RhdGVgLCBvciBpdCBjYW4gYmUgb24gYSBwYXJlbnQgZWxlbWVudC5cbiAqIElmIGEgYHVpLXNyZWYtYWN0aXZlYCBpcyBhIHBhcmVudCB0byBtb3JlIHRoYW4gb25lIGB1aS1zcmVmYC9gdWktc3RhdGVgLCBpdCB3aWxsIGFwcGx5IHRoZSBDU1MgY2xhc3Mgd2hlbiAqKmFueSBvZiB0aGUgbGlua3MgYXJlIGFjdGl2ZSoqLlxuICpcbiAqICMjIyBNYXRjaGluZ1xuICpcbiAqIFRoZSBgdWktc3JlZi1hY3RpdmVgIGRpcmVjdGl2ZSBhcHBsaWVzIHRoZSBDU1MgY2xhc3Mgd2hlbiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAncyB0YXJnZXQgc3RhdGUgKipvciBhbnkgY2hpbGQgc3RhdGUgaXMgYWN0aXZlKiouXG4gKiBUaGlzIGlzIGEgXCJmdXp6eSBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaW5jbHVkZXNdXS5cbiAqXG4gKiBUaGUgYHVpLXNyZWYtYWN0aXZlLWVxYCBkaXJlY3RpdmUgYXBwbGllcyB0aGUgQ1NTIGNsYXNzIHdoZW4gdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgJ3MgdGFyZ2V0IHN0YXRlIGlzIGRpcmVjdGx5IGFjdGl2ZSAobm90IHdoZW4gY2hpbGQgc3RhdGVzIGFyZSBhY3RpdmUpLlxuICogVGhpcyBpcyBhbiBcImV4YWN0IG1hdGNoXCIgd2hpY2ggdXNlcyBbW1N0YXRlU2VydmljZS5pc11dLlxuICpcbiAqICMjIyBQYXJhbWV0ZXIgdmFsdWVzXG4gKiBJZiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAgaW5jbHVkZXMgcGFyYW1ldGVyIHZhbHVlcywgdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyBtdXN0IG1hdGNoIHRoZSBsaW5rJ3MgdmFsdWVzIGZvciB0aGUgbGluayB0byBiZSBoaWdobGlnaHRlZC5cbiAqIFRoaXMgYWxsb3dzIGEgbGlzdCBvZiBsaW5rcyB0byB0aGUgc2FtZSBzdGF0ZSB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIHRvIGJlIHJlbmRlcmVkLCBhbmQgdGhlIGNvcnJlY3Qgb25lIGhpZ2hsaWdodGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJ1c2VyIGluIHVzZXJzXCIgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIj5cbiAqICAgPGEgdWktc3JlZj1cInVzZXIuZGV0YWlscyh7IHVzZXJJZDogdXNlci5pZCB9KVwiPnt7IHVzZXIubGFzdE5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogIyMjIEV4YW1wbGVzXG4gKlxuICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZTpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtXCI+XG4gKiAgICAgPGEgaHJlZiB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGFwcCBzdGF0ZSBpcyBgYXBwLnVzZXJgIChvciBhbnkgY2hpbGQgc3RhdGUpLFxuICogYW5kIGNvbnRhaW5zIHRoZSBzdGF0ZSBwYXJhbWV0ZXIgXCJ1c2VyXCIgd2l0aCB2YWx1ZSBcImJpbGJvYmFnZ2luc1wiLFxuICogdGhlIHJlc3VsdGluZyBIVE1MIHdpbGwgYXBwZWFyIGFzIChub3RlIHRoZSAnYWN0aXZlJyBjbGFzcyk6XG4gKlxuICogYGBgaHRtbFxuICogPHVsPlxuICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW0gYWN0aXZlXCI+XG4gKiAgICAgPGEgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCIgaHJlZj1cIi91c2Vycy9iaWxib2JhZ2dpbnNcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqICMjIyBHbG9iIG1vZGVcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBwYXNzIGB1aS1zcmVmLWFjdGl2ZWAgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBvYmplY3QuXG4gKiBUaGUgb2JqZWN0cyBrZXlzIHJlcHJlc2VudCBhY3RpdmUgY2xhc3MgbmFtZXMgYW5kIHZhbHVlcyByZXByZXNlbnQgdGhlIHJlc3BlY3RpdmUgc3RhdGUgbmFtZXMvZ2xvYnMuXG4gKiBgdWktc3JlZi1hY3RpdmVgIHdpbGwgbWF0Y2ggaWYgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlICoqaW5jbHVkZXMqKiBhbnkgb2ZcbiAqIHRoZSBzcGVjaWZpZWQgc3RhdGUgbmFtZXMvZ2xvYnMsIGV2ZW4gdGhlIGFic3RyYWN0IG9uZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSwgd2l0aCBcImFkbWluXCIgYmVpbmcgYW4gYWJzdHJhY3Qgc3RhdGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IHVpLXNyZWYtYWN0aXZlPVwieydhY3RpdmUnOiAnYWRtaW4uKionfVwiPlxuICogICA8YSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIHVpLXNyZWY9XCJhZG1pbi5yb2xlc1wiPlJvbGVzPC9hPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBBcnJheXMgYXJlIGFsc28gc3VwcG9ydGVkIGFzIHZhbHVlcyBpbiB0aGUgYG5nQ2xhc3NgLWxpa2UgaW50ZXJmYWNlLlxuICogVGhpcyBhbGxvd3MgbXVsdGlwbGUgc3RhdGVzIHRvIGFkZCBgYWN0aXZlYCBjbGFzcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlLCB3aXRoIFwiYWRtaW4ucm9sZXNcIiBiZWluZyB0aGUgY3VycmVudCBzdGF0ZSwgdGhlIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG9vOlxuICogYGBgaHRtbFxuICogPGRpdiB1aS1zcmVmLWFjdGl2ZT1cInsnYWN0aXZlJzogWydvd25lci4qKicsICdhZG1pbi4qKiddfVwiPlxuICogICA8YSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIHVpLXNyZWY9XCJhZG1pbi5yb2xlc1wiPlJvbGVzPC9hPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBjdXJyZW50IHN0YXRlIGlzIFwiYWRtaW4ucm9sZXNcIiB0aGUgXCJhY3RpdmVcIiBjbGFzcyB3aWxsIGJlIGFwcGxpZWQgdG8gYm90aCB0aGUgYDxkaXY+YCBhbmQgYDxhPmAgZWxlbWVudHMuXG4gKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHRoZSBzdGF0ZSBuYW1lcy9nbG9icyBwYXNzZWQgdG8gYHVpLXNyZWYtYWN0aXZlYCBvdmVycmlkZSBhbnkgc3RhdGUgcHJvdmlkZWQgYnkgYSBsaW5rZWQgYHVpLXNyZWZgLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiAtIFRoZSBjbGFzcyBuYW1lIGlzIGludGVycG9sYXRlZCAqKm9uY2UqKiBkdXJpbmcgdGhlIGRpcmVjdGl2ZXMgbGluayB0aW1lIChhbnkgZnVydGhlciBjaGFuZ2VzIHRvIHRoZVxuICogaW50ZXJwb2xhdGVkIHZhbHVlIGFyZSBpZ25vcmVkKS5cbiAqXG4gKiAtIE11bHRpcGxlIGNsYXNzZXMgbWF5IGJlIHNwZWNpZmllZCBpbiBhIHNwYWNlLXNlcGFyYXRlZCBmb3JtYXQ6IGB1aS1zcmVmLWFjdGl2ZT0nY2xhc3MxIGNsYXNzMiBjbGFzczMnYFxuICovXG5sZXQgdWlTcmVmQWN0aXZlRGlyZWN0aXZlOiBuZzFfZGlyZWN0aXZlO1xudWlTcmVmQWN0aXZlRGlyZWN0aXZlID0gW1xuICAnJHN0YXRlJyxcbiAgJyRzdGF0ZVBhcmFtcycsXG4gICckaW50ZXJwb2xhdGUnLFxuICAnJHVpUm91dGVyJyxcbiAgZnVuY3Rpb24gJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlKFxuICAgICRzdGF0ZTogU3RhdGVTZXJ2aWNlLFxuICAgICRzdGF0ZVBhcmFtczogT2JqLFxuICAgICRpbnRlcnBvbGF0ZTogSUludGVycG9sYXRlU2VydmljZSxcbiAgICAkdWlSb3V0ZXI6IFVJUm91dGVyXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAnJHNjb3BlJyxcbiAgICAgICAgJyRlbGVtZW50JyxcbiAgICAgICAgJyRhdHRycycsXG4gICAgICAgIGZ1bmN0aW9uKCRzY29wZTogSVNjb3BlLCAkZWxlbWVudDogSUF1Z21lbnRlZEpRdWVyeSwgJGF0dHJzOiBhbnkpIHtcbiAgICAgICAgICBsZXQgc3RhdGVzOiBTdGF0ZURhdGFbXSA9IFtdO1xuICAgICAgICAgIGxldCBhY3RpdmVFcUNsYXNzOiBzdHJpbmc7XG4gICAgICAgICAgbGV0IHVpU3JlZkFjdGl2ZTogYW55O1xuXG4gICAgICAgICAgLy8gVGhlcmUgcHJvYmFibHkgaXNuJ3QgbXVjaCBwb2ludCBpbiAkb2JzZXJ2aW5nIHRoaXNcbiAgICAgICAgICAvLyB1aVNyZWZBY3RpdmUgYW5kIHVpU3JlZkFjdGl2ZUVxIHNoYXJlIHRoZSBzYW1lIGRpcmVjdGl2ZSBvYmplY3Qgd2l0aCBzb21lXG4gICAgICAgICAgLy8gc2xpZ2h0IGRpZmZlcmVuY2UgaW4gbG9naWMgcm91dGluZ1xuICAgICAgICAgIGFjdGl2ZUVxQ2xhc3MgPSAkaW50ZXJwb2xhdGUoJGF0dHJzLnVpU3JlZkFjdGl2ZUVxIHx8ICcnLCBmYWxzZSkoJHNjb3BlKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1aVNyZWZBY3RpdmUgPSAkc2NvcGUuJGV2YWwoJGF0dHJzLnVpU3JlZkFjdGl2ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZy4gdWlTcmVmQWN0aXZlIGlzIG5vdCBhIHZhbGlkIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgJGludGVycG9sYXRlIGJlbG93XG4gICAgICAgICAgfVxuICAgICAgICAgIHVpU3JlZkFjdGl2ZSA9IHVpU3JlZkFjdGl2ZSB8fCAkaW50ZXJwb2xhdGUoJGF0dHJzLnVpU3JlZkFjdGl2ZSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG4gICAgICAgICAgc2V0U3RhdGVzRnJvbURlZmluaXRpb25PYmplY3QodWlTcmVmQWN0aXZlKTtcblxuICAgICAgICAgIC8vIEFsbG93IHVpU3JlZiB0byBjb21tdW5pY2F0ZSB3aXRoIHVpU3JlZkFjdGl2ZVtFcXVhbHNdXG4gICAgICAgICAgdGhpcy4kJGFkZFN0YXRlSW5mbyA9IGZ1bmN0aW9uKG5ld1N0YXRlOiBzdHJpbmcsIG5ld1BhcmFtczogT2JqKSB7XG4gICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGdvdCBhbiBleHBsaWNpdCBzdGF0ZSBwcm92aWRlZCBieSB1aS1zcmVmLWFjdGl2ZSwgc28gd2VcbiAgICAgICAgICAgIC8vIHNoYWRvdyB0aGUgb25lIHRoYXQgY29tZXMgZnJvbSB1aS1zcmVmXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodWlTcmVmQWN0aXZlKSAmJiBzdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXJlZ2lzdGVyID0gYWRkU3RhdGUobmV3U3RhdGUsIG5ld1BhcmFtcywgdWlTcmVmQWN0aXZlKTtcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlcmVnaXN0ZXI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbih0cmFucykge1xuICAgICAgICAgICAgdHJhbnMucHJvbWlzZS50aGVuKHVwZGF0ZSwgbm9vcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95Jywgc2V0dXBFdmVudExpc3RlbmVycygpKTtcbiAgICAgICAgICBpZiAoJHVpUm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKCR1aVJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXJlZ2lzdGVyU3RhdGVzQ2hhbmdlZExpc3RlbmVyID0gJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKGhhbmRsZVN0YXRlc0NoYW5nZWQpO1xuICAgICAgICAgICAgY29uc3QgZGVyZWdpc3Rlck9uU3RhcnRMaXN0ZW5lciA9ICR1aVJvdXRlci50cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCB1cGRhdGVBZnRlclRyYW5zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZGVyZWdpc3RlclN0YXRlQ2hhbmdlU3VjY2Vzc0xpc3RlbmVyID0gJHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIHVwZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgICAgICAgZGVyZWdpc3RlclN0YXRlc0NoYW5nZWRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICBkZXJlZ2lzdGVyT25TdGFydExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgIGRlcmVnaXN0ZXJTdGF0ZUNoYW5nZVN1Y2Nlc3NMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVTdGF0ZXNDaGFuZ2VkKCkge1xuICAgICAgICAgICAgc2V0U3RhdGVzRnJvbURlZmluaXRpb25PYmplY3QodWlTcmVmQWN0aXZlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRTdGF0ZXNGcm9tRGVmaW5pdGlvbk9iamVjdChzdGF0ZXNEZWZpbml0aW9uOiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzdGF0ZXNEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICBzdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yRWFjaChzdGF0ZXNEZWZpbml0aW9uLCBmdW5jdGlvbihzdGF0ZU9yTmFtZTogU3RhdGVPck5hbWUgfCBBcnJheTxTdGF0ZU9yTmFtZT4sIGFjdGl2ZUNsYXNzOiBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWJzdHJhY3QgYWRkaW5nIHN0YXRlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZFN0YXRlRm9yQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZU9yTmFtZTogc3RyaW5nLCBhY3RpdmVDbGFzczogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBwYXJzZVN0YXRlUmVmKHN0YXRlT3JOYW1lKTtcbiAgICAgICAgICAgICAgICAgIGFkZFN0YXRlKHJlZi5zdGF0ZSwgJHNjb3BlLiRldmFsKHJlZi5wYXJhbUV4cHIpLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhzdGF0ZU9yTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXRlIGlzIHN0cmluZywganVzdCBhZGQgaXQuXG4gICAgICAgICAgICAgICAgICBhZGRTdGF0ZUZvckNsYXNzKHN0YXRlT3JOYW1lIGFzIHN0cmluZywgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShzdGF0ZU9yTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXRlIGlzIGFuIGFycmF5LCBpdGVyYXRlIG92ZXIgaXQgYW5kIGFkZCBlYWNoIGFycmF5IGl0ZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgICAgICAgICAgICAgZm9yRWFjaChzdGF0ZU9yTmFtZSwgZnVuY3Rpb24oc3RhdGVPck5hbWU6IHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdGF0ZUZvckNsYXNzKHN0YXRlT3JOYW1lLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFkZFN0YXRlKHN0YXRlTmFtZTogc3RyaW5nLCBzdGF0ZVBhcmFtczogT2JqLCBhY3RpdmVDbGFzczogc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9ICRzdGF0ZS5nZXQoc3RhdGVOYW1lLCBzdGF0ZUNvbnRleHQoJGVsZW1lbnQpKTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdGVJbmZvID0ge1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUgfHwgeyBuYW1lOiBzdGF0ZU5hbWUgfSxcbiAgICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZVBhcmFtcyxcbiAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IGFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3RhdGVzLnB1c2goc3RhdGVJbmZvKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZVN0YXRlKCkge1xuICAgICAgICAgICAgICByZW1vdmVGcm9tKHN0YXRlcykoc3RhdGVJbmZvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIHJvdXRlIHN0YXRlXG4gICAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRDbGFzc2VzID0gc3RyID0+IHN0ci5zcGxpdCgvXFxzLykuZmlsdGVyKGlkZW50aXR5KTtcbiAgICAgICAgICAgIGNvbnN0IGdldENsYXNzZXMgPSAoc3RhdGVMaXN0OiBTdGF0ZURhdGFbXSkgPT5cbiAgICAgICAgICAgICAgc3RhdGVMaXN0XG4gICAgICAgICAgICAgICAgLm1hcCh4ID0+IHguYWN0aXZlQ2xhc3MpXG4gICAgICAgICAgICAgICAgLm1hcChzcGxpdENsYXNzZXMpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBnZXRDbGFzc2VzKHN0YXRlcylcbiAgICAgICAgICAgICAgLmNvbmNhdChzcGxpdENsYXNzZXMoYWN0aXZlRXFDbGFzcykpXG4gICAgICAgICAgICAgIC5yZWR1Y2UodW5pcVIsIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1enp5Q2xhc3NlcyA9IGdldENsYXNzZXMoc3RhdGVzLmZpbHRlcih4ID0+ICRzdGF0ZS5pbmNsdWRlcyh4LnN0YXRlLm5hbWUsIHgucGFyYW1zKSkpO1xuICAgICAgICAgICAgY29uc3QgZXhhY3RseU1hdGNoZXNBbnkgPSAhIXN0YXRlcy5maWx0ZXIoeCA9PiAkc3RhdGUuaXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcykpLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGV4YWN0Q2xhc3NlcyA9IGV4YWN0bHlNYXRjaGVzQW55ID8gc3BsaXRDbGFzc2VzKGFjdGl2ZUVxQ2xhc3MpIDogW107XG5cbiAgICAgICAgICAgIGNvbnN0IGFkZENsYXNzZXMgPSBmdXp6eUNsYXNzZXMuY29uY2F0KGV4YWN0Q2xhc3NlcykucmVkdWNlKHVuaXFSLCBbXSk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVDbGFzc2VzID0gYWxsQ2xhc3Nlcy5maWx0ZXIoY2xzID0+ICFpbkFycmF5KGFkZENsYXNzZXMsIGNscykpO1xuXG4gICAgICAgICAgICAkc2NvcGUuJGV2YWxBc3luYygoKSA9PiB7XG4gICAgICAgICAgICAgIGFkZENsYXNzZXMuZm9yRWFjaChjbGFzc05hbWUgPT4gJGVsZW1lbnQuYWRkQ2xhc3MoY2xhc3NOYW1lKSk7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzZXMuZm9yRWFjaChjbGFzc05hbWUgPT4gJGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfSxcbl07XG5cbi8qKiBAaGlkZGVuICovXG5pbnRlcmZhY2UgRGVmIHtcbiAgdWlTdGF0ZTogc3RyaW5nO1xuICBocmVmOiBzdHJpbmc7XG4gIHVpU3RhdGVQYXJhbXM6IE9iajtcbiAgdWlTdGF0ZU9wdHM6IGFueTtcbn1cbi8qKiBAaGlkZGVuICovXG5pbnRlcmZhY2UgU3RhdGVEYXRhIHtcbiAgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb247XG4gIHBhcmFtczogUmF3UGFyYW1zO1xuICBhY3RpdmVDbGFzczogc3RyaW5nO1xufVxuXG5hbmd1bGFyXG4gIC5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5kaXJlY3RpdmUoJ3VpU3JlZicsIHVpU3JlZkRpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlJywgdWlTcmVmQWN0aXZlRGlyZWN0aXZlKVxuICAuZGlyZWN0aXZlKCd1aVNyZWZBY3RpdmVFcScsIHVpU3JlZkFjdGl2ZURpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTdGF0ZScsIHVpU3RhdGVEaXJlY3RpdmUpO1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5cbmltcG9ydCB7IG5nIGFzIGFuZ3VsYXIgfSBmcm9tICcuL2FuZ3VsYXInO1xuaW1wb3J0IHsgT2JqLCBTdGF0ZVNlcnZpY2UsIFN0YXRlT3JOYW1lIH0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuXG4vKipcbiAqIGBpc1N0YXRlYCBGaWx0ZXI6IHRydXRoeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB0aGUgcGFyYW1ldGVyXG4gKlxuICogVHJhbnNsYXRlcyB0byBbW1N0YXRlU2VydmljZS5pc11dIGAkc3RhdGUuaXMoXCJzdGF0ZU5hbWVcIilgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctaWY9XCInc3RhdGVOYW1lJyB8IGlzU3RhdGVcIj5zaG93IGlmIHN0YXRlIGlzICdzdGF0ZU5hbWUnPC9kaXY+XG4gKiBgYGBcbiAqL1xuJElzU3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XG5mdW5jdGlvbiAkSXNTdGF0ZUZpbHRlcigkc3RhdGU6IFN0YXRlU2VydmljZSkge1xuICBjb25zdCBpc0ZpbHRlcjogYW55ID0gZnVuY3Rpb24oc3RhdGU6IFN0YXRlT3JOYW1lLCBwYXJhbXM6IE9iaiwgb3B0aW9ucz86IHsgcmVsYXRpdmU/OiBTdGF0ZU9yTmFtZSB9KSB7XG4gICAgcmV0dXJuICRzdGF0ZS5pcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfTtcbiAgaXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgcmV0dXJuIGlzRmlsdGVyO1xufVxuXG4vKipcbiAqIGBpbmNsdWRlZEJ5U3RhdGVgIEZpbHRlcjogdHJ1dGh5IGlmIHRoZSBjdXJyZW50IHN0YXRlIGluY2x1ZGVzIHRoZSBwYXJhbWV0ZXJcbiAqXG4gKiBUcmFuc2xhdGVzIHRvIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV1gICRzdGF0ZS5pcyhcImZ1bGxPclBhcnRpYWxTdGF0ZU5hbWVcIilgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctaWY9XCInZnVsbE9yUGFydGlhbFN0YXRlTmFtZScgfCBpbmNsdWRlZEJ5U3RhdGVcIj5zaG93IGlmIHN0YXRlIGluY2x1ZGVzICdmdWxsT3JQYXJ0aWFsU3RhdGVOYW1lJzwvZGl2PlxuICogYGBgXG4gKi9cbiRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XG5mdW5jdGlvbiAkSW5jbHVkZWRCeVN0YXRlRmlsdGVyKCRzdGF0ZTogU3RhdGVTZXJ2aWNlKSB7XG4gIGNvbnN0IGluY2x1ZGVzRmlsdGVyOiBhbnkgPSBmdW5jdGlvbihzdGF0ZTogU3RhdGVPck5hbWUsIHBhcmFtczogT2JqLCBvcHRpb25zOiB7IHJlbGF0aXZlPzogU3RhdGVPck5hbWUgfSkge1xuICAgIHJldHVybiAkc3RhdGUuaW5jbHVkZXMoc3RhdGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH07XG4gIGluY2x1ZGVzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XG4gIHJldHVybiBpbmNsdWRlc0ZpbHRlcjtcbn1cblxuYW5ndWxhclxuICAubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKVxuICAuZmlsdGVyKCdpc1N0YXRlJywgJElzU3RhdGVGaWx0ZXIpXG4gIC5maWx0ZXIoJ2luY2x1ZGVkQnlTdGF0ZScsICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIpO1xuXG5leHBvcnQgeyAkSXNTdGF0ZUZpbHRlciwgJEluY2x1ZGVkQnlTdGF0ZUZpbHRlciB9O1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBkaXJlY3RpdmVzICovIC8qKiAqL1xuaW1wb3J0IHtcbiAgJFFMaWtlLFxuICBBY3RpdmVVSVZpZXcsXG4gIGV4dGVuZCxcbiAgZmlsdGVyLFxuICBIb29rUmVnT3B0aW9ucyxcbiAgaXNEZWZpbmVkLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmluZyxcbiAga2Vib2JTdHJpbmcsXG4gIG5vb3AsXG4gIE9iaixcbiAgUGFyYW0sXG4gIHBhcnNlLFxuICBQYXRoTm9kZSxcbiAgUmVzb2x2ZUNvbnRleHQsXG4gIFN0YXRlRGVjbGFyYXRpb24sXG4gIHRhaWwsXG4gIHRyYWNlLFxuICBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uU2VydmljZSxcbiAgVHlwZWRNYXAsXG4gIHVubmVzdFIsXG4gIFZpZXdTZXJ2aWNlLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBJQXVnbWVudGVkSlF1ZXJ5LCBJSW50ZXJwb2xhdGVTZXJ2aWNlLCBJU2NvcGUsIElUaW1lb3V0U2VydmljZSwgSVRyYW5zY2x1ZGVGdW5jdGlvbiB9IGZyb20gJ2FuZ3VsYXInO1xuaW1wb3J0IHsgbmcgYXMgYW5ndWxhciB9IGZyb20gJy4uL2FuZ3VsYXInO1xuaW1wb3J0IHsgTmcxQ29udHJvbGxlciwgTmcxU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBnZXRMb2NhbHMgfSBmcm9tICcuLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBOZzFWaWV3Q29uZmlnIH0gZnJvbSAnLi4vc3RhdGVidWlsZGVycy92aWV3cyc7XG5pbXBvcnQgeyBuZzFfZGlyZWN0aXZlIH0gZnJvbSAnLi9zdGF0ZURpcmVjdGl2ZXMnO1xuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IHR5cGUgVUlWaWV3RGF0YSA9IHtcbiAgJGNmZzogTmcxVmlld0NvbmZpZztcbiAgJHVpVmlldzogQWN0aXZlVUlWaWV3O1xufTtcblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCB0eXBlIFVJVmlld0FuaW1EYXRhID0ge1xuICAkYW5pbUVudGVyOiBQcm9taXNlPGFueT47XG4gICRhbmltTGVhdmU6IFByb21pc2U8YW55PjtcbiAgJCRhbmltTGVhdmU6IHsgcmVzb2x2ZTogKCkgPT4gYW55IH07IC8vIFwiZGVmZXJyZWRcIlxufTtcblxuLyoqXG4gKiBgdWktdmlld2A6IEEgdmlld3BvcnQgZGlyZWN0aXZlIHdoaWNoIGlzIGZpbGxlZCBpbiBieSBhIHZpZXcgZnJvbSB0aGUgYWN0aXZlIHN0YXRlLlxuICpcbiAqICMjIyBBdHRyaWJ1dGVzXG4gKlxuICogLSBgbmFtZWA6IChPcHRpb25hbCkgQSB2aWV3IG5hbWUuXG4gKiAgIFRoZSBuYW1lIHNob3VsZCBiZSB1bmlxdWUgYW1vbmdzdCB0aGUgb3RoZXIgdmlld3MgaW4gdGhlIHNhbWUgc3RhdGUuXG4gKiAgIFlvdSBjYW4gaGF2ZSB2aWV3cyBvZiB0aGUgc2FtZSBuYW1lIHRoYXQgbGl2ZSBpbiBkaWZmZXJlbnQgc3RhdGVzLlxuICogICBUaGUgdWktdmlldyBjYW4gYmUgdGFyZ2V0ZWQgaW4gYSBWaWV3IHVzaW5nIHRoZSBuYW1lIChbW05nMVN0YXRlRGVjbGFyYXRpb24udmlld3NdXSkuXG4gKlxuICogLSBgYXV0b3Njcm9sbGA6IGFuIGV4cHJlc3Npb24uIFdoZW4gaXQgZXZhbHVhdGVzIHRvIHRydWUsIHRoZSBgdWktdmlld2Agd2lsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgd2hlbiBpdCBpcyBhY3RpdmF0ZWQuXG4gKiAgIFVzZXMgW1skdWlWaWV3U2Nyb2xsXV0gdG8gZG8gdGhlIHNjcm9sbGluZy5cbiAqXG4gKiAtIGBvbmxvYWRgOiBFeHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW5ldmVyIHRoZSB2aWV3IHVwZGF0ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQSB2aWV3IGNhbiBiZSB1bm5hbWVkIG9yIG5hbWVkLlxuICogYGBgaHRtbFxuICogPCEtLSBVbm5hbWVkIC0tPlxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgLS0+XG4gKiA8ZGl2IHVpLXZpZXc9XCJ2aWV3TmFtZVwiPjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgKGRpZmZlcmVudCBzdHlsZSkgLS0+XG4gKiA8dWktdmlldyBuYW1lPVwidmlld05hbWVcIj48L3VpLXZpZXc+XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIG9ubHkgaGF2ZSBvbmUgdW5uYW1lZCB2aWV3IHdpdGhpbiBhbnkgdGVtcGxhdGUgKG9yIHJvb3QgaHRtbCkuIElmIHlvdSBhcmUgb25seSB1c2luZyBhXG4gKiBzaW5nbGUgdmlldyBhbmQgaXQgaXMgdW5uYW1lZCB0aGVuIHlvdSBjYW4gcG9wdWxhdGUgaXQgbGlrZSBzbzpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IHVpLXZpZXc+PC9kaXY+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBpcyBhIGNvbnZlbmllbnQgc2hvcnRjdXQgZXF1aXZhbGVudCB0byBzcGVjaWZ5aW5nIHlvdXIgdmlldyBleHBsaWNpdGx5IHdpdGggdGhlXG4gKiBbW05nMVN0YXRlRGVjbGFyYXRpb24udmlld3NdXSBjb25maWcgcHJvcGVydHksIGJ5IG5hbWUsIGluIHRoaXMgY2FzZSBhbiBlbXB0eSBuYW1lOlxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQnV0IHR5cGljYWxseSB5b3UnbGwgb25seSB1c2UgdGhlIHZpZXdzIHByb3BlcnR5IGlmIHlvdSBuYW1lIHlvdXIgdmlldyBvciBoYXZlIG1vcmUgdGhhbiBvbmUgdmlld1xuICogaW4gdGhlIHNhbWUgdGVtcGxhdGUuIFRoZXJlJ3Mgbm90IHJlYWxseSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIG5hbWUgYSB2aWV3IGlmIGl0cyB0aGUgb25seSBvbmUsXG4gKiBidXQgeW91IGNvdWxkIGlmIHlvdSB3YW50ZWQsIGxpa2Ugc286XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PVwibWFpblwiPjwvZGl2PlxuICogYGBgXG4gKlxuICogYGBganNcbiAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gKiAgIHZpZXdzOiB7XG4gKiAgICAgXCJtYWluXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogUmVhbGx5IHRob3VnaCwgeW91J2xsIHVzZSB2aWV3cyB0byBzZXQgdXAgbXVsdGlwbGUgdmlld3M6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICogPGRpdiB1aS12aWV3PVwiY2hhcnRcIj48L2Rpdj5cbiAqIDxkaXYgdWktdmlldz1cImRhdGFcIj48L2Rpdj5cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfSxcbiAqICAgICBcImNoYXJ0XCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxjaGFydF90aGluZy8+XCJcbiAqICAgICB9LFxuICogICAgIFwiZGF0YVwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8ZGF0YV90aGluZy8+XCJcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGVzIGZvciBgYXV0b3Njcm9sbGA6XG4gKiBgYGBodG1sXG4gKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIG5vIGV4cHJlc3Npb24sXG4gKiAgICAgIHRoZW4gc2Nyb2xsIHVpLXZpZXcgaW50byB2aWV3IC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbC8+XG4gKlxuICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCB2YWxpZCBleHByZXNzaW9uLFxuICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyBpZiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlIC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0ndHJ1ZScvPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0nZmFsc2UnLz5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3Njb3BlVmFyaWFibGUnLz5cbiAqIGBgYFxuICpcbiAqIFJlc29sdmUgZGF0YTpcbiAqXG4gKiBUaGUgcmVzb2x2ZWQgZGF0YSBmcm9tIHRoZSBzdGF0ZSdzIGByZXNvbHZlYCBibG9jayBpcyBwbGFjZWQgb24gdGhlIHNjb3BlIGFzIGAkcmVzb2x2ZWAgKHRoaXNcbiAqIGNhbiBiZSBjdXN0b21pemVkIHVzaW5nIFtbTmcxVmlld0RlY2xhcmF0aW9uLnJlc29sdmVBc11dKS4gIFRoaXMgY2FuIGJlIHRoZW4gYWNjZXNzZWQgZnJvbSB0aGUgdGVtcGxhdGUuXG4gKlxuICogTm90ZSB0aGF0IHdoZW4gYGNvbnRyb2xsZXJBc2AgaXMgYmVpbmcgdXNlZCwgYCRyZXNvbHZlYCBpcyBzZXQgb24gdGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UgKmFmdGVyKiB0aGVcbiAqIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiAgVGhlIGAkb25Jbml0KClgIGhvb2sgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiBjb2RlIHdoaWNoXG4gKiBkZXBlbmRzIG9uIGAkcmVzb2x2ZWAgZGF0YS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gKiAgIHRlbXBsYXRlOiAnPG15LWNvbXBvbmVudCB1c2VyPVwiJHJlc29sdmUudXNlclwiPjwvbXktY29tcG9uZW50PicsXG4gKiAgIHJlc29sdmU6IHtcbiAqICAgICB1c2VyOiBmdW5jdGlvbihVc2VyU2VydmljZSkgeyByZXR1cm4gVXNlclNlcnZpY2UuZmV0Y2hVc2VyKCk7IH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGxldCB1aVZpZXc6IG5nMV9kaXJlY3RpdmU7XG51aVZpZXcgPSBbXG4gICckdmlldycsXG4gICckYW5pbWF0ZScsXG4gICckdWlWaWV3U2Nyb2xsJyxcbiAgJyRpbnRlcnBvbGF0ZScsXG4gICckcScsXG4gIGZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlKFxuICAgICR2aWV3OiBWaWV3U2VydmljZSxcbiAgICAkYW5pbWF0ZTogYW55LFxuICAgICR1aVZpZXdTY3JvbGw6IGFueSxcbiAgICAkaW50ZXJwb2xhdGU6IElJbnRlcnBvbGF0ZVNlcnZpY2UsXG4gICAgJHE6ICRRTGlrZVxuICApIHtcbiAgICBmdW5jdGlvbiBnZXRSZW5kZXJlcihhdHRyczogT2JqLCBzY29wZTogSVNjb3BlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24oZWxlbWVudDogSlF1ZXJ5LCB0YXJnZXQ6IGFueSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCkudGhlbihjYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQ6IEpRdWVyeSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGVsZW1lbnQpLnRoZW4oY2IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50LCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdzRXF1YWwoY29uZmlnMTogTmcxVmlld0NvbmZpZywgY29uZmlnMjogTmcxVmlld0NvbmZpZykge1xuICAgICAgcmV0dXJuIGNvbmZpZzEgPT09IGNvbmZpZzI7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdERhdGEgPSB7XG4gICAgICAkY2ZnOiB7IHZpZXdEZWNsOiB7ICRjb250ZXh0OiAkdmlldy5fcGx1Z2luYXBpLl9yb290Vmlld0NvbnRleHQoKSB9IH0sXG4gICAgICAkdWlWaWV3OiB7fSxcbiAgICB9O1xuXG4gICAgY29uc3QgZGlyZWN0aXZlID0ge1xuICAgICAgY291bnQ6IDAsXG4gICAgICByZXN0cmljdDogJ0VDQScsXG4gICAgICB0ZXJtaW5hbDogdHJ1ZSxcbiAgICAgIHByaW9yaXR5OiA0MDAsXG4gICAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudDogSlF1ZXJ5LCB0QXR0cnM6IE9iaiwgJHRyYW5zY2x1ZGU6IElUcmFuc2NsdWRlRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlOiBJU2NvcGUsICRlbGVtZW50OiBJQXVnbWVudGVkSlF1ZXJ5LCBhdHRyczogT2JqKSB7XG4gICAgICAgICAgY29uc3Qgb25sb2FkRXhwID0gYXR0cnNbJ29ubG9hZCddIHx8ICcnLFxuICAgICAgICAgICAgYXV0b1Njcm9sbEV4cCA9IGF0dHJzWydhdXRvc2Nyb2xsJ10sXG4gICAgICAgICAgICByZW5kZXJlciA9IGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSksXG4gICAgICAgICAgICBpbmhlcml0ZWQgPSAkZWxlbWVudC5pbmhlcml0ZWREYXRhKCckdWlWaWV3JykgfHwgcm9vdERhdGEsXG4gICAgICAgICAgICBuYW1lID0gJGludGVycG9sYXRlKGF0dHJzWyd1aVZpZXcnXSB8fCBhdHRyc1snbmFtZSddIHx8ICcnKShzY29wZSkgfHwgJyRkZWZhdWx0JztcblxuICAgICAgICAgIGxldCBwcmV2aW91c0VsOiBKUXVlcnksXG4gICAgICAgICAgICBjdXJyZW50RWw6IEpRdWVyeSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZTogSVNjb3BlLFxuICAgICAgICAgICAgdmlld0NvbmZpZzogTmcxVmlld0NvbmZpZyxcbiAgICAgICAgICAgIHVucmVnaXN0ZXI6IEZ1bmN0aW9uO1xuXG4gICAgICAgICAgY29uc3QgYWN0aXZlVUlWaWV3OiBBY3RpdmVVSVZpZXcgPSB7XG4gICAgICAgICAgICAkdHlwZTogJ25nMScsXG4gICAgICAgICAgICBpZDogZGlyZWN0aXZlLmNvdW50KyssIC8vIEdsb2JhbCBzZXF1ZW50aWFsIElEIGZvciB1aS12aWV3IHRhZ3MgYWRkZWQgdG8gRE9NXG4gICAgICAgICAgICBuYW1lOiBuYW1lLCAvLyB1aS12aWV3IG5hbWUgKDxkaXYgdWktdmlldz1cIm5hbWVcIj48L2Rpdj5cbiAgICAgICAgICAgIGZxbjogaW5oZXJpdGVkLiR1aVZpZXcuZnFuID8gaW5oZXJpdGVkLiR1aVZpZXcuZnFuICsgJy4nICsgbmFtZSA6IG5hbWUsIC8vIGZ1bGx5IHF1YWxpZmllZCBuYW1lLCBkZXNjcmliZXMgbG9jYXRpb24gaW4gRE9NXG4gICAgICAgICAgICBjb25maWc6IG51bGwsIC8vIFRoZSBWaWV3Q29uZmlnIGxvYWRlZCAoZnJvbSBhIHN0YXRlLnZpZXdzIGRlZmluaXRpb24pXG4gICAgICAgICAgICBjb25maWdVcGRhdGVkOiBjb25maWdVcGRhdGVkQ2FsbGJhY2ssIC8vIENhbGxlZCB3aGVuIHRoZSBtYXRjaGluZyBWaWV3Q29uZmlnIGNoYW5nZXNcbiAgICAgICAgICAgIGdldCBjcmVhdGlvbkNvbnRleHQoKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBjb250ZXh0IGluIHdoaWNoIHRoaXMgdWktdmlldyBcInRhZ1wiIHdhcyBjcmVhdGVkXG4gICAgICAgICAgICAgIGNvbnN0IGZyb21QYXJlbnRUYWdDb25maWcgPSBwYXJzZSgnJGNmZy52aWV3RGVjbC4kY29udGV4dCcpKGluaGVyaXRlZCk7XG4gICAgICAgICAgICAgIC8vIEFsbG93IDx1aS12aWV3IG5hbWU9XCJmb29cIj48dWktdmlldyBuYW1lPVwiYmFyXCI+PC91aS12aWV3PjwvdWktdmlldz5cbiAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlci9pc3N1ZXMvMzM1NVxuICAgICAgICAgICAgICBjb25zdCBmcm9tUGFyZW50VGFnID0gcGFyc2UoJyR1aVZpZXcuY3JlYXRpb25Db250ZXh0JykoaW5oZXJpdGVkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZyb21QYXJlbnRUYWdDb25maWcgfHwgZnJvbVBhcmVudFRhZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0xpbmtpbmcnLCBhY3RpdmVVSVZpZXcpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY29uZmlnVXBkYXRlZENhbGxiYWNrKGNvbmZpZz86IE5nMVZpZXdDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgIShjb25maWcgaW5zdGFuY2VvZiBOZzFWaWV3Q29uZmlnKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3NFcXVhbCh2aWV3Q29uZmlnLCBjb25maWcpKSByZXR1cm47XG4gICAgICAgICAgICB0cmFjZS50cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQoYWN0aXZlVUlWaWV3LCBjb25maWcgJiYgY29uZmlnLnZpZXdEZWNsICYmIGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCk7XG5cbiAgICAgICAgICAgIHZpZXdDb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICB1cGRhdGVWaWV3KGNvbmZpZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJGVsZW1lbnQuZGF0YSgnJHVpVmlldycsIHsgJHVpVmlldzogYWN0aXZlVUlWaWV3IH0pO1xuXG4gICAgICAgICAgdXBkYXRlVmlldygpO1xuXG4gICAgICAgICAgdW5yZWdpc3RlciA9ICR2aWV3LnJlZ2lzdGVyVUlWaWV3KGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJhY2UudHJhY2VVSVZpZXdFdmVudCgnRGVzdHJveWluZy9VbnJlZ2lzdGVyaW5nJywgYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNsZWFudXBMYXN0VmlldygpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0VsKSB7XG4gICAgICAgICAgICAgIHRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ1JlbW92aW5nIChwcmV2aW91cykgZWwnLCBwcmV2aW91c0VsLmRhdGEoJyR1aVZpZXcnKSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgICAgIHRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0Rlc3Ryb3lpbmcgc2NvcGUnLCBhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbCkge1xuICAgICAgICAgICAgICBjb25zdCBfdmlld0RhdGEgPSBjdXJyZW50RWwuZGF0YSgnJHVpVmlld0FuaW0nKTtcbiAgICAgICAgICAgICAgdHJhY2UudHJhY2VVSVZpZXdFdmVudCgnQW5pbWF0ZSBvdXQnLCBfdmlld0RhdGEpO1xuICAgICAgICAgICAgICByZW5kZXJlci5sZWF2ZShjdXJyZW50RWwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF92aWV3RGF0YS4kJGFuaW1MZWF2ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNFbCA9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBjdXJyZW50RWw7XG4gICAgICAgICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlldyhjb25maWc/OiBOZzFWaWV3Q29uZmlnKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1FbnRlciA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgICAgIGFuaW1MZWF2ZSA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIGNvbnN0ICR1aVZpZXdEYXRhOiBVSVZpZXdEYXRhID0ge1xuICAgICAgICAgICAgICAkY2ZnOiBjb25maWcsXG4gICAgICAgICAgICAgICR1aVZpZXc6IGFjdGl2ZVVJVmlldyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0ICR1aVZpZXdBbmltOiBVSVZpZXdBbmltRGF0YSA9IHtcbiAgICAgICAgICAgICAgJGFuaW1FbnRlcjogYW5pbUVudGVyLnByb21pc2UsXG4gICAgICAgICAgICAgICRhbmltTGVhdmU6IGFuaW1MZWF2ZS5wcm9taXNlLFxuICAgICAgICAgICAgICAkJGFuaW1MZWF2ZTogYW5pbUxlYXZlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkaW5nXG4gICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgKipiZWdpbnMgbG9hZGluZyoqLCAqYmVmb3JlKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgTmFtZSBvZiB0aGUgdmlldy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbmV3U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudExvYWRpbmcnLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gJHRyYW5zY2x1ZGUobmV3U2NvcGUsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgICAgIGNsb25lLmRhdGEoJyR1aVZpZXdBbmltJywgJHVpVmlld0FuaW0pO1xuICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3JywgJHVpVmlld0RhdGEpO1xuICAgICAgICAgICAgICByZW5kZXJlci5lbnRlcihjbG9uZSwgJGVsZW1lbnQsIGZ1bmN0aW9uIG9uVUlWaWV3RW50ZXIoKSB7XG4gICAgICAgICAgICAgICAgYW5pbUVudGVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlKSBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudEFuaW1hdGlvbkVuZGVkJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGlzRGVmaW5lZChhdXRvU2Nyb2xsRXhwKSAmJiAhYXV0b1Njcm9sbEV4cCkgfHwgc2NvcGUuJGV2YWwoYXV0b1Njcm9sbEV4cCkpIHtcbiAgICAgICAgICAgICAgICAgICR1aVZpZXdTY3JvbGwoY2xvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2xlYW51cExhc3RWaWV3KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3VycmVudEVsID0gY2xvbmVkO1xuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3IyR2aWV3Q29udGVudExvYWRlZFxuICAgICAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3XG4gICAgICAgICAgICAgKiBAZXZlbnRUeXBlIGVtaXRzIG9uIHVpLXZpZXcgZGlyZWN0aXZlIHNjb3BlXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgaXMgKipsb2FkZWQqKiwgKmFmdGVyKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGVkJywgY29uZmlnIHx8IHZpZXdDb25maWcpO1xuICAgICAgICAgICAgY3VycmVudFNjb3BlLiRldmFsKG9ubG9hZEV4cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpcmVjdGl2ZTtcbiAgfSxcbl07XG5cbiRWaWV3RGlyZWN0aXZlRmlsbC4kaW5qZWN0ID0gWyckY29tcGlsZScsICckY29udHJvbGxlcicsICckdHJhbnNpdGlvbnMnLCAnJHZpZXcnLCAnJHEnLCAnJHRpbWVvdXQnXTtcblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlRmlsbChcbiAgJGNvbXBpbGU6IGFuZ3VsYXIuSUNvbXBpbGVTZXJ2aWNlLFxuICAkY29udHJvbGxlcjogYW5ndWxhci5JQ29udHJvbGxlclNlcnZpY2UsXG4gICR0cmFuc2l0aW9uczogVHJhbnNpdGlvblNlcnZpY2UsXG4gICR2aWV3OiBWaWV3U2VydmljZSxcbiAgJHE6IGFuZ3VsYXIuSVFTZXJ2aWNlLFxuICAkdGltZW91dDogSVRpbWVvdXRTZXJ2aWNlXG4pIHtcbiAgY29uc3QgZ2V0Q29udHJvbGxlckFzID0gcGFyc2UoJ3ZpZXdEZWNsLmNvbnRyb2xsZXJBcycpO1xuICBjb25zdCBnZXRSZXNvbHZlQXMgPSBwYXJzZSgndmlld0RlY2wucmVzb2x2ZUFzJyk7XG5cbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VDQScsXG4gICAgcHJpb3JpdHk6IC00MDAsXG4gICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQ6IEpRdWVyeSkge1xuICAgICAgY29uc3QgaW5pdGlhbCA9IHRFbGVtZW50Lmh0bWwoKTtcbiAgICAgIHRFbGVtZW50LmVtcHR5KCk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZTogSVNjb3BlLCAkZWxlbWVudDogSlF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGRhdGE6IFVJVmlld0RhdGEgPSAkZWxlbWVudC5kYXRhKCckdWlWaWV3Jyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICRlbGVtZW50Lmh0bWwoaW5pdGlhbCk7XG4gICAgICAgICAgJGNvbXBpbGUoJGVsZW1lbnQuY29udGVudHMoKSBhcyBhbnkpKHNjb3BlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjZmc6IE5nMVZpZXdDb25maWcgPSBkYXRhLiRjZmcgfHwgPGFueT57IHZpZXdEZWNsOiB7fSwgZ2V0VGVtcGxhdGU6IG5vb3AgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZUN0eDogUmVzb2x2ZUNvbnRleHQgPSBjZmcucGF0aCAmJiBuZXcgUmVzb2x2ZUNvbnRleHQoY2ZnLnBhdGgpO1xuICAgICAgICAkZWxlbWVudC5odG1sKGNmZy5nZXRUZW1wbGF0ZSgkZWxlbWVudCwgcmVzb2x2ZUN0eCkgfHwgaW5pdGlhbCk7XG4gICAgICAgIHRyYWNlLnRyYWNlVUlWaWV3RmlsbChkYXRhLiR1aVZpZXcsICRlbGVtZW50Lmh0bWwoKSk7XG5cbiAgICAgICAgY29uc3QgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkgYXMgYW55KTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGNmZy5jb250cm9sbGVyIGFzIGFuZ3VsYXIuSUNvbnRyb2xsZXJTZXJ2aWNlO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyQXM6IHN0cmluZyA9IGdldENvbnRyb2xsZXJBcyhjZmcpO1xuICAgICAgICBjb25zdCByZXNvbHZlQXM6IHN0cmluZyA9IGdldFJlc29sdmVBcyhjZmcpO1xuICAgICAgICBjb25zdCBsb2NhbHMgPSByZXNvbHZlQ3R4ICYmIGdldExvY2FscyhyZXNvbHZlQ3R4KTtcblxuICAgICAgICBzY29wZVtyZXNvbHZlQXNdID0gbG9jYWxzO1xuXG4gICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgY29udHJvbGxlckluc3RhbmNlID0gPE5nMUNvbnRyb2xsZXI+KFxuICAgICAgICAgICAgJGNvbnRyb2xsZXIoY29udHJvbGxlciwgZXh0ZW5kKHt9LCBsb2NhbHMsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGNvbnRyb2xsZXJBcykge1xuICAgICAgICAgICAgc2NvcGVbY29udHJvbGxlckFzXSA9IGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICAgICAgICAgIHNjb3BlW2NvbnRyb2xsZXJBc11bcmVzb2x2ZUFzXSA9IGxvY2FscztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBVc2UgJHZpZXcgc2VydmljZSBhcyBhIGNlbnRyYWwgcG9pbnQgZm9yIHJlZ2lzdGVyaW5nIGNvbXBvbmVudC1sZXZlbCBob29rc1xuICAgICAgICAgIC8vIFRoZW4sIHdoZW4gYSBjb21wb25lbnQgaXMgY3JlYXRlZCwgdGVsbCB0aGUgJHZpZXcgc2VydmljZSwgc28gaXQgY2FuIGludm9rZSBob29rc1xuICAgICAgICAgIC8vICR2aWV3LmNvbXBvbmVudExvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pO1xuICAgICAgICAgIC8vIHNjb3BlLiRvbignJGRlc3Ryb3knLCAoKSA9PiAkdmlldy5jb21wb25lbnRVbmxvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pKTtcblxuICAgICAgICAgICRlbGVtZW50LmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlckluc3RhbmNlKTtcbiAgICAgICAgICAkZWxlbWVudC5jaGlsZHJlbigpLmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlckluc3RhbmNlKTtcblxuICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsIHNjb3BlLCBjZmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGNvbXBvbmVudCB0byBhcHBlYXIgaW4gdGhlIERPTVxuICAgICAgICBpZiAoaXNTdHJpbmcoY2ZnLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICBjb25zdCBrZWJvYk5hbWUgPSBrZWJvYlN0cmluZyhjZmcuY29tcG9uZW50KTtcbiAgICAgICAgICBjb25zdCB0YWdSZWdleHAgPSBuZXcgUmVnRXhwKGBeKHgtfGRhdGEtKT8ke2tlYm9iTmFtZX0kYCwgJ2knKTtcblxuICAgICAgICAgIGNvbnN0IGdldENvbXBvbmVudENvbnRyb2xsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmVFbCA9IFtdLnNsaWNlXG4gICAgICAgICAgICAgIC5jYWxsKCRlbGVtZW50WzBdLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAuZmlsdGVyKChlbDogRWxlbWVudCkgPT4gZWwgJiYgZWwudGFnTmFtZSAmJiB0YWdSZWdleHAuZXhlYyhlbC50YWdOYW1lKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVFbCAmJiBhbmd1bGFyLmVsZW1lbnQoZGlyZWN0aXZlRWwpLmRhdGEoYCQke2NmZy5jb21wb25lbnR9Q29udHJvbGxlcmApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBkZXJlZ2lzdGVyV2F0Y2ggPSBzY29wZS4kd2F0Y2goZ2V0Q29tcG9uZW50Q29udHJvbGxlciwgZnVuY3Rpb24oY3RybEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoIWN0cmxJbnN0YW5jZSkgcmV0dXJuO1xuICAgICAgICAgICAgcmVnaXN0ZXJDb250cm9sbGVyQ2FsbGJhY2tzKCRxLCAkdHJhbnNpdGlvbnMsIGN0cmxJbnN0YW5jZSwgc2NvcGUsIGNmZyk7XG4gICAgICAgICAgICBkZXJlZ2lzdGVyV2F0Y2goKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmsoc2NvcGUpO1xuICAgICAgfTtcbiAgICB9LFxuICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgaGFzQ29tcG9uZW50SW1wbCA9IHR5cGVvZiAoYW5ndWxhciBhcyBhbnkpLm1vZHVsZSgndWkucm91dGVyJylbJ2NvbXBvbmVudCddID09PSAnZnVuY3Rpb24nO1xuLyoqIEBoaWRkZW4gaW5jcmVtZW50aW5nIGlkICovXG5sZXQgX3VpQ2FuRXhpdElkID0gMDtcblxuLyoqIEBoaWRkZW4gVE9ETzogbW92ZSB0aGVzZSBjYWxsYmFja3MgdG8gJHZpZXcgYW5kL29yIGAvaG9va3MvY29tcG9uZW50cy50c2Agb3Igc29tZXRoaW5nICovXG5mdW5jdGlvbiByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoXG4gICRxOiBhbmd1bGFyLklRU2VydmljZSxcbiAgJHRyYW5zaXRpb25zOiBUcmFuc2l0aW9uU2VydmljZSxcbiAgY29udHJvbGxlckluc3RhbmNlOiBOZzFDb250cm9sbGVyLFxuICAkc2NvcGU6IElTY29wZSxcbiAgY2ZnOiBOZzFWaWV3Q29uZmlnXG4pIHtcbiAgLy8gQ2FsbCAkb25Jbml0KCkgQVNBUFxuICBpZiAoaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UuJG9uSW5pdCkgJiYgISgoY2ZnLnZpZXdEZWNsLmNvbXBvbmVudCB8fCBjZmcudmlld0RlY2wuY29tcG9uZW50UHJvdmlkZXIpICYmIGhhc0NvbXBvbmVudEltcGwpKSB7XG4gICAgY29udHJvbGxlckluc3RhbmNlLiRvbkluaXQoKTtcbiAgfVxuXG4gIGNvbnN0IHZpZXdTdGF0ZTogTmcxU3RhdGVEZWNsYXJhdGlvbiA9IHRhaWwoY2ZnLnBhdGgpLnN0YXRlLnNlbGY7XG5cbiAgY29uc3QgaG9va09wdGlvbnM6IEhvb2tSZWdPcHRpb25zID0geyBiaW5kOiBjb250cm9sbGVySW5zdGFuY2UgfTtcbiAgLy8gQWRkIGNvbXBvbmVudC1sZXZlbCBob29rIGZvciBvblVpUGFyYW1zQ2hhbmdlZFxuICBpZiAoaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQpKSB7XG4gICAgY29uc3QgcmVzb2x2ZUNvbnRleHQ6IFJlc29sdmVDb250ZXh0ID0gbmV3IFJlc29sdmVDb250ZXh0KGNmZy5wYXRoKTtcbiAgICBjb25zdCB2aWV3Q3JlYXRpb25UcmFucyA9IHJlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGUoJyR0cmFuc2l0aW9uJCcpLmRhdGE7XG5cbiAgICAvLyBGaXJlIGNhbGxiYWNrIG9uIGFueSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAgICBjb25zdCBwYXJhbXNVcGRhdGVkID0gKCR0cmFuc2l0aW9uJDogVHJhbnNpdGlvbikgPT4ge1xuICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIGlzIHRoZSBzYW1lIGFzIHRoZSB2aWV3IHdhcyBjcmVhdGVkIHdpdGhpbi5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCB3aWxsIGV4aXQgdGhlIHN0YXRlIHRoZSB2aWV3IGlzIGZvci5cbiAgICAgIGlmICgkdHJhbnNpdGlvbiQgPT09IHZpZXdDcmVhdGlvblRyYW5zIHx8ICR0cmFuc2l0aW9uJC5leGl0aW5nKCkuaW5kZXhPZih2aWV3U3RhdGUgYXMgU3RhdGVEZWNsYXJhdGlvbikgIT09IC0xKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNvbnN0IHRvUGFyYW1zID0gJHRyYW5zaXRpb24kLnBhcmFtcygndG8nKSBhcyBUeXBlZE1hcDxhbnk+O1xuICAgICAgY29uc3QgZnJvbVBhcmFtcyA9ICR0cmFuc2l0aW9uJC5wYXJhbXM8VHlwZWRNYXA8YW55Pj4oJ2Zyb20nKSBhcyBUeXBlZE1hcDxhbnk+O1xuICAgICAgY29uc3QgZ2V0Tm9kZVNjaGVtYSA9IChub2RlOiBQYXRoTm9kZSkgPT4gbm9kZS5wYXJhbVNjaGVtYTtcbiAgICAgIGNvbnN0IHRvU2NoZW1hOiBQYXJhbVtdID0gJHRyYW5zaXRpb24kXG4gICAgICAgIC50cmVlQ2hhbmdlcygndG8nKVxuICAgICAgICAubWFwKGdldE5vZGVTY2hlbWEpXG4gICAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pO1xuICAgICAgY29uc3QgZnJvbVNjaGVtYTogUGFyYW1bXSA9ICR0cmFuc2l0aW9uJFxuICAgICAgICAudHJlZUNoYW5nZXMoJ2Zyb20nKVxuICAgICAgICAubWFwKGdldE5vZGVTY2hlbWEpXG4gICAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pO1xuXG4gICAgICAvLyBGaW5kIHRoZSB0byBwYXJhbXMgdGhhdCBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgdGhhbiB0aGUgZnJvbSBwYXJhbXNcbiAgICAgIGNvbnN0IGNoYW5nZWRUb1BhcmFtcyA9IHRvU2NoZW1hLmZpbHRlcigocGFyYW06IFBhcmFtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGZyb21TY2hlbWEuaW5kZXhPZihwYXJhbSk7XG4gICAgICAgIHJldHVybiBpZHggPT09IC0xIHx8ICFmcm9tU2NoZW1hW2lkeF0udHlwZS5lcXVhbHModG9QYXJhbXNbcGFyYW0uaWRdLCBmcm9tUGFyYW1zW3BhcmFtLmlkXSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gT25seSB0cmlnZ2VyIGNhbGxiYWNrIGlmIGEgdG8gcGFyYW0gaGFzIGNoYW5nZWQgb3IgaXMgbmV3XG4gICAgICBpZiAoY2hhbmdlZFRvUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjaGFuZ2VkS2V5czogc3RyaW5nW10gPSBjaGFuZ2VkVG9QYXJhbXMubWFwKHggPT4geC5pZCk7XG4gICAgICAgIC8vIEZpbHRlciB0aGUgcGFyYW1zIHRvIG9ubHkgY2hhbmdlZC9uZXcgdG8gcGFyYW1zLiAgYCR0cmFuc2l0aW9uJC5wYXJhbXMoKWAgbWF5IGJlIHVzZWQgdG8gZ2V0IGFsbCBwYXJhbXMuXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IGZpbHRlcih0b1BhcmFtcywgKHZhbCwga2V5KSA9PiBjaGFuZ2VkS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29udHJvbGxlckluc3RhbmNlLnVpT25QYXJhbXNDaGFuZ2VkKG5ld1ZhbHVlcywgJHRyYW5zaXRpb24kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgPGFueT4kdHJhbnNpdGlvbnMub25TdWNjZXNzKHt9LCBwYXJhbXNVcGRhdGVkLCBob29rT3B0aW9ucykpO1xuICB9XG5cbiAgLy8gQWRkIGNvbXBvbmVudC1sZXZlbCBob29rIGZvciB1aUNhbkV4aXRcbiAgaWYgKGlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLnVpQ2FuRXhpdCkpIHtcbiAgICBjb25zdCBpZCA9IF91aUNhbkV4aXRJZCsrO1xuICAgIGNvbnN0IGNhY2hlUHJvcCA9ICdfdWlDYW5FeGl0SWRzJztcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHJlZGlyZWN0IHRyYW5zaXRpb24gYWxyZWFkeSBhbnN3ZXJlZCB0cnV0aHlcbiAgICBjb25zdCBwcmV2VHJ1dGh5QW5zd2VyID0gKHRyYW5zOiBUcmFuc2l0aW9uKSA9PlxuICAgICAgISF0cmFucyAmJiAoKHRyYW5zW2NhY2hlUHJvcF0gJiYgdHJhbnNbY2FjaGVQcm9wXVtpZF0gPT09IHRydWUpIHx8IHByZXZUcnV0aHlBbnN3ZXIodHJhbnMucmVkaXJlY3RlZEZyb20oKSkpO1xuXG4gICAgLy8gSWYgYSB1c2VyIGFuc3dlcmVkIHllcywgYnV0IHRoZSB0cmFuc2l0aW9uIHdhcyBsYXRlciByZWRpcmVjdGVkLCBkb24ndCBhbHNvIGFzayBmb3IgdGhlIG5ldyByZWRpcmVjdCB0cmFuc2l0aW9uXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSAodHJhbnM6IFRyYW5zaXRpb24pID0+IHtcbiAgICAgIGxldCBwcm9taXNlO1xuICAgICAgY29uc3QgaWRzID0gKHRyYW5zW2NhY2hlUHJvcF0gPSB0cmFuc1tjYWNoZVByb3BdIHx8IHt9KTtcblxuICAgICAgaWYgKCFwcmV2VHJ1dGh5QW5zd2VyKHRyYW5zKSkge1xuICAgICAgICBwcm9taXNlID0gJHEud2hlbihjb250cm9sbGVySW5zdGFuY2UudWlDYW5FeGl0KHRyYW5zKSk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWwgPT4gKGlkc1tpZF0gPSB2YWwgIT09IGZhbHNlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgY29uc3QgY3JpdGVyaWEgPSB7IGV4aXRpbmc6IHZpZXdTdGF0ZS5uYW1lIH07XG4gICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCA8YW55PiR0cmFuc2l0aW9ucy5vbkJlZm9yZShjcml0ZXJpYSwgd3JhcHBlZEhvb2ssIGhvb2tPcHRpb25zKSk7XG4gIH1cbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlWaWV3JywgPGFueT51aVZpZXcpO1xuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlWaWV3JywgPGFueT4kVmlld0RpcmVjdGl2ZUZpbGwpO1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5pbXBvcnQgeyBuZyBhcyBhbmd1bGFyIH0gZnJvbSAnLi9hbmd1bGFyJztcbmltcG9ydCB7IElTZXJ2aWNlUHJvdmlkZXJGYWN0b3J5IH0gZnJvbSAnYW5ndWxhcic7XG5pbXBvcnQgSUFuY2hvclNjcm9sbFNlcnZpY2UgPSBhbmd1bGFyLklBbmNob3JTY3JvbGxTZXJ2aWNlO1xuaW1wb3J0IElUaW1lb3V0U2VydmljZSA9IGFuZ3VsYXIuSVRpbWVvdXRTZXJ2aWNlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVJVmlld1Njcm9sbFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIFVzZXMgc3RhbmRhcmQgYW5jaG9yU2Nyb2xsIGJlaGF2aW9yXG4gICAqXG4gICAqIFJldmVydHMgW1skdWlWaWV3U2Nyb2xsXV0gYmFjayB0byB1c2luZyB0aGUgY29yZSBbYCRhbmNob3JTY3JvbGxgXShodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy4kYW5jaG9yU2Nyb2xsKVxuICAgKiBzZXJ2aWNlIGZvciBzY3JvbGxpbmcgYmFzZWQgb24gdGhlIHVybCBhbmNob3IuXG4gICAqL1xuICB1c2VBbmNob3JTY3JvbGwoKTogdm9pZDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uICRWaWV3U2Nyb2xsUHJvdmlkZXIoKSB7XG4gIGxldCB1c2VBbmNob3JTY3JvbGwgPSBmYWxzZTtcblxuICB0aGlzLnVzZUFuY2hvclNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHVzZUFuY2hvclNjcm9sbCA9IHRydWU7XG4gIH07XG5cbiAgdGhpcy4kZ2V0ID0gW1xuICAgICckYW5jaG9yU2Nyb2xsJyxcbiAgICAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uKCRhbmNob3JTY3JvbGw6IElBbmNob3JTY3JvbGxTZXJ2aWNlLCAkdGltZW91dDogSVRpbWVvdXRTZXJ2aWNlKTogRnVuY3Rpb24ge1xuICAgICAgaWYgKHVzZUFuY2hvclNjcm9sbCkge1xuICAgICAgICByZXR1cm4gJGFuY2hvclNjcm9sbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRlbGVtZW50OiBKUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuICR0aW1lb3V0KFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGVsZW1lbnRbMF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfSxcbiAgXTtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckdWlWaWV3U2Nyb2xsJywgPElTZXJ2aWNlUHJvdmlkZXJGYWN0b3J5PiRWaWV3U2Nyb2xsUHJvdmlkZXIpO1xuIiwiLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciBhbmd1bGFyIDEueCBidWlsZFxuICogQHB1YmxpY2FwaSBAbW9kdWxlIG5nMVxuICovIC8qKiAqL1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9zZXJ2aWNlcyc7XG5leHBvcnQgKiBmcm9tICcuL3N0YXRlYnVpbGRlcnMvdmlld3MnO1xuZXhwb3J0ICogZnJvbSAnLi9zdGF0ZVByb3ZpZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vdXJsUm91dGVyUHJvdmlkZXInO1xuXG5pbXBvcnQgJy4vaW5qZWN0YWJsZXMnO1xuaW1wb3J0ICcuL2RpcmVjdGl2ZXMvc3RhdGVEaXJlY3RpdmVzJztcbmltcG9ydCAnLi9zdGF0ZUZpbHRlcnMnO1xuaW1wb3J0ICcuL2RpcmVjdGl2ZXMvdmlld0RpcmVjdGl2ZSc7XG5pbXBvcnQgJy4vdmlld1Njcm9sbCc7XG5cbmV4cG9ydCBkZWZhdWx0ICd1aS5yb3V0ZXInO1xuXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJ0B1aXJvdXRlci9jb3JlJztcbmV4cG9ydCB7IGNvcmUgfTtcbmV4cG9ydCAqIGZyb20gJ0B1aXJvdXRlci9jb3JlJztcbiJdfQ==
