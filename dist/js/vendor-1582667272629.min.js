/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});

/**
 * State-based routing for AngularJS 1.x
 * NOTICE: This monolithic bundle also bundles the @uirouter/core code.
 *         This causes it to be incompatible with plugins that depend on @uirouter/core.
 *         We recommend switching to the ui-router-core.js and ui-router-angularjs.js bundles instead.
 *         For more information, see https://ui-router.github.io/blog/uirouter-for-angularjs-umd-bundles
 * @version v1.0.25
 * @link https://ui-router.github.io
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular')) :
    typeof define === 'function' && define.amd ? define(['exports', 'angular'], factory) :
    (global = global || self, factory(global['@uirouter/angularjs'] = {}, global.angular));
}(this, (function (exports, ng_from_import) { 'use strict';

    /** @publicapi @module ng1 */ /** */
    /** @hidden */ var ng_from_global = angular;
    /** @hidden */ var ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global;

    /**
     * Higher order functions
     *
     * These utility functions are exported, but are subject to change without notice.
     *
     * @module common_hof
     */ /** */
    var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    /**
     * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
     *
     * Given a function with N parameters, returns a new function that supports partial application.
     * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
     * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
     * accept more parameters until all N parameters have been supplied.
     *
     *
     * This contrived example uses a partially applied function as an predicate, which returns true
     * if an object is found in both arrays.
     * @example
     * ```
     * // returns true if an object is in both of the two arrays
     * function inBoth(array1, array2, object) {
     *   return array1.indexOf(object) !== -1 &&
     *          array2.indexOf(object) !== 1;
     * }
     * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
     * let foos = [obj1, obj3]
     * let bars = [obj3, obj4, obj5]
     *
     * // A curried "copy" of inBoth
     * let curriedInBoth = curry(inBoth);
     * // Partially apply both the array1 and array2
     * let inFoosAndBars = curriedInBoth(foos, bars);
     *
     * // Supply the final argument; since all arguments are
     * // supplied, the original inBoth function is then called.
     * let obj1InBoth = inFoosAndBars(obj1); // false
     *
     * // Use the inFoosAndBars as a predicate.
     * // Filter, on each iteration, supplies the final argument
     * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
     * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
     *
     * ```
     *
     * @param fn
     * @returns {*|function(): (*|any)}
     */
    function curry(fn) {
        return function curried() {
            if (arguments.length >= fn.length) {
                return fn.apply(this, arguments);
            }
            var args = Array.prototype.slice.call(arguments);
            return curried.bind.apply(curried, __spreadArrays([this], args));
        };
    }
    /**
     * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
     * given: f(x), g(x), h(x)
     * let composed = compose(f,g,h)
     * then, composed is: f(g(h(x)))
     */
    function compose() {
        var args = arguments;
        var start = args.length - 1;
        return function () {
            var i = start, result = args[start].apply(this, arguments);
            while (i--)
                result = args[i].call(this, result);
            return result;
        };
    }
    /**
     * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
     * given: f(x), g(x), h(x)
     * let piped = pipe(f,g,h);
     * then, piped is: h(g(f(x)))
     */
    function pipe() {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        return compose.apply(null, [].slice.call(arguments).reverse());
    }
    /**
     * Given a property name, returns a function that returns that property from an object
     * let obj = { foo: 1, name: "blarg" };
     * let getName = prop("name");
     * getName(obj) === "blarg"
     */
    var prop = function (name) { return function (obj) { return obj && obj[name]; }; };
    /**
     * Given a property name and a value, returns a function that returns a boolean based on whether
     * the passed object has a property that matches the value
     * let obj = { foo: 1, name: "blarg" };
     * let getName = propEq("name", "blarg");
     * getName(obj) === true
     */
    var propEq = curry(function (name, _val, obj) { return obj && obj[name] === _val; });
    /**
     * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
     * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
     * let getName = prop("nestedObj.name");
     * getName(obj) === "blarg"
     * let propNotFound = prop("this.property.doesnt.exist");
     * propNotFound(obj) === undefined
     */
    var parse = function (name) { return pipe.apply(null, name.split('.').map(prop)); };
    /**
     * Given a function that returns a truthy or falsey value, returns a
     * function that returns the opposite (falsey or truthy) value given the same inputs
     */
    var not = function (fn) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return !fn.apply(null, args);
    }; };
    /**
     * Given two functions that return truthy or falsey values, returns a function that returns truthy
     * if both functions return truthy for the given arguments
     */
    function and(fn1, fn2) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fn1.apply(null, args) && fn2.apply(null, args);
        };
    }
    /**
     * Given two functions that return truthy or falsey values, returns a function that returns truthy
     * if at least one of the functions returns truthy for the given arguments
     */
    function or(fn1, fn2) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fn1.apply(null, args) || fn2.apply(null, args);
        };
    }
    /**
     * Check if all the elements of an array match a predicate function
     *
     * @param fn1 a predicate function `fn1`
     * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
     */
    var all = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); }; };
    // tslint:disable-next-line:variable-name
    var any = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); }; };
    /** Given a class, returns a Predicate function that returns true if the object is of that class */
    var is = function (ctor) { return function (obj) {
        return (obj != null && obj.constructor === ctor) || obj instanceof ctor;
    }; };
    /** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */
    var eq = function (value) { return function (other) { return value === other; }; };
    /** Given a value, returns a function which returns the value */
    var val = function (v) { return function () { return v; }; };
    function invoke(fnName, args) {
        return function (obj) { return obj[fnName].apply(obj, args); };
    }
    /**
     * Sorta like Pattern Matching (a functional programming conditional construct)
     *
     * See http://c2.com/cgi/wiki?PatternMatching
     *
     * This is a conditional construct which allows a series of predicates and output functions
     * to be checked and then applied.  Each predicate receives the input.  If the predicate
     * returns truthy, then its matching output function (mapping function) is provided with
     * the input and, then the result is returned.
     *
     * Each combination (2-tuple) of predicate + output function should be placed in an array
     * of size 2: [ predicate, mapFn ]
     *
     * These 2-tuples should be put in an outer array.
     *
     * @example
     * ```
     *
     * // Here's a 2-tuple where the first element is the isString predicate
     * // and the second element is a function that returns a description of the input
     * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
     *
     * // Second tuple: predicate "isNumber", mapfn returns a description
     * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
     *
     * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
     *
     * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
     *
     * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
     *
     * console.log(descriptionOf(undefined)); // 'notdefined'
     * console.log(descriptionOf(55)); // '(55) That's a number!'
     * console.log(descriptionOf("foo")); // 'Here's your string foo'
     * ```
     *
     * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
     * with a Predicate and a mapping/output function
     * @returns {function(any): *}
     */
    function pattern(struct) {
        return function (x) {
            for (var i = 0; i < struct.length; i++) {
                if (struct[i][0](x))
                    return struct[i][1](x);
            }
        };
    }

    /** Predicates
     *
     * These predicates return true/false based on the input.
     * Although these functions are exported, they are subject to change without notice.
     *
     * @module common_predicates
     */ /** */
    var toStr = Object.prototype.toString;
    var tis = function (t) { return function (x) { return typeof x === t; }; };
    var isUndefined = tis('undefined');
    var isDefined = not(isUndefined);
    var isNull = function (o) { return o === null; };
    var isNullOrUndefined = or(isNull, isUndefined);
    var isFunction = tis('function');
    var isNumber = tis('number');
    var isString = tis('string');
    var isObject = function (x) { return x !== null && typeof x === 'object'; };
    var isArray = Array.isArray;
    var isDate = (function (x) { return toStr.call(x) === '[object Date]'; });
    var isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });
    /**
     * Predicate which checks if a value is injectable
     *
     * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
     * where all the elements in the array are Strings, except the last one, which is a Function
     */
    function isInjectable(val) {
        if (isArray(val) && val.length) {
            var head = val.slice(0, -1), tail = val.slice(-1);
            return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);
        }
        return isFunction(val);
    }
    /**
     * Predicate which checks if a value looks like a Promise
     *
     * It is probably a Promise if it's an object, and it has a `then` property which is a Function
     */
    var isPromise = and(isObject, pipe(prop('then'), isFunction));

    var noImpl = function (fnname) { return function () {
        throw new Error("No implementation for " + fnname + ". The framework specific code did not implement this method.");
    }; };
    var makeStub = function (service, methods) {
        return methods.reduce(function (acc, key) { return ((acc[key] = noImpl(service + "." + key + "()")), acc); }, {});
    };
    var services = {
        $q: undefined,
        $injector: undefined,
    };

    var __spreadArrays$1 = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    var root = (typeof self === 'object' && self.self === self && self) ||
        (typeof global === 'object' && global.global === global && global) ||
        undefined;
    var angular$1 = root.angular || {};
    var fromJson = angular$1.fromJson || JSON.parse.bind(JSON);
    var toJson = angular$1.toJson || JSON.stringify.bind(JSON);
    var forEach = angular$1.forEach || _forEach;
    var extend = Object.assign || _extend;
    var equals = angular$1.equals || _equals;
    function identity(x) {
        return x;
    }
    function noop() { }
    /**
     * Builds proxy functions on the `to` object which pass through to the `from` object.
     *
     * For each key in `fnNames`, creates a proxy function on the `to` object.
     * The proxy function calls the real function on the `from` object.
     *
     *
     * #### Example:
     * This example creates an new class instance whose functions are prebound to the new'd object.
     * ```js
     * class Foo {
     *   constructor(data) {
     *     // Binds all functions from Foo.prototype to 'this',
     *     // then copies them to 'this'
     *     bindFunctions(Foo.prototype, this, this);
     *     this.data = data;
     *   }
     *
     *   log() {
     *     console.log(this.data);
     *   }
     * }
     *
     * let myFoo = new Foo([1,2,3]);
     * var logit = myFoo.log;
     * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
     * ```
     *
     * #### Example:
     * This example creates a bound version of a service function, and copies it to another object
     * ```
     *
     * var SomeService = {
     *   this.data = [3, 4, 5];
     *   this.log = function() {
     *     console.log(this.data);
     *   }
     * }
     *
     * // Constructor fn
     * function OtherThing() {
     *   // Binds all functions from SomeService to SomeService,
     *   // then copies them to 'this'
     *   bindFunctions(SomeService, this, SomeService);
     * }
     *
     * let myOtherThing = new OtherThing();
     * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
     * ```
     *
     * @param source A function that returns the source object which contains the original functions to be bound
     * @param target A function that returns the target object which will receive the bound functions
     * @param bind A function that returns the object which the functions will be bound to
     * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
     * @param latebind If true, the binding of the function is delayed until the first time it's invoked
     */
    function createProxyFunctions(source, target, bind, fnNames, latebind) {
        if (latebind === void 0) { latebind = false; }
        var bindFunction = function (fnName) { return source()[fnName].bind(bind()); };
        var makeLateRebindFn = function (fnName) {
            return function lateRebindFunction() {
                target[fnName] = bindFunction(fnName);
                return target[fnName].apply(null, arguments);
            };
        };
        fnNames = fnNames || Object.keys(source());
        return fnNames.reduce(function (acc, name) {
            acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
            return acc;
        }, target);
    }
    /**
     * prototypal inheritance helper.
     * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
     */
    var inherit = function (parent, extra) { return extend(Object.create(parent), extra); };
    /** Given an array, returns true if the object is found in the array, (using indexOf) */
    var inArray = curry(_inArray);
    function _inArray(array, obj) {
        return array.indexOf(obj) !== -1;
    }
    /**
     * Given an array, and an item, if the item is found in the array, it removes it (in-place).
     * The same array is returned
     */
    var removeFrom = curry(_removeFrom);
    function _removeFrom(array, obj) {
        var idx = array.indexOf(obj);
        if (idx >= 0)
            array.splice(idx, 1);
        return array;
    }
    /** pushes a values to an array and returns the value */
    var pushTo = curry(_pushTo);
    function _pushTo(arr, val) {
        return arr.push(val), val;
    }
    /** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */
    var deregAll = function (functions) {
        return functions.slice().forEach(function (fn) {
            typeof fn === 'function' && fn();
            removeFrom(functions, fn);
        });
    };
    /**
     * Applies a set of defaults to an options object.  The options object is filtered
     * to only those properties of the objects in the defaultsList.
     * Earlier objects in the defaultsList take precedence when applying defaults.
     */
    function defaults(opts) {
        var defaultsList = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            defaultsList[_i - 1] = arguments[_i];
        }
        var defaultVals = extend.apply(void 0, __spreadArrays$1([{}], defaultsList.reverse()));
        return extend(defaultVals, pick(opts || {}, Object.keys(defaultVals)));
    }
    /** Reduce function that merges each element of the list into a single object, using extend */
    var mergeR = function (memo, item) { return extend(memo, item); };
    /**
     * Finds the common ancestor path between two states.
     *
     * @param {Object} first The first state.
     * @param {Object} second The second state.
     * @return {Array} Returns an array of state names in descending order, not including the root.
     */
    function ancestors(first, second) {
        var path = [];
        // tslint:disable-next-line:forin
        for (var n in first.path) {
            if (first.path[n] !== second.path[n])
                break;
            path.push(first.path[n]);
        }
        return path;
    }
    /**
     * Return a copy of the object only containing the whitelisted properties.
     *
     * #### Example:
     * ```
     * var foo = { a: 1, b: 2, c: 3 };
     * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
     * ```
     * @param obj the source object
     * @param propNames an Array of strings, which are the whitelisted property names
     */
    function pick(obj, propNames) {
        var objCopy = {};
        for (var _prop in obj) {
            if (propNames.indexOf(_prop) !== -1) {
                objCopy[_prop] = obj[_prop];
            }
        }
        return objCopy;
    }
    /**
     * Return a copy of the object omitting the blacklisted properties.
     *
     * @example
     * ```
     *
     * var foo = { a: 1, b: 2, c: 3 };
     * var ab = omit(foo, ['a', 'b']); // { c: 3 }
     * ```
     * @param obj the source object
     * @param propNames an Array of strings, which are the blacklisted property names
     */
    function omit(obj, propNames) {
        return Object.keys(obj)
            .filter(not(inArray(propNames)))
            .reduce(function (acc, key) { return ((acc[key] = obj[key]), acc); }, {});
    }
    /**
     * Maps an array, or object to a property (by name)
     */
    function pluck(collection, propName) {
        return map(collection, prop(propName));
    }
    /** Filters an Array or an Object's properties based on a predicate */
    function filter(collection, callback) {
        var arr = isArray(collection), result = arr ? [] : {};
        var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return (result[key] = x); };
        forEach(collection, function (item, i) {
            if (callback(item, i))
                accept(item, i);
        });
        return result;
    }
    /** Finds an object from an array, or a property of an object, that matches a predicate */
    function find(collection, callback) {
        var result;
        forEach(collection, function (item, i) {
            if (result)
                return;
            if (callback(item, i))
                result = item;
        });
        return result;
    }
    /** Given an object, returns a new object, where each property is transformed by the callback function */
    var mapObj = map;
    /** Maps an array or object properties using a callback function */
    function map(collection, callback, target) {
        target = target || (isArray(collection) ? [] : {});
        forEach(collection, function (item, i) { return (target[i] = callback(item, i)); });
        return target;
    }
    /**
     * Given an object, return its enumerable property values
     *
     * @example
     * ```
     *
     * let foo = { a: 1, b: 2, c: 3 }
     * let vals = values(foo); // [ 1, 2, 3 ]
     * ```
     */
    var values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };
    /**
     * Reduce function that returns true if all of the values are truthy.
     *
     * @example
     * ```
     *
     * let vals = [ 1, true, {}, "hello world"];
     * vals.reduce(allTrueR, true); // true
     *
     * vals.push(0);
     * vals.reduce(allTrueR, true); // false
     * ```
     */
    var allTrueR = function (memo, elem) { return memo && elem; };
    /**
     * Reduce function that returns true if any of the values are truthy.
     *
     *  * @example
     * ```
     *
     * let vals = [ 0, null, undefined ];
     * vals.reduce(anyTrueR, true); // false
     *
     * vals.push("hello world");
     * vals.reduce(anyTrueR, true); // true
     * ```
     */
    var anyTrueR = function (memo, elem) { return memo || elem; };
    /**
     * Reduce function which un-nests a single level of arrays
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
     * ```
     */
    var unnestR = function (memo, elem) { return memo.concat(elem); };
    /**
     * Reduce function which recursively un-nests all arrays
     *
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
     * ```
     */
    var flattenR = function (memo, elem) {
        return isArray(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem);
    };
    /**
     * Reduce function that pushes an object to an array, then returns the array.
     * Mostly just for [[flattenR]] and [[uniqR]]
     */
    function pushR(arr, obj) {
        arr.push(obj);
        return arr;
    }
    /** Reduce function that filters out duplicates */
    var uniqR = function (acc, token) { return (inArray(acc, token) ? acc : pushR(acc, token)); };
    /**
     * Return a new array with a single level of arrays unnested.
     *
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
     * ```
     */
    var unnest = function (arr) { return arr.reduce(unnestR, []); };
    /**
     * Return a completely flattened version of an array.
     *
     * @example
     * ```
     *
     * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
     * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]
     * ```
     */
    var flatten = function (arr) { return arr.reduce(flattenR, []); };
    /**
     * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
     * @example
     * ```
     *
     * let isNumber = (obj) => typeof(obj) === 'number';
     * let allNumbers = [ 1, 2, 3, 4, 5 ];
     * allNumbers.filter(assertPredicate(isNumber)); //OK
     *
     * let oneString = [ 1, 2, 3, 4, "5" ];
     * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
     * ```
     */
    var assertPredicate = assertFn;
    /**
     * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.
     * @example
     * ```
     *
     * var data = { foo: 1, bar: 2 };
     *
     * let keys = [ 'foo', 'bar' ]
     * let values = keys.map(assertMap(key => data[key], "Key not found"));
     * // values is [1, 2]
     *
     * let keys = [ 'foo', 'bar', 'baz' ]
     * let values = keys.map(assertMap(key => data[key], "Key not found"));
     * // throws Error("Key not found")
     * ```
     */
    var assertMap = assertFn;
    function assertFn(predicateOrMap, errMsg) {
        if (errMsg === void 0) { errMsg = 'assert failure'; }
        return function (obj) {
            var result = predicateOrMap(obj);
            if (!result) {
                throw new Error(isFunction(errMsg) ? errMsg(obj) : errMsg);
            }
            return result;
        };
    }
    /**
     * Like _.pairs: Given an object, returns an array of key/value pairs
     *
     * @example
     * ```
     *
     * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]
     * ```
     */
    var pairs = function (obj) { return Object.keys(obj).map(function (key) { return [key, obj[key]]; }); };
    /**
     * Given two or more parallel arrays, returns an array of tuples where
     * each tuple is composed of [ a[i], b[i], ... z[i] ]
     *
     * @example
     * ```
     *
     * let foo = [ 0, 2, 4, 6 ];
     * let bar = [ 1, 3, 5, 7 ];
     * let baz = [ 10, 30, 50, 70 ];
     * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
     * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
     * ```
     */
    function arrayTuples() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0)
            return [];
        var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER
        var result = [];
        var _loop_1 = function (i) {
            // This is a hot function
            // Unroll when there are 1-4 arguments
            switch (args.length) {
                case 1:
                    result.push([args[0][i]]);
                    break;
                case 2:
                    result.push([args[0][i], args[1][i]]);
                    break;
                case 3:
                    result.push([args[0][i], args[1][i], args[2][i]]);
                    break;
                case 4:
                    result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                    break;
                default:
                    result.push(args.map(function (array) { return array[i]; }));
                    break;
            }
        };
        for (var i = 0; i < maxArrayLen; i++) {
            _loop_1(i);
        }
        return result;
    }
    /**
     * Reduce function which builds an object from an array of [key, value] pairs.
     *
     * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
     *
     * Each keyValueTuple should be an array with values [ key: string, value: any ]
     *
     * @example
     * ```
     *
     * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
     *
     * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
     * // pairsToObj == { fookey: "fooval", barkey: "barval" }
     *
     * // Or, more simply:
     * var pairsToObj = pairs.reduce(applyPairs, {})
     * // pairsToObj == { fookey: "fooval", barkey: "barval" }
     * ```
     */
    function applyPairs(memo, keyValTuple) {
        var key, value;
        if (isArray(keyValTuple))
            key = keyValTuple[0], value = keyValTuple[1];
        if (!isString(key))
            throw new Error('invalid parameters to applyPairs');
        memo[key] = value;
        return memo;
    }
    /** Get the last element of an array */
    function tail(arr) {
        return (arr.length && arr[arr.length - 1]) || undefined;
    }
    /**
     * shallow copy from src to dest
     */
    function copy(src, dest) {
        if (dest)
            Object.keys(dest).forEach(function (key) { return delete dest[key]; });
        if (!dest)
            dest = {};
        return extend(dest, src);
    }
    /** Naive forEach implementation works with Objects or Arrays */
    function _forEach(obj, cb, _this) {
        if (isArray(obj))
            return obj.forEach(cb, _this);
        Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });
    }
    function _extend(toObj) {
        for (var i = 1; i < arguments.length; i++) {
            var obj = arguments[i];
            if (!obj)
                continue;
            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; j++) {
                toObj[keys[j]] = obj[keys[j]];
            }
        }
        return toObj;
    }
    function _equals(o1, o2) {
        if (o1 === o2)
            return true;
        if (o1 === null || o2 === null)
            return false;
        if (o1 !== o1 && o2 !== o2)
            return true; // NaN === NaN
        var t1 = typeof o1, t2 = typeof o2;
        if (t1 !== t2 || t1 !== 'object')
            return false;
        var tup = [o1, o2];
        if (all(isArray)(tup))
            return _arraysEq(o1, o2);
        if (all(isDate)(tup))
            return o1.getTime() === o2.getTime();
        if (all(isRegExp)(tup))
            return o1.toString() === o2.toString();
        if (all(isFunction)(tup))
            return true; // meh
        var predicates = [isFunction, isArray, isDate, isRegExp];
        if (predicates.map(any).reduce(function (b, fn) { return b || !!fn(tup); }, false))
            return false;
        var keys = {};
        // tslint:disable-next-line:forin
        for (var key in o1) {
            if (!_equals(o1[key], o2[key]))
                return false;
            keys[key] = true;
        }
        for (var key in o2) {
            if (!keys[key])
                return false;
        }
        return true;
    }
    function _arraysEq(a1, a2) {
        if (a1.length !== a2.length)
            return false;
        return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);
    }
    // issue #2676
    var silenceUncaughtInPromise = function (promise) { return promise.catch(function (e) { return 0; }) && promise; };
    var silentRejection = function (error) { return silenceUncaughtInPromise(services.$q.reject(error)); };

    /** @publicapi @module core */
    /**
     * Matches state names using glob-like pattern strings.
     *
     * Globs can be used in specific APIs including:
     *
     * - [[StateService.is]]
     * - [[StateService.includes]]
     * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
     *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
     *
     * A `Glob` string is a pattern which matches state names.
     * Nested state names are split into segments (separated by a dot) when processing.
     * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
     *
     * Globs work according to the following rules:
     *
     * ### Exact match:
     *
     * The glob `'A.B'` matches the state named exactly `'A.B'`.
     *
     * | Glob        |Matches states named|Does not match state named|
     * |:------------|:--------------------|:---------------------|
     * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
     * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
     * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
     *
     * ### Single star (`*`)
     *
     * A single star (`*`) is a wildcard that matches exactly one segment.
     *
     * | Glob        |Matches states named  |Does not match state named |
     * |:------------|:---------------------|:--------------------------|
     * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
     * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
     * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
     *
     * ### Double star (`**`)
     *
     * A double star (`'**'`) is a wildcard that matches *zero or more segments*
     *
     * | Glob        |Matches states named                           |Does not match state named         |
     * |:------------|:----------------------------------------------|:----------------------------------|
     * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
     * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
     * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
     * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
     *
     */
    var Glob = /** @class */ (function () {
        function Glob(text) {
            this.text = text;
            this.glob = text.split('.');
            var regexpString = this.text
                .split('.')
                .map(function (seg) {
                if (seg === '**')
                    return '(?:|(?:\\.[^.]*)*)';
                if (seg === '*')
                    return '\\.[^.]*';
                return '\\.' + seg;
            })
                .join('');
            this.regexp = new RegExp('^' + regexpString + '$');
        }
        /** Returns true if the string has glob-like characters in it */
        Glob.is = function (text) {
            return !!/[!,*]+/.exec(text);
        };
        /** Returns a glob from the string, or null if the string isn't Glob-like */
        Glob.fromString = function (text) {
            return Glob.is(text) ? new Glob(text) : null;
        };
        Glob.prototype.matches = function (name) {
            return this.regexp.test('.' + name);
        };
        return Glob;
    }());

    /** @publicapi @module common */ /** */
    var Queue = /** @class */ (function () {
        function Queue(_items, _limit) {
            if (_items === void 0) { _items = []; }
            if (_limit === void 0) { _limit = null; }
            this._items = _items;
            this._limit = _limit;
            this._evictListeners = [];
            this.onEvict = pushTo(this._evictListeners);
        }
        Queue.prototype.enqueue = function (item) {
            var items = this._items;
            items.push(item);
            if (this._limit && items.length > this._limit)
                this.evict();
            return item;
        };
        Queue.prototype.evict = function () {
            var item = this._items.shift();
            this._evictListeners.forEach(function (fn) { return fn(item); });
            return item;
        };
        Queue.prototype.dequeue = function () {
            if (this.size())
                return this._items.splice(0, 1)[0];
        };
        Queue.prototype.clear = function () {
            var current = this._items;
            this._items = [];
            return current;
        };
        Queue.prototype.size = function () {
            return this._items.length;
        };
        Queue.prototype.remove = function (item) {
            var idx = this._items.indexOf(item);
            return idx > -1 && this._items.splice(idx, 1)[0];
        };
        Queue.prototype.peekTail = function () {
            return this._items[this._items.length - 1];
        };
        Queue.prototype.peekHead = function () {
            if (this.size())
                return this._items[0];
        };
        return Queue;
    }());

    /** @publicapi @module transition */ /** */

    (function (RejectType) {
        /**
         * A new transition superseded this one.
         *
         * While this transition was running, a new transition started.
         * This transition is cancelled because it was superseded by new transition.
         */
        RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
        /**
         * The transition was aborted
         *
         * The transition was aborted by a hook which returned `false`
         */
        RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
        /**
         * The transition was invalid
         *
         * The transition was never started because it was invalid
         */
        RejectType[RejectType["INVALID"] = 4] = "INVALID";
        /**
         * The transition was ignored
         *
         * The transition was ignored because it would have no effect.
         *
         * Either:
         *
         * - The transition is targeting the current state and parameter values
         * - The transition is targeting the same state and parameter values as the currently running transition.
         */
        RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
        /**
         * The transition errored.
         *
         * This generally means a hook threw an error or returned a rejected promise
         */
        RejectType[RejectType["ERROR"] = 6] = "ERROR";
    })(exports.RejectType || (exports.RejectType = {}));
    /** @hidden */
    var id = 0;
    var Rejection = /** @class */ (function () {
        function Rejection(type, message, detail) {
            /** @hidden */
            this.$id = id++;
            this.type = type;
            this.message = message;
            this.detail = detail;
        }
        /** Returns true if the obj is a rejected promise created from the `asPromise` factory */
        Rejection.isRejectionPromise = function (obj) {
            return obj && typeof obj.then === 'function' && is(Rejection)(obj._transitionRejection);
        };
        /** Returns a Rejection due to transition superseded */
        Rejection.superseded = function (detail, options) {
            var message = 'The transition has been superseded by a different transition';
            var rejection = new Rejection(exports.RejectType.SUPERSEDED, message, detail);
            if (options && options.redirected) {
                rejection.redirected = true;
            }
            return rejection;
        };
        /** Returns a Rejection due to redirected transition */
        Rejection.redirected = function (detail) {
            return Rejection.superseded(detail, { redirected: true });
        };
        /** Returns a Rejection due to invalid transition */
        Rejection.invalid = function (detail) {
            var message = 'This transition is invalid';
            return new Rejection(exports.RejectType.INVALID, message, detail);
        };
        /** Returns a Rejection due to ignored transition */
        Rejection.ignored = function (detail) {
            var message = 'The transition was ignored';
            return new Rejection(exports.RejectType.IGNORED, message, detail);
        };
        /** Returns a Rejection due to aborted transition */
        Rejection.aborted = function (detail) {
            var message = 'The transition has been aborted';
            return new Rejection(exports.RejectType.ABORTED, message, detail);
        };
        /** Returns a Rejection due to aborted transition */
        Rejection.errored = function (detail) {
            var message = 'The transition errored';
            return new Rejection(exports.RejectType.ERROR, message, detail);
        };
        /**
         * Returns a Rejection
         *
         * Normalizes a value as a Rejection.
         * If the value is already a Rejection, returns it.
         * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
         *
         * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
         */
        Rejection.normalize = function (detail) {
            return is(Rejection)(detail) ? detail : Rejection.errored(detail);
        };
        Rejection.prototype.toString = function () {
            var detailString = function (d) { return (d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d)); };
            var detail = detailString(this.detail);
            var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
            return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
        };
        Rejection.prototype.toPromise = function () {
            return extend(silentRejection(this), { _transitionRejection: this });
        };
        return Rejection;
    }());

    /**
     * Functions that manipulate strings
     *
     * Although these functions are exported, they are subject to change without notice.
     *
     * @module common_strings
     */ /** */
    /**
     * Returns a string shortened to a maximum length
     *
     * If the string is already less than the `max` length, return the string.
     * Else return the string, shortened to `max - 3` and append three dots ("...").
     *
     * @param max the maximum length of the string to return
     * @param str the input string
     */
    function maxLength(max, str) {
        if (str.length <= max)
            return str;
        return str.substr(0, max - 3) + '...';
    }
    /**
     * Returns a string, with spaces added to the end, up to a desired str length
     *
     * If the string is already longer than the desired length, return the string.
     * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
     *
     * @param length the desired length of the string to return
     * @param str the input string
     */
    function padString(length, str) {
        while (str.length < length)
            str += ' ';
        return str;
    }
    function kebobString(camelCase) {
        return camelCase
            .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char
            .replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); }); // replace rest
    }
    function functionToString(fn) {
        var fnStr = fnToString(fn);
        var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
        var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
        var fnName = fn['name'] || '';
        if (fnName && toStr.match(/function \(/)) {
            return 'function ' + fnName + toStr.substr(9);
        }
        return toStr;
    }
    function fnToString(fn) {
        var _fn = isArray(fn) ? fn.slice(-1)[0] : fn;
        return (_fn && _fn.toString()) || 'undefined';
    }
    var isRejection = Rejection.isRejectionPromise;
    var hasToString = function (obj) {
        return isObject(obj) && !isArray(obj) && obj.constructor !== Object && isFunction(obj.toString);
    };
    var stringifyPattern = pattern([
        [isUndefined, val('undefined')],
        [isNull, val('null')],
        [isPromise, val('[Promise]')],
        [isRejection, function (x) { return x._transitionRejection.toString(); }],
        [hasToString, function (x) { return x.toString(); }],
        [isInjectable, functionToString],
        [val(true), identity],
    ]);
    function stringify(o) {
        var seen = [];
        function format(value) {
            if (isObject(value)) {
                if (seen.indexOf(value) !== -1)
                    return '[circular ref]';
                seen.push(value);
            }
            return stringifyPattern(value);
        }
        if (isUndefined(o)) {
            // Workaround for IE & Edge Spec incompatibility where replacer function would not be called when JSON.stringify
            // is given `undefined` as value. To work around that, we simply detect `undefined` and bail out early by
            // manually stringifying it.
            return format(o);
        }
        return JSON.stringify(o, function (key, value) { return format(value); }).replace(/\\"/g, '"');
    }
    /** Returns a function that splits a string on a character or substring */
    var beforeAfterSubstr = function (char) { return function (str) {
        if (!str)
            return ['', ''];
        var idx = str.indexOf(char);
        if (idx === -1)
            return [str, ''];
        return [str.substr(0, idx), str.substr(idx + 1)];
    }; };
    var hostRegex = new RegExp('^(?:[a-z]+:)?//[^/]+/');
    var stripLastPathElement = function (str) { return str.replace(/\/[^/]*$/, ''); };
    var splitHash = beforeAfterSubstr('#');
    var splitQuery = beforeAfterSubstr('?');
    var splitEqual = beforeAfterSubstr('=');
    var trimHashVal = function (str) { return (str ? str.replace(/^#/, '') : ''); };
    /**
     * Splits on a delimiter, but returns the delimiters in the array
     *
     * #### Example:
     * ```js
     * var splitOnSlashes = splitOnDelim('/');
     * splitOnSlashes("/foo"); // ["/", "foo"]
     * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
     * ```
     */
    function splitOnDelim(delim) {
        var re = new RegExp('(' + delim + ')', 'g');
        return function (str) { return str.split(re).filter(identity); };
    }
    /**
     * Reduce fn that joins neighboring strings
     *
     * Given an array of strings, returns a new array
     * where all neighboring strings have been joined.
     *
     * #### Example:
     * ```js
     * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
     * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
     * ```
     */
    function joinNeighborsR(acc, x) {
        if (isString(tail(acc)) && isString(x))
            return acc.slice(0, -1).concat(tail(acc) + x);
        return pushR(acc, x);
    }

    /** workaround for missing console object in IE9 when dev tools haven't been opened o_O */
    var noopConsoleStub = { log: noop, error: noop, table: noop };
    function ie9Console(console) {
        var bound = function (fn) { return Function.prototype.bind.call(fn, console); };
        return {
            log: bound(console.log),
            error: bound(console.log),
            table: bound(console.log),
        };
    }
    function fallbackConsole(console) {
        var log = console.log.bind(console);
        var error = console.error ? console.error.bind(console) : log;
        var table = console.table ? console.table.bind(console) : log;
        return { log: log, error: error, table: table };
    }
    function getSafeConsole() {
        // @ts-ignore
        var isIE9 = typeof document !== 'undefined' && document.documentMode && document.documentMode === 9;
        if (isIE9) {
            return window && window.console ? ie9Console(window.console) : noopConsoleStub;
        }
        else if (!console.table || !console.error) {
            return fallbackConsole(console);
        }
        else {
            return console;
        }
    }
    var safeConsole = getSafeConsole();

    /**
     * # Transition tracing (debug)
     *
     * Enable transition tracing to print transition information to the console,
     * in order to help debug your application.
     * Tracing logs detailed information about each Transition to your console.
     *
     * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
     *
     * ### ES6
     * ```js
     * import {trace} from "@uirouter/core";
     * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
     * ```
     *
     * ### CJS
     * ```js
     * let trace = require("@uirouter/core").trace;
     * trace.enable("TRANSITION", "VIEWCONFIG");
     * ```
     *
     * ### Globals
     * ```js
     * let trace = window["@uirouter/core"].trace;
     * trace.enable(); // Trace everything (very verbose)
     * ```
     *
     * ### Angular 1:
     * ```js
     * app.run($trace => $trace.enable());
     * ```
     *
     * @publicapi @module trace
     */
    /** @hidden */
    function uiViewString(uiview) {
        if (!uiview)
            return 'ui-view (defunct)';
        var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';
        return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";
    }
    /** @hidden */
    var viewConfigString = function (viewConfig) {
        var view = viewConfig.viewDecl;
        var state = view.$context.name || '(root)';
        return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'";
    };
    /** @hidden */
    function normalizedCat(input) {
        return isNumber(input) ? exports.Category[input] : exports.Category[exports.Category[input]];
    }
    /**
     * Trace categories Enum
     *
     * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
     *
     * `trace.enable(Category.TRANSITION)`
     *
     * These can also be provided using a matching string, or position ordinal
     *
     * `trace.enable("TRANSITION")`
     *
     * `trace.enable(1)`
     */

    (function (Category) {
        Category[Category["RESOLVE"] = 0] = "RESOLVE";
        Category[Category["TRANSITION"] = 1] = "TRANSITION";
        Category[Category["HOOK"] = 2] = "HOOK";
        Category[Category["UIVIEW"] = 3] = "UIVIEW";
        Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
    })(exports.Category || (exports.Category = {}));
    /** @hidden */
    var _tid = parse('$id');
    /** @hidden */
    var _rid = parse('router.$id');
    /** @hidden */
    var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };
    /**
     * Prints UI-Router Transition trace information to the console.
     */
    var Trace = /** @class */ (function () {
        /** @hidden */
        function Trace() {
            /** @hidden */
            this._enabled = {};
            this.approximateDigests = 0;
        }
        /** @hidden */
        Trace.prototype._set = function (enabled, categories) {
            var _this = this;
            if (!categories.length) {
                categories = Object.keys(exports.Category)
                    .map(function (k) { return parseInt(k, 10); })
                    .filter(function (k) { return !isNaN(k); })
                    .map(function (key) { return exports.Category[key]; });
            }
            categories.map(normalizedCat).forEach(function (category) { return (_this._enabled[category] = enabled); });
        };
        Trace.prototype.enable = function () {
            var categories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i] = arguments[_i];
            }
            this._set(true, categories);
        };
        Trace.prototype.disable = function () {
            var categories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                categories[_i] = arguments[_i];
            }
            this._set(false, categories);
        };
        /**
         * Retrieves the enabled stateus of a [[Category]]
         *
         * ```js
         * trace.enabled("VIEWCONFIG"); // true or false
         * ```
         *
         * @returns boolean true if the category is enabled
         */
        Trace.prototype.enabled = function (category) {
            return !!this._enabled[normalizedCat(category)];
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceTransitionStart = function (trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": Started  -> " + stringify(trans));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceTransitionIgnored = function (trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": Ignored  <> " + stringify(trans));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceHookInvocation = function (step, trans, options) {
            if (!this.enabled(exports.Category.HOOK))
                return;
            var event = parse('traceData.hookType')(options) || 'internal', context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown', name = functionToString(step.registeredHook.callback);
            safeConsole.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + maxLength(200, name));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {
            if (!this.enabled(exports.Category.HOOK))
                return;
            safeConsole.log(transLbl(trans) + ":   <- Hook returned: " + maxLength(200, stringify(hookResult)));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceResolvePath = function (path, when, trans) {
            if (!this.enabled(exports.Category.RESOLVE))
                return;
            safeConsole.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceResolvableResolved = function (resolvable, trans) {
            if (!this.enabled(exports.Category.RESOLVE))
                return;
            safeConsole.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + maxLength(200, stringify(resolvable.data)));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceError = function (reason, trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": <- Rejected " + stringify(trans) + ", reason: " + reason);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceSuccess = function (finalState, trans) {
            if (!this.enabled(exports.Category.TRANSITION))
                return;
            safeConsole.log(transLbl(trans) + ": <- Success  " + stringify(trans) + ", final state: " + finalState.name);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {
            if (extra === void 0) { extra = ''; }
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            safeConsole.log("ui-view: " + padString(30, event) + " " + uiViewString(viewData) + extra);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            this.traceUIViewEvent('Updating', viewData, " with ViewConfig from context='" + context + "'");
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceUIViewFill = function (viewData, html) {
            if (!this.enabled(exports.Category.UIVIEW))
                return;
            this.traceUIViewEvent('Fill', viewData, " with: " + maxLength(200, html));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceViewSync = function (pairs) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            var uivheader = 'uiview component fqn';
            var cfgheader = 'view config state (view name)';
            var mapping = pairs
                .map(function (_a) {
                var _b;
                var uiView = _a.uiView, viewConfig = _a.viewConfig;
                var uiv = uiView && uiView.fqn;
                var cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";
                return _b = {}, _b[uivheader] = uiv, _b[cfgheader] = cfg, _b;
            })
                .sort(function (a, b) { return (a[uivheader] || '').localeCompare(b[uivheader] || ''); });
            safeConsole.table(mapping);
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            safeConsole.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
        };
        /** @internalapi called by ui-router code */
        Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {
            if (!this.enabled(exports.Category.VIEWCONFIG))
                return;
            safeConsole.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
        };
        return Trace;
    }());
    /**
     * The [[Trace]] singleton
     *
     * #### Example:
     * ```js
     * import {trace} from "@uirouter/core";
     * trace.enable(1, 5);
     * ```
     */
    var trace = new Trace();

    /** @publicapi @module params */ /** */
    /**
     * An internal class which implements [[ParamTypeDefinition]].
     *
     * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
     * When a param type definition is registered, an instance of this class is created internally.
     *
     * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
     *
     * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
     *
     * #### Example:
     * ```js
     * var paramTypeDef = {
     *   decode: function(val) { return parseInt(val, 10); },
     *   encode: function(val) { return val && val.toString(); },
     *   equals: function(a, b) { return this.is(a) && a === b; },
     *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
     *   pattern: /\d+/
     * }
     *
     * var paramType = new ParamType(paramTypeDef);
     * ```
     * @internalapi
     */
    var ParamType = /** @class */ (function () {
        /**
         * @param def  A configuration object which contains the custom type definition.  The object's
         *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
         * @returns a new ParamType object
         */
        function ParamType(def) {
            /** @inheritdoc */
            this.pattern = /.*/;
            /** @inheritdoc */
            this.inherit = true;
            extend(this, def);
        }
        // consider these four methods to be "abstract methods" that should be overridden
        /** @inheritdoc */
        ParamType.prototype.is = function (val, key) {
            return true;
        };
        /** @inheritdoc */
        ParamType.prototype.encode = function (val, key) {
            return val;
        };
        /** @inheritdoc */
        ParamType.prototype.decode = function (val, key) {
            return val;
        };
        /** @inheritdoc */
        ParamType.prototype.equals = function (a, b) {
            // tslint:disable-next-line:triple-equals
            return a == b;
        };
        ParamType.prototype.$subPattern = function () {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2);
        };
        ParamType.prototype.toString = function () {
            return "{ParamType:" + this.name + "}";
        };
        /** Given an encoded string, or a decoded object, returns a decoded object */
        ParamType.prototype.$normalize = function (val) {
            return this.is(val) ? val : this.decode(val);
        };
        /**
         * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
         * e.g.:
         * - urlmatcher pattern "/path?{queryParam[]:int}"
         * - url: "/path?queryParam=1&queryParam=2
         * - $stateParams.queryParam will be [1, 2]
         * if `mode` is "auto", then
         * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
         * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
         */
        ParamType.prototype.$asArray = function (mode, isSearch) {
            if (!mode)
                return this;
            if (mode === 'auto' && !isSearch)
                throw new Error("'auto' array mode is for query parameters only");
            return new ArrayType(this, mode);
        };
        return ParamType;
    }());
    /**
     * Wraps up a `ParamType` object to handle array values.
     * @internalapi
     */
    function ArrayType(type, mode) {
        var _this = this;
        // Wrap non-array value as array
        function arrayWrap(val) {
            return isArray(val) ? val : isDefined(val) ? [val] : [];
        }
        // Unwrap array value for "auto" mode. Return undefined for empty array.
        function arrayUnwrap(val) {
            switch (val.length) {
                case 0:
                    return undefined;
                case 1:
                    return mode === 'auto' ? val[0] : val;
                default:
                    return val;
            }
        }
        // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
        function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
                if (isArray(val) && val.length === 0)
                    return val;
                var arr = arrayWrap(val);
                var result = map(arr, callback);
                return allTruthyMode === true ? filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);
            };
        }
        // Wraps type (.equals) functions to operate on each value of an array
        function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
                var left = arrayWrap(val1), right = arrayWrap(val2);
                if (left.length !== right.length)
                    return false;
                for (var i = 0; i < left.length; i++) {
                    if (!callback(left[i], right[i]))
                        return false;
                }
                return true;
            };
        }
        ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {
            var paramTypeFn = type[name].bind(type);
            var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;
            _this[name] = wrapperFn(paramTypeFn);
        });
        extend(this, {
            dynamic: type.dynamic,
            name: type.name,
            pattern: type.pattern,
            inherit: type.inherit,
            raw: type.raw,
            is: arrayHandler(type.is.bind(type), true),
            $arrayMode: mode,
        });
    }

    /** @publicapi @module params */ /** */
    /** @hidden */
    var hasOwn = Object.prototype.hasOwnProperty;
    /** @hidden */
    var isShorthand = function (cfg) {
        return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;
    };
    /** @internalapi */

    (function (DefType) {
        DefType[DefType["PATH"] = 0] = "PATH";
        DefType[DefType["SEARCH"] = 1] = "SEARCH";
        DefType[DefType["CONFIG"] = 2] = "CONFIG";
    })(exports.DefType || (exports.DefType = {}));
    /** @internalapi */
    function getParamDeclaration(paramName, location, state) {
        var noReloadOnSearch = (state.reloadOnSearch === false && location === exports.DefType.SEARCH) || undefined;
        var dynamic = find([state.dynamic, noReloadOnSearch], isDefined);
        var defaultConfig = isDefined(dynamic) ? { dynamic: dynamic } : {};
        var paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);
        return extend(defaultConfig, paramConfig);
    }
    /** @hidden */
    function unwrapShorthand(cfg) {
        cfg = isShorthand(cfg) ? { value: cfg } : cfg;
        getStaticDefaultValue['__cacheable'] = true;
        function getStaticDefaultValue() {
            return cfg.value;
        }
        var $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;
        return extend(cfg, { $$fn: $$fn });
    }
    /** @hidden */
    function getType(cfg, urlType, location, id, paramTypes) {
        if (cfg.type && urlType && urlType.name !== 'string')
            throw new Error("Param '" + id + "' has two type configurations.");
        if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))
            return paramTypes.type(cfg.type);
        if (urlType)
            return urlType;
        if (!cfg.type) {
            var type = location === exports.DefType.CONFIG
                ? 'any'
                : location === exports.DefType.PATH
                    ? 'path'
                    : location === exports.DefType.SEARCH
                        ? 'query'
                        : 'string';
            return paramTypes.type(type);
        }
        return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
    }
    /**
     * @internalapi
     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
     */
    function getSquashPolicy(config, isOptional, defaultPolicy) {
        var squash = config.squash;
        if (!isOptional || squash === false)
            return false;
        if (!isDefined(squash) || squash == null)
            return defaultPolicy;
        if (squash === true || isString(squash))
            return squash;
        throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }
    /** @internalapi */
    function getReplace(config, arrayMode, isOptional, squash) {
        var defaultPolicy = [
            { from: '', to: isOptional || arrayMode ? undefined : '' },
            { from: null, to: isOptional || arrayMode ? undefined : '' },
        ];
        var replace = isArray(config.replace) ? config.replace : [];
        if (isString(squash))
            replace.push({ from: squash, to: undefined });
        var configuredKeys = map(replace, prop('from'));
        return filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);
    }
    /** @internalapi */
    var Param = /** @class */ (function () {
        function Param(id, type, location, urlConfig, state) {
            var config = getParamDeclaration(id, location, state);
            type = getType(config, type, location, id, urlConfig.paramTypes);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === exports.DefType.SEARCH) : type;
            var isOptional = config.value !== undefined || location === exports.DefType.SEARCH;
            var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
            var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;
            var squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());
            var replace = getReplace(config, arrayMode, isOptional, squash);
            var inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
            // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
            function getArrayMode() {
                var arrayDefaults = { array: location === exports.DefType.SEARCH ? 'auto' : false };
                var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });
        }
        Param.values = function (params, values) {
            if (values === void 0) { values = {}; }
            var paramValues = {};
            for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                var param = params_1[_i];
                paramValues[param.id] = param.value(values[param.id]);
            }
            return paramValues;
        };
        /**
         * Finds [[Param]] objects which have different param values
         *
         * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
         *
         * @param params: The list of Param objects to filter
         * @param values1: The first set of parameter values
         * @param values2: the second set of parameter values
         *
         * @returns any Param objects whose values were different between values1 and values2
         */
        Param.changed = function (params, values1, values2) {
            if (values1 === void 0) { values1 = {}; }
            if (values2 === void 0) { values2 = {}; }
            return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });
        };
        /**
         * Checks if two param value objects are equal (for a set of [[Param]] objects)
         *
         * @param params The list of [[Param]] objects to check
         * @param values1 The first set of param values
         * @param values2 The second set of param values
         *
         * @returns true if the param values in values1 and values2 are equal
         */
        Param.equals = function (params, values1, values2) {
            if (values1 === void 0) { values1 = {}; }
            if (values2 === void 0) { values2 = {}; }
            return Param.changed(params, values1, values2).length === 0;
        };
        /** Returns true if a the parameter values are valid, according to the Param definitions */
        Param.validates = function (params, values) {
            if (values === void 0) { values = {}; }
            return params.map(function (param) { return param.validates(values[param.id]); }).reduce(allTrueR, true);
        };
        Param.prototype.isDefaultValue = function (value) {
            return this.isOptional && this.type.equals(this.value(), value);
        };
        /**
         * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
         * default value, which may be the result of an injectable function.
         */
        Param.prototype.value = function (value) {
            var _this = this;
            /**
             * [Internal] Get the default value of a parameter, which may be an injectable function.
             */
            var getDefaultValue = function () {
                if (_this._defaultValueCache)
                    return _this._defaultValueCache.defaultValue;
                if (!services.$injector)
                    throw new Error('Injectable functions cannot be called at configuration time');
                var defaultValue = services.$injector.invoke(_this.config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                    throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
                if (_this.config.$$fn['__cacheable']) {
                    _this._defaultValueCache = { defaultValue: defaultValue };
                }
                return defaultValue;
            };
            var replaceSpecialValues = function (val) {
                for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                    var tuple = _a[_i];
                    if (tuple.from === val)
                        return tuple.to;
                }
                return val;
            };
            value = replaceSpecialValues(value);
            return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
        };
        Param.prototype.isSearch = function () {
            return this.location === exports.DefType.SEARCH;
        };
        Param.prototype.validates = function (value) {
            // There was no parameter value, but the param is optional
            if ((isUndefined(value) || value === null) && this.isOptional)
                return true;
            // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
            var normalized = this.type.$normalize(value);
            if (!this.type.is(normalized))
                return false;
            // The value was of the correct type, but when encoded, did not match the ParamType's regexp
            var encoded = this.type.encode(normalized);
            return !(isString(encoded) && !this.type.pattern.exec(encoded));
        };
        Param.prototype.toString = function () {
            return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
        };
        return Param;
    }());

    /** @publicapi @module params */ /** */
    /**
     * A registry for parameter types.
     *
     * This registry manages the built-in (and custom) parameter types.
     *
     * The built-in parameter types are:
     *
     * - [[string]]
     * - [[path]]
     * - [[query]]
     * - [[hash]]
     * - [[int]]
     * - [[bool]]
     * - [[date]]
     * - [[json]]
     * - [[any]]
     *
     * To register custom parameter types, use [[UrlConfig.type]], i.e.,
     *
     * ```js
     * router.urlService.config.type(customType)
     * ```
     */
    var ParamTypes = /** @class */ (function () {
        /** @internalapi */
        function ParamTypes() {
            /** @hidden */
            this.enqueue = true;
            /** @hidden */
            this.typeQueue = [];
            /** @internalapi */
            this.defaultTypes = pick(ParamTypes.prototype, [
                'hash',
                'string',
                'query',
                'path',
                'int',
                'bool',
                'date',
                'json',
                'any',
            ]);
            // Register default types. Store them in the prototype of this.types.
            var makeType = function (definition, name) { return new ParamType(extend({ name: name }, definition)); };
            this.types = inherit(map(this.defaultTypes, makeType), {});
        }
        /** @internalapi */
        ParamTypes.prototype.dispose = function () {
            this.types = {};
        };
        /**
         * Registers a parameter type
         *
         * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
         */
        ParamTypes.prototype.type = function (name, definition, definitionFn) {
            if (!isDefined(definition))
                return this.types[name];
            if (this.types.hasOwnProperty(name))
                throw new Error("A type named '" + name + "' has already been defined.");
            this.types[name] = new ParamType(extend({ name: name }, definition));
            if (definitionFn) {
                this.typeQueue.push({ name: name, def: definitionFn });
                if (!this.enqueue)
                    this._flushTypeQueue();
            }
            return this;
        };
        /** @internalapi */
        ParamTypes.prototype._flushTypeQueue = function () {
            while (this.typeQueue.length) {
                var type = this.typeQueue.shift();
                if (type.pattern)
                    throw new Error("You cannot override a type's .pattern at runtime.");
                extend(this.types[type.name], services.$injector.invoke(type.def));
            }
        };
        return ParamTypes;
    }());
    /** @hidden */
    function initDefaultTypes() {
        var makeDefaultType = function (def) {
            var valToString = function (val) { return (val != null ? val.toString() : val); };
            var defaultTypeBase = {
                encode: valToString,
                decode: valToString,
                is: is(String),
                pattern: /.*/,
                // tslint:disable-next-line:triple-equals
                equals: function (a, b) { return a == b; },
            };
            return extend({}, defaultTypeBase, def);
        };
        // Default Parameter Type Definitions
        extend(ParamTypes.prototype, {
            string: makeDefaultType({}),
            path: makeDefaultType({
                pattern: /[^/]*/,
            }),
            query: makeDefaultType({}),
            hash: makeDefaultType({
                inherit: false,
            }),
            int: makeDefaultType({
                decode: function (val) { return parseInt(val, 10); },
                is: function (val) {
                    return !isNullOrUndefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /-?\d+/,
            }),
            bool: makeDefaultType({
                encode: function (val) { return (val && 1) || 0; },
                decode: function (val) { return parseInt(val, 10) !== 0; },
                is: is(Boolean),
                pattern: /0|1/,
            }),
            date: makeDefaultType({
                encode: function (val) {
                    return !this.is(val)
                        ? undefined
                        : [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join('-');
                },
                decode: function (val) {
                    if (this.is(val))
                        return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },
                equals: function (l, r) {
                    return ['getFullYear', 'getMonth', 'getDate'].reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
            }),
            json: makeDefaultType({
                encode: toJson,
                decode: fromJson,
                is: is(Object),
                equals: equals,
                pattern: /[^/]*/,
            }),
            // does not encode/decode
            any: makeDefaultType({
                encode: identity,
                decode: identity,
                is: function () { return true; },
                equals: equals,
            }),
        });
    }
    initDefaultTypes();

    /** @publicapi @module params */ /** */
    /** @internalapi */
    var StateParams = /** @class */ (function () {
        function StateParams(params) {
            if (params === void 0) { params = {}; }
            extend(this, params);
        }
        /**
         * Merges a set of parameters with all parameters inherited between the common parents of the
         * current state and a given destination state.
         *
         * @param {Object} newParams The set of parameters which will be composited with inherited params.
         * @param {Object} $current Internal definition of object representing the current state.
         * @param {Object} $to Internal definition of object representing state to transition to.
         */
        StateParams.prototype.$inherit = function (newParams, $current, $to) {
            var parentParams;
            var parents = ancestors($current, $to), inherited = {}, inheritList = [];
            for (var i in parents) {
                if (!parents[i] || !parents[i].params)
                    continue;
                parentParams = Object.keys(parents[i].params);
                if (!parentParams.length)
                    continue;
                for (var j in parentParams) {
                    if (inheritList.indexOf(parentParams[j]) >= 0)
                        continue;
                    inheritList.push(parentParams[j]);
                    inherited[parentParams[j]] = this[parentParams[j]];
                }
            }
            return extend({}, inherited, newParams);
        };
        return StateParams;
    }());

    /** @internalapi @module path */ /** */
    /**
     * A node in a [[TreeChanges]] path
     *
     * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
     * Each PathNode corresponds to a state being entered, exited, or retained.
     * The stateful information includes parameter values and resolve data.
     */
    var PathNode = /** @class */ (function () {
        function PathNode(stateOrNode) {
            if (stateOrNode instanceof PathNode) {
                var node = stateOrNode;
                this.state = node.state;
                this.paramSchema = node.paramSchema.slice();
                this.paramValues = extend({}, node.paramValues);
                this.resolvables = node.resolvables.slice();
                this.views = node.views && node.views.slice();
            }
            else {
                var state = stateOrNode;
                this.state = state;
                this.paramSchema = state.parameters({ inherit: false });
                this.paramValues = {};
                this.resolvables = state.resolvables.map(function (res) { return res.clone(); });
            }
        }
        PathNode.prototype.clone = function () {
            return new PathNode(this);
        };
        /** Sets [[paramValues]] for the node, from the values of an object hash */
        PathNode.prototype.applyRawParams = function (params) {
            var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };
            this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return applyPairs(memo, getParamVal(pDef)); }, {});
            return this;
        };
        /** Gets a specific [[Param]] metadata that belongs to the node */
        PathNode.prototype.parameter = function (name) {
            return find(this.paramSchema, propEq('id', name));
        };
        /**
         * @returns true if the state and parameter values for another PathNode are
         * equal to the state and param values for this PathNode
         */
        PathNode.prototype.equals = function (node, paramsFn) {
            var diff = this.diff(node, paramsFn);
            return diff && diff.length === 0;
        };
        /**
         * Finds Params with different parameter values on another PathNode.
         *
         * Given another node (of the same state), finds the parameter values which differ.
         * Returns the [[Param]] (schema objects) whose parameter values differ.
         *
         * Given another node for a different state, returns `false`
         *
         * @param node The node to compare to
         * @param paramsFn A function that returns which parameters should be compared.
         * @returns The [[Param]]s which differ, or null if the two nodes are for different states
         */
        PathNode.prototype.diff = function (node, paramsFn) {
            if (this.state !== node.state)
                return false;
            var params = paramsFn ? paramsFn(this) : this.paramSchema;
            return Param.changed(params, this.paramValues, node.paramValues);
        };
        /**
         * Returns a clone of the PathNode
         * @deprecated use instance method `node.clone()`
         */
        PathNode.clone = function (node) { return node.clone(); };
        return PathNode;
    }());

    /** @publicapi @module state */ /** */
    /**
     * Encapsulate the target (destination) state/params/options of a [[Transition]].
     *
     * This class is frequently used to redirect a transition to a new destination.
     *
     * See:
     *
     * - [[HookResult]]
     * - [[TransitionHookFn]]
     * - [[TransitionService.onStart]]
     *
     * To create a `TargetState`, use [[StateService.target]].
     *
     * ---
     *
     * This class wraps:
     *
     * 1) an identifier for a state
     * 2) a set of parameters
     * 3) and transition options
     * 4) the registered state object (the [[StateDeclaration]])
     *
     * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
     * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
     * The `TargetState` class normalizes those options.
     *
     * A `TargetState` may be valid (the state being targeted exists in the registry)
     * or invalid (the state being targeted is not registered).
     */
    var TargetState = /** @class */ (function () {
        /**
         * The TargetState constructor
         *
         * Note: Do not construct a `TargetState` manually.
         * To create a `TargetState`, use the [[StateService.target]] factory method.
         *
         * @param _stateRegistry The StateRegistry to use to look up the _definition
         * @param _identifier An identifier for a state.
         *    Either a fully-qualified state name, or the object used to define the state.
         * @param _params Parameters for the target state
         * @param _options Transition options.
         *
         * @internalapi
         */
        function TargetState(_stateRegistry, _identifier, _params, _options) {
            this._stateRegistry = _stateRegistry;
            this._identifier = _identifier;
            this._identifier = _identifier;
            this._params = extend({}, _params || {});
            this._options = extend({}, _options || {});
            this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);
        }
        /** The name of the state this object targets */
        TargetState.prototype.name = function () {
            return (this._definition && this._definition.name) || this._identifier;
        };
        /** The identifier used when creating this TargetState */
        TargetState.prototype.identifier = function () {
            return this._identifier;
        };
        /** The target parameter values */
        TargetState.prototype.params = function () {
            return this._params;
        };
        /** The internal state object (if it was found) */
        TargetState.prototype.$state = function () {
            return this._definition;
        };
        /** The internal state declaration (if it was found) */
        TargetState.prototype.state = function () {
            return this._definition && this._definition.self;
        };
        /** The target options */
        TargetState.prototype.options = function () {
            return this._options;
        };
        /** True if the target state was found */
        TargetState.prototype.exists = function () {
            return !!(this._definition && this._definition.self);
        };
        /** True if the object is valid */
        TargetState.prototype.valid = function () {
            return !this.error();
        };
        /** If the object is invalid, returns the reason why */
        TargetState.prototype.error = function () {
            var base = this.options().relative;
            if (!this._definition && !!base) {
                var stateName = base.name ? base.name : base;
                return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
            }
            if (!this._definition)
                return "No such state '" + this.name() + "'";
            if (!this._definition.self)
                return "State '" + this.name() + "' has an invalid definition";
        };
        TargetState.prototype.toString = function () {
            return "'" + this.name() + "'" + stringify(this.params());
        };
        /**
         * Returns a copy of this TargetState which targets a different state.
         * The new TargetState has the same parameter values and transition options.
         *
         * @param state The new state that should be targeted
         */
        TargetState.prototype.withState = function (state) {
            return new TargetState(this._stateRegistry, state, this._params, this._options);
        };
        /**
         * Returns a copy of this TargetState, using the specified parameter values.
         *
         * @param params the new parameter values to use
         * @param replace When false (default) the new parameter values will be merged with the current values.
         *                When true the parameter values will be used instead of the current values.
         */
        TargetState.prototype.withParams = function (params, replace) {
            if (replace === void 0) { replace = false; }
            var newParams = replace ? params : extend({}, this._params, params);
            return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);
        };
        /**
         * Returns a copy of this TargetState, using the specified Transition Options.
         *
         * @param options the new options to use
         * @param replace When false (default) the new options will be merged with the current options.
         *                When true the options will be used instead of the current options.
         */
        TargetState.prototype.withOptions = function (options, replace) {
            if (replace === void 0) { replace = false; }
            var newOpts = replace ? options : extend({}, this._options, options);
            return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);
        };
        /** Returns true if the object has a state property that might be a state or state name */
        TargetState.isDef = function (obj) { return obj && obj.state && (isString(obj.state) || isString(obj.state.name)); };
        return TargetState;
    }());

    /** @internalapi @module path */ /** */
    /**
     * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
     */
    var PathUtils = /** @class */ (function () {
        function PathUtils() {
        }
        /** Given a PathNode[], create an TargetState */
        PathUtils.makeTargetState = function (registry, path) {
            var state = tail(path).state;
            return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});
        };
        PathUtils.buildPath = function (targetState) {
            var toParams = targetState.params();
            return targetState.$state().path.map(function (state) { return new PathNode(state).applyRawParams(toParams); });
        };
        /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
        PathUtils.buildToPath = function (fromPath, targetState) {
            var toPath = PathUtils.buildPath(targetState);
            if (targetState.options().inherit) {
                return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
            }
            return toPath;
        };
        /**
         * Creates ViewConfig objects and adds to nodes.
         *
         * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
         */
        PathUtils.applyViewConfigs = function ($view, path, states) {
            // Only apply the viewConfigs to the nodes for the given states
            path
                .filter(function (node) { return inArray(states, node.state); })
                .forEach(function (node) {
                var viewDecls = values(node.state.views || {});
                var subPath = PathUtils.subPath(path, function (n) { return n === node; });
                var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });
                node.views = viewConfigs.reduce(unnestR, []);
            });
        };
        /**
         * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
         *
         * For a parameter in a node to be inherited from the from path:
         * - The toPath's node must have a matching node in the fromPath (by state).
         * - The parameter name must not be found in the toKeys parameter array.
         *
         * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
         * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
         * it is not inherited from the fromPath.
         */
        PathUtils.inheritParams = function (fromPath, toPath, toKeys) {
            if (toKeys === void 0) { toKeys = []; }
            function nodeParamVals(path, state) {
                var node = find(path, propEq('state', state));
                return extend({}, node && node.paramValues);
            }
            var noInherit = fromPath
                .map(function (node) { return node.paramSchema; })
                .reduce(unnestR, [])
                .filter(function (param) { return !param.inherit; })
                .map(prop('id'));
            /**
             * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
             * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
             */
            function makeInheritedParamsNode(toNode) {
                // All param values for the node (may include default key/vals, when key was not found in toParams)
                var toParamVals = extend({}, toNode && toNode.paramValues);
                // limited to only those keys found in toParams
                var incomingParamVals = pick(toParamVals, toKeys);
                toParamVals = omit(toParamVals, toKeys);
                var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
                // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
                var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);
                return new PathNode(toNode.state).applyRawParams(ownParamVals);
            }
            // The param keys specified by the incoming toParams
            return toPath.map(makeInheritedParamsNode);
        };
        /**
         * Computes the tree changes (entering, exiting) between a fromPath and toPath.
         */
        PathUtils.treeChanges = function (fromPath, toPath, reloadState) {
            var max = Math.min(fromPath.length, toPath.length);
            var keep = 0;
            var nodesMatch = function (node1, node2) { return node1.equals(node2, PathUtils.nonDynamicParams); };
            while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
                keep++;
            }
            /** Given a retained node, return a new node which uses the to node's param values */
            function applyToParams(retainedNode, idx) {
                var cloned = retainedNode.clone();
                cloned.paramValues = toPath[idx].paramValues;
                return cloned;
            }
            var from, retained, exiting, entering, to;
            from = fromPath;
            retained = from.slice(0, keep);
            exiting = from.slice(keep);
            // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
            var retainedWithToParams = retained.map(applyToParams);
            entering = toPath.slice(keep);
            to = retainedWithToParams.concat(entering);
            return { from: from, to: to, retained: retained, retainedWithToParams: retainedWithToParams, exiting: exiting, entering: entering };
        };
        /**
         * Returns a new path which is: the subpath of the first path which matches the second path.
         *
         * The new path starts from root and contains any nodes that match the nodes in the second path.
         * It stops before the first non-matching node.
         *
         * Nodes are compared using their state property and their parameter values.
         * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
         *
         * @param pathA the first path
         * @param pathB the second path
         * @param paramsFn a function which returns the parameters to consider when comparing
         *
         * @returns an array of PathNodes from the first path which match the nodes in the second path
         */
        PathUtils.matching = function (pathA, pathB, paramsFn) {
            var done = false;
            var tuples = arrayTuples(pathA, pathB);
            return tuples.reduce(function (matching, _a) {
                var nodeA = _a[0], nodeB = _a[1];
                done = done || !nodeA.equals(nodeB, paramsFn);
                return done ? matching : matching.concat(nodeA);
            }, []);
        };
        /**
         * Returns true if two paths are identical.
         *
         * @param pathA
         * @param pathB
         * @param paramsFn a function which returns the parameters to consider when comparing
         * @returns true if the the states and parameter values for both paths are identical
         */
        PathUtils.equals = function (pathA, pathB, paramsFn) {
            return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
        };
        /**
         * Return a subpath of a path, which stops at the first matching node
         *
         * Given an array of nodes, returns a subset of the array starting from the first node,
         * stopping when the first node matches the predicate.
         *
         * @param path a path of [[PathNode]]s
         * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
         * @returns a subpath up to the matching node, or undefined if no match is found
         */
        PathUtils.subPath = function (path, predicate) {
            var node = find(path, predicate);
            var elementIdx = path.indexOf(node);
            return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
        };
        PathUtils.nonDynamicParams = function (node) {
            return node.state.parameters({ inherit: false }).filter(function (param) { return !param.dynamic; });
        };
        /** Gets the raw parameter values from a path */
        PathUtils.paramValues = function (path) { return path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {}); };
        return PathUtils;
    }());

    /** @internalapi */
    var resolvePolicies = {
        when: {
            LAZY: 'LAZY',
            EAGER: 'EAGER',
        },
        async: {
            WAIT: 'WAIT',
            NOWAIT: 'NOWAIT',
        },
    };

    /** @publicapi @module resolve */ /** */
    // TODO: explicitly make this user configurable
    var defaultResolvePolicy = {
        when: 'LAZY',
        async: 'WAIT',
    };
    /**
     * The basic building block for the resolve system.
     *
     * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
     * and the unwrapped-when-complete (.data) result of the resolveFn.
     *
     * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
     * resolveFn) and returns the resulting promise.
     *
     * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
     * parameter to those fns.
     */
    var Resolvable = /** @class */ (function () {
        function Resolvable(arg1, resolveFn, deps, policy, data) {
            this.resolved = false;
            this.promise = undefined;
            if (arg1 instanceof Resolvable) {
                extend(this, arg1);
            }
            else if (isFunction(resolveFn)) {
                if (isNullOrUndefined(arg1))
                    throw new Error('new Resolvable(): token argument is required');
                if (!isFunction(resolveFn))
                    throw new Error('new Resolvable(): resolveFn argument must be a function');
                this.token = arg1;
                this.policy = policy;
                this.resolveFn = resolveFn;
                this.deps = deps || [];
                this.data = data;
                this.resolved = data !== undefined;
                this.promise = this.resolved ? services.$q.when(this.data) : undefined;
            }
            else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {
                var literal = arg1;
                return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
            }
        }
        Resolvable.prototype.getPolicy = function (state) {
            var thisPolicy = this.policy || {};
            var statePolicy = (state && state.resolvePolicy) || {};
            return {
                when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
                async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,
            };
        };
        /**
         * Asynchronously resolve this Resolvable's data
         *
         * Given a ResolveContext that this Resolvable is found in:
         * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
         * and update the Resolvable's state
         */
        Resolvable.prototype.resolve = function (resolveContext, trans) {
            var _this = this;
            var $q = services.$q;
            // Gets all dependencies from ResolveContext and wait for them to be resolved
            var getResolvableDependencies = function () {
                return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) { return resolvable.get(resolveContext, trans); }));
            };
            // Invokes the resolve function passing the resolved dependencies as arguments
            var invokeResolveFn = function (resolvedDeps) { return _this.resolveFn.apply(null, resolvedDeps); };
            var node = resolveContext.findNode(this);
            var state = node && node.state;
            var asyncPolicy = this.getPolicy(state).async;
            var customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity;
            // After the final value has been resolved, update the state of the Resolvable
            var applyResolvedValue = function (resolvedValue) {
                _this.data = resolvedValue;
                _this.resolved = true;
                _this.resolveFn = null;
                trace.traceResolvableResolved(_this, trans);
                return _this.data;
            };
            // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
            return (this.promise = $q
                .when()
                .then(getResolvableDependencies)
                .then(invokeResolveFn)
                .then(customAsyncPolicy)
                .then(applyResolvedValue));
        };
        /**
         * Gets a promise for this Resolvable's data.
         *
         * Fetches the data and returns a promise.
         * Returns the existing promise if it has already been fetched once.
         */
        Resolvable.prototype.get = function (resolveContext, trans) {
            return this.promise || this.resolve(resolveContext, trans);
        };
        Resolvable.prototype.toString = function () {
            return "Resolvable(token: " + stringify(this.token) + ", requires: [" + this.deps.map(stringify) + "])";
        };
        Resolvable.prototype.clone = function () {
            return new Resolvable(this);
        };
        Resolvable.fromData = function (token, data) { return new Resolvable(token, function () { return data; }, null, null, data); };
        return Resolvable;
    }());

    /** @publicapi @module resolve */ /** */
    var whens = resolvePolicies.when;
    var ALL_WHENS = [whens.EAGER, whens.LAZY];
    var EAGER_WHENS = [whens.EAGER];
    // tslint:disable-next-line:no-inferrable-types
    var NATIVE_INJECTOR_TOKEN = 'Native Injector';
    /**
     * Encapsulates Dependency Injection for a path of nodes
     *
     * UI-Router states are organized as a tree.
     * A nested state has a path of ancestors to the root of the tree.
     * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
     * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
     *
     * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
     */
    var ResolveContext = /** @class */ (function () {
        function ResolveContext(_path) {
            this._path = _path;
        }
        /** Gets all the tokens found in the resolve context, de-duplicated */
        ResolveContext.prototype.getTokens = function () {
            return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(uniqR, []);
        };
        /**
         * Gets the Resolvable that matches the token
         *
         * Gets the last Resolvable that matches the token in this context, or undefined.
         * Throws an error if it doesn't exist in the ResolveContext
         */
        ResolveContext.prototype.getResolvable = function (token) {
            var matching = this._path
                .map(function (node) { return node.resolvables; })
                .reduce(unnestR, [])
                .filter(function (r) { return r.token === token; });
            return tail(matching);
        };
        /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
        ResolveContext.prototype.getPolicy = function (resolvable) {
            var node = this.findNode(resolvable);
            return resolvable.getPolicy(node.state);
        };
        /**
         * Returns a ResolveContext that includes a portion of this one
         *
         * Given a state, this method creates a new ResolveContext from this one.
         * The new context starts at the first node (root) and stops at the node for the `state` parameter.
         *
         * #### Why
         *
         * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
         * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
         * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
         * This method is used to create a narrower context when injecting ancestor nodes.
         *
         * @example
         * `let ABCD = new ResolveContext([A, B, C, D]);`
         *
         * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
         * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
         * However, `B` should only be able to access resolvables from `A`, `B`.
         *
         * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
         * `let AB = ABCD.subcontext(a)`
         */
        ResolveContext.prototype.subContext = function (state) {
            return new ResolveContext(PathUtils.subPath(this._path, function (node) { return node.state === state; }));
        };
        /**
         * Adds Resolvables to the node that matches the state
         *
         * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
         * The resolvable is added to the node matching the `state` parameter.
         *
         * These new resolvables are not automatically fetched.
         * The calling code should either fetch them, fetch something that depends on them,
         * or rely on [[resolvePath]] being called when some state is being entered.
         *
         * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
         *
         * @param newResolvables the new Resolvables
         * @param state Used to find the node to put the resolvable on
         */
        ResolveContext.prototype.addResolvables = function (newResolvables, state) {
            var node = find(this._path, propEq('state', state));
            var keys = newResolvables.map(function (r) { return r.token; });
            node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);
        };
        /**
         * Returns a promise for an array of resolved path Element promises
         *
         * @param when
         * @param trans
         * @returns {Promise<any>|any}
         */
        ResolveContext.prototype.resolvePath = function (when, trans) {
            var _this = this;
            if (when === void 0) { when = 'LAZY'; }
            // This option determines which 'when' policy Resolvables we are about to fetch.
            var whenOption = inArray(ALL_WHENS, when) ? when : 'LAZY';
            // If the caller specified EAGER, only the EAGER Resolvables are fetched.
            // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
            var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
            // get the subpath to the state argument, if provided
            trace.traceResolvePath(this._path, when, trans);
            var matchesPolicy = function (acceptedVals, whenOrAsync) { return function (resolvable) {
                return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
            }; };
            // Trigger all the (matching) Resolvables in the path
            // Reduce all the "WAIT" Resolvables into an array
            var promises = this._path.reduce(function (acc, node) {
                var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));
                var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));
                var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));
                // For the matching Resolvables, start their async fetch process.
                var subContext = _this.subContext(node.state);
                var getResult = function (r) {
                    return r
                        .get(subContext, trans)
                        // Return a tuple that includes the Resolvable's token
                        .then(function (value) { return ({ token: r.token, value: value }); });
                };
                nowait.forEach(getResult);
                return acc.concat(wait.map(getResult));
            }, []);
            // Wait for all the "WAIT" resolvables
            return services.$q.all(promises);
        };
        ResolveContext.prototype.injector = function () {
            return this._injector || (this._injector = new UIInjectorImpl(this));
        };
        ResolveContext.prototype.findNode = function (resolvable) {
            return find(this._path, function (node) { return inArray(node.resolvables, resolvable); });
        };
        /**
         * Gets the async dependencies of a Resolvable
         *
         * Given a Resolvable, returns its dependencies as a Resolvable[]
         */
        ResolveContext.prototype.getDependencies = function (resolvable) {
            var _this = this;
            var node = this.findNode(resolvable);
            // Find which other resolvables are "visible" to the `resolvable` argument
            // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
            var subPath = PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;
            var availableResolvables = subPath
                .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, []) // all of subpath's resolvables
                .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument
            var getDependency = function (token) {
                var matching = availableResolvables.filter(function (r) { return r.token === token; });
                if (matching.length)
                    return tail(matching);
                var fromInjector = _this.injector().getNative(token);
                if (isUndefined(fromInjector)) {
                    throw new Error('Could not find Dependency Injection token: ' + stringify(token));
                }
                return new Resolvable(token, function () { return fromInjector; }, [], fromInjector);
            };
            return resolvable.deps.map(getDependency);
        };
        return ResolveContext;
    }());
    /** @internalapi */
    var UIInjectorImpl = /** @class */ (function () {
        function UIInjectorImpl(context) {
            this.context = context;
            this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;
        }
        UIInjectorImpl.prototype.get = function (token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable) {
                if (this.context.getPolicy(resolvable).async === 'NOWAIT') {
                    return resolvable.get(this.context);
                }
                if (!resolvable.resolved) {
                    throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));
                }
                return resolvable.data;
            }
            return this.getNative(token);
        };
        UIInjectorImpl.prototype.getAsync = function (token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable)
                return resolvable.get(this.context);
            return services.$q.when(this.native.get(token));
        };
        UIInjectorImpl.prototype.getNative = function (token) {
            return this.native && this.native.get(token);
        };
        return UIInjectorImpl;
    }());

    /** @publicapi @module state */ /** */
    var parseUrl = function (url) {
        if (!isString(url))
            return false;
        var root = url.charAt(0) === '^';
        return { val: root ? url.substring(1) : url, root: root };
    };
    function nameBuilder(state) {
        return state.name;
    }
    function selfBuilder(state) {
        state.self.$$state = function () { return state; };
        return state.self;
    }
    function dataBuilder(state) {
        if (state.parent && state.parent.data) {
            state.data = state.self.data = inherit(state.parent.data, state.data);
        }
        return state.data;
    }
    var getUrlBuilder = function ($urlMatcherFactoryProvider, root) {
        return function urlBuilder(stateObject) {
            var stateDec = stateObject.self;
            // For future states, i.e., states whose name ends with `.**`,
            // match anything that starts with the url prefix
            if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
                var newStateDec = {};
                copy(stateDec, newStateDec);
                newStateDec.url += '{remainder:any}'; // match any path (.*)
                stateDec = newStateDec;
            }
            var parent = stateObject.parent;
            var parsed = parseUrl(stateDec.url);
            var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, { state: stateDec });
            if (!url)
                return null;
            if (!$urlMatcherFactoryProvider.isMatcher(url))
                throw new Error("Invalid url '" + url + "' in state '" + stateObject + "'");
            return parsed && parsed.root ? url : ((parent && parent.navigable) || root()).url.append(url);
        };
    };
    var getNavigableBuilder = function (isRoot) {
        return function navigableBuilder(state) {
            return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;
        };
    };
    var getParamsBuilder = function (paramFactory) {
        return function paramsBuilder(state) {
            var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, state.self); };
            var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];
            var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));
            return urlParams
                .concat(nonUrlParams)
                .map(function (p) { return [p.id, p]; })
                .reduce(applyPairs, {});
        };
    };
    function pathBuilder(state) {
        return state.parent ? state.parent.path.concat(state) : /*root*/ [state];
    }
    function includesBuilder(state) {
        var includes = state.parent ? extend({}, state.parent.includes) : {};
        includes[state.name] = true;
        return includes;
    }
    /**
     * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * validates the `resolve` property and converts it to a [[Resolvable]] array.
     *
     * resolve: input value can be:
     *
     * {
     *   // analyzed but not injected
     *   myFooResolve: function() { return "myFooData"; },
     *
     *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
     *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
     *
     *   // Array split; "DependencyName" dep as string
     *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
     *
     *   // Array split; DependencyType dep as token (compared using ===)
     *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
     *
     *   // val.$inject used as deps
     *   // where:
     *   //     corgeResolve.$inject = ["DependencyName"];
     *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
     *   // then "DependencyName" dep as string
     *   myCorgeResolve: corgeResolve,
     *
     *  // inject service by name
     *  // When a string is found, desugar creating a resolve that injects the named service
     *   myGraultResolve: "SomeService"
     * }
     *
     * or:
     *
     * [
     *   new Resolvable("myFooResolve", function() { return "myFooData" }),
     *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
     *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
     * ]
     */
    function resolvablesBuilder(state) {
        /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
        var objects2Tuples = function (resolveObj, resolvePolicies) {
            return Object.keys(resolveObj || {}).map(function (token) { return ({
                token: token,
                val: resolveObj[token],
                deps: undefined,
                policy: resolvePolicies[token],
            }); });
        };
        /** fetch DI annotations from a function or ng1-style array */
        var annotate = function (fn) {
            var $injector = services.$injector;
            // ng1 doesn't have an $injector until runtime.
            // If the $injector doesn't exist, use "deferred" literal as a
            // marker indicating they should be annotated when runtime starts
            return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || 'deferred';
        };
        /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
        var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };
        /** true if the object looks like a provide literal, or a ng2 Provider */
        var isLikeNg2Provider = function (obj) {
            return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));
        };
        /** true if the object looks like a tuple from obj2Tuples */
        var isTupleFromObj = function (obj) {
            return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));
        };
        /** extracts the token from a Provider or provide literal */
        var getToken = function (p) { return p.provide || p.token; };
        // prettier-ignore: Given a literal resolve or provider object, returns a Resolvable
        var literal2Resolvable = pattern([
            [prop('resolveFn'), function (p) { return new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy); }],
            [prop('useFactory'), function (p) { return new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy); }],
            [prop('useClass'), function (p) { return new Resolvable(getToken(p), function () { return new p.useClass(); }, [], p.policy); }],
            [prop('useValue'), function (p) { return new Resolvable(getToken(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],
            [prop('useExisting'), function (p) { return new Resolvable(getToken(p), identity, [p.useExisting], p.policy); }],
        ]);
        // prettier-ignore
        var tuple2Resolvable = pattern([
            [pipe(prop('val'), isString), function (tuple) { return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy); }],
            [pipe(prop('val'), isArray), function (tuple) { return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],
            [pipe(prop('val'), isFunction), function (tuple) { return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],
        ]);
        // prettier-ignore
        var item2Resolvable = pattern([
            [is(Resolvable), function (r) { return r; }],
            [isResolveLiteral, literal2Resolvable],
            [isLikeNg2Provider, literal2Resolvable],
            [isTupleFromObj, tuple2Resolvable],
            [val(true), function (obj) { throw new Error('Invalid resolve value: ' + stringify(obj)); },],
        ]);
        // If resolveBlock is already an array, use it as-is.
        // Otherwise, assume it's an object and convert to an Array of tuples
        var decl = state.resolve;
        var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
        return items.map(item2Resolvable);
    }
    /**
     * @internalapi A internal global service
     *
     * StateBuilder is a factory for the internal [[StateObject]] objects.
     *
     * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
     * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
     * [[StateObject]] object, which has an API and is used internally.
     *
     * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
     * using the [[builder]] method.
     */
    var StateBuilder = /** @class */ (function () {
        function StateBuilder(matcher, urlMatcherFactory) {
            this.matcher = matcher;
            var self = this;
            var root = function () { return matcher.find(''); };
            var isRoot = function (state) { return state.name === ''; };
            function parentBuilder(state) {
                if (isRoot(state))
                    return null;
                return matcher.find(self.parentName(state)) || root();
            }
            this.builders = {
                name: [nameBuilder],
                self: [selfBuilder],
                parent: [parentBuilder],
                data: [dataBuilder],
                // Build a URLMatcher if necessary, either via a relative or absolute URL
                url: [getUrlBuilder(urlMatcherFactory, root)],
                // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
                navigable: [getNavigableBuilder(isRoot)],
                params: [getParamsBuilder(urlMatcherFactory.paramFactory)],
                // Each framework-specific ui-router implementation should define its own `views` builder
                // e.g., src/ng1/statebuilders/views.ts
                views: [],
                // Keep a full path from the root down to this state as this is needed for state activation.
                path: [pathBuilder],
                // Speed up $state.includes() as it's used a lot
                includes: [includesBuilder],
                resolvables: [resolvablesBuilder],
            };
        }
        /**
         * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
         * More than one BuilderFunction can be registered for a given property.
         *
         * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
         *
         * @param name The name of the State property being registered for.
         * @param fn The BuilderFunction which will be used to build the State property
         * @returns a function which deregisters the BuilderFunction
         */
        StateBuilder.prototype.builder = function (name, fn) {
            var builders = this.builders;
            var array = builders[name] || [];
            // Backwards compat: if only one builder exists, return it, else return whole arary.
            if (isString(name) && !isDefined(fn))
                return array.length > 1 ? array : array[0];
            if (!isString(name) || !isFunction(fn))
                return;
            builders[name] = array;
            builders[name].push(fn);
            return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };
        };
        /**
         * Builds all of the properties on an essentially blank State object, returning a State object which has all its
         * properties and API built.
         *
         * @param state an uninitialized State object
         * @returns the built State object
         */
        StateBuilder.prototype.build = function (state) {
            var _a = this, matcher = _a.matcher, builders = _a.builders;
            var parent = this.parentName(state);
            if (parent && !matcher.find(parent, undefined, false)) {
                return null;
            }
            for (var key in builders) {
                if (!builders.hasOwnProperty(key))
                    continue;
                var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, noop);
                state[key] = chain(state);
            }
            return state;
        };
        StateBuilder.prototype.parentName = function (state) {
            // name = 'foo.bar.baz.**'
            var name = state.name || '';
            // segments = ['foo', 'bar', 'baz', '.**']
            var segments = name.split('.');
            // segments = ['foo', 'bar', 'baz']
            var lastSegment = segments.pop();
            // segments = ['foo', 'bar'] (ignore .** segment for future states)
            if (lastSegment === '**')
                segments.pop();
            if (segments.length) {
                if (state.parent) {
                    throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
                }
                // 'foo.bar'
                return segments.join('.');
            }
            if (!state.parent)
                return '';
            return isString(state.parent) ? state.parent : state.parent.name;
        };
        StateBuilder.prototype.name = function (state) {
            var name = state.name;
            if (name.indexOf('.') !== -1 || !state.parent)
                return name;
            var parentName = isString(state.parent) ? state.parent : state.parent.name;
            return parentName ? parentName + '.' + name : name;
        };
        return StateBuilder;
    }());

    /**
     * Internal representation of a UI-Router state.
     *
     * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
     *
     * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
     *
     * This class prototypally inherits from the corresponding [[StateDeclaration]].
     * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
     */
    var StateObject = /** @class */ (function () {
        /** @deprecated use State.create() */
        function StateObject(config) {
            return StateObject.create(config || {});
        }
        /**
         * Create a state object to put the private/internal implementation details onto.
         * The object's prototype chain looks like:
         * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)
         *
         * @param stateDecl the user-supplied State Declaration
         * @returns {StateObject} an internal State object
         */
        StateObject.create = function (stateDecl) {
            stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
            var state = inherit(inherit(stateDecl, StateObject.prototype));
            stateDecl.$$state = function () { return state; };
            state.self = stateDecl;
            state.__stateObjectCache = {
                nameGlob: Glob.fromString(state.name),
            };
            return state;
        };
        /**
         * Returns true if the provided parameter is the same state.
         *
         * Compares the identity of the state against the passed value, which is either an object
         * reference to the actual `State` instance, the original definition object passed to
         * `$stateProvider.state()`, or the fully-qualified name.
         *
         * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
         *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
         * @returns Returns `true` if `ref` matches the current `State` instance.
         */
        StateObject.prototype.is = function (ref) {
            return this === ref || this.self === ref || this.fqn() === ref;
        };
        /**
         * @deprecated this does not properly handle dot notation
         * @returns Returns a dot-separated name of the state.
         */
        StateObject.prototype.fqn = function () {
            if (!this.parent || !(this.parent instanceof this.constructor))
                return this.name;
            var name = this.parent.fqn();
            return name ? name + '.' + this.name : this.name;
        };
        /**
         * Returns the root node of this state's tree.
         *
         * @returns The root of this state's tree.
         */
        StateObject.prototype.root = function () {
            return (this.parent && this.parent.root()) || this;
        };
        /**
         * Gets the state's `Param` objects
         *
         * Gets the list of [[Param]] objects owned by the state.
         * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
         * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
         *
         * @param opts options
         */
        StateObject.prototype.parameters = function (opts) {
            opts = defaults(opts, { inherit: true, matchingKeys: null });
            var inherited = (opts.inherit && this.parent && this.parent.parameters()) || [];
            return inherited
                .concat(values(this.params))
                .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });
        };
        /**
         * Returns a single [[Param]] that is owned by the state
         *
         * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
         * @param id the name of the [[Param]] to return
         * @param opts options
         */
        StateObject.prototype.parameter = function (id, opts) {
            if (opts === void 0) { opts = {}; }
            return ((this.url && this.url.parameter(id, opts)) ||
                find(values(this.params), propEq('id', id)) ||
                (opts.inherit && this.parent && this.parent.parameter(id)));
        };
        StateObject.prototype.toString = function () {
            return this.fqn();
        };
        /** Predicate which returns true if the object is an class with @State() decorator */
        StateObject.isStateClass = function (stateDecl) {
            return isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;
        };
        /** Predicate which returns true if the object is an internal [[StateObject]] object */
        StateObject.isState = function (obj) { return isObject(obj['__stateObjectCache']); };
        return StateObject;
    }());

    /** @publicapi @module state */ /** */
    var StateMatcher = /** @class */ (function () {
        function StateMatcher(_states) {
            this._states = _states;
        }
        StateMatcher.prototype.isRelative = function (stateName) {
            stateName = stateName || '';
            return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;
        };
        StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {
            if (matchGlob === void 0) { matchGlob = true; }
            if (!stateOrName && stateOrName !== '')
                return undefined;
            var isStr = isString(stateOrName);
            var name = isStr ? stateOrName : stateOrName.name;
            if (this.isRelative(name))
                name = this.resolvePath(name, base);
            var state = this._states[name];
            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
                return state;
            }
            else if (isStr && matchGlob) {
                var _states = values(this._states);
                var matches = _states.filter(function (_state) { return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name); });
                if (matches.length > 1) {
                    safeConsole.error("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));
                }
                return matches[0];
            }
            return undefined;
        };
        StateMatcher.prototype.resolvePath = function (name, base) {
            if (!base)
                throw new Error("No reference point given for path '" + name + "'");
            var baseState = this.find(base);
            var splitName = name.split('.');
            var pathLength = splitName.length;
            var i = 0, current = baseState;
            for (; i < pathLength; i++) {
                if (splitName[i] === '' && i === 0) {
                    current = baseState;
                    continue;
                }
                if (splitName[i] === '^') {
                    if (!current.parent)
                        throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                    current = current.parent;
                    continue;
                }
                break;
            }
            var relName = splitName.slice(i).join('.');
            return current.name + (current.name && relName ? '.' : '') + relName;
        };
        return StateMatcher;
    }());

    /** @publicapi @module state */ /** */
    /** @internalapi */
    var StateQueueManager = /** @class */ (function () {
        function StateQueueManager(router, states, builder, listeners) {
            this.router = router;
            this.states = states;
            this.builder = builder;
            this.listeners = listeners;
            this.queue = [];
        }
        /** @internalapi */
        StateQueueManager.prototype.dispose = function () {
            this.queue = [];
        };
        StateQueueManager.prototype.register = function (stateDecl) {
            var queue = this.queue;
            var state = StateObject.create(stateDecl);
            var name = state.name;
            if (!isString(name))
                throw new Error('State must have a valid name');
            if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))
                throw new Error("State '" + name + "' is already defined");
            queue.push(state);
            this.flush();
            return state;
        };
        StateQueueManager.prototype.flush = function () {
            var _this = this;
            var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
            var registered = [], // states that got registered
            orphans = [], // states that don't yet have a parent registered
            previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered
            var getState = function (name) { return _this.states.hasOwnProperty(name) && _this.states[name]; };
            var notifyListeners = function () {
                if (registered.length) {
                    _this.listeners.forEach(function (listener) { return listener('registered', registered.map(function (s) { return s.self; })); });
                }
            };
            while (queue.length > 0) {
                var state = queue.shift();
                var name_1 = state.name;
                var result = builder.build(state);
                var orphanIdx = orphans.indexOf(state);
                if (result) {
                    var existingState = getState(name_1);
                    if (existingState && existingState.name === name_1) {
                        throw new Error("State '" + name_1 + "' is already defined");
                    }
                    var existingFutureState = getState(name_1 + '.**');
                    if (existingFutureState) {
                        // Remove future state of the same name
                        this.router.stateRegistry.deregister(existingFutureState);
                    }
                    states[name_1] = state;
                    this.attachRoute(state);
                    if (orphanIdx >= 0)
                        orphans.splice(orphanIdx, 1);
                    registered.push(state);
                    continue;
                }
                var prev = previousQueueLength[name_1];
                previousQueueLength[name_1] = queue.length;
                if (orphanIdx >= 0 && prev === queue.length) {
                    // Wait until two consecutive iterations where no additional states were dequeued successfully.
                    // throw new Error(`Cannot register orphaned state '${name}'`);
                    queue.push(state);
                    notifyListeners();
                    return states;
                }
                else if (orphanIdx < 0) {
                    orphans.push(state);
                }
                queue.push(state);
            }
            notifyListeners();
            return states;
        };
        StateQueueManager.prototype.attachRoute = function (state) {
            if (state.abstract || !state.url)
                return;
            var rulesApi = this.router.urlService.rules;
            rulesApi.rule(rulesApi.urlRuleFactory.create(state));
        };
        return StateQueueManager;
    }());

    /** @publicapi @module state */ /** */
    var StateRegistry = /** @class */ (function () {
        /** @internalapi */
        function StateRegistry(router) {
            this.router = router;
            this.states = {};
            this.listeners = [];
            this.matcher = new StateMatcher(this.states);
            this.builder = new StateBuilder(this.matcher, router.urlMatcherFactory);
            this.stateQueue = new StateQueueManager(router, this.states, this.builder, this.listeners);
            this._registerRoot();
        }
        /** @internalapi */
        StateRegistry.prototype._registerRoot = function () {
            var rootStateDef = {
                name: '',
                url: '^',
                views: null,
                params: {
                    '#': { value: null, type: 'hash', dynamic: true },
                },
                abstract: true,
            };
            var _root = (this._root = this.stateQueue.register(rootStateDef));
            _root.navigable = null;
        };
        /** @internalapi */
        StateRegistry.prototype.dispose = function () {
            var _this = this;
            this.stateQueue.dispose();
            this.listeners = [];
            this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });
        };
        /**
         * Listen for a State Registry events
         *
         * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
         *
         * #### Example:
         * ```js
         * let allStates = registry.get();
         *
         * // Later, invoke deregisterFn() to remove the listener
         * let deregisterFn = registry.onStatesChanged((event, states) => {
         *   switch(event) {
         *     case: 'registered':
         *       states.forEach(state => allStates.push(state));
         *       break;
         *     case: 'deregistered':
         *       states.forEach(state => {
         *         let idx = allStates.indexOf(state);
         *         if (idx !== -1) allStates.splice(idx, 1);
         *       });
         *       break;
         *   }
         * });
         * ```
         *
         * @param listener a callback function invoked when the registered states changes.
         *        The function receives two parameters, `event` and `state`.
         *        See [[StateRegistryListener]]
         * @return a function that deregisters the listener
         */
        StateRegistry.prototype.onStatesChanged = function (listener) {
            this.listeners.push(listener);
            return function deregisterListener() {
                removeFrom(this.listeners)(listener);
            }.bind(this);
        };
        /**
         * Gets the implicit root state
         *
         * Gets the root of the state tree.
         * The root state is implicitly created by UI-Router.
         * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
         *
         * @return the root [[StateObject]]
         */
        StateRegistry.prototype.root = function () {
            return this._root;
        };
        /**
         * Adds a state to the registry
         *
         * Registers a [[StateDeclaration]] or queues it for registration.
         *
         * Note: a state will be queued if the state's parent isn't yet registered.
         *
         * @param stateDefinition the definition of the state to register.
         * @returns the internal [[StateObject]] object.
         *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
         *          If the state was only queued, then the object is not fully built.
         */
        StateRegistry.prototype.register = function (stateDefinition) {
            return this.stateQueue.register(stateDefinition);
        };
        /** @hidden */
        StateRegistry.prototype._deregisterTree = function (state) {
            var _this = this;
            var all = this.get().map(function (s) { return s.$$state(); });
            var getChildren = function (states) {
                var _children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });
                return _children.length === 0 ? _children : _children.concat(getChildren(_children));
            };
            var children = getChildren([state]);
            var deregistered = [state].concat(children).reverse();
            deregistered.forEach(function (_state) {
                var rulesApi = _this.router.urlService.rules;
                // Remove URL rule
                rulesApi
                    .rules()
                    .filter(propEq('state', _state))
                    .forEach(function (rule) { return rulesApi.removeRule(rule); });
                // Remove state from registry
                delete _this.states[_state.name];
            });
            return deregistered;
        };
        /**
         * Removes a state from the registry
         *
         * This removes a state from the registry.
         * If the state has children, they are are also removed from the registry.
         *
         * @param stateOrName the state's name or object representation
         * @returns {StateObject[]} a list of removed states
         */
        StateRegistry.prototype.deregister = function (stateOrName) {
            var _state = this.get(stateOrName);
            if (!_state)
                throw new Error("Can't deregister state; not found: " + stateOrName);
            var deregisteredStates = this._deregisterTree(_state.$$state());
            this.listeners.forEach(function (listener) { return listener('deregistered', deregisteredStates.map(function (s) { return s.self; })); });
            return deregisteredStates;
        };
        StateRegistry.prototype.get = function (stateOrName, base) {
            var _this = this;
            if (arguments.length === 0)
                return Object.keys(this.states).map(function (name) { return _this.states[name].self; });
            var found = this.matcher.find(stateOrName, base);
            return (found && found.self) || null;
        };
        StateRegistry.prototype.decorator = function (name, func) {
            return this.builder.builder(name, func);
        };
        return StateRegistry;
    }());

    (function (TransitionHookPhase) {
        TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
        TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
        TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
        TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
        TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
    })(exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));

    (function (TransitionHookScope) {
        TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
        TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
    })(exports.TransitionHookScope || (exports.TransitionHookScope = {}));

    /** @publicapi @module transition */ /** */
    var defaultOptions = {
        current: noop,
        transition: null,
        traceData: {},
        bind: null,
    };
    /** @hidden */
    var TransitionHook = /** @class */ (function () {
        function TransitionHook(transition, stateContext, registeredHook, options) {
            var _this = this;
            this.transition = transition;
            this.stateContext = stateContext;
            this.registeredHook = registeredHook;
            this.options = options;
            this.isSuperseded = function () { return _this.type.hookPhase === exports.TransitionHookPhase.RUN && !_this.options.transition.isActive(); };
            this.options = defaults(options, defaultOptions);
            this.type = registeredHook.eventType;
        }
        /**
         * Chains together an array of TransitionHooks.
         *
         * Given a list of [[TransitionHook]] objects, chains them together.
         * Each hook is invoked after the previous one completes.
         *
         * #### Example:
         * ```js
         * var hooks: TransitionHook[] = getHooks();
         * let promise: Promise<any> = TransitionHook.chain(hooks);
         *
         * promise.then(handleSuccess, handleError);
         * ```
         *
         * @param hooks the list of hooks to chain together
         * @param waitFor if provided, the chain is `.then()`'ed off this promise
         * @returns a `Promise` for sequentially invoking the hooks (in order)
         */
        TransitionHook.chain = function (hooks, waitFor) {
            // Chain the next hook off the previous
            var createHookChainR = function (prev, nextHook) { return prev.then(function () { return nextHook.invokeHook(); }); };
            return hooks.reduce(createHookChainR, waitFor || services.$q.when());
        };
        /**
         * Invokes all the provided TransitionHooks, in order.
         * Each hook's return value is checked.
         * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
         * If no hook returns a promise, then all hooks are processed synchronously.
         *
         * @param hooks the list of TransitionHooks to invoke
         * @param doneCallback a callback that is invoked after all the hooks have successfully completed
         *
         * @returns a promise for the async result, or the result of the callback
         */
        TransitionHook.invokeHooks = function (hooks, doneCallback) {
            for (var idx = 0; idx < hooks.length; idx++) {
                var hookResult = hooks[idx].invokeHook();
                if (isPromise(hookResult)) {
                    var remainingHooks = hooks.slice(idx + 1);
                    return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);
                }
            }
            return doneCallback();
        };
        /**
         * Run all TransitionHooks, ignoring their return value.
         */
        TransitionHook.runAllHooks = function (hooks) {
            hooks.forEach(function (hook) { return hook.invokeHook(); });
        };
        TransitionHook.prototype.logError = function (err) {
            this.transition.router.stateService.defaultErrorHandler()(err);
        };
        TransitionHook.prototype.invokeHook = function () {
            var _this = this;
            var hook = this.registeredHook;
            if (hook._deregistered)
                return;
            var notCurrent = this.getNotCurrentRejection();
            if (notCurrent)
                return notCurrent;
            var options = this.options;
            trace.traceHookInvocation(this, this.transition, options);
            var invokeCallback = function () { return hook.callback.call(options.bind, _this.transition, _this.stateContext); };
            var normalizeErr = function (err) { return Rejection.normalize(err).toPromise(); };
            var handleError = function (err) { return hook.eventType.getErrorHandler(_this)(err); };
            var handleResult = function (result) { return hook.eventType.getResultHandler(_this)(result); };
            try {
                var result = invokeCallback();
                if (!this.type.synchronous && isPromise(result)) {
                    return result.catch(normalizeErr).then(handleResult, handleError);
                }
                else {
                    return handleResult(result);
                }
            }
            catch (err) {
                // If callback throws (synchronously)
                return handleError(Rejection.normalize(err));
            }
            finally {
                if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
                    hook.deregister();
                }
            }
        };
        /**
         * This method handles the return value of a Transition Hook.
         *
         * A hook can return false (cancel), a TargetState (redirect),
         * or a promise (which may later resolve to false or a redirect)
         *
         * This also handles "transition superseded" -- when a new transition
         * was started while the hook was still running
         */
        TransitionHook.prototype.handleHookResult = function (result) {
            var _this = this;
            var notCurrent = this.getNotCurrentRejection();
            if (notCurrent)
                return notCurrent;
            // Hook returned a promise
            if (isPromise(result)) {
                // Wait for the promise, then reprocess with the resulting value
                return result.then(function (val) { return _this.handleHookResult(val); });
            }
            trace.traceHookResult(result, this.transition, this.options);
            // Hook returned false
            if (result === false) {
                // Abort this Transition
                return Rejection.aborted('Hook aborted transition').toPromise();
            }
            var isTargetState = is(TargetState);
            // hook returned a TargetState
            if (isTargetState(result)) {
                // Halt the current Transition and redirect (a new Transition) to the TargetState.
                return Rejection.redirected(result).toPromise();
            }
        };
        /**
         * Return a Rejection promise if the transition is no longer current due
         * to a stopped router (disposed), or a new transition has started and superseded this one.
         */
        TransitionHook.prototype.getNotCurrentRejection = function () {
            var router = this.transition.router;
            // The router is stopped
            if (router._disposed) {
                return Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
            }
            if (this.transition._aborted) {
                return Rejection.aborted().toPromise();
            }
            // This transition is no longer current.
            // Another transition started while this hook was still running.
            if (this.isSuperseded()) {
                // Abort this transition
                return Rejection.superseded(this.options.current()).toPromise();
            }
        };
        TransitionHook.prototype.toString = function () {
            var _a = this, options = _a.options, registeredHook = _a.registeredHook;
            var event = parse('traceData.hookType')(options) || 'internal', context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown', name = fnToString(registeredHook.callback);
            return event + " context: " + context + ", " + maxLength(200, name);
        };
        /**
         * These GetResultHandler(s) are used by [[invokeHook]] below
         * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
         */
        TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {
            return hook.handleHookResult(result);
        }; };
        /**
         * If the result is a promise rejection, log it.
         * Otherwise, ignore the result.
         */
        TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {
            isPromise(result) && result.catch(function (err) { return hook.logError(Rejection.normalize(err)); });
            return undefined;
        }; };
        /**
         * These GetErrorHandler(s) are used by [[invokeHook]] below
         * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
         */
        TransitionHook.LOG_ERROR = function (hook) { return function (error) { return hook.logError(error); }; };
        TransitionHook.REJECT_ERROR = function (hook) { return function (error) { return silentRejection(error); }; };
        TransitionHook.THROW_ERROR = function (hook) { return function (error) {
            throw error;
        }; };
        return TransitionHook;
    }());

    /** @publicapi @module transition */ /** */
    /**
     * Determines if the given state matches the matchCriteria
     *
     * @hidden
     *
     * @param state a State Object to test against
     * @param criterion
     * - If a string, matchState uses the string as a glob-matcher against the state name
     * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
     *   and returns a positive match if any of the globs match.
     * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
     * @returns {boolean}
     */
    function matchState(state, criterion, transition) {
        var toMatch = isString(criterion) ? [criterion] : criterion;
        function matchGlobs(_state) {
            var globStrings = toMatch;
            for (var i = 0; i < globStrings.length; i++) {
                var glob = new Glob(globStrings[i]);
                if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {
                    return true;
                }
            }
            return false;
        }
        var matchFn = (isFunction(toMatch) ? toMatch : matchGlobs);
        return !!matchFn(state, transition);
    }
    /**
     * @internalapi
     * The registration data for a registered transition hook
     */
    var RegisteredHook = /** @class */ (function () {
        function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
            if (options === void 0) { options = {}; }
            this.tranSvc = tranSvc;
            this.eventType = eventType;
            this.callback = callback;
            this.matchCriteria = matchCriteria;
            this.removeHookFromRegistry = removeHookFromRegistry;
            this.invokeCount = 0;
            this._deregistered = false;
            this.priority = options.priority || 0;
            this.bind = options.bind || null;
            this.invokeLimit = options.invokeLimit;
        }
        /**
         * Gets the matching [[PathNode]]s
         *
         * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
         * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
         *
         * Returning `null` is significant to distinguish between the default
         * "match-all criterion value" of `true` compared to a `() => true` function,
         * when the nodes is an empty array.
         *
         * This is useful to allow a transition match criteria of `entering: true`
         * to still match a transition, even when `entering === []`.  Contrast that
         * with `entering: (state) => true` which only matches when a state is actually
         * being entered.
         */
        RegisteredHook.prototype._matchingNodes = function (nodes, criterion, transition) {
            if (criterion === true)
                return nodes;
            var matching = nodes.filter(function (node) { return matchState(node.state, criterion, transition); });
            return matching.length ? matching : null;
        };
        /**
         * Gets the default match criteria (all `true`)
         *
         * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
         *
         * ```js
         * {
         *   to: true,
         *   from: true,
         *   entering: true,
         *   exiting: true,
         *   retained: true,
         * }
         */
        RegisteredHook.prototype._getDefaultMatchCriteria = function () {
            return mapObj(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });
        };
        /**
         * Gets matching nodes as [[IMatchingNodes]]
         *
         * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
         *
         * ```js
         * let matches: IMatchingNodes = {
         *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
         *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
         *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
         *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
         *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
         * };
         * ```
         */
        RegisteredHook.prototype._getMatchingNodes = function (treeChanges, transition) {
            var _this = this;
            var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);
            var paths = values(this.tranSvc._pluginapi._getPathTypes());
            return paths.reduce(function (mn, pathtype) {
                // STATE scope criteria matches against every node in the path.
                // TRANSITION scope criteria matches against only the last node in the path
                var isStateHook = pathtype.scope === exports.TransitionHookScope.STATE;
                var path = treeChanges[pathtype.name] || [];
                var nodes = isStateHook ? path : [tail(path)];
                mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name], transition);
                return mn;
            }, {});
        };
        /**
         * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
         *
         * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
         * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
         */
        RegisteredHook.prototype.matches = function (treeChanges, transition) {
            var matches = this._getMatchingNodes(treeChanges, transition);
            // Check if all the criteria matched the TreeChanges object
            var allMatched = values(matches).every(identity);
            return allMatched ? matches : null;
        };
        RegisteredHook.prototype.deregister = function () {
            this.removeHookFromRegistry(this);
            this._deregistered = true;
        };
        return RegisteredHook;
    }());
    /** @hidden Return a registration function of the requested type. */
    function makeEvent(registry, transitionService, eventType) {
        // Create the object which holds the registered transition hooks.
        var _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});
        var hooks = (_registeredHooks[eventType.name] = []);
        var removeHookFn = removeFrom(hooks);
        // Create hook registration function on the IHookRegistry for the event
        registry[eventType.name] = hookRegistrationFn;
        function hookRegistrationFn(matchObject, callback, options) {
            if (options === void 0) { options = {}; }
            var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
            hooks.push(registeredHook);
            return registeredHook.deregister.bind(registeredHook);
        }
        return hookRegistrationFn;
    }

    /** @publicapi @module transition */ /** */
    /**
     * This class returns applicable TransitionHooks for a specific Transition instance.
     *
     * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
     * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
     * determined by the type of hook)
     *
     * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
     *
     * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
     * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
     * in the Transition class, so we must also provide the Transition's _treeChanges)
     *
     */
    var HookBuilder = /** @class */ (function () {
        function HookBuilder(transition) {
            this.transition = transition;
        }
        HookBuilder.prototype.buildHooksForPhase = function (phase) {
            var _this = this;
            var $transitions = this.transition.router.transitionService;
            return $transitions._pluginapi
                ._getEvents(phase)
                .map(function (type) { return _this.buildHooks(type); })
                .reduce(unnestR, [])
                .filter(identity);
        };
        /**
         * Returns an array of newly built TransitionHook objects.
         *
         * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
         * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
         * - For each of the [[PathNode]]s, creates a TransitionHook
         *
         * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
         */
        HookBuilder.prototype.buildHooks = function (hookType) {
            var transition = this.transition;
            var treeChanges = transition.treeChanges();
            // Find all the matching registered hooks for a given hook type
            var matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);
            if (!matchingHooks)
                return [];
            var baseHookOptions = {
                transition: transition,
                current: transition.options().current,
            };
            var makeTransitionHooks = function (hook) {
                // Fetch the Nodes that caused this hook to match.
                var matches = hook.matches(treeChanges, transition);
                // Select the PathNode[] that will be used as TransitionHook context objects
                var matchingNodes = matches[hookType.criteriaMatchPath.name];
                // Return an array of HookTuples
                return matchingNodes.map(function (node) {
                    var _options = extend({
                        bind: hook.bind,
                        traceData: { hookType: hookType.name, context: node },
                    }, baseHookOptions);
                    var state = hookType.criteriaMatchPath.scope === exports.TransitionHookScope.STATE ? node.state.self : null;
                    var transitionHook = new TransitionHook(transition, state, hook, _options);
                    return { hook: hook, node: node, transitionHook: transitionHook };
                });
            };
            return matchingHooks
                .map(makeTransitionHooks)
                .reduce(unnestR, [])
                .sort(tupleSort(hookType.reverseSort))
                .map(function (tuple) { return tuple.transitionHook; });
        };
        /**
         * Finds all RegisteredHooks from:
         * - The Transition object instance hook registry
         * - The TransitionService ($transitions) global hook registry
         *
         * which matched:
         * - the eventType
         * - the matchCriteria (to, from, exiting, retained, entering)
         *
         * @returns an array of matched [[RegisteredHook]]s
         */
        HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges, transition) {
            var isCreate = hookType.hookPhase === exports.TransitionHookPhase.CREATE;
            // Instance and Global hook registries
            var $transitions = this.transition.router.transitionService;
            var registries = isCreate ? [$transitions] : [this.transition, $transitions];
            return registries
                .map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries
                .filter(assertPredicate(isArray, "broken event named: " + hookType.name)) // Sanity check
                .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
                .filter(function (hook) { return hook.matches(treeChanges, transition); }); // Only those satisfying matchCriteria
        };
        return HookBuilder;
    }());
    /**
     * A factory for a sort function for HookTuples.
     *
     * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
     * the EventHook priority.
     *
     * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
     * @returns a tuple sort function
     */
    function tupleSort(reverseDepthSort) {
        if (reverseDepthSort === void 0) { reverseDepthSort = false; }
        return function nodeDepthThenPriority(l, r) {
            var factor = reverseDepthSort ? -1 : 1;
            var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
            return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
        };
    }

    /** @publicapi @module transition */ /** */
    /** @hidden */
    var stateSelf = prop('self');
    /**
     * Represents a transition between two states.
     *
     * When navigating to a state, we are transitioning **from** the current state **to** the new state.
     *
     * This object contains all contextual information about the to/from states, parameters, resolves.
     * It has information about all states being entered and exited as a result of the transition.
     */
    var Transition = /** @class */ (function () {
        /**
         * Creates a new Transition object.
         *
         * If the target state is not valid, an error is thrown.
         *
         * @internalapi
         *
         * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
         *        encapsulates the "from state".
         * @param targetState The target state and parameters being transitioned to (also, the transition options)
         * @param router The [[UIRouter]] instance
         */
        function Transition(fromPath, targetState, router) {
            var _this = this;
            /** @hidden */
            this._deferred = services.$q.defer();
            /**
             * This promise is resolved or rejected based on the outcome of the Transition.
             *
             * When the transition is successful, the promise is resolved
             * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
             */
            this.promise = this._deferred.promise;
            /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */
            this._registeredHooks = {};
            /** @hidden */
            this._hookBuilder = new HookBuilder(this);
            /** Checks if this transition is currently active/running. */
            this.isActive = function () { return _this.router.globals.transition === _this; };
            this.router = router;
            this._targetState = targetState;
            if (!targetState.valid()) {
                throw new Error(targetState.error());
            }
            // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
            this._options = extend({ current: val(this) }, targetState.options());
            this.$id = router.transitionService._transitionCount++;
            var toPath = PathUtils.buildToPath(fromPath, targetState);
            this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
            this.createTransitionHookRegFns();
            var onCreateHooks = this._hookBuilder.buildHooksForPhase(exports.TransitionHookPhase.CREATE);
            TransitionHook.invokeHooks(onCreateHooks, function () { return null; });
            this.applyViewConfigs(router);
        }
        /** @hidden */
        Transition.prototype.onBefore = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onStart = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onExit = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onRetain = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onEnter = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onFinish = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onSuccess = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        Transition.prototype.onError = function (criteria, callback, options) {
            return;
        };
        /** @hidden
         * Creates the transition-level hook registration functions
         * (which can then be used to register hooks)
         */
        Transition.prototype.createTransitionHookRegFns = function () {
            var _this = this;
            this.router.transitionService._pluginapi
                ._getEvents()
                .filter(function (type) { return type.hookPhase !== exports.TransitionHookPhase.CREATE; })
                .forEach(function (type) { return makeEvent(_this, _this.router.transitionService, type); });
        };
        /** @internalapi */
        Transition.prototype.getHooks = function (hookName) {
            return this._registeredHooks[hookName];
        };
        Transition.prototype.applyViewConfigs = function (router) {
            var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });
            PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
        };
        /**
         * @internalapi
         *
         * @returns the internal from [State] object
         */
        Transition.prototype.$from = function () {
            return tail(this._treeChanges.from).state;
        };
        /**
         * @internalapi
         *
         * @returns the internal to [State] object
         */
        Transition.prototype.$to = function () {
            return tail(this._treeChanges.to).state;
        };
        /**
         * Returns the "from state"
         *
         * Returns the state that the transition is coming *from*.
         *
         * @returns The state declaration object for the Transition's ("from state").
         */
        Transition.prototype.from = function () {
            return this.$from().self;
        };
        /**
         * Returns the "to state"
         *
         * Returns the state that the transition is going *to*.
         *
         * @returns The state declaration object for the Transition's target state ("to state").
         */
        Transition.prototype.to = function () {
            return this.$to().self;
        };
        /**
         * Gets the Target State
         *
         * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
         *
         * @returns the [[TargetState]] of this Transition
         */
        Transition.prototype.targetState = function () {
            return this._targetState;
        };
        /**
         * Determines whether two transitions are equivalent.
         * @deprecated
         */
        Transition.prototype.is = function (compare) {
            if (compare instanceof Transition) {
                // TODO: Also compare parameters
                return this.is({ to: compare.$to().name, from: compare.$from().name });
            }
            return !((compare.to && !matchState(this.$to(), compare.to, this)) ||
                (compare.from && !matchState(this.$from(), compare.from, this)));
        };
        Transition.prototype.params = function (pathname) {
            if (pathname === void 0) { pathname = 'to'; }
            return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));
        };
        Transition.prototype.paramsChanged = function () {
            var fromParams = this.params('from');
            var toParams = this.params('to');
            // All the parameters declared on both the "to" and "from" paths
            var allParamDescriptors = []
                .concat(this._treeChanges.to)
                .concat(this._treeChanges.from)
                .map(function (pathNode) { return pathNode.paramSchema; })
                .reduce(flattenR, [])
                .reduce(uniqR, []);
            var changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);
            return changedParamDescriptors.reduce(function (changedValues, descriptor) {
                changedValues[descriptor.id] = toParams[descriptor.id];
                return changedValues;
            }, {});
        };
        /**
         * Creates a [[UIInjector]] Dependency Injector
         *
         * Returns a Dependency Injector for the Transition's target state (to state).
         * The injector provides resolve values which the target state has access to.
         *
         * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).
         *
         * #### Example:
         * ```js
         * .onEnter({ entering: 'myState' }, trans => {
         *   var myResolveValue = trans.injector().get('myResolve');
         *   // Inject a global service from the global/native injector (if it exists)
         *   var MyService = trans.injector().get('MyService');
         * })
         * ```
         *
         * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.
         * You can use [[UIInjector.getAsync]] to get a promise for the data.
         * #### Example:
         * ```js
         * .onBefore({}, trans => {
         *   return trans.injector().getAsync('myResolve').then(myResolveValue =>
         *     return myResolveValue !== 'ABORT';
         *   });
         * });
         * ```
         *
         * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.
         * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.
         * #### Example:
         * ```js
         * .onEnter({ to: 'foo.bar' }, trans => {
         *   // returns result of `foo` state's `myResolve` resolve
         *   // even though `foo.bar` also has a `myResolve` resolve
         *   var fooData = trans.injector('foo').get('myResolve');
         * });
         * ```
         *
         * If you need resolve data from the exiting states, pass `'from'` as `pathName`.
         * The resolve data from the `from` path will be returned.
         * #### Example:
         * ```js
         * .onExit({ exiting: 'foo.bar' }, trans => {
         *   // Gets the resolve value of `myResolve` from the state being exited
         *   var fooData = trans.injector(null, 'from').get('myResolve');
         * });
         * ```
         *
         *
         * @param state Limits the resolves provided to only the resolves the provided state has access to.
         * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.
         *
         * @returns a [[UIInjector]]
         */
        Transition.prototype.injector = function (state, pathName) {
            if (pathName === void 0) { pathName = 'to'; }
            var path = this._treeChanges[pathName];
            if (state)
                path = PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });
            return new ResolveContext(path).injector();
        };
        /**
         * Gets all available resolve tokens (keys)
         *
         * This method can be used in conjunction with [[injector]] to inspect the resolve values
         * available to the Transition.
         *
         * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
         * in the Transition's [[TreeChanges.to]] path.
         *
         * #### Example:
         * This example logs all resolve values
         * ```js
         * let tokens = trans.getResolveTokens();
         * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
         * ```
         *
         * #### Example:
         * This example creates promises for each resolve value.
         * This triggers fetches of resolves (if any have not yet been fetched).
         * When all promises have all settled, it logs the resolve values.
         * ```js
         * let tokens = trans.getResolveTokens();
         * let promise = tokens.map(token => trans.injector().getAsync(token));
         * Promise.all(promises).then(values => console.log("Resolved values: " + values));
         * ```
         *
         * Note: Angular 1 users whould use `$q.all()`
         *
         * @param pathname resolve context's path name (e.g., `to` or `from`)
         *
         * @returns an array of resolve tokens (keys)
         */
        Transition.prototype.getResolveTokens = function (pathname) {
            if (pathname === void 0) { pathname = 'to'; }
            return new ResolveContext(this._treeChanges[pathname]).getTokens();
        };
        /**
         * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
         *
         * Allows a transition hook to dynamically add a Resolvable to this Transition.
         *
         * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).
         *
         * If a `state` argument is provided, the Resolvable is processed when that state is being entered.
         * If no `state` is provided then the root state is used.
         * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.
         * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.
         *
         * The `state` argument also scopes the resolved data.
         * The resolved data is available from the injector for that `state` and any children states.
         *
         * #### Example:
         * ```js
         * transitionService.onBefore({}, transition => {
         *   transition.addResolvable({
         *     token: 'myResolve',
         *     deps: ['MyService'],
         *     resolveFn: myService => myService.getData()
         *   });
         * });
         * ```
         *
         * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
         * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
         */
        Transition.prototype.addResolvable = function (resolvable, state) {
            if (state === void 0) { state = ''; }
            resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);
            var stateName = typeof state === 'string' ? state : state.name;
            var topath = this._treeChanges.to;
            var targetNode = find(topath, function (node) { return node.state.name === stateName; });
            var resolveContext = new ResolveContext(topath);
            resolveContext.addResolvables([resolvable], targetNode.state);
        };
        /**
         * Gets the transition from which this transition was redirected.
         *
         * If the current transition is a redirect, this method returns the transition that was redirected.
         *
         * #### Example:
         * ```js
         * let transitionA = $state.go('A').transition
         * transitionA.onStart({}, () => $state.target('B'));
         * $transitions.onSuccess({ to: 'B' }, (trans) => {
         *   trans.to().name === 'B'; // true
         *   trans.redirectedFrom() === transitionA; // true
         * });
         * ```
         *
         * @returns The previous Transition, or null if this Transition is not the result of a redirection
         */
        Transition.prototype.redirectedFrom = function () {
            return this._options.redirectedFrom || null;
        };
        /**
         * Gets the original transition in a redirect chain
         *
         * A transition might belong to a long chain of multiple redirects.
         * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
         *
         * #### Example:
         * ```js
         * // states
         * registry.register({ name: 'A', redirectTo: 'B' });
         * registry.register({ name: 'B', redirectTo: 'C' });
         * registry.register({ name: 'C', redirectTo: 'D' });
         * registry.register({ name: 'D' });
         *
         * let transitionA = $state.go('A').transition
         *
         * $transitions.onSuccess({ to: 'D' }, (trans) => {
         *   trans.to().name === 'D'; // true
         *   trans.redirectedFrom().to().name === 'C'; // true
         *   trans.originalTransition() === transitionA; // true
         *   trans.originalTransition().to().name === 'A'; // true
         * });
         * ```
         *
         * @returns The original Transition that started a redirect chain
         */
        Transition.prototype.originalTransition = function () {
            var rf = this.redirectedFrom();
            return (rf && rf.originalTransition()) || this;
        };
        /**
         * Get the transition options
         *
         * @returns the options for this Transition.
         */
        Transition.prototype.options = function () {
            return this._options;
        };
        /**
         * Gets the states being entered.
         *
         * @returns an array of states that will be entered during this transition.
         */
        Transition.prototype.entering = function () {
            return map(this._treeChanges.entering, prop('state')).map(stateSelf);
        };
        /**
         * Gets the states being exited.
         *
         * @returns an array of states that will be exited during this transition.
         */
        Transition.prototype.exiting = function () {
            return map(this._treeChanges.exiting, prop('state'))
                .map(stateSelf)
                .reverse();
        };
        /**
         * Gets the states being retained.
         *
         * @returns an array of states that are already entered from a previous Transition, that will not be
         *    exited during this Transition
         */
        Transition.prototype.retained = function () {
            return map(this._treeChanges.retained, prop('state')).map(stateSelf);
        };
        /**
         * Get the [[ViewConfig]]s associated with this Transition
         *
         * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
         * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
         *
         * @param pathname the name of the path to fetch views for:
         *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
         * @param state If provided, only returns the `ViewConfig`s for a single state in the path
         *
         * @returns a list of ViewConfig objects for the given path.
         */
        Transition.prototype.views = function (pathname, state) {
            if (pathname === void 0) { pathname = 'entering'; }
            var path = this._treeChanges[pathname];
            path = !state ? path : path.filter(propEq('state', state));
            return path
                .map(prop('views'))
                .filter(identity)
                .reduce(unnestR, []);
        };
        Transition.prototype.treeChanges = function (pathname) {
            return pathname ? this._treeChanges[pathname] : this._treeChanges;
        };
        /**
         * Creates a new transition that is a redirection of the current one.
         *
         * This transition can be returned from a [[TransitionService]] hook to
         * redirect a transition to a new state and/or set of parameters.
         *
         * @internalapi
         *
         * @returns Returns a new [[Transition]] instance.
         */
        Transition.prototype.redirect = function (targetState) {
            var redirects = 1, trans = this;
            // tslint:disable-next-line:no-conditional-assignment
            while ((trans = trans.redirectedFrom()) != null) {
                if (++redirects > 20)
                    throw new Error("Too many consecutive Transition redirects (20+)");
            }
            var redirectOpts = { redirectedFrom: this, source: 'redirect' };
            // If the original transition was caused by URL sync, then use { location: 'replace' }
            // on the new transition (unless the target state explicitly specifies location: false).
            // This causes the original url to be replaced with the url for the redirect target
            // so the original url disappears from the browser history.
            if (this.options().source === 'url' && targetState.options().location !== false) {
                redirectOpts.location = 'replace';
            }
            var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);
            targetState = targetState.withOptions(newOptions, true);
            var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
            var originalEnteringNodes = this._treeChanges.entering;
            var redirectEnteringNodes = newTransition._treeChanges.entering;
            // --- Re-use resolve data from original transition ---
            // When redirecting from a parent state to a child state where the parent parameter values haven't changed
            // (because of the redirect), the resolves fetched by the original transition are still valid in the
            // redirected transition.
            //
            // This allows you to define a redirect on a parent state which depends on an async resolve value.
            // You can wait for the resolve, then redirect to a child state based on the result.
            // The redirected transition does not have to re-fetch the resolve.
            // ---------------------------------------------------------
            var nodeIsReloading = function (reloadState) { return function (node) {
                return reloadState && node.state.includes[reloadState.name];
            }; };
            // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
            var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams).filter(not(nodeIsReloading(targetState.options().reloadState)));
            // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
            matchingEnteringNodes.forEach(function (node, idx) {
                node.resolvables = originalEnteringNodes[idx].resolvables;
            });
            return newTransition;
        };
        /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
        Transition.prototype._changedParams = function () {
            var tc = this._treeChanges;
            /** Return undefined if it's not a "dynamic" transition, for the following reasons */
            // If user explicitly wants a reload
            if (this._options.reload)
                return undefined;
            // If any states are exiting or entering
            if (tc.exiting.length || tc.entering.length)
                return undefined;
            // If to/from path lengths differ
            if (tc.to.length !== tc.from.length)
                return undefined;
            // If the to/from paths are different
            var pathsDiffer = arrayTuples(tc.to, tc.from)
                .map(function (tuple) { return tuple[0].state !== tuple[1].state; })
                .reduce(anyTrueR, false);
            if (pathsDiffer)
                return undefined;
            // Find any parameter values that differ
            var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });
            var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];
            var tuples = arrayTuples(nodeSchemas, toValues, fromValues);
            return tuples.map(function (_a) {
                var schema = _a[0], toVals = _a[1], fromVals = _a[2];
                return Param.changed(schema, toVals, fromVals);
            }).reduce(unnestR, []);
        };
        /**
         * Returns true if the transition is dynamic.
         *
         * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
         *
         * @returns true if the Transition is dynamic
         */
        Transition.prototype.dynamic = function () {
            var changes = this._changedParams();
            return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(anyTrueR, false);
        };
        /**
         * Returns true if the transition is ignored.
         *
         * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
         *
         * @returns true if the Transition is ignored.
         */
        Transition.prototype.ignored = function () {
            return !!this._ignoredReason();
        };
        /** @hidden */
        Transition.prototype._ignoredReason = function () {
            var pending = this.router.globals.transition;
            var reloadState = this._options.reloadState;
            var same = function (pathA, pathB) {
                if (pathA.length !== pathB.length)
                    return false;
                var matching = PathUtils.matching(pathA, pathB);
                return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;
            };
            var newTC = this.treeChanges();
            var pendTC = pending && pending.treeChanges();
            if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
                return 'SameAsPending';
            if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
                return 'SameAsCurrent';
        };
        /**
         * Runs the transition
         *
         * This method is generally called from the [[StateService.transitionTo]]
         *
         * @internalapi
         *
         * @returns a promise for a successful transition.
         */
        Transition.prototype.run = function () {
            var _this = this;
            var runAllHooks = TransitionHook.runAllHooks;
            // Gets transition hooks array for the given phase
            var getHooksFor = function (phase) { return _this._hookBuilder.buildHooksForPhase(phase); };
            // When the chain is complete, then resolve or reject the deferred
            var transitionSuccess = function () {
                trace.traceSuccess(_this.$to(), _this);
                _this.success = true;
                _this._deferred.resolve(_this.to());
                runAllHooks(getHooksFor(exports.TransitionHookPhase.SUCCESS));
            };
            var transitionError = function (reason) {
                trace.traceError(reason, _this);
                _this.success = false;
                _this._deferred.reject(reason);
                _this._error = reason;
                runAllHooks(getHooksFor(exports.TransitionHookPhase.ERROR));
            };
            var runTransition = function () {
                // Wait to build the RUN hook chain until the BEFORE hooks are done
                // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
                var allRunHooks = getHooksFor(exports.TransitionHookPhase.RUN);
                var done = function () { return services.$q.when(undefined); };
                return TransitionHook.invokeHooks(allRunHooks, done);
            };
            var startTransition = function () {
                var globals = _this.router.globals;
                globals.lastStartedTransitionId = _this.$id;
                globals.transition = _this;
                globals.transitionHistory.enqueue(_this);
                trace.traceTransitionStart(_this);
                return services.$q.when(undefined);
            };
            var allBeforeHooks = getHooksFor(exports.TransitionHookPhase.BEFORE);
            TransitionHook.invokeHooks(allBeforeHooks, startTransition)
                .then(runTransition)
                .then(transitionSuccess, transitionError);
            return this.promise;
        };
        /**
         * Checks if the Transition is valid
         *
         * @returns true if the Transition is valid
         */
        Transition.prototype.valid = function () {
            return !this.error() || this.success !== undefined;
        };
        /**
         * Aborts this transition
         *
         * Imperative API to abort a Transition.
         * This only applies to Transitions that are not yet complete.
         */
        Transition.prototype.abort = function () {
            // Do not set flag if the transition is already complete
            if (isUndefined(this.success)) {
                this._aborted = true;
            }
        };
        /**
         * The Transition error reason.
         *
         * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
         * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
         *
         * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.
         */
        Transition.prototype.error = function () {
            var state = this.$to();
            if (state.self.abstract) {
                return Rejection.invalid("Cannot transition to abstract state '" + state.name + "'");
            }
            var paramDefs = state.parameters();
            var values = this.params();
            var invalidParams = paramDefs.filter(function (param) { return !param.validates(values[param.id]); });
            if (invalidParams.length) {
                var invalidValues = invalidParams.map(function (param) { return "[" + param.id + ":" + stringify(values[param.id]) + "]"; }).join(', ');
                var detail = "The following parameter values are not valid for state '" + state.name + "': " + invalidValues;
                return Rejection.invalid(detail);
            }
            if (this.success === false)
                return this._error;
        };
        /**
         * A string representation of the Transition
         *
         * @returns A string representation of the Transition
         */
        Transition.prototype.toString = function () {
            var fromStateOrName = this.from();
            var toStateOrName = this.to();
            var avoidEmptyHash = function (params) {
                return params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);
            };
            // (X) means the to state is invalid.
            var id = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))), toValid = this.valid() ? '' : '(X) ', to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = stringify(avoidEmptyHash(this.params()));
            return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
        };
        /** @hidden */
        Transition.diToken = Transition;
        return Transition;
    }());

    /** @publicapi @module url */ /** */
    /** @hidden */
    function quoteRegExp(str, param) {
        var surroundPattern = ['', ''], result = str.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&');
        if (!param)
            return result;
        switch (param.squash) {
            case false:
                surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
                break;
            case true:
                result = result.replace(/\/$/, '');
                surroundPattern = ['(?:/(', ')|/)?'];
                break;
            default:
                surroundPattern = ["(" + param.squash + "|", ')?'];
                break;
        }
        return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
    }
    /** @hidden */
    var memoizeTo = function (obj, _prop, fn) { return (obj[_prop] = obj[_prop] || fn()); };
    /** @hidden */
    var splitOnSlash = splitOnDelim('/');
    /** @hidden */
    var defaultConfig = {
        state: { params: {} },
        strict: true,
        caseInsensitive: true,
    };
    /**
     * Matches URLs against patterns.
     *
     * Matches URLs against patterns and extracts named parameters from the path or the search
     * part of the URL.
     *
     * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
     * parameters. Multiple search parameter names are separated by '&'. Search parameters
     * do not influence whether or not a URL is matched, but their values are passed through into
     * the matched parameters returned by [[UrlMatcher.exec]].
     *
     * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
     * or colon placeholders (`/somePath/:param`).
     *
     * - *A parameter RegExp* may be defined for a param after a colon
     * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
     * The regexp must match for the url to be matched.
     * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
     *
     * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
     *
     * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
     *   See [[UrlMatcherFactory.type]] for more information.
     *
     * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
     *   A catch-all * parameter value will contain the remainder of the URL.
     *
     * ---
     *
     * Parameter names may contain only word characters (latin letters, digits, and underscore) and
     * must be unique within the pattern (across both path and search parameters).
     * A path parameter matches any number of characters other than '/'. For catch-all
     * placeholders the path parameter matches any number of characters.
     *
     * Examples:
     *
     * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
     *   trailing slashes, and patterns have to match the entire path, not just a prefix.
     * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
     *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
     * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
     * * `'/user/{id:[^/]*}'` - Same as the previous example.
     * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
     *   parameter consists of 1 to 8 hex digits.
     * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
     *   path into the parameter 'path'.
     * * `'/files/*path'` - ditto.
     * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
     *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
     *
     */
    var UrlMatcher = /** @class */ (function () {
        /**
         * @param pattern The pattern to compile into a matcher.
         * @param paramTypes The [[ParamTypes]] registry
         * @param paramFactory A [[ParamFactory]] object
         * @param config  A [[UrlMatcherCompileConfig]] configuration object
         */
        function UrlMatcher(pattern, paramTypes, paramFactory, config) {
            var _this = this;
            /** @hidden */
            this._cache = { path: [this] };
            /** @hidden */
            this._children = [];
            /** @hidden */
            this._params = [];
            /** @hidden */
            this._segments = [];
            /** @hidden */
            this._compiled = [];
            this.config = config = defaults(config, defaultConfig);
            this.pattern = pattern;
            // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
            //   '*' name
            //   ':' name
            //   '{' name '}'
            //   '{' name ':' regexp '}'
            // The regular expression is somewhat complicated due to the need to allow curly braces
            // inside the regular expression. The placeholder regexp breaks down as follows:
            //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
            //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
            //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
            //    [^{}\\]+                       - anything other than curly braces or backslash
            //    \\.                            - a backslash escape
            //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
            var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
            var searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
            var patterns = [];
            var last = 0;
            var matchArray;
            var checkParamErrors = function (id) {
                if (!UrlMatcher.nameValidator.test(id))
                    throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
                if (find(_this._params, propEq('id', id)))
                    throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            };
            // Split into static segments separated by path parameter placeholders.
            // The number of segments is always 1 more than the number of parameters.
            var matchDetails = function (m, isSearch) {
                // IE[78] returns '' for unmatched groups instead of null
                var id = m[2] || m[3];
                var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\s\\S]*' : null);
                var makeRegexpType = function (str) {
                    return inherit(paramTypes.type(isSearch ? 'query' : 'path'), {
                        pattern: new RegExp(str, _this.config.caseInsensitive ? 'i' : undefined),
                    });
                };
                return {
                    id: id,
                    regexp: regexp,
                    segment: pattern.substring(last, m.index),
                    type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp),
                };
            };
            var details;
            var segment;
            // tslint:disable-next-line:no-conditional-assignment
            while ((matchArray = placeholder.exec(pattern))) {
                details = matchDetails(matchArray, false);
                if (details.segment.indexOf('?') >= 0)
                    break; // we're into the search part
                checkParamErrors(details.id);
                this._params.push(paramFactory.fromPath(details.id, details.type, config.state));
                this._segments.push(details.segment);
                patterns.push([details.segment, tail(this._params)]);
                last = placeholder.lastIndex;
            }
            segment = pattern.substring(last);
            // Find any search parameter names and remove them from the last segment
            var i = segment.indexOf('?');
            if (i >= 0) {
                var search = segment.substring(i);
                segment = segment.substring(0, i);
                if (search.length > 0) {
                    last = 0;
                    // tslint:disable-next-line:no-conditional-assignment
                    while ((matchArray = searchPlaceholder.exec(search))) {
                        details = matchDetails(matchArray, true);
                        checkParamErrors(details.id);
                        this._params.push(paramFactory.fromSearch(details.id, details.type, config.state));
                        last = placeholder.lastIndex;
                        // check if ?&
                    }
                }
            }
            this._segments.push(segment);
            this._compiled = patterns.map(function (_pattern) { return quoteRegExp.apply(null, _pattern); }).concat(quoteRegExp(segment));
        }
        /** @hidden */
        UrlMatcher.encodeDashes = function (str) {
            // Replace dashes with encoded "\-"
            return encodeURIComponent(str).replace(/-/g, function (c) {
                return "%5C%" + c
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
            });
        };
        /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */
        UrlMatcher.pathSegmentsAndParams = function (matcher) {
            var staticSegments = matcher._segments;
            var pathParams = matcher._params.filter(function (p) { return p.location === exports.DefType.PATH; });
            return arrayTuples(staticSegments, pathParams.concat(undefined))
                .reduce(unnestR, [])
                .filter(function (x) { return x !== '' && isDefined(x); });
        };
        /** @hidden Given a matcher, return an array with the matcher's query params */
        UrlMatcher.queryParams = function (matcher) {
            return matcher._params.filter(function (p) { return p.location === exports.DefType.SEARCH; });
        };
        /**
         * Compare two UrlMatchers
         *
         * This comparison function converts a UrlMatcher into static and dynamic path segments.
         * Each static path segment is a static string between a path separator (slash character).
         * Each dynamic segment is a path parameter.
         *
         * The comparison function sorts static segments before dynamic ones.
         */
        UrlMatcher.compare = function (a, b) {
            /**
             * Turn a UrlMatcher and all its parent matchers into an array
             * of slash literals '/', string literals, and Param objects
             *
             * This example matcher matches strings like "/foo/:param/tail":
             * var matcher = $umf.compile("/foo").append($umf.compile("/:param")).append($umf.compile("/")).append($umf.compile("tail"));
             * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]
             *
             * Caches the result as `matcher._cache.segments`
             */
            var segments = function (matcher) {
                return (matcher._cache.segments =
                    matcher._cache.segments ||
                        matcher._cache.path
                            .map(UrlMatcher.pathSegmentsAndParams)
                            .reduce(unnestR, [])
                            .reduce(joinNeighborsR, [])
                            .map(function (x) { return (isString(x) ? splitOnSlash(x) : x); })
                            .reduce(unnestR, []));
            };
            /**
             * Gets the sort weight for each segment of a UrlMatcher
             *
             * Caches the result as `matcher._cache.weights`
             */
            var weights = function (matcher) {
                return (matcher._cache.weights =
                    matcher._cache.weights ||
                        segments(matcher).map(function (segment) {
                            // Sort slashes first, then static strings, the Params
                            if (segment === '/')
                                return 1;
                            if (isString(segment))
                                return 2;
                            if (segment instanceof Param)
                                return 3;
                        }));
            };
            /**
             * Pads shorter array in-place (mutates)
             */
            var padArrays = function (l, r, padVal) {
                var len = Math.max(l.length, r.length);
                while (l.length < len)
                    l.push(padVal);
                while (r.length < len)
                    r.push(padVal);
            };
            var weightsA = weights(a), weightsB = weights(b);
            padArrays(weightsA, weightsB, 0);
            var _pairs = arrayTuples(weightsA, weightsB);
            var cmp, i;
            for (i = 0; i < _pairs.length; i++) {
                cmp = _pairs[i][0] - _pairs[i][1];
                if (cmp !== 0)
                    return cmp;
            }
            return 0;
        };
        /**
         * Creates a new concatenated UrlMatcher
         *
         * Builds a new UrlMatcher by appending another UrlMatcher to this one.
         *
         * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
         */
        UrlMatcher.prototype.append = function (url) {
            this._children.push(url);
            url._cache = {
                path: this._cache.path.concat(url),
                parent: this,
                pattern: null,
            };
            return url;
        };
        /** @hidden */
        UrlMatcher.prototype.isRoot = function () {
            return this._cache.path[0] === this;
        };
        /** Returns the input pattern string */
        UrlMatcher.prototype.toString = function () {
            return this.pattern;
        };
        /**
         * Tests the specified url/path against this matcher.
         *
         * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
         * parameter values.  Returns null if the path does not match.
         *
         * The returned object contains the values
         * of any search parameters that are mentioned in the pattern, but their value may be null if
         * they are not present in `search`. This means that search parameters are always treated
         * as optional.
         *
         * #### Example:
         * ```js
         * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
         *   x: '1', q: 'hello'
         * });
         * // returns { id: 'bob', q: 'hello', r: null }
         * ```
         *
         * @param path    The URL path to match, e.g. `$location.path()`.
         * @param search  URL search parameters, e.g. `$location.search()`.
         * @param hash    URL hash e.g. `$location.hash()`.
         * @param options
         *
         * @returns The captured parameter values.
         */
        UrlMatcher.prototype.exec = function (path, search, hash, options) {
            var _this = this;
            if (search === void 0) { search = {}; }
            var match = memoizeTo(this._cache, 'pattern', function () {
                return new RegExp([
                    '^',
                    unnest(_this._cache.path.map(prop('_compiled'))).join(''),
                    _this.config.strict === false ? '/?' : '',
                    '$',
                ].join(''), _this.config.caseInsensitive ? 'i' : undefined);
            }).exec(path);
            if (!match)
                return null;
            // options = defaults(options, { isolate: false });
            var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};
            if (nPathSegments !== match.length - 1)
                throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
            function decodePathArray(paramVal) {
                var reverseString = function (str) {
                    return str
                        .split('')
                        .reverse()
                        .join('');
                };
                var unquoteDashes = function (str) { return str.replace(/\\-/g, '-'); };
                var split = reverseString(paramVal).split(/-(?!\\)/);
                var allReversed = map(split, reverseString);
                return map(allReversed, unquoteDashes).reverse();
            }
            for (var i = 0; i < nPathSegments; i++) {
                var param = pathParams[i];
                var value = match[i + 1];
                // if the param value matches a pre-replace pair, replace the value before decoding.
                for (var j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === value)
                        value = param.replace[j].to;
                }
                if (value && param.array === true)
                    value = decodePathArray(value);
                if (isDefined(value))
                    value = param.type.decode(value);
                values[param.id] = param.value(value);
            }
            searchParams.forEach(function (param) {
                var value = search[param.id];
                for (var j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === value)
                        value = param.replace[j].to;
                }
                if (isDefined(value))
                    value = param.type.decode(value);
                values[param.id] = param.value(value);
            });
            if (hash)
                values['#'] = hash;
            return values;
        };
        /**
         * @hidden
         * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
         *
         * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
         *    pattern has no parameters, an empty array is returned.
         */
        UrlMatcher.prototype.parameters = function (opts) {
            if (opts === void 0) { opts = {}; }
            if (opts.inherit === false)
                return this._params;
            return unnest(this._cache.path.map(function (matcher) { return matcher._params; }));
        };
        /**
         * @hidden
         * Returns a single parameter from this UrlMatcher by id
         *
         * @param id
         * @param opts
         * @returns {T|Param|any|boolean|UrlMatcher|null}
         */
        UrlMatcher.prototype.parameter = function (id, opts) {
            var _this = this;
            if (opts === void 0) { opts = {}; }
            var findParam = function () {
                for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                    var param = _a[_i];
                    if (param.id === id)
                        return param;
                }
            };
            var parent = this._cache.parent;
            return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;
        };
        /**
         * Validates the input parameter values against this UrlMatcher
         *
         * Checks an object hash of parameters to validate their correctness according to the parameter
         * types of this `UrlMatcher`.
         *
         * @param params The object hash of parameters to validate.
         * @returns Returns `true` if `params` validates, otherwise `false`.
         */
        UrlMatcher.prototype.validates = function (params) {
            var validParamVal = function (param, val) { return !param || param.validates(val); };
            params = params || {};
            // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
            var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });
            return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(allTrueR, true);
        };
        /**
         * Given a set of parameter values, creates a URL from this UrlMatcher.
         *
         * Creates a URL that matches this pattern by substituting the specified values
         * for the path and search parameters.
         *
         * #### Example:
         * ```js
         * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
         * // returns '/user/bob?q=yes'
         * ```
         *
         * @param values  the values to substitute for the parameters in this pattern.
         * @returns the formatted URL (path and optionally search part).
         */
        UrlMatcher.prototype.format = function (values) {
            if (values === void 0) { values = {}; }
            // Build the full path of UrlMatchers (including all parent UrlMatchers)
            var urlMatchers = this._cache.path;
            // Extract all the static segments and Params (processed as ParamDetails)
            // into an ordered array
            var pathSegmentsAndParams = urlMatchers
                .map(UrlMatcher.pathSegmentsAndParams)
                .reduce(unnestR, [])
                .map(function (x) { return (isString(x) ? x : getDetails(x)); });
            // Extract the query params into a separate array
            var queryParams = urlMatchers
                .map(UrlMatcher.queryParams)
                .reduce(unnestR, [])
                .map(getDetails);
            var isInvalid = function (param) { return param.isValid === false; };
            if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
                return null;
            }
            /**
             * Given a Param, applies the parameter value, then returns detailed information about it
             */
            function getDetails(param) {
                // Normalize to typed value
                var value = param.value(values[param.id]);
                var isValid = param.validates(value);
                var isDefaultValue = param.isDefaultValue(value);
                // Check if we're in squash mode for the parameter
                var squash = isDefaultValue ? param.squash : false;
                // Allow the Parameter's Type to encode the value
                var encoded = param.type.encode(value);
                return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };
            }
            // Build up the path-portion from the list of static segments and parameters
            var pathString = pathSegmentsAndParams.reduce(function (acc, x) {
                // The element is a static segment (a raw string); just append it
                if (isString(x))
                    return acc + x;
                // Otherwise, it's a ParamDetails.
                var squash = x.squash, encoded = x.encoded, param = x.param;
                // If squash is === true, try to remove a slash from the path
                if (squash === true)
                    return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
                // If squash is a string, use the string for the param value
                if (isString(squash))
                    return acc + squash;
                if (squash !== false)
                    return acc; // ?
                if (encoded == null)
                    return acc;
                // If this parameter value is an array, encode the value using encodeDashes
                if (isArray(encoded))
                    return acc + map(encoded, UrlMatcher.encodeDashes).join('-');
                // If the parameter type is "raw", then do not encodeURIComponent
                if (param.raw)
                    return acc + encoded;
                // Encode the value
                return acc + encodeURIComponent(encoded);
            }, '');
            // Build the query string by applying parameter values (array or regular)
            // then mapping to key=value, then flattening and joining using "&"
            var queryString = queryParams
                .map(function (paramDetails) {
                var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
                if (encoded == null || (isDefaultValue && squash !== false))
                    return;
                if (!isArray(encoded))
                    encoded = [encoded];
                if (encoded.length === 0)
                    return;
                if (!param.raw)
                    encoded = map(encoded, encodeURIComponent);
                return encoded.map(function (val) { return param.id + "=" + val; });
            })
                .filter(identity)
                .reduce(unnestR, [])
                .join('&');
            // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
            return pathString + (queryString ? "?" + queryString : '') + (values['#'] ? '#' + values['#'] : '');
        };
        /** @hidden */
        UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
        return UrlMatcher;
    }());

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    /** @internalapi */
    var ParamFactory = /** @class */ (function () {
        function ParamFactory(router) {
            this.router = router;
        }
        ParamFactory.prototype.fromConfig = function (id, type, state) {
            return new Param(id, type, exports.DefType.CONFIG, this.router.urlService.config, state);
        };
        ParamFactory.prototype.fromPath = function (id, type, state) {
            return new Param(id, type, exports.DefType.PATH, this.router.urlService.config, state);
        };
        ParamFactory.prototype.fromSearch = function (id, type, state) {
            return new Param(id, type, exports.DefType.SEARCH, this.router.urlService.config, state);
        };
        return ParamFactory;
    }());
    /**
     * Factory for [[UrlMatcher]] instances.
     *
     * The factory is available to ng1 services as
     * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.
     *
     * @internalapi
     */
    var UrlMatcherFactory = /** @class */ (function () {
        // TODO: move implementations to UrlConfig (urlService.config)
        function UrlMatcherFactory(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @internalapi Creates a new [[Param]] for a given location (DefType) */
            this.paramFactory = new ParamFactory(this.router);
            /** @deprecated use [[UrlConfig.caseInsensitive]] */
            this.caseInsensitive = function (value) { return _this.router.urlService.config.caseInsensitive(value); };
            /** @deprecated use [[UrlConfig.defaultSquashPolicy]] */
            this.defaultSquashPolicy = function (value) { return _this.router.urlService.config.defaultSquashPolicy(value); };
            /** @deprecated use [[UrlConfig.strictMode]] */
            this.strictMode = function (value) { return _this.router.urlService.config.strictMode(value); };
            /** @deprecated use [[UrlConfig.type]] */
            this.type = function (name, definition, definitionFn) {
                return _this.router.urlService.config.type(name, definition, definitionFn) || _this;
            };
            extend(this, { UrlMatcher: UrlMatcher, Param: Param });
        }
        /**
         * Creates a [[UrlMatcher]] for the specified pattern.
         *
         * @param pattern  The URL pattern.
         * @param config  The config object hash.
         * @returns The UrlMatcher.
         */
        UrlMatcherFactory.prototype.compile = function (pattern, config) {
            var urlConfig = this.router.urlService.config;
            // backward-compatible support for config.params -> config.state.params
            var params = config && !config.state && config.params;
            config = params ? __assign({ state: { params: params } }, config) : config;
            var globalConfig = { strict: urlConfig._isStrictMode, caseInsensitive: urlConfig._isCaseInsensitive };
            return new UrlMatcher(pattern, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));
        };
        /**
         * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
         *
         * @param object  The object to perform the type check against.
         * @returns `true` if the object matches the `UrlMatcher` interface, by
         *          implementing all the same methods.
         */
        UrlMatcherFactory.prototype.isMatcher = function (object) {
            // TODO: typeof?
            if (!isObject(object))
                return false;
            var result = true;
            forEach(UrlMatcher.prototype, function (val, name) {
                if (isFunction(val))
                    result = result && (isDefined(object[name]) && isFunction(object[name]));
            });
            return result;
        };
        /** @hidden */
        UrlMatcherFactory.prototype.$get = function () {
            var urlConfig = this.router.urlService.config;
            urlConfig.paramTypes.enqueue = false;
            urlConfig.paramTypes._flushTypeQueue();
            return this;
        };
        return UrlMatcherFactory;
    }());

    /** @publicapi @module url */ /** */
    /**
     * Creates a [[UrlRule]]
     *
     * Creates a [[UrlRule]] from a:
     *
     * - `string`
     * - [[UrlMatcher]]
     * - `RegExp`
     * - [[StateObject]]
     * @internalapi
     */
    var UrlRuleFactory = /** @class */ (function () {
        function UrlRuleFactory(router) {
            this.router = router;
        }
        UrlRuleFactory.prototype.compile = function (str) {
            return this.router.urlMatcherFactory.compile(str);
        };
        UrlRuleFactory.prototype.create = function (what, handler) {
            var _this = this;
            var isState = StateObject.isState;
            var makeRule = pattern([
                [isString, function (_what) { return makeRule(_this.compile(_what)); }],
                [is(UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],
                [isState, function (_what) { return _this.fromState(_what, _this.router); }],
                [is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],
                [isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],
            ]);
            var rule = makeRule(what);
            if (!rule)
                throw new Error("invalid 'what' in when()");
            return rule;
        };
        /**
         * A UrlRule which matches based on a UrlMatcher
         *
         * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
         *
         * ## Handler as a function
         *
         * If `handler` is a function, the function is invoked with:
         *
         * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
         * - url: the current Url ([[UrlParts]])
         * - router: the router object ([[UIRouter]])
         *
         * #### Example:
         * ```js
         * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
         * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match); // '/home/123/456'
         * ```
         *
         * ## Handler as UrlMatcher
         *
         * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
         * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
         * The url is replaced with the result.
         *
         * #### Example:
         * ```js
         * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
         * var handler = $umf.compile("/home/:fooId/:barId");
         * var rule = factory.fromUrlMatcher(urlMatcher, handler);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match); // '/home/123/456'
         * ```
         */
        UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {
            var _handler = handler;
            if (isString(handler))
                handler = this.router.urlMatcherFactory.compile(handler);
            if (is(UrlMatcher)(handler))
                _handler = function (match) { return handler.format(match); };
            function matchUrlParamters(url) {
                var params = urlMatcher.exec(url.path, url.search, url.hash);
                return urlMatcher.validates(params) && params;
            }
            // Prioritize URLs, lowest to highest:
            // - Some optional URL parameters, but none matched
            // - No optional parameters in URL
            // - Some optional parameters, some matched
            // - Some optional parameters, all matched
            function matchPriority(params) {
                var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });
                if (!optional.length)
                    return 0.000001;
                var matched = optional.filter(function (param) { return params[param.id]; });
                return matched.length / optional.length;
            }
            var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: 'URLMATCHER' };
            return extend(new BaseUrlRule(matchUrlParamters, _handler), details);
        };
        /**
         * A UrlRule which matches a state by its url
         *
         * #### Example:
         * ```js
         * var rule = factory.fromState($state.get('foo'), router);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match);
         * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
         * ```
         */
        UrlRuleFactory.prototype.fromState = function (state, router) {
            /**
             * Handles match by transitioning to matched state
             *
             * First checks if the router should start a new transition.
             * A new transition is not required if the current state's URL
             * and the new URL are already identical
             */
            var handler = function (match) {
                var $state = router.stateService;
                var globals = router.globals;
                if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                    $state.transitionTo(state, match, { inherit: true, source: 'url' });
                }
            };
            var details = { state: state, type: 'STATE' };
            return extend(this.fromUrlMatcher(state.url, handler), details);
        };
        /**
         * A UrlRule which matches based on a regular expression
         *
         * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
         *
         * ## Handler as a function
         *
         * If `handler` is a function, the function is invoked with:
         *
         * - regexp match array (from `regexp`)
         * - url: the current Url ([[UrlParts]])
         * - router: the router object ([[UIRouter]])
         *
         * #### Example:
         * ```js
         * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
         * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
         * var result = rule.handler(match); // '/home/bar'
         * ```
         *
         * ## Handler as string
         *
         * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
         * The string is first interpolated using `string.replace()` style pattern.
         *
         * #### Example:
         * ```js
         * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
         * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
         * var result = rule.handler(match); // '/home/bar'
         * ```
         */
        UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {
            if (regexp.global || regexp.sticky)
                throw new Error('Rule RegExp must not be global or sticky');
            /**
             * If handler is a string, the url will be replaced by the string.
             * If the string has any String.replace() style variables in it (like `$2`),
             * they will be replaced by the captures from [[match]]
             */
            var redirectUrlTo = function (match) {
                // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
                return handler.replace(/\$(\$|\d{1,2})/, function (m, what) { return match[what === '$' ? 0 : Number(what)]; });
            };
            var _handler = isString(handler) ? redirectUrlTo : handler;
            var matchParamsFromRegexp = function (url) { return regexp.exec(url.path); };
            var details = { regexp: regexp, type: 'REGEXP' };
            return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);
        };
        UrlRuleFactory.isUrlRule = function (obj) { return obj && ['type', 'match', 'handler'].every(function (key) { return isDefined(obj[key]); }); };
        return UrlRuleFactory;
    }());
    /**
     * A base rule which calls `match`
     *
     * The value from the `match` function is passed through to the `handler`.
     * @internalapi
     */
    var BaseUrlRule = /** @class */ (function () {
        function BaseUrlRule(match, handler) {
            var _this = this;
            this.match = match;
            this.type = 'RAW';
            this.matchPriority = function (match) { return 0 - _this.$id; };
            this.handler = handler || identity;
        }
        return BaseUrlRule;
    }());

    /** @publicapi @module url */ /** */
    /** @hidden */
    function appendBasePath(url, isHtml5, absolute, baseHref) {
        if (baseHref === '/')
            return url;
        if (isHtml5)
            return stripLastPathElement(baseHref) + url;
        if (absolute)
            return baseHref.slice(1) + url;
        return url;
    }
    /**
     * Updates URL and responds to URL changes
     *
     * ### Deprecation warning:
     * This class is now considered to be an internal API
     * Use the [[UrlService]] instead.
     * For configuring URL rules, use the [[UrlRules]] which can be found as [[UrlService.rules]].
     *
     * @internalapi
     */
    var UrlRouter = /** @class */ (function () {
        /** @hidden */
        function UrlRouter(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            // Delegate these calls to [[UrlService]]
            /** @deprecated use [[UrlService.sync]]*/
            this.sync = function (evt) { return _this.router.urlService.sync(evt); };
            /** @deprecated use [[UrlService.listen]]*/
            this.listen = function (enabled) { return _this.router.urlService.listen(enabled); };
            /** @deprecated use [[UrlService.deferIntercept]]*/
            this.deferIntercept = function (defer) { return _this.router.urlService.deferIntercept(defer); };
            /** @deprecated use [[UrlService.match]]*/
            this.match = function (urlParts) { return _this.router.urlService.match(urlParts); };
            // Delegate these calls to [[UrlRules]]
            /** @deprecated use [[UrlRules.initial]]*/
            this.initial = function (handler) {
                return _this.router.urlService.rules.initial(handler);
            };
            /** @deprecated use [[UrlRules.otherwise]]*/
            this.otherwise = function (handler) {
                return _this.router.urlService.rules.otherwise(handler);
            };
            /** @deprecated use [[UrlRules.removeRule]]*/
            this.removeRule = function (rule) { return _this.router.urlService.rules.removeRule(rule); };
            /** @deprecated use [[UrlRules.rule]]*/
            this.rule = function (rule) { return _this.router.urlService.rules.rule(rule); };
            /** @deprecated use [[UrlRules.rules]]*/
            this.rules = function () { return _this.router.urlService.rules.rules(); };
            /** @deprecated use [[UrlRules.sort]]*/
            this.sort = function (compareFn) { return _this.router.urlService.rules.sort(compareFn); };
            /** @deprecated use [[UrlRules.when]]*/
            this.when = function (matcher, handler, options) { return _this.router.urlService.rules.when(matcher, handler, options); };
            this.urlRuleFactory = new UrlRuleFactory(router);
        }
        /**
         * Internal API.
         * @internalapi
         */
        UrlRouter.prototype.update = function (read) {
            var $url = this.router.locationService;
            if (read) {
                this.location = $url.url();
                return;
            }
            if ($url.url() === this.location)
                return;
            $url.url(this.location, true);
        };
        /**
         * Internal API.
         *
         * Pushes a new location to the browser history.
         *
         * @internalapi
         * @param urlMatcher
         * @param params
         * @param options
         */
        UrlRouter.prototype.push = function (urlMatcher, params, options) {
            var replace = options && !!options.replace;
            this.router.urlService.url(urlMatcher.format(params || {}), replace);
        };
        /**
         * Builds and returns a URL with interpolated parameters
         *
         * #### Example:
         * ```js
         * matcher = $umf.compile("/about/:person");
         * params = { person: "bob" };
         * $bob = $urlRouter.href(matcher, params);
         * // $bob == "/about/bob";
         * ```
         *
         * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
         * @param params An object of parameter values to fill the matcher's required parameters.
         * @param options Options object. The options are:
         *
         * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
         *
         * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
         */
        UrlRouter.prototype.href = function (urlMatcher, params, options) {
            var url = urlMatcher.format(params);
            if (url == null)
                return null;
            options = options || { absolute: false };
            var cfg = this.router.urlService.config;
            var isHtml5 = cfg.html5Mode();
            if (!isHtml5 && url !== null) {
                url = '#' + cfg.hashPrefix() + url;
            }
            url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
            if (!options.absolute || !url) {
                return url;
            }
            var slash = !isHtml5 && url ? '/' : '';
            var cfgPort = cfg.port();
            var port = (cfgPort === 80 || cfgPort === 443 ? '' : ':' + cfgPort);
            return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
        };
        Object.defineProperty(UrlRouter.prototype, "interceptDeferred", {
            /** @deprecated use [[UrlService.interceptDeferred]]*/
            get: function () {
                return this.router.urlService.interceptDeferred;
            },
            enumerable: true,
            configurable: true
        });
        return UrlRouter;
    }());

    /** @publicapi @module view */ /** */
    /**
     * The View service
     *
     * This service pairs existing `ui-view` components (which live in the DOM)
     * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
     *
     * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
     *   The views from exited states are deactivated via [[deactivateViewConfig]].
     *   (See: the [[registerActivateViews]] Transition Hook)
     *
     * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].
     *
     * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])
     * are configured with the matching [[ViewConfig]](s)
     *
     */
    var ViewService = /** @class */ (function () {
        /** @hidden */
        function ViewService(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @hidden */ this._uiViews = [];
            /** @hidden */ this._viewConfigs = [];
            /** @hidden */ this._viewConfigFactories = {};
            /** @hidden */ this._listeners = [];
            /** @internalapi */
            this._pluginapi = {
                _rootViewContext: this._rootViewContext.bind(this),
                _viewConfigFactory: this._viewConfigFactory.bind(this),
                _registeredUIView: function (id) { return find(_this._uiViews, function (view) { return _this.router.$id + "." + view.id === id; }); },
                _registeredUIViews: function () { return _this._uiViews; },
                _activeViewConfigs: function () { return _this._viewConfigs; },
                _onSync: function (listener) {
                    _this._listeners.push(listener);
                    return function () { return removeFrom(_this._listeners, listener); };
                },
            };
        }
        /**
         * Normalizes a view's name from a state.views configuration block.
         *
         * This should be used by a framework implementation to calculate the values for
         * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].
         *
         * @param context the context object (state declaration) that the view belongs to
         * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
         *
         * @returns the normalized uiViewName and uiViewContextAnchor that the view targets
         */
        ViewService.normalizeUIViewTarget = function (context, rawViewName) {
            if (rawViewName === void 0) { rawViewName = ''; }
            // TODO: Validate incoming view name with a regexp to allow:
            // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
            // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
            var viewAtContext = rawViewName.split('@');
            var uiViewName = viewAtContext[0] || '$default'; // default to unnamed view
            var uiViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : '^'; // default to parent context
            // Handle relative view-name sugar syntax.
            // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
            var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
            if (relativeViewNameSugar) {
                // Clobbers existing contextAnchor (rawViewName validation will fix this)
                uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
                uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
            }
            if (uiViewName.charAt(0) === '!') {
                uiViewName = uiViewName.substr(1);
                uiViewContextAnchor = ''; // target absolutely from root
            }
            // handle parent relative targeting "^.^.^"
            var relativeMatch = /^(\^(?:\.\^)*)$/;
            if (relativeMatch.exec(uiViewContextAnchor)) {
                var anchorState = uiViewContextAnchor.split('.').reduce(function (anchor, x) { return anchor.parent; }, context);
                uiViewContextAnchor = anchorState.name;
            }
            else if (uiViewContextAnchor === '.') {
                uiViewContextAnchor = context.name;
            }
            return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
        };
        /** @hidden */
        ViewService.prototype._rootViewContext = function (context) {
            return (this._rootContext = context || this._rootContext);
        };
        /** @hidden */
        ViewService.prototype._viewConfigFactory = function (viewType, factory) {
            this._viewConfigFactories[viewType] = factory;
        };
        ViewService.prototype.createViewConfig = function (path, decl) {
            var cfgFactory = this._viewConfigFactories[decl.$type];
            if (!cfgFactory)
                throw new Error('ViewService: No view config factory registered for type ' + decl.$type);
            var cfgs = cfgFactory(path, decl);
            return isArray(cfgs) ? cfgs : [cfgs];
        };
        /**
         * Deactivates a ViewConfig.
         *
         * This function deactivates a `ViewConfig`.
         * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.
         *
         * @param viewConfig The ViewConfig view to deregister.
         */
        ViewService.prototype.deactivateViewConfig = function (viewConfig) {
            trace.traceViewServiceEvent('<- Removing', viewConfig);
            removeFrom(this._viewConfigs, viewConfig);
        };
        ViewService.prototype.activateViewConfig = function (viewConfig) {
            trace.traceViewServiceEvent('-> Registering', viewConfig);
            this._viewConfigs.push(viewConfig);
        };
        ViewService.prototype.sync = function () {
            var _this = this;
            var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(applyPairs, {});
            // Return a weighted depth value for a uiView.
            // The depth is the nesting depth of ui-views (based on FQN; times 10,000)
            // plus the depth of the state that is populating the uiView
            function uiViewDepth(uiView) {
                var stateDepth = function (context) { return (context && context.parent ? stateDepth(context.parent) + 1 : 1); };
                return uiView.fqn.split('.').length * 10000 + stateDepth(uiView.creationContext);
            }
            // Return the ViewConfig's context's depth in the context tree.
            function viewConfigDepth(config) {
                var context = config.viewDecl.$context, count = 0;
                while (++count && context.parent)
                    context = context.parent;
                return count;
            }
            // Given a depth function, returns a compare function which can return either ascending or descending order
            var depthCompare = curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
            var matchingConfigPair = function (uiView) {
                var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
                if (matchingConfigs.length > 1) {
                    // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)
                    // Sort by depth and return the match from the deepest child
                    // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);
                    matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
                }
                return { uiView: uiView, viewConfig: matchingConfigs[0] };
            };
            var configureUIView = function (tuple) {
                // If a parent ui-view is reconfigured, it could destroy child ui-views.
                // Before configuring a child ui-view, make sure it's still in the active uiViews array.
                if (_this._uiViews.indexOf(tuple.uiView) !== -1)
                    tuple.uiView.configUpdated(tuple.viewConfig);
            };
            // Sort views by FQN and state depth. Process uiviews nearest the root first.
            var uiViewTuples = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);
            var matchedViewConfigs = uiViewTuples.map(function (tuple) { return tuple.viewConfig; });
            var unmatchedConfigTuples = this._viewConfigs
                .filter(function (config) { return !inArray(matchedViewConfigs, config); })
                .map(function (viewConfig) { return ({ uiView: undefined, viewConfig: viewConfig }); });
            uiViewTuples.forEach(configureUIView);
            var allTuples = uiViewTuples.concat(unmatchedConfigTuples);
            this._listeners.forEach(function (cb) { return cb(allTuples); });
            trace.traceViewSync(allTuples);
        };
        /**
         * Registers a `ui-view` component
         *
         * When a `ui-view` component is created, it uses this method to register itself.
         * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].
         *
         * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,
         * and what the view's state context is.
         *
         * Note: There is no corresponding `deregisterUIView`.
         *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
         *
         * @param uiView The metadata for a UIView
         * @return a de-registration function used when the view is destroyed.
         */
        ViewService.prototype.registerUIView = function (uiView) {
            trace.traceViewServiceUIViewEvent('-> Registering', uiView);
            var uiViews = this._uiViews;
            var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };
            if (uiViews.filter(fqnAndTypeMatches).length)
                trace.traceViewServiceUIViewEvent('!!!! duplicate uiView named:', uiView);
            uiViews.push(uiView);
            this.sync();
            return function () {
                var idx = uiViews.indexOf(uiView);
                if (idx === -1) {
                    trace.traceViewServiceUIViewEvent('Tried removing non-registered uiView', uiView);
                    return;
                }
                trace.traceViewServiceUIViewEvent('<- Deregistering', uiView);
                removeFrom(uiViews)(uiView);
            };
        };
        /**
         * Returns the list of views currently available on the page, by fully-qualified name.
         *
         * @return {Array} Returns an array of fully-qualified view names.
         */
        ViewService.prototype.available = function () {
            return this._uiViews.map(prop('fqn'));
        };
        /**
         * Returns the list of views on the page containing loaded content.
         *
         * @return {Array} Returns an array of fully-qualified view names.
         */
        ViewService.prototype.active = function () {
            return this._uiViews.filter(prop('$config')).map(prop('name'));
        };
        /**
         * Given a ui-view and a ViewConfig, determines if they "match".
         *
         * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
         * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
         *
         * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
         * can be a segmented ui-view path, describing a portion of a ui-view fqn.
         *
         * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type
         *
         * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
         * - the ui-view's name matches the ViewConfig's target name
         * - the ui-view's context matches the ViewConfig's anchor
         *
         * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
         * - There exists a parent ui-view where:
         *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
         *    - the parent ui-view's context matches the ViewConfig's anchor
         * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
         *
         * Example:
         *
         * DOM:
         * <ui-view>                        <!-- created in the root context (name: "") -->
         *   <ui-view name="foo">                <!-- created in the context named: "A"      -->
         *     <ui-view>                    <!-- created in the context named: "A.B"    -->
         *       <ui-view name="bar">            <!-- created in the context named: "A.B.C"  -->
         *       </ui-view>
         *     </ui-view>
         *   </ui-view>
         * </ui-view>
         *
         * uiViews: [
         *  { fqn: "$default",                  creationContext: { name: "" } },
         *  { fqn: "$default.foo",              creationContext: { name: "A" } },
         *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
         *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
         * ]
         *
         * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
         *
         * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
         * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
         * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
         * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
         *
         * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
         * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
         * - There exists a parent ui-view (which has fqn: "$default.foo") where:
         *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
         *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
         * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
         *   the tail of the ui-view's fqn "default.bar"
         *
         * @internalapi
         */
        ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {
            // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc
            if (uiView.$type !== viewConfig.viewDecl.$type)
                return false;
            // Split names apart from both viewConfig and uiView into segments
            var vc = viewConfig.viewDecl;
            var vcSegments = vc.$uiViewName.split('.');
            var uivSegments = uiView.fqn.split('.');
            // Check if the tails of the segment arrays match. ex, these arrays' tails match:
            // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
            if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
                return false;
            // Now check if the fqn ending at the first segment of the viewConfig matches the context:
            // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
            var negOffset = 1 - vcSegments.length || undefined;
            var fqnToFirstSegment = uivSegments.slice(0, negOffset).join('.');
            var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
            return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
        }; };
        return ViewService;
    }());

    /** @publicapi @module core */ /** */
    /**
     * Global router state
     *
     * This is where we hold the global mutable state such as current state, current
     * params, current transition, etc.
     */
    var UIRouterGlobals = /** @class */ (function () {
        function UIRouterGlobals() {
            /**
             * Current parameter values
             *
             * The parameter values from the latest successful transition
             */
            this.params = new StateParams();
            /** @internalapi */
            this.lastStartedTransitionId = -1;
            /** @internalapi */
            this.transitionHistory = new Queue([], 1);
            /** @internalapi */
            this.successfulTransitions = new Queue([], 1);
        }
        UIRouterGlobals.prototype.dispose = function () {
            this.transitionHistory.clear();
            this.successfulTransitions.clear();
            this.transition = null;
        };
        return UIRouterGlobals;
    }());

    /** @hidden */
    var prioritySort = function (a, b) { return (b.priority || 0) - (a.priority || 0); };
    /** @hidden */
    var typeSort = function (a, b) {
        var weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
        return (weights[a.type] || 0) - (weights[b.type] || 0);
    };
    /** @hidden */
    var urlMatcherSort = function (a, b) {
        return !a.urlMatcher || !b.urlMatcher ? 0 : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);
    };
    /** @hidden */
    var idSort = function (a, b) {
        // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL
        var useMatchPriority = { STATE: true, URLMATCHER: true };
        var equal = useMatchPriority[a.type] && useMatchPriority[b.type];
        return equal ? 0 : (a.$id || 0) - (b.$id || 0);
    };
    /**
     * Default rule priority sorting function.
     *
     * Sorts rules by:
     *
     * - Explicit priority (set rule priority using [[UrlRules.when]])
     * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
     * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
     * - Rule registration order (for rule types other than STATE and URLMATCHER)
     *   - Equally sorted State and UrlMatcher rules will each match the URL.
     *     Then, the *best* match is chosen based on how many parameter values were matched.
     *
     * @publicapi
     */
    var defaultRuleSortFn;
    defaultRuleSortFn = function (a, b) {
        var cmp = prioritySort(a, b);
        if (cmp !== 0)
            return cmp;
        cmp = typeSort(a, b);
        if (cmp !== 0)
            return cmp;
        cmp = urlMatcherSort(a, b);
        if (cmp !== 0)
            return cmp;
        return idSort(a, b);
    };
    /** @hidden */
    function getHandlerFn(handler) {
        if (!isFunction(handler) && !isString(handler) && !is(TargetState)(handler) && !TargetState.isDef(handler)) {
            throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
        }
        return isFunction(handler) ? handler : val(handler);
    }
    /**
     * API for managing URL rules
     *
     * This API is used to create and manage URL rules.
     * URL rules are a mechanism to respond to specific URL patterns.
     *
     * The most commonly used methods are [[otherwise]] and [[when]].
     *
     * This API is a property of [[UrlService]] as [[UrlService.rules]]
     *
     * @publicapi
     */
    var UrlRules = /** @class */ (function () {
        /** @hidden */
        function UrlRules(/** @hidden */ router) {
            this.router = router;
            /** @hidden */ this._sortFn = defaultRuleSortFn;
            /** @hidden */ this._rules = [];
            /** @hidden */ this._id = 0;
            this.urlRuleFactory = new UrlRuleFactory(router);
        }
        /** @hidden */
        UrlRules.prototype.dispose = function (router) {
            this._rules = [];
            delete this._otherwiseFn;
        };
        /**
         * Defines the initial state, path, or behavior to use when the app starts.
         *
         * This rule defines the initial/starting state for the application.
         *
         * This rule is triggered the first time the URL is checked (when the app initially loads).
         * The rule is triggered only when the url matches either `""` or `"/"`.
         *
         * Note: The rule is intended to be used when the root of the application is directly linked to.
         * When the URL is *not* `""` or `"/"` and doesn't match other rules, the [[otherwise]] rule is triggered.
         * This allows 404-like behavior when an unknown URL is deep-linked.
         *
         * #### Example:
         * Start app at `home` state.
         * ```js
         * .initial({ state: 'home' });
         * ```
         *
         * #### Example:
         * Start app at `/home` (by url)
         * ```js
         * .initial('/home');
         * ```
         *
         * #### Example:
         * When no other url rule matches, go to `home` state
         * ```js
         * .initial((matchValue, url, router) => {
         *   console.log('initial state');
         *   return { state: 'home' };
         * })
         * ```
         *
         * @param handler The initial state or url path, or a function which returns the state or url path (or performs custom logic).
         */
        UrlRules.prototype.initial = function (handler) {
            var handlerFn = getHandlerFn(handler);
            var matchFn = function (urlParts, router) {
                return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
            };
            this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
        };
        /**
         * Defines the state, url, or behavior to use when no other rule matches the URL.
         *
         * This rule is matched when *no other rule* matches.
         * It is generally used to handle unknown URLs (similar to "404" behavior, but on the client side).
         *
         * - If `handler` a string, it is treated as a url redirect
         *
         * #### Example:
         * When no other url rule matches, redirect to `/index`
         * ```js
         * .otherwise('/index');
         * ```
         *
         * - If `handler` is an object with a `state` property, the state is activated.
         *
         * #### Example:
         * When no other url rule matches, redirect to `home` and provide a `dashboard` parameter value.
         * ```js
         * .otherwise({ state: 'home', params: { dashboard: 'default' } });
         * ```
         *
         * - If `handler` is a function, the function receives the current url ([[UrlParts]]) and the [[UIRouter]] object.
         *   The function can perform actions, and/or return a value.
         *
         * #### Example:
         * When no other url rule matches, manually trigger a transition to the `home` state
         * ```js
         * .otherwise((matchValue, urlParts, router) => {
         *   router.stateService.go('home');
         * });
         * ```
         *
         * #### Example:
         * When no other url rule matches, go to `home` state
         * ```js
         * .otherwise((matchValue, urlParts, router) => {
         *   return { state: 'home' };
         * });
         * ```
         *
         * @param handler The url path to redirect to, or a function which returns the url path (or performs custom logic).
         */
        UrlRules.prototype.otherwise = function (handler) {
            var handlerFn = getHandlerFn(handler);
            this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);
            this._sorted = false;
        };
        /**
         * Remove a rule previously registered
         *
         * @param rule the matcher rule that was previously registered using [[rule]]
         */
        UrlRules.prototype.removeRule = function (rule) {
            removeFrom(this._rules, rule);
        };
        /**
         * Manually adds a URL Rule.
         *
         * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
         * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
         * Rules can be created using [[urlRuleFactory]], or created manually as simple objects.
         *
         * A rule should have a `match` function which returns truthy if the rule matched.
         * It should also have a `handler` function which is invoked if the rule is the best match.
         *
         * @return a function that deregisters the rule
         */
        UrlRules.prototype.rule = function (rule) {
            var _this = this;
            if (!UrlRuleFactory.isUrlRule(rule))
                throw new Error('invalid rule');
            rule.$id = this._id++;
            rule.priority = rule.priority || 0;
            this._rules.push(rule);
            this._sorted = false;
            return function () { return _this.removeRule(rule); };
        };
        /**
         * Gets all registered rules
         *
         * @returns an array of all the registered rules
         */
        UrlRules.prototype.rules = function () {
            this.ensureSorted();
            return this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : []);
        };
        /**
         * Defines URL Rule priorities
         *
         * More than one rule ([[UrlRule]]) might match a given URL.
         * This `compareFn` is used to sort the rules by priority.
         * Higher priority rules should sort earlier.
         *
         * The [[defaultRuleSortFn]] is used by default.
         *
         * You only need to call this function once.
         * The `compareFn` will be used to sort the rules as each is registered.
         *
         * If called without any parameter, it will re-sort the rules.
         *
         * ---
         *
         * Url rules may come from multiple sources: states's urls ([[StateDeclaration.url]]), [[when]], and [[rule]].
         * Each rule has a (user-provided) [[UrlRule.priority]], a [[UrlRule.type]], and a [[UrlRule.$id]]
         * The `$id` is is the order in which the rule was registered.
         *
         * The sort function should use these data, or data found on a specific type
         * of [[UrlRule]] (such as [[StateRule.state]]), to order the rules as desired.
         *
         * #### Example:
         * This compare function prioritizes rules by the order in which the rules were registered.
         * A rule registered earlier has higher priority.
         *
         * ```js
         * function compareFn(a, b) {
         *   return a.$id - b.$id;
         * }
         * ```
         *
         * @param compareFn a function that compares to [[UrlRule]] objects.
         *    The `compareFn` should abide by the `Array.sort` compare function rules.
         *    Given two rules, `a` and `b`, return a negative number if `a` should be higher priority.
         *    Return a positive number if `b` should be higher priority.
         *    Return `0` if the rules are identical.
         *
         *    See the [mozilla reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description)
         *    for details.
         */
        UrlRules.prototype.sort = function (compareFn) {
            var sorted = this.stableSort(this._rules, (this._sortFn = compareFn || this._sortFn));
            // precompute _sortGroup values and apply to each rule
            var group = 0;
            for (var i = 0; i < sorted.length; i++) {
                sorted[i]._group = group;
                if (i < sorted.length - 1 && this._sortFn(sorted[i], sorted[i + 1]) !== 0) {
                    group++;
                }
            }
            this._rules = sorted;
            this._sorted = true;
        };
        /** @hidden */
        UrlRules.prototype.ensureSorted = function () {
            this._sorted || this.sort();
        };
        /** @hidden */
        UrlRules.prototype.stableSort = function (arr, compareFn) {
            var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });
            arrOfWrapper.sort(function (wrapperA, wrapperB) {
                var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
                return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
            });
            return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });
        };
        /**
         * Registers a `matcher` and `handler` for custom URLs handling.
         *
         * The `matcher` can be:
         *
         * - a [[UrlMatcher]]: See: [[UrlMatcherFactory.compile]]
         * - a `string`: The string is compiled to a [[UrlMatcher]]
         * - a `RegExp`: The regexp is used to match the url.
         *
         * The `handler` can be:
         *
         * - a string: The url is redirected to the value of the string.
         * - a function: The url is redirected to the return value of the function.
         *
         * ---
         *
         * When the `handler` is a `string` and the `matcher` is a `UrlMatcher` (or string), the redirect
         * string is interpolated with parameter values.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when("/foo/:param1", "/bar/:param1")
         * ```
         *
         * ---
         *
         * When the `handler` is a string and the `matcher` is a `RegExp`, the redirect string is
         * interpolated with capture groups from the RegExp.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when(new RegExp("^/foo/(.*)$"), "/bar/$1");
         * ```
         *
         * ---
         *
         * When the handler is a function, it receives the matched value, the current URL, and the `UIRouter` object (See [[UrlRuleHandlerFn]]).
         * The "matched value" differs based on the `matcher`.
         * For [[UrlMatcher]]s, it will be the matched state params.
         * For `RegExp`, it will be the match array from `regexp.exec()`.
         *
         * If the handler returns a string, the URL is redirected to the string.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when(new RegExp("^/foo/(.*)$"), match => "/bar/" + match[1]);
         * ```
         *
         * Note: the `handler` may also invoke arbitrary code, such as `$state.go()`
         *
         * @param matcher A pattern `string` to match, compiled as a [[UrlMatcher]], or a `RegExp`.
         * @param handler The path to redirect to, or a function that returns the path.
         * @param options `{ priority: number }`
         *
         * @return the registered [[UrlRule]]
         */
        UrlRules.prototype.when = function (matcher, handler, options) {
            var rule = this.urlRuleFactory.create(matcher, handler);
            if (isDefined(options && options.priority))
                rule.priority = options.priority;
            this.rule(rule);
            return rule;
        };
        return UrlRules;
    }());

    /**
     * An API to customize the URL behavior and retrieve URL configuration
     *
     * This API is used to customize the behavior of the URL.
     * This includes optional trailing slashes ([[strictMode]]), case sensitivity ([[caseInsensitive]]),
     * and custom parameter encoding (custom [[type]]).
     *
     * It also has information about the location (url) configuration such as [[port]] and [[baseHref]].
     * This information can be used to build absolute URLs, such as
     * `https://example.com:443/basepath/state/substate?param1=a#hashvalue`;
     *
     * This API is a property of [[UrlService]] as [[UrlService.config]].
     */
    var UrlConfig = /** @class */ (function () {
        /** @hidden */ function UrlConfig(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @hidden */ this.paramTypes = new ParamTypes();
            /** @hidden */ this._isCaseInsensitive = false;
            /** @hidden */ this._isStrictMode = true;
            /** @hidden */ this._defaultSquashPolicy = false;
            /** @internalapi */ this.dispose = function () { return _this.paramTypes.dispose(); };
            // Delegate these calls to the current LocationConfig implementation
            /**
             * Gets the base Href, e.g., `http://localhost/approot/`
             *
             * @return the application's base href
             */
            this.baseHref = function () { return _this.router.locationConfig.baseHref(); };
            /**
             * Gets or sets the hashPrefix
             *
             * This only applies when not running in [[html5Mode]] (pushstate mode)
             *
             * If the current url is `http://localhost/app#!/uirouter/path/#anchor`, it returns `!` which is the prefix for the "hashbang" portion.
             *
             * @return the hash prefix
             */
            this.hashPrefix = function (newprefix) { return _this.router.locationConfig.hashPrefix(newprefix); };
            /**
             * Gets the host, e.g., `localhost`
             *
             * @return the protocol
             */
            this.host = function () { return _this.router.locationConfig.host(); };
            /**
             * Returns true when running in pushstate mode
             *
             * @return true when running in html5 mode (pushstate mode).
             */
            this.html5Mode = function () { return _this.router.locationConfig.html5Mode(); };
            /**
             * Gets the port, e.g., `80`
             *
             * @return the port number
             */
            this.port = function () { return _this.router.locationConfig.port(); };
            /**
             * Gets the protocol, e.g., `http`
             *
             * @return the protocol
             */
            this.protocol = function () { return _this.router.locationConfig.protocol(); };
        }
        /**
         * Defines whether URL matching should be case sensitive (the default behavior), or not.
         *
         * #### Example:
         * ```js
         * // Allow case insensitive url matches
         * urlService.config.caseInsensitive(true);
         * ```
         *
         * @param value `false` to match URL in a case sensitive manner; otherwise `true`;
         * @returns the current value of caseInsensitive
         */
        UrlConfig.prototype.caseInsensitive = function (value) {
            return (this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive);
        };
        /**
         * Sets the default behavior when generating or matching URLs with default parameter values.
         *
         * #### Example:
         * ```js
         * // Remove default parameter values from the url
         * urlService.config.defaultSquashPolicy(true);
         * ```
         *
         * @param value A string that defines the default parameter URL squashing behavior.
         *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
         *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
         *      parameter is surrounded by slashes, squash (remove) one slash from the URL
         *    - any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
         *      the parameter value from the URL and replace it with this string.
         * @returns the current value of defaultSquashPolicy
         */
        UrlConfig.prototype.defaultSquashPolicy = function (value) {
            if (isDefined(value) && value !== true && value !== false && !isString(value))
                throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return (this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy);
        };
        /**
         * Defines whether URLs should match trailing slashes, or not (the default behavior).
         *
         * #### Example:
         * ```js
         * // Allow optional trailing slashes
         * urlService.config.strictMode(false);
         * ```
         *
         * @param value `false` to match trailing slashes in URLs, otherwise `true`.
         * @returns the current value of strictMode
         */
        UrlConfig.prototype.strictMode = function (value) {
            return (this._isStrictMode = isDefined(value) ? value : this._isStrictMode);
        };
        /**
         * Creates and registers a custom [[ParamType]] object
         *
         * A custom parameter type can be used to generate URLs with typed parameters or custom encoding/decoding.
         *
         * #### Note: Register custom types *before using them* in a state definition.
         *
         * #### Example:
         * ```js
         * // Encode object parameter as JSON string
         * urlService.config.type('myjson', {
         *   encode: (obj) => JSON.stringify(obj),
         *   decode: (str) => JSON.parse(str),
         *   is: (val) => typeof(val) === 'object',
         *   pattern: /[^/]+/,
         *   equals: (a, b) => _.isEqual(a, b),
         * });
         * ```
         *
         * See [[ParamTypeDefinition]] for more examples
         *
         * @param name The type name.
         * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
         * @param definitionFn A function that is injected before the app runtime starts.
         *        The result of this function should be a [[ParamTypeDefinition]].
         *        The result is merged into the existing `definition`.
         *        See [[ParamType]] for information on the values accepted.
         *
         * @returns if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
         */
        UrlConfig.prototype.type = function (name, definition, definitionFn) {
            var type = this.paramTypes.type(name, definition, definitionFn);
            return !isDefined(definition) ? type : this;
        };
        return UrlConfig;
    }());

    /** API for URL management */
    var UrlService = /** @class */ (function () {
        /** @hidden */
        function UrlService(/** @hidden */ router) {
            var _this = this;
            this.router = router;
            /** @hidden */ this.interceptDeferred = false;
            /**
             * The nested [[UrlRules]] API for managing URL rules and rewrites
             *
             * See: [[UrlRules]] for details
             */
            this.rules = new UrlRules(this.router);
            /**
             * The nested [[UrlConfig]] API to configure the URL and retrieve URL information
             *
             * See: [[UrlConfig]] for details
             */
            this.config = new UrlConfig(this.router);
            // Delegate these calls to the current LocationServices implementation
            /**
             * Gets the current url, or updates the url
             *
             * ### Getting the current URL
             *
             * When no arguments are passed, returns the current URL.
             * The URL is normalized using the internal [[path]]/[[search]]/[[hash]] values.
             *
             * For example, the URL may be stored in the hash ([[HashLocationServices]]) or
             * have a base HREF prepended ([[PushStateLocationServices]]).
             *
             * The raw URL in the browser might be:
             *
             * ```
             * http://mysite.com/somepath/index.html#/internal/path/123?param1=foo#anchor
             * ```
             *
             * or
             *
             * ```
             * http://mysite.com/basepath/internal/path/123?param1=foo#anchor
             * ```
             *
             * then this method returns:
             *
             * ```
             * /internal/path/123?param1=foo#anchor
             * ```
             *
             *
             * #### Example:
             * ```js
             * locationServices.url(); // "/some/path?query=value#anchor"
             * ```
             *
             * ### Updating the URL
             *
             * When `newurl` arguments is provided, changes the URL to reflect `newurl`
             *
             * #### Example:
             * ```js
             * locationServices.url("/some/path?query=value#anchor", true);
             * ```
             *
             * @param newurl The new value for the URL.
             *               This url should reflect only the new internal [[path]], [[search]], and [[hash]] values.
             *               It should not include the protocol, site, port, or base path of an absolute HREF.
             * @param replace When true, replaces the current history entry (instead of appending it) with this new url
             * @param state The history's state object, i.e., pushState (if the LocationServices implementation supports it)
             *
             * @return the url (after potentially being processed)
             */
            this.url = function (newurl, replace, state) {
                return _this.router.locationService.url(newurl, replace, state);
            };
            /**
             * Gets the path part of the current url
             *
             * If the current URL is `/some/path?query=value#anchor`, this returns `/some/path`
             *
             * @return the path portion of the url
             */
            this.path = function () { return _this.router.locationService.path(); };
            /**
             * Gets the search part of the current url as an object
             *
             * If the current URL is `/some/path?query=value#anchor`, this returns `{ query: 'value' }`
             *
             * @return the search (query) portion of the url, as an object
             */
            this.search = function () { return _this.router.locationService.search(); };
            /**
             * Gets the hash part of the current url
             *
             * If the current URL is `/some/path?query=value#anchor`, this returns `anchor`
             *
             * @return the hash (anchor) portion of the url
             */
            this.hash = function () { return _this.router.locationService.hash(); };
            /**
             * @internalapi
             *
             * Registers a low level url change handler
             *
             * Note: Because this is a low level handler, it's not recommended for general use.
             *
             * #### Example:
             * ```js
             * let deregisterFn = locationServices.onChange((evt) => console.log("url change", evt));
             * ```
             *
             * @param callback a function that will be called when the url is changing
             * @return a function that de-registers the callback
             */
            this.onChange = function (callback) { return _this.router.locationService.onChange(callback); };
        }
        /** @hidden */
        UrlService.prototype.dispose = function () {
            this.listen(false);
            this.rules.dispose();
        };
        /**
         * Gets the current URL parts
         *
         * This method returns the different parts of the current URL (the [[path]], [[search]], and [[hash]]) as a [[UrlParts]] object.
         */
        UrlService.prototype.parts = function () {
            return { path: this.path(), search: this.search(), hash: this.hash() };
        };
        /**
         * Activates the best rule for the current URL
         *
         * Checks the current URL for a matching [[UrlRule]], then invokes that rule's handler.
         * This method is called internally any time the URL has changed.
         *
         * This effectively activates the state (or redirect, etc) which matches the current URL.
         *
         * #### Example:
         * ```js
         * urlService.deferIntercept();
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   urlService.listen();
         *   // Find the matching URL and invoke the handler.
         *   urlService.sync();
         * });
         * ```
         */
        UrlService.prototype.sync = function (evt) {
            if (evt && evt.defaultPrevented)
                return;
            var _a = this.router, urlService = _a.urlService, stateService = _a.stateService;
            var url = { path: urlService.path(), search: urlService.search(), hash: urlService.hash() };
            var best = this.match(url);
            var applyResult = pattern([
                [isString, function (newurl) { return urlService.url(newurl, true); }],
                [TargetState.isDef, function (def) { return stateService.go(def.state, def.params, def.options); }],
                [is(TargetState), function (target) { return stateService.go(target.state(), target.params(), target.options()); }],
            ]);
            applyResult(best && best.rule.handler(best.match, url, this.router));
        };
        /**
         * Starts or stops listening for URL changes
         *
         * Call this sometime after calling [[deferIntercept]] to start monitoring the url.
         * This causes UI-Router to start listening for changes to the URL, if it wasn't already listening.
         *
         * If called with `false`, UI-Router will stop listening (call listen(true) to start listening again).
         *
         * #### Example:
         * ```js
         * urlService.deferIntercept();
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   // Start responding to URL changes
         *   urlService.listen();
         *   urlService.sync();
         * });
         * ```
         *
         * @param enabled `true` or `false` to start or stop listening to URL changes
         */
        UrlService.prototype.listen = function (enabled) {
            var _this = this;
            if (enabled === false) {
                this._stopListeningFn && this._stopListeningFn();
                delete this._stopListeningFn;
            }
            else {
                return (this._stopListeningFn = this._stopListeningFn || this.router.urlService.onChange(function (evt) { return _this.sync(evt); }));
            }
        };
        /**
         * Disables monitoring of the URL.
         *
         * Call this method before UI-Router has bootstrapped.
         * It will stop UI-Router from performing the initial url sync.
         *
         * This can be useful to perform some asynchronous initialization before the router starts.
         * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.
         *
         * #### Example:
         * ```js
         * // Prevent UI-Router from automatically intercepting URL changes when it starts;
         * urlService.deferIntercept();
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   urlService.listen();
         *   urlService.sync();
         * });
         * ```
         *
         * @param defer Indicates whether to defer location change interception.
         *        Passing no parameter is equivalent to `true`.
         */
        UrlService.prototype.deferIntercept = function (defer) {
            if (defer === undefined)
                defer = true;
            this.interceptDeferred = defer;
        };
        /**
         * Matches a URL
         *
         * Given a URL (as a [[UrlParts]] object), check all rules and determine the best matching rule.
         * Return the result as a [[MatchResult]].
         */
        UrlService.prototype.match = function (url) {
            var _this = this;
            url = extend({ path: '', search: {}, hash: '' }, url);
            var rules = this.rules.rules();
            // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
            var checkRule = function (rule) {
                var match = rule.match(url, _this.router);
                return match && { match: match, rule: rule, weight: rule.matchPriority(match) };
            };
            // The rules are pre-sorted.
            // - Find the first matching rule.
            // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
            // - Choose the rule with the highest match weight.
            var best;
            for (var i = 0; i < rules.length; i++) {
                // Stop when there is a 'best' rule and the next rule sorts differently than it.
                if (best && best.rule._group !== rules[i]._group)
                    break;
                var current = checkRule(rules[i]);
                // Pick the best MatchResult
                best = !best || (current && current.weight > best.weight) ? current : best;
            }
            return best;
        };
        return UrlService;
    }());

    /** @publicapi @module core */ /** */
    /** @hidden */
    var _routerInstance = 0;
    /** @hidden */
    var locSvcFns = ['url', 'path', 'search', 'hash', 'onChange'];
    /** @hidden */
    var locCfgFns = ['port', 'protocol', 'host', 'baseHref', 'html5Mode', 'hashPrefix'];
    /** @hidden */
    var locationServiceStub = makeStub('LocationServices', locSvcFns);
    /** @hidden */
    var locationConfigStub = makeStub('LocationConfig', locCfgFns);
    /**
     * The master class used to instantiate an instance of UI-Router.
     *
     * UI-Router (for each specific framework) will create an instance of this class during bootstrap.
     * This class instantiates and wires the UI-Router services together.
     *
     * After a new instance of the UIRouter class is created, it should be configured for your app.
     * For instance, app states should be registered with the [[UIRouter.stateRegistry]].
     *
     * ---
     *
     * Normally the framework code will bootstrap UI-Router.
     * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling
     * [[UrlService.listen]] then [[UrlService.sync]].
     */
    var UIRouter = /** @class */ (function () {
        /**
         * Creates a new `UIRouter` object
         *
         * @param locationService a [[LocationServices]] implementation
         * @param locationConfig a [[LocationConfig]] implementation
         * @internalapi
         */
        function UIRouter(locationService, locationConfig) {
            if (locationService === void 0) { locationService = locationServiceStub; }
            if (locationConfig === void 0) { locationConfig = locationConfigStub; }
            this.locationService = locationService;
            this.locationConfig = locationConfig;
            /** @hidden */ this.$id = _routerInstance++;
            /** @hidden */ this._disposed = false;
            /** @hidden */ this._disposables = [];
            /** Provides trace information to the console */
            this.trace = trace;
            /** Provides services related to ui-view synchronization */
            this.viewService = new ViewService(this);
            /** Global router state */
            this.globals = new UIRouterGlobals();
            /** Provides services related to Transitions */
            this.transitionService = new TransitionService(this);
            /**
             * Deprecated for public use. Use [[urlService]] instead.
             * @deprecated Use [[urlService]] instead
             */
            this.urlMatcherFactory = new UrlMatcherFactory(this);
            /**
             * Deprecated for public use. Use [[urlService]] instead.
             * @deprecated Use [[urlService]] instead
             */
            this.urlRouter = new UrlRouter(this);
            /** Provides services related to the URL */
            this.urlService = new UrlService(this);
            /** Provides a registry for states, and related registration services */
            this.stateRegistry = new StateRegistry(this);
            /** Provides services related to states */
            this.stateService = new StateService(this);
            /** @hidden plugin instances are registered here */
            this._plugins = {};
            this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
            this.globals.$current = this.stateRegistry.root();
            this.globals.current = this.globals.$current.self;
            this.disposable(this.globals);
            this.disposable(this.stateService);
            this.disposable(this.stateRegistry);
            this.disposable(this.transitionService);
            this.disposable(this.urlService);
            this.disposable(locationService);
            this.disposable(locationConfig);
        }
        /** Registers an object to be notified when the router is disposed */
        UIRouter.prototype.disposable = function (disposable) {
            this._disposables.push(disposable);
        };
        /**
         * Disposes this router instance
         *
         * When called, clears resources retained by the router by calling `dispose(this)` on all
         * registered [[disposable]] objects.
         *
         * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.
         *
         * @param disposable (optional) the disposable to dispose
         */
        UIRouter.prototype.dispose = function (disposable) {
            var _this = this;
            if (disposable && isFunction(disposable.dispose)) {
                disposable.dispose(this);
                return undefined;
            }
            this._disposed = true;
            this._disposables.slice().forEach(function (d) {
                try {
                    typeof d.dispose === 'function' && d.dispose(_this);
                    removeFrom(_this._disposables, d);
                }
                catch (ignored) { }
            });
        };
        /**
         * Adds a plugin to UI-Router
         *
         * This method adds a UI-Router Plugin.
         * A plugin can enhance or change UI-Router behavior using any public API.
         *
         * #### Example:
         * ```js
         * import { MyCoolPlugin } from "ui-router-cool-plugin";
         *
         * var plugin = router.addPlugin(MyCoolPlugin);
         * ```
         *
         * ### Plugin authoring
         *
         * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.
         *
         * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].
         * For example, it may configure router options or add a Transition Hook.
         *
         * The plugin can then be published as a separate module.
         *
         * #### Example:
         * ```js
         * export class MyAuthPlugin implements UIRouterPlugin {
         *   constructor(router: UIRouter, options: any) {
         *     this.name = "MyAuthPlugin";
         *     let $transitions = router.transitionService;
         *     let $state = router.stateService;
         *
         *     let authCriteria = {
         *       to: (state) => state.data && state.data.requiresAuth
         *     };
         *
         *     function authHook(transition: Transition) {
         *       let authService = transition.injector().get('AuthService');
         *       if (!authService.isAuthenticated()) {
         *         return $state.target('login');
         *       }
         *     }
         *
         *     $transitions.onStart(authCriteria, authHook);
         *   }
         * }
         * ```
         *
         * @param plugin one of:
         *        - a plugin class which implements [[UIRouterPlugin]]
         *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance
         *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance
         * @param options options to pass to the plugin class/factory
         * @returns the registered plugin instance
         */
        UIRouter.prototype.plugin = function (plugin, options) {
            if (options === void 0) { options = {}; }
            var pluginInstance = new plugin(this, options);
            if (!pluginInstance.name)
                throw new Error('Required property `name` missing on plugin: ' + pluginInstance);
            this._disposables.push(pluginInstance);
            return (this._plugins[pluginInstance.name] = pluginInstance);
        };
        UIRouter.prototype.getPlugin = function (pluginName) {
            return pluginName ? this._plugins[pluginName] : values(this._plugins);
        };
        return UIRouter;
    }());

    /** @internalapi @module hooks */ /** */
    function addCoreResolvables(trans) {
        trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');
        trans.addResolvable(Resolvable.fromData(Transition, trans), '');
        trans.addResolvable(Resolvable.fromData('$transition$', trans), '');
        trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');
        trans.entering().forEach(function (state) {
            trans.addResolvable(Resolvable.fromData('$state$', state), state);
        });
    }
    var registerAddCoreResolvables = function (transitionService) {
        return transitionService.onCreate({}, addCoreResolvables);
    };
    var TRANSITION_TOKENS = ['$transition$', Transition];
    var isTransition = inArray(TRANSITION_TOKENS);
    // References to Transition in the treeChanges pathnodes makes all
    // previous Transitions reachable in memory, causing a memory leak
    // This function removes resolves for '$transition$' and `Transition` from the treeChanges.
    // Do not use this on current transitions, only on old ones.
    var treeChangesCleanup = function (trans) {
        var nodes = values(trans.treeChanges())
            .reduce(unnestR, [])
            .reduce(uniqR, []);
        // If the resolvable is a Transition, return a new resolvable with null data
        var replaceTransitionWithNull = function (r) {
            return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;
        };
        nodes.forEach(function (node) {
            node.resolvables = node.resolvables.map(replaceTransitionWithNull);
        });
    };

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] that redirects to a different state or params
     *
     * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
     *
     * See [[StateDeclaration.redirectTo]]
     */
    var redirectToHook = function (trans) {
        var redirect = trans.to().redirectTo;
        if (!redirect)
            return;
        var $state = trans.router.stateService;
        function handleResult(result) {
            if (!result)
                return;
            if (result instanceof TargetState)
                return result;
            if (isString(result))
                return $state.target(result, trans.params(), trans.options());
            if (result['state'] || result['params'])
                return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());
        }
        if (isFunction(redirect)) {
            return services.$q.when(redirect(trans)).then(handleResult);
        }
        return handleResult(redirect);
    };
    var registerRedirectToHook = function (transitionService) {
        return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);
    };

    /**
     * A factory which creates an onEnter, onExit or onRetain transition hook function
     *
     * The returned function invokes the (for instance) state.onEnter hook when the
     * state is being entered.
     *
     * @hidden
     */
    function makeEnterExitRetainHook(hookName) {
        return function (transition, state) {
            var _state = state.$$state();
            var hookFn = _state[hookName];
            return hookFn(transition, state);
        };
    }
    /**
     * The [[TransitionStateHookFn]] for onExit
     *
     * When the state is being exited, the state's .onExit function is invoked.
     *
     * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
     *
     * See: [[IHookRegistry.onExit]]
     */
    var onExitHook = makeEnterExitRetainHook('onExit');
    var registerOnExitHook = function (transitionService) {
        return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);
    };
    /**
     * The [[TransitionStateHookFn]] for onRetain
     *
     * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
     *
     * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
     *
     * See: [[IHookRegistry.onRetain]]
     */
    var onRetainHook = makeEnterExitRetainHook('onRetain');
    var registerOnRetainHook = function (transitionService) {
        return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);
    };
    /**
     * The [[TransitionStateHookFn]] for onEnter
     *
     * When the state is being entered, the state's .onEnter function is invoked.
     *
     * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
     *
     * See: [[IHookRegistry.onEnter]]
     */
    var onEnterHook = makeEnterExitRetainHook('onEnter');
    var registerOnEnterHook = function (transitionService) {
        return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);
    };

    /** @internalapi @module hooks */ /** */
    var RESOLVE_HOOK_PRIORITY = 1000;
    /**
     * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
     *
     * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`
     *
     * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
     *
     * See [[StateDeclaration.resolve]]
     */
    var eagerResolvePath = function (trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);
    };
    var registerEagerResolvePath = function (transitionService) {
        return transitionService.onStart({}, eagerResolvePath, { priority: RESOLVE_HOOK_PRIORITY });
    };
    /**
     * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
     *
     * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`
     *
     * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
     *
     * See [[StateDeclaration.resolve]]
     */
    var lazyResolveState = function (trans, state) {
        return new ResolveContext(trans.treeChanges().to)
            .subContext(state.$$state())
            .resolvePath('LAZY', trans)
            .then(noop);
    };
    var registerLazyResolveState = function (transitionService) {
        return transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: RESOLVE_HOOK_PRIORITY });
    };
    /**
     * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.
     *
     * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`
     *
     * After all entering states have been entered, this hook resolves any remaining Resolvables.
     * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].
     *
     * See [[StateDeclaration.resolve]]
     */
    var resolveRemaining = function (trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);
    };
    var registerResolveRemaining = function (transitionService) {
        return transitionService.onFinish({}, resolveRemaining, { priority: RESOLVE_HOOK_PRIORITY });
    };

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] which waits for the views to load
     *
     * Registered using `transitionService.onStart({}, loadEnteringViews);`
     *
     * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
     * In angular 1, this includes loading the templates.
     */
    var loadEnteringViews = function (transition) {
        var $q = services.$q;
        var enteringViews = transition.views('entering');
        if (!enteringViews.length)
            return;
        return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(noop);
    };
    var registerLoadEnteringViews = function (transitionService) {
        return transitionService.onFinish({}, loadEnteringViews);
    };
    /**
     * A [[TransitionHookFn]] which activates the new views when a transition is successful.
     *
     * Registered using `transitionService.onSuccess({}, activateViews);`
     *
     * After a transition is complete, this hook deactivates the old views from the previous state,
     * and activates the new views from the destination state.
     *
     * See [[ViewService]]
     */
    var activateViews = function (transition) {
        var enteringViews = transition.views('entering');
        var exitingViews = transition.views('exiting');
        if (!enteringViews.length && !exitingViews.length)
            return;
        var $view = transition.router.viewService;
        exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });
        enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });
        $view.sync();
    };
    var registerActivateViews = function (transitionService) {
        return transitionService.onSuccess({}, activateViews);
    };

    /**
     * A [[TransitionHookFn]] which updates global UI-Router state
     *
     * Registered using `transitionService.onBefore({}, updateGlobalState);`
     *
     * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
     * After a successful [[Transition]], updates the global values of "the current state"
     * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
     *
     * See also the deprecated properties:
     * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
     */
    var updateGlobalState = function (trans) {
        var globals = trans.router.globals;
        var transitionSuccessful = function () {
            globals.successfulTransitions.enqueue(trans);
            globals.$current = trans.$to();
            globals.current = globals.$current.self;
            copy(trans.params(), globals.params);
        };
        var clearCurrentTransition = function () {
            // Do not clear globals.transition if a different transition has started in the meantime
            if (globals.transition === trans)
                globals.transition = null;
        };
        trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
        trans.promise.then(clearCurrentTransition, clearCurrentTransition);
    };
    var registerUpdateGlobalState = function (transitionService) {
        return transitionService.onCreate({}, updateGlobalState);
    };

    /**
     * A [[TransitionHookFn]] which updates the URL after a successful transition
     *
     * Registered using `transitionService.onSuccess({}, updateUrl);`
     */
    var updateUrl = function (transition) {
        var options = transition.options();
        var $state = transition.router.stateService;
        var $urlRouter = transition.router.urlRouter;
        // Dont update the url in these situations:
        // The transition was triggered by a URL sync (options.source === 'url')
        // The user doesn't want the url to update (options.location === false)
        // The destination state, and all parents have no navigable url
        if (options.source !== 'url' && options.location && $state.$current.navigable) {
            var urlOptions = { replace: options.location === 'replace' };
            $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
        }
        $urlRouter.update(true);
    };
    var registerUpdateUrl = function (transitionService) {
        return transitionService.onSuccess({}, updateUrl, { priority: 9999 });
    };

    /**
     * A [[TransitionHookFn]] that performs lazy loading
     *
     * When entering a state "abc" which has a `lazyLoad` function defined:
     * - Invoke the `lazyLoad` function (unless it is already in process)
     *   - Flag the hook function as "in process"
     *   - The function should return a promise (that resolves when lazy loading is complete)
     * - Wait for the promise to settle
     *   - If the promise resolves to a [[LazyLoadResult]], then register those states
     *   - Flag the hook function as "not in process"
     * - If the hook was successful
     *   - Remove the `lazyLoad` function from the state declaration
     * - If all the hooks were successful
     *   - Retry the transition (by returning a TargetState)
     *
     * ```
     * .state('abc', {
     *   component: 'fooComponent',
     *   lazyLoad: () => import('./fooComponent')
     *   });
     * ```
     *
     * See [[StateDeclaration.lazyLoad]]
     */
    var lazyLoadHook = function (transition) {
        var router = transition.router;
        function retryTransition() {
            if (transition.originalTransition().options().source !== 'url') {
                // The original transition was not triggered via url sync
                // The lazy state should be loaded now, so re-try the original transition
                var orig = transition.targetState();
                return router.stateService.target(orig.identifier(), orig.params(), orig.options());
            }
            // The original transition was triggered via url sync
            // Run the URL rules and find the best match
            var $url = router.urlService;
            var result = $url.match($url.parts());
            var rule = result && result.rule;
            // If the best match is a state, redirect the transition (instead
            // of calling sync() which supersedes the current transition)
            if (rule && rule.type === 'STATE') {
                var state = rule.state;
                var params = result.match;
                return router.stateService.target(state, params, transition.options());
            }
            // No matching state found, so let .sync() choose the best non-state match/otherwise
            router.urlService.sync();
        }
        var promises = transition
            .entering()
            .filter(function (state) { return !!state.$$state().lazyLoad; })
            .map(function (state) { return lazyLoadState(transition, state); });
        return services.$q.all(promises).then(retryTransition);
    };
    var registerLazyLoadHook = function (transitionService) {
        return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);
    };
    /**
     * Invokes a state's lazy load function
     *
     * @param transition a Transition context
     * @param state the state to lazy load
     * @returns A promise for the lazy load result
     */
    function lazyLoadState(transition, state) {
        var lazyLoadFn = state.$$state().lazyLoad;
        // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
        var promise = lazyLoadFn['_promise'];
        if (!promise) {
            var success = function (result) {
                delete state.lazyLoad;
                delete state.$$state().lazyLoad;
                delete lazyLoadFn['_promise'];
                return result;
            };
            var error = function (err) {
                delete lazyLoadFn['_promise'];
                return services.$q.reject(err);
            };
            promise = lazyLoadFn['_promise'] = services.$q
                .when(lazyLoadFn(transition, state))
                .then(updateStateRegistry)
                .then(success, error);
        }
        /** Register any lazy loaded state definitions */
        function updateStateRegistry(result) {
            if (result && Array.isArray(result.states)) {
                result.states.forEach(function (_state) { return transition.router.stateRegistry.register(_state); });
            }
            return result;
        }
        return promise;
    }

    /**
     * This class defines a type of hook, such as `onBefore` or `onEnter`.
     * Plugins can define custom hook types, such as sticky states does for `onInactive`.
     *
     * @interalapi
     */
    var TransitionEventType = /** @class */ (function () {
        /* tslint:disable:no-inferrable-types */
        function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            if (reverseSort === void 0) { reverseSort = false; }
            if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }
            if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }
            if (synchronous === void 0) { synchronous = false; }
            this.name = name;
            this.hookPhase = hookPhase;
            this.hookOrder = hookOrder;
            this.criteriaMatchPath = criteriaMatchPath;
            this.reverseSort = reverseSort;
            this.getResultHandler = getResultHandler;
            this.getErrorHandler = getErrorHandler;
            this.synchronous = synchronous;
        }
        return TransitionEventType;
    }());

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] that skips a transition if it should be ignored
     *
     * This hook is invoked at the end of the onBefore phase.
     *
     * If the transition should be ignored (because no parameter or states changed)
     * then the transition is ignored and not processed.
     */
    function ignoredHook(trans) {
        var ignoredReason = trans._ignoredReason();
        if (!ignoredReason)
            return;
        trace.traceTransitionIgnored(trans);
        var pending = trans.router.globals.transition;
        // The user clicked a link going back to the *current state* ('A')
        // However, there is also a pending transition in flight (to 'B')
        // Abort the transition to 'B' because the user now wants to be back at 'A'.
        if (ignoredReason === 'SameAsCurrent' && pending) {
            pending.abort();
        }
        return Rejection.ignored().toPromise();
    }
    var registerIgnoredTransitionHook = function (transitionService) {
        return transitionService.onBefore({}, ignoredHook, { priority: -9999 });
    };

    /** @internalapi @module hooks */ /** */
    /**
     * A [[TransitionHookFn]] that rejects the Transition if it is invalid
     *
     * This hook is invoked at the end of the onBefore phase.
     * If the transition is invalid (for example, param values do not validate)
     * then the transition is rejected.
     */
    function invalidTransitionHook(trans) {
        if (!trans.valid()) {
            throw new Error(trans.error().toString());
        }
    }
    var registerInvalidTransitionHook = function (transitionService) {
        return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });
    };

    /** @publicapi @module transition */ /** */
    /**
     * The default [[Transition]] options.
     *
     * Include this object when applying custom defaults:
     * let reloadOpts = { reload: true, notify: true }
     * let options = defaults(theirOpts, customDefaults, defaultOptions);
     */
    var defaultTransOpts = {
        location: true,
        relative: null,
        inherit: false,
        notify: true,
        reload: false,
        supercede: true,
        custom: {},
        current: function () { return null; },
        source: 'unknown',
    };
    /**
     * This class provides services related to Transitions.
     *
     * - Most importantly, it allows global Transition Hooks to be registered.
     * - It allows the default transition error handler to be set.
     * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
     *
     * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
     */
    var TransitionService = /** @class */ (function () {
        /** @hidden */
        function TransitionService(_router) {
            /** @hidden */
            this._transitionCount = 0;
            /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */
            this._eventTypes = [];
            /** @hidden The registered transition hooks */
            this._registeredHooks = {};
            /** @hidden The  paths on a criteria object */
            this._criteriaPaths = {};
            this._router = _router;
            this.$view = _router.viewService;
            this._deregisterHookFns = {};
            this._pluginapi = (createProxyFunctions(val(this), {}, val(this), [
                '_definePathType',
                '_defineEvent',
                '_getPathTypes',
                '_getEvents',
                'getHooks',
            ]));
            this._defineCorePaths();
            this._defineCoreEvents();
            this._registerCoreTransitionHooks();
            _router.globals.successfulTransitions.onEvict(treeChangesCleanup);
        }
        /**
         * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
         *
         * Registers a transition lifecycle hook, which is invoked during transition construction.
         *
         * This low level hook should only be used by plugins.
         * This can be a useful time for plugins to add resolves or mutate the transition as needed.
         * The Sticky States plugin uses this hook to modify the treechanges.
         *
         * ### Lifecycle
         *
         * `onCreate` hooks are invoked *while a transition is being constructed*.
         *
         * ### Return value
         *
         * The hook's return value is ignored
         *
         * @internalapi
         * @param criteria defines which Transitions the Hook should be invoked for.
         * @param callback the hook function which will be invoked.
         * @param options the registration options
         * @returns a function which deregisters the hook.
         */
        TransitionService.prototype.onCreate = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onBefore = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onStart = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onExit = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onRetain = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onEnter = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onFinish = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onSuccess = function (criteria, callback, options) {
            return;
        };
        /** @inheritdoc */
        TransitionService.prototype.onError = function (criteria, callback, options) {
            return;
        };
        /**
         * dispose
         * @internalapi
         */
        TransitionService.prototype.dispose = function (router) {
            values(this._registeredHooks).forEach(function (hooksArray) {
                return hooksArray.forEach(function (hook) {
                    hook._deregistered = true;
                    removeFrom(hooksArray, hook);
                });
            });
        };
        /**
         * Creates a new [[Transition]] object
         *
         * This is a factory function for creating new Transition objects.
         * It is used internally by the [[StateService]] and should generally not be called by application code.
         *
         * @param fromPath the path to the current state (the from state)
         * @param targetState the target state (destination)
         * @returns a Transition
         */
        TransitionService.prototype.create = function (fromPath, targetState) {
            return new Transition(fromPath, targetState, this._router);
        };
        /** @hidden */
        TransitionService.prototype._defineCoreEvents = function () {
            var Phase = exports.TransitionHookPhase;
            var TH = TransitionHook;
            var paths = this._criteriaPaths;
            var NORMAL_SORT = false, REVERSE_SORT = true;
            var SYNCHRONOUS = true;
            this._defineEvent('onCreate', Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
            this._defineEvent('onBefore', Phase.BEFORE, 0, paths.to);
            this._defineEvent('onStart', Phase.RUN, 0, paths.to);
            this._defineEvent('onExit', Phase.RUN, 100, paths.exiting, REVERSE_SORT);
            this._defineEvent('onRetain', Phase.RUN, 200, paths.retained);
            this._defineEvent('onEnter', Phase.RUN, 300, paths.entering);
            this._defineEvent('onFinish', Phase.RUN, 400, paths.to);
            this._defineEvent('onSuccess', Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
            this._defineEvent('onError', Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        };
        /** @hidden */
        TransitionService.prototype._defineCorePaths = function () {
            var STATE = exports.TransitionHookScope.STATE, TRANSITION = exports.TransitionHookScope.TRANSITION;
            this._definePathType('to', TRANSITION);
            this._definePathType('from', TRANSITION);
            this._definePathType('exiting', STATE);
            this._definePathType('retained', STATE);
            this._definePathType('entering', STATE);
        };
        /** @hidden */
        TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            if (reverseSort === void 0) { reverseSort = false; }
            if (getResultHandler === void 0) { getResultHandler = TransitionHook.HANDLE_RESULT; }
            if (getErrorHandler === void 0) { getErrorHandler = TransitionHook.REJECT_ERROR; }
            if (synchronous === void 0) { synchronous = false; }
            var eventType = new TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
            this._eventTypes.push(eventType);
            makeEvent(this, this, eventType);
        };
        /** @hidden */
        // tslint:disable-next-line
        TransitionService.prototype._getEvents = function (phase) {
            var transitionHookTypes = isDefined(phase)
                ? this._eventTypes.filter(function (type) { return type.hookPhase === phase; })
                : this._eventTypes.slice();
            return transitionHookTypes.sort(function (l, r) {
                var cmpByPhase = l.hookPhase - r.hookPhase;
                return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
            });
        };
        /**
         * Adds a Path to be used as a criterion against a TreeChanges path
         *
         * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
         * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
         * Each state in the exiting path is checked against the criteria and returned as part of the match.
         *
         * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
         * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
         * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
         *
         * @hidden
         */
        TransitionService.prototype._definePathType = function (name, hookScope) {
            this._criteriaPaths[name] = { name: name, scope: hookScope };
        };
        /** * @hidden */
        // tslint:disable-next-line
        TransitionService.prototype._getPathTypes = function () {
            return this._criteriaPaths;
        };
        /** @hidden */
        TransitionService.prototype.getHooks = function (hookName) {
            return this._registeredHooks[hookName];
        };
        /** @hidden */
        TransitionService.prototype._registerCoreTransitionHooks = function () {
            var fns = this._deregisterHookFns;
            fns.addCoreResolves = registerAddCoreResolvables(this);
            fns.ignored = registerIgnoredTransitionHook(this);
            fns.invalid = registerInvalidTransitionHook(this);
            // Wire up redirectTo hook
            fns.redirectTo = registerRedirectToHook(this);
            // Wire up onExit/Retain/Enter state hooks
            fns.onExit = registerOnExitHook(this);
            fns.onRetain = registerOnRetainHook(this);
            fns.onEnter = registerOnEnterHook(this);
            // Wire up Resolve hooks
            fns.eagerResolve = registerEagerResolvePath(this);
            fns.lazyResolve = registerLazyResolveState(this);
            fns.resolveAll = registerResolveRemaining(this);
            // Wire up the View management hooks
            fns.loadViews = registerLoadEnteringViews(this);
            fns.activateViews = registerActivateViews(this);
            // Updates global state after a transition
            fns.updateGlobals = registerUpdateGlobalState(this);
            // After globals.current is updated at priority: 10000
            fns.updateUrl = registerUpdateUrl(this);
            // Lazy load state trees
            fns.lazyLoad = registerLazyLoadHook(this);
        };
        return TransitionService;
    }());

    /** @publicapi @module state */ /** */
    /**
     * Provides state related service functions
     *
     * This class provides services related to ui-router states.
     * An instance of this class is located on the global [[UIRouter]] object.
     */
    var StateService = /** @class */ (function () {
        /** @internalapi */
        function StateService(/** @hidden */ router) {
            this.router = router;
            /** @internalapi */
            this.invalidCallbacks = [];
            /** @hidden */
            this._defaultErrorHandler = function $defaultErrorHandler($error$) {
                if ($error$ instanceof Error && $error$.stack) {
                    console.error($error$);
                    console.error($error$.stack);
                }
                else if ($error$ instanceof Rejection) {
                    console.error($error$.toString());
                    if ($error$.detail && $error$.detail.stack)
                        console.error($error$.detail.stack);
                }
                else {
                    console.error($error$);
                }
            };
            var getters = ['current', '$current', 'params', 'transition'];
            var boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));
            createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);
        }
        Object.defineProperty(StateService.prototype, "transition", {
            /**
             * The [[Transition]] currently in progress (or null)
             *
             * This is a passthrough through to [[UIRouterGlobals.transition]]
             */
            get: function () {
                return this.router.globals.transition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "params", {
            /**
             * The latest successful state parameters
             *
             * This is a passthrough through to [[UIRouterGlobals.params]]
             */
            get: function () {
                return this.router.globals.params;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "current", {
            /**
             * The current [[StateDeclaration]]
             *
             * This is a passthrough through to [[UIRouterGlobals.current]]
             */
            get: function () {
                return this.router.globals.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateService.prototype, "$current", {
            /**
             * The current [[StateObject]]
             *
             * This is a passthrough through to [[UIRouterGlobals.$current]]
             */
            get: function () {
                return this.router.globals.$current;
            },
            enumerable: true,
            configurable: true
        });
        /** @internalapi */
        StateService.prototype.dispose = function () {
            this.defaultErrorHandler(noop);
            this.invalidCallbacks = [];
        };
        /**
         * Handler for when [[transitionTo]] is called with an invalid state.
         *
         * Invokes the [[onInvalid]] callbacks, in natural order.
         * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
         * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.
         *
         * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
         *
         * @internalapi
         */
        StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {
            var _this = this;
            var fromState = PathUtils.makeTargetState(this.router.stateRegistry, fromPath);
            var globals = this.router.globals;
            var latestThing = function () { return globals.transitionHistory.peekTail(); };
            var latest = latestThing();
            var callbackQueue = new Queue(this.invalidCallbacks.slice());
            var injector = new ResolveContext(fromPath).injector();
            var checkForRedirect = function (result) {
                if (!(result instanceof TargetState)) {
                    return;
                }
                var target = result;
                // Recreate the TargetState, in case the state is now defined.
                target = _this.target(target.identifier(), target.params(), target.options());
                if (!target.valid()) {
                    return Rejection.invalid(target.error()).toPromise();
                }
                if (latestThing() !== latest) {
                    return Rejection.superseded().toPromise();
                }
                return _this.transitionTo(target.identifier(), target.params(), target.options());
            };
            function invokeNextCallback() {
                var nextCallback = callbackQueue.dequeue();
                if (nextCallback === undefined)
                    return Rejection.invalid(toState.error()).toPromise();
                var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));
                return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });
            }
            return invokeNextCallback();
        };
        /**
         * Registers an Invalid State handler
         *
         * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
         * has been called with an invalid state reference parameter
         *
         * Example:
         * ```js
         * stateService.onInvalid(function(to, from, injector) {
         *   if (to.name() === 'foo') {
         *     let lazyLoader = injector.get('LazyLoadService');
         *     return lazyLoader.load('foo')
         *         .then(() => stateService.target('foo'));
         *   }
         * });
         * ```
         *
         * @param {function} callback invoked when the toState is invalid
         *   This function receives the (invalid) toState, the fromState, and an injector.
         *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
         *   If one is returned, it is treated as a redirect.
         *
         * @returns a function which deregisters the callback
         */
        StateService.prototype.onInvalid = function (callback) {
            this.invalidCallbacks.push(callback);
            return function deregisterListener() {
                removeFrom(this.invalidCallbacks)(callback);
            }.bind(this);
        };
        /**
         * Reloads the current state
         *
         * A method that force reloads the current state, or a partial state hierarchy.
         * All resolves are re-resolved, and components reinstantiated.
         *
         * #### Example:
         * ```js
         * let app angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.reload = function(){
         *     $state.reload();
         *   }
         * });
         * ```
         *
         * Note: `reload()` is just an alias for:
         *
         * ```js
         * $state.transitionTo($state.current, $state.params, {
         *   reload: true, inherit: false
         * });
         * ```
         *
         * @param reloadState A state name or a state object.
         *    If present, this state and all its children will be reloaded, but ancestors will not reload.
         *
         * #### Example:
         * ```js
         * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
         * //and current state is 'contacts.detail.item'
         * let app angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.reload = function(){
         *     //will reload 'contact.detail' and nested 'contact.detail.item' states
         *     $state.reload('contact.detail');
         *   }
         * });
         * ```
         *
         * @returns A promise representing the state of the new transition. See [[StateService.go]]
         */
        StateService.prototype.reload = function (reloadState) {
            return this.transitionTo(this.current, this.params, {
                reload: isDefined(reloadState) ? reloadState : true,
                inherit: false,
                notify: false,
            });
        };
        /**
         * Transition to a different state and/or parameters
         *
         * Convenience method for transitioning to a new state.
         *
         * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
         * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
         * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
         * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
         * inherit from the current parameter values (because of `inherit: true`).
         *
         * #### Example:
         * ```js
         * let app = angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.changeState = function () {
         *     $state.go('contact.detail');
         *   };
         * });
         * ```
         *
         * @param to Absolute state name, state object, or relative state path (relative to current state).
         *
         * Some examples:
         *
         * - `$state.go('contact.detail')` - will go to the `contact.detail` state
         * - `$state.go('^')` - will go to the parent state
         * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
         * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
         *
         * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
         *
         *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
         *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
         *
         * @param options Transition options
         *
         * @returns {promise} A promise representing the state of the new transition.
         */
        StateService.prototype.go = function (to, params, options) {
            var defautGoOpts = { relative: this.$current, inherit: true };
            var transOpts = defaults(options, defautGoOpts, defaultTransOpts);
            return this.transitionTo(to, params, transOpts);
        };
        /**
         * Creates a [[TargetState]]
         *
         * This is a factory method for creating a TargetState
         *
         * This may be returned from a Transition Hook to redirect a transition, for example.
         */
        StateService.prototype.target = function (identifier, params, options) {
            if (options === void 0) { options = {}; }
            // If we're reloading, find the state object to reload from
            if (isObject(options.reload) && !options.reload.name)
                throw new Error('Invalid reload state object');
            var reg = this.router.stateRegistry;
            options.reloadState =
                options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
            if (options.reload && !options.reloadState)
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
            return new TargetState(this.router.stateRegistry, identifier, params, options);
        };
        StateService.prototype.getCurrentPath = function () {
            var _this = this;
            var globals = this.router.globals;
            var latestSuccess = globals.successfulTransitions.peekTail();
            var rootPath = function () { return [new PathNode(_this.router.stateRegistry.root())]; };
            return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
        };
        /**
         * Low-level method for transitioning to a new state.
         *
         * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
         *
         * #### Example:
         * ```js
         * let app = angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.changeState = function () {
         *     $state.transitionTo('contact.detail');
         *   };
         * });
         * ```
         *
         * @param to State name or state object.
         * @param toParams A map of the parameters that will be sent to the state,
         *      will populate $stateParams.
         * @param options Transition options
         *
         * @returns A promise representing the state of the new transition. See [[go]]
         */
        StateService.prototype.transitionTo = function (to, toParams, options) {
            var _this = this;
            if (toParams === void 0) { toParams = {}; }
            if (options === void 0) { options = {}; }
            var router = this.router;
            var globals = router.globals;
            options = defaults(options, defaultTransOpts);
            var getCurrent = function () { return globals.transition; };
            options = extend(options, { current: getCurrent });
            var ref = this.target(to, toParams, options);
            var currentPath = this.getCurrentPath();
            if (!ref.exists())
                return this._handleInvalidTargetState(currentPath, ref);
            if (!ref.valid())
                return silentRejection(ref.error());
            if (options.supercede === false && getCurrent()) {
                return Rejection.ignored('Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.').toPromise();
            }
            /**
             * Special handling for Ignored, Aborted, and Redirected transitions
             *
             * The semantics for the transition.run() promise and the StateService.transitionTo()
             * promise differ. For instance, the run() promise may be rejected because it was
             * IGNORED, but the transitionTo() promise is resolved because from the user perspective
             * no error occurred.  Likewise, the transition.run() promise may be rejected because of
             * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
             */
            var rejectedTransitionHandler = function (trans) { return function (error) {
                if (error instanceof Rejection) {
                    var isLatest = router.globals.lastStartedTransitionId <= trans.$id;
                    if (error.type === exports.RejectType.IGNORED) {
                        isLatest && router.urlRouter.update();
                        // Consider ignored `Transition.run()` as a successful `transitionTo`
                        return services.$q.when(globals.current);
                    }
                    var detail = error.detail;
                    if (error.type === exports.RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {
                        // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
                        // by returning the promise for the new (redirect) `Transition.run()`.
                        var redirect = trans.redirect(detail);
                        return redirect.run().catch(rejectedTransitionHandler(redirect));
                    }
                    if (error.type === exports.RejectType.ABORTED) {
                        isLatest && router.urlRouter.update();
                        return services.$q.reject(error);
                    }
                }
                var errorHandler = _this.defaultErrorHandler();
                errorHandler(error);
                return services.$q.reject(error);
            }; };
            var transition = this.router.transitionService.create(currentPath, ref);
            var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
            silenceUncaughtInPromise(transitionToPromise); // issue #2676
            // Return a promise for the transition, which also has the transition object on it.
            return extend(transitionToPromise, { transition: transition });
        };
        /**
         * Checks if the current state *is* the provided state
         *
         * Similar to [[includes]] but only checks for the full state name.
         * If params is supplied then it will be tested for strict equality against the current
         * active params object, so all params must match with none missing and no extras.
         *
         * #### Example:
         * ```js
         * $state.$current.name = 'contacts.details.item';
         *
         * // absolute name
         * $state.is('contact.details.item'); // returns true
         * $state.is(contactDetailItemStateObject); // returns true
         * ```
         *
         * // relative name (. and ^), typically from a template
         * // E.g. from the 'contacts.details' template
         * ```html
         * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
         * ```
         *
         * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
         * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
         * to test against the current active state.
         * @param options An options object. The options are:
         *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
         *     test relative to `options.relative` state (or name).
         *
         * @returns Returns true if it is the state.
         */
        StateService.prototype.is = function (stateOrName, params, options) {
            options = defaults(options, { relative: this.$current });
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state))
                return undefined;
            if (this.$current !== state)
                return false;
            if (!params)
                return true;
            var schema = state.parameters({ inherit: true, matchingKeys: params });
            return Param.equals(schema, Param.values(schema, params), this.params);
        };
        /**
         * Checks if the current state *includes* the provided state
         *
         * A method to determine if the current active state is equal to or is the child of the
         * state stateName. If any params are passed then they will be tested for a match as well.
         * Not all the parameters need to be passed, just the ones you'd like to test for equality.
         *
         * #### Example when `$state.$current.name === 'contacts.details.item'`
         * ```js
         * // Using partial names
         * $state.includes("contacts"); // returns true
         * $state.includes("contacts.details"); // returns true
         * $state.includes("contacts.details.item"); // returns true
         * $state.includes("contacts.list"); // returns false
         * $state.includes("about"); // returns false
         * ```
         *
         * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
         * ```js
         * $state.includes("*.details.*.*"); // returns true
         * $state.includes("*.details.**"); // returns true
         * $state.includes("**.item.**"); // returns true
         * $state.includes("*.details.item.url"); // returns true
         * $state.includes("*.details.*.url"); // returns true
         * $state.includes("*.details.*"); // returns false
         * $state.includes("item.**"); // returns false
         * ```
         *
         * @param stateOrName A partial name, relative name, glob pattern,
         *   or state object to be searched for within the current state name.
         * @param params A param object, e.g. `{sectionId: section.id}`,
         *   that you'd like to test against the current active state.
         * @param options An options object. The options are:
         *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
         *     test relative to `options.relative` state (or name).
         *
         * @returns {boolean} Returns true if it does include the state
         */
        StateService.prototype.includes = function (stateOrName, params, options) {
            options = defaults(options, { relative: this.$current });
            var glob = isString(stateOrName) && Glob.fromString(stateOrName);
            if (glob) {
                if (!glob.matches(this.$current.name))
                    return false;
                stateOrName = this.$current.name;
            }
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
            if (!isDefined(state))
                return undefined;
            if (!isDefined(include[state.name]))
                return false;
            if (!params)
                return true;
            var schema = state.parameters({ inherit: true, matchingKeys: params });
            return Param.equals(schema, Param.values(schema, params), this.params);
        };
        /**
         * Generates a URL for a state and parameters
         *
         * Returns the url for the given state populated with the given params.
         *
         * #### Example:
         * ```js
         * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
         * ```
         *
         * @param stateOrName The state name or state object you'd like to generate a url from.
         * @param params An object of parameter values to fill the state's required parameters.
         * @param options Options object. The options are:
         *
         * @returns {string} compiled state url
         */
        StateService.prototype.href = function (stateOrName, params, options) {
            var defaultHrefOpts = {
                lossy: true,
                inherit: true,
                absolute: false,
                relative: this.$current,
            };
            options = defaults(options, defaultHrefOpts);
            params = params || {};
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state))
                return null;
            if (options.inherit)
                params = this.params.$inherit(params, this.$current, state);
            var nav = state && options.lossy ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
                return null;
            }
            return this.router.urlRouter.href(nav.url, params, { absolute: options.absolute });
        };
        /**
         * Sets or gets the default [[transitionTo]] error handler.
         *
         * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
         * This includes errors caused by resolves and transition hooks.
         *
         * Note:
         * This handler does not receive certain Transition rejections.
         * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
         *
         * The built-in default error handler logs the error to the console.
         *
         * You can provide your own custom handler.
         *
         * #### Example:
         * ```js
         * stateService.defaultErrorHandler(function() {
         *   // Do not log transitionTo errors
         * });
         * ```
         *
         * @param handler a global error handler function
         * @returns the current global error handler
         */
        StateService.prototype.defaultErrorHandler = function (handler) {
            return (this._defaultErrorHandler = handler || this._defaultErrorHandler);
        };
        StateService.prototype.get = function (stateOrName, base) {
            var reg = this.router.stateRegistry;
            if (arguments.length === 0)
                return reg.get();
            return reg.get(stateOrName, base || this.$current);
        };
        /**
         * Lazy loads a state
         *
         * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
         *
         * @param stateOrName the state that should be lazy loaded
         * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
         * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
         * This noop transition is not actually run.
         *
         * @returns a promise to lazy load
         */
        StateService.prototype.lazyLoad = function (stateOrName, transition) {
            var state = this.get(stateOrName);
            if (!state || !state.lazyLoad)
                throw new Error('Can not lazy load ' + stateOrName);
            var currentPath = this.getCurrentPath();
            var target = PathUtils.makeTargetState(this.router.stateRegistry, currentPath);
            transition = transition || this.router.transitionService.create(currentPath, target);
            return lazyLoadState(transition, state);
        };
        return StateService;
    }());

    /** @internalapi @module vanilla */ /** */
    /**
     * An angular1-like promise api
     *
     * This object implements four methods similar to the
     * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)
     *
     * UI-Router evolved from an angular 1 library to a framework agnostic library.
     * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
     *
     * This API provides native ES6 promise support wrapped as a $q-like API.
     * Internally, UI-Router uses this $q object to perform promise operations.
     * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.
     *
     * $q-like promise api
     */
    var $q = {
        /** Normalizes a value as a promise */
        when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },
        /** Normalizes a value as a promise rejection */
        reject: function (val) {
            return new Promise(function (resolve, reject) {
                reject(val);
            });
        },
        /** @returns a deferred object, which has `resolve` and `reject` functions */
        defer: function () {
            var deferred = {};
            deferred.promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            return deferred;
        },
        /** Like Promise.all(), but also supports object key/promise notation like $q */
        all: function (promises) {
            if (isArray(promises)) {
                return Promise.all(promises);
            }
            if (isObject(promises)) {
                // Convert promises map to promises array.
                // When each promise resolves, map it to a tuple { key: key, val: val }
                var chain = Object.keys(promises).map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });
                // Then wait for all promises to resolve, and convert them back to an object
                return $q.all(chain).then(function (values) {
                    return values.reduce(function (acc, tuple) {
                        acc[tuple.key] = tuple.val;
                        return acc;
                    }, {});
                });
            }
        },
    };

    /** @internalapi @module vanilla */ /** */
    // globally available injectables
    var globals = {};
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var ARGUMENT_NAMES = /([^\s,]+)/g;
    /**
     * A basic angular1-like injector api
     *
     * This object implements four methods similar to the
     * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)
     *
     * UI-Router evolved from an angular 1 library to a framework agnostic library.
     * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
     *
     * This object provides a naive implementation of a globally scoped dependency injection system.
     * It supports the following DI approaches:
     *
     * ### Function parameter names
     *
     * A function's `.toString()` is called, and the parameter names are parsed.
     * This only works when the parameter names aren't "mangled" by a minifier such as UglifyJS.
     *
     * ```js
     * function injectedFunction(FooService, BarService) {
     *   // FooService and BarService are injected
     * }
     * ```
     *
     * ### Function annotation
     *
     * A function may be annotated with an array of dependency names as the `$inject` property.
     *
     * ```js
     * injectedFunction.$inject = [ 'FooService', 'BarService' ];
     * function injectedFunction(fs, bs) {
     *   // FooService and BarService are injected as fs and bs parameters
     * }
     * ```
     *
     * ### Array notation
     *
     * An array provides the names of the dependencies to inject (as strings).
     * The function is the last element of the array.
     *
     * ```js
     * [ 'FooService', 'BarService', function (fs, bs) {
     *   // FooService and BarService are injected as fs and bs parameters
     * }]
     * ```
     *
     * @type {$InjectorLike}
     */
    var $injector = {
        /** Gets an object from DI based on a string token */
        get: function (name) { return globals[name]; },
        /** Returns true if an object named `name` exists in global DI */
        has: function (name) { return $injector.get(name) != null; },
        /**
         * Injects a function
         *
         * @param fn the function to inject
         * @param context the function's `this` binding
         * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`
         */
        invoke: function (fn, context, locals) {
            var all = extend({}, globals, locals || {});
            var params = $injector.annotate(fn);
            var ensureExist = assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return "DI can't find injectable: '" + key + "'"; });
            var args = params.filter(ensureExist).map(function (x) { return all[x]; });
            if (isFunction(fn))
                return fn.apply(context, args);
            else
                return fn.slice(-1)[0].apply(context, args);
        },
        /**
         * Returns a function's dependencies
         *
         * Analyzes a function (or array) and returns an array of DI tokens that the function requires.
         * @return an array of `string`s
         */
        annotate: function (fn) {
            if (!isInjectable(fn))
                throw new Error("Not an injectable function: " + fn);
            if (fn && fn.$inject)
                return fn.$inject;
            if (isArray(fn))
                return fn.slice(0, -1);
            var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
            var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
            return result || [];
        },
    };

    /** @internalapi @module vanilla */ /** */
    var keyValsToObjectR = function (accum, _a) {
        var key = _a[0], val = _a[1];
        if (!accum.hasOwnProperty(key)) {
            accum[key] = val;
        }
        else if (isArray(accum[key])) {
            accum[key].push(val);
        }
        else {
            accum[key] = [accum[key], val];
        }
        return accum;
    };
    var getParams = function (queryString) {
        return queryString
            .split('&')
            .filter(identity)
            .map(splitEqual)
            .reduce(keyValsToObjectR, {});
    };
    function parseUrl$1(url) {
        var orEmptyString = function (x) { return x || ''; };
        var _a = splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
        var _b = splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
        return { path: path, search: search, hash: hash, url: url };
    }
    var buildUrl = function (loc) {
        var path = loc.path();
        var searchObject = loc.search();
        var hash = loc.hash();
        var search = Object.keys(searchObject)
            .map(function (key) {
            var param = searchObject[key];
            var vals = isArray(param) ? param : [param];
            return vals.map(function (val) { return key + '=' + val; });
        })
            .reduce(unnestR, [])
            .join('&');
        return path + (search ? '?' + search : '') + (hash ? '#' + hash : '');
    };
    function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
        return function (uiRouter) {
            var service = (uiRouter.locationService = new serviceClass(uiRouter));
            var configuration = (uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5));
            function dispose(router) {
                router.dispose(service);
                router.dispose(configuration);
            }
            return { name: name, service: service, configuration: configuration, dispose: dispose };
        };
    }

    /** @internalapi @module vanilla */ /** */
    /** A base `LocationServices` */
    var BaseLocationServices = /** @class */ (function () {
        function BaseLocationServices(router, fireAfterUpdate) {
            var _this = this;
            this.fireAfterUpdate = fireAfterUpdate;
            this._listeners = [];
            this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };
            this.hash = function () { return parseUrl$1(_this._get()).hash; };
            this.path = function () { return parseUrl$1(_this._get()).path; };
            this.search = function () { return getParams(parseUrl$1(_this._get()).search); };
            this._location = root.location;
            this._history = root.history;
        }
        BaseLocationServices.prototype.url = function (url, replace) {
            if (replace === void 0) { replace = true; }
            if (isDefined(url) && url !== this._get()) {
                this._set(null, null, url, replace);
                if (this.fireAfterUpdate) {
                    this._listeners.forEach(function (cb) { return cb({ url: url }); });
                }
            }
            return buildUrl(this);
        };
        BaseLocationServices.prototype.onChange = function (cb) {
            var _this = this;
            this._listeners.push(cb);
            return function () { return removeFrom(_this._listeners, cb); };
        };
        BaseLocationServices.prototype.dispose = function (router) {
            deregAll(this._listeners);
        };
        return BaseLocationServices;
    }());

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** A `LocationServices` that uses the browser hash "#" to get/set the current location */
    var HashLocationService = /** @class */ (function (_super) {
        __extends(HashLocationService, _super);
        function HashLocationService(router) {
            var _this = _super.call(this, router, false) || this;
            root.addEventListener('hashchange', _this._listener, false);
            return _this;
        }
        HashLocationService.prototype._get = function () {
            return trimHashVal(this._location.hash);
        };
        HashLocationService.prototype._set = function (state, title, url, replace) {
            this._location.hash = url;
        };
        HashLocationService.prototype.dispose = function (router) {
            _super.prototype.dispose.call(this, router);
            root.removeEventListener('hashchange', this._listener);
        };
        return HashLocationService;
    }(BaseLocationServices));

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** A `LocationServices` that gets/sets the current location from an in-memory object */
    var MemoryLocationService = /** @class */ (function (_super) {
        __extends$1(MemoryLocationService, _super);
        function MemoryLocationService(router) {
            return _super.call(this, router, true) || this;
        }
        MemoryLocationService.prototype._get = function () {
            return this._url;
        };
        MemoryLocationService.prototype._set = function (state, title, url, replace) {
            this._url = url;
        };
        return MemoryLocationService;
    }(BaseLocationServices));

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis
     *
     * Uses `history.pushState` and `history.replaceState`
     */
    var PushStateLocationService = /** @class */ (function (_super) {
        __extends$2(PushStateLocationService, _super);
        function PushStateLocationService(router) {
            var _this = _super.call(this, router, true) || this;
            _this._config = router.urlService.config;
            root.addEventListener('popstate', _this._listener, false);
            return _this;
        }
        /**
         * Gets the base prefix without:
         * - trailing slash
         * - trailing filename
         * - protocol and hostname
         *
         * If <base href='/base/'>, this returns '/base'.
         * If <base href='/foo/base/'>, this returns '/foo/base'.
         * If <base href='/base/index.html'>, this returns '/base'.
         * If <base href='http://localhost:8080/base/index.html'>, this returns '/base'.
         * If <base href='/base'>, this returns ''.
         * If <base href='http://localhost:8080'>, this returns ''.
         * If <base href='http://localhost:8080/'>, this returns ''.
         *
         * See: https://html.spec.whatwg.org/dev/semantics.html#the-base-element
         */
        PushStateLocationService.prototype._getBasePrefix = function () {
            return stripLastPathElement(this._config.baseHref());
        };
        PushStateLocationService.prototype._get = function () {
            var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
            search = splitQuery(search)[1]; // strip ? if found
            hash = splitHash(hash)[1]; // strip # if found
            var basePrefix = this._getBasePrefix();
            var exactBaseHrefMatch = pathname === this._config.baseHref();
            var startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;
            pathname = exactBaseHrefMatch ? '/' : startsWithBase ? pathname.substring(basePrefix.length) : pathname;
            return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');
        };
        PushStateLocationService.prototype._set = function (state, title, url, replace) {
            var basePrefix = this._getBasePrefix();
            var slash = url && url[0] !== '/' ? '/' : '';
            var fullUrl = url === '' || url === '/' ? this._config.baseHref() : basePrefix + slash + url;
            if (replace) {
                this._history.replaceState(state, title, fullUrl);
            }
            else {
                this._history.pushState(state, title, fullUrl);
            }
        };
        PushStateLocationService.prototype.dispose = function (router) {
            _super.prototype.dispose.call(this, router);
            root.removeEventListener('popstate', this._listener);
        };
        return PushStateLocationService;
    }(BaseLocationServices));

    /** A `LocationConfig` mock that gets/sets all config from an in-memory object */
    var MemoryLocationConfig = /** @class */ (function () {
        function MemoryLocationConfig() {
            var _this = this;
            this.dispose = noop;
            this._baseHref = '';
            this._port = 80;
            this._protocol = 'http';
            this._host = 'localhost';
            this._hashPrefix = '';
            this.port = function () { return _this._port; };
            this.protocol = function () { return _this._protocol; };
            this.host = function () { return _this._host; };
            this.baseHref = function () { return _this._baseHref; };
            this.html5Mode = function () { return false; };
            this.hashPrefix = function (newval) { return (isDefined(newval) ? (_this._hashPrefix = newval) : _this._hashPrefix); };
        }
        return MemoryLocationConfig;
    }());

    /** @internalapi @module vanilla */
    /** A `LocationConfig` that delegates to the browser's `location` object */
    var BrowserLocationConfig = /** @class */ (function () {
        function BrowserLocationConfig(router, _isHtml5) {
            if (_isHtml5 === void 0) { _isHtml5 = false; }
            this._isHtml5 = _isHtml5;
            this._baseHref = undefined;
            this._hashPrefix = '';
        }
        BrowserLocationConfig.prototype.port = function () {
            if (location.port) {
                return Number(location.port);
            }
            return this.protocol() === 'https' ? 443 : 80;
        };
        BrowserLocationConfig.prototype.protocol = function () {
            return location.protocol.replace(/:/g, '');
        };
        BrowserLocationConfig.prototype.host = function () {
            return location.hostname;
        };
        BrowserLocationConfig.prototype.html5Mode = function () {
            return this._isHtml5;
        };
        BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {
            return isDefined(newprefix) ? (this._hashPrefix = newprefix) : this._hashPrefix;
        };
        BrowserLocationConfig.prototype.baseHref = function (href) {
            if (isDefined(href))
                this._baseHref = href;
            if (isUndefined(this._baseHref))
                this._baseHref = this.getBaseHref();
            return this._baseHref;
        };
        BrowserLocationConfig.prototype.getBaseHref = function () {
            var baseTag = document.getElementsByTagName('base')[0];
            if (baseTag && baseTag.href) {
                return baseTag.href.replace(/^([^/:]*:)?\/\/[^/]*/, '');
            }
            return this._isHtml5 ? '/' : location.pathname || '/';
        };
        BrowserLocationConfig.prototype.dispose = function () { };
        return BrowserLocationConfig;
    }());

    /** @internalapi @module vanilla */ /** */
    function servicesPlugin(router) {
        services.$injector = $injector;
        services.$q = $q;
        return { name: 'vanilla.services', $q: $q, $injector: $injector, dispose: function () { return null; } };
    }
    /** A `UIRouterPlugin` uses the browser hash to get/set the current location */
    var hashLocationPlugin = locationPluginFactory('vanilla.hashBangLocation', false, HashLocationService, BrowserLocationConfig);
    /** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */
    var pushStateLocationPlugin = locationPluginFactory('vanilla.pushStateLocation', true, PushStateLocationService, BrowserLocationConfig);
    /** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */
    var memoryLocationPlugin = locationPluginFactory('vanilla.memoryLocation', false, MemoryLocationService, MemoryLocationConfig);

    /**
     * # Core classes and interfaces
     *
     * The classes and interfaces that are core to ui-router and do not belong
     * to a more specific subsystem (such as resolve).
     *
     * @preferred @publicapi @module core
     */ /** */
    /** @internalapi */
    var UIRouterPluginBase = /** @class */ (function () {
        function UIRouterPluginBase() {
        }
        UIRouterPluginBase.prototype.dispose = function (router) { };
        return UIRouterPluginBase;
    }());

    /** @publicapi @module common */ /** */

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        root: root,
        fromJson: fromJson,
        toJson: toJson,
        forEach: forEach,
        extend: extend,
        equals: equals,
        identity: identity,
        noop: noop,
        createProxyFunctions: createProxyFunctions,
        inherit: inherit,
        inArray: inArray,
        _inArray: _inArray,
        removeFrom: removeFrom,
        _removeFrom: _removeFrom,
        pushTo: pushTo,
        _pushTo: _pushTo,
        deregAll: deregAll,
        defaults: defaults,
        mergeR: mergeR,
        ancestors: ancestors,
        pick: pick,
        omit: omit,
        pluck: pluck,
        filter: filter,
        find: find,
        mapObj: mapObj,
        map: map,
        values: values,
        allTrueR: allTrueR,
        anyTrueR: anyTrueR,
        unnestR: unnestR,
        flattenR: flattenR,
        pushR: pushR,
        uniqR: uniqR,
        unnest: unnest,
        flatten: flatten,
        assertPredicate: assertPredicate,
        assertMap: assertMap,
        assertFn: assertFn,
        pairs: pairs,
        arrayTuples: arrayTuples,
        applyPairs: applyPairs,
        tail: tail,
        copy: copy,
        _extend: _extend,
        silenceUncaughtInPromise: silenceUncaughtInPromise,
        silentRejection: silentRejection,
        makeStub: makeStub,
        services: services,
        Glob: Glob,
        curry: curry,
        compose: compose,
        pipe: pipe,
        prop: prop,
        propEq: propEq,
        parse: parse,
        not: not,
        and: and,
        or: or,
        all: all,
        any: any,
        is: is,
        eq: eq,
        val: val,
        invoke: invoke,
        pattern: pattern,
        isUndefined: isUndefined,
        isDefined: isDefined,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isFunction: isFunction,
        isNumber: isNumber,
        isString: isString,
        isObject: isObject,
        isArray: isArray,
        isDate: isDate,
        isRegExp: isRegExp,
        isInjectable: isInjectable,
        isPromise: isPromise,
        Queue: Queue,
        maxLength: maxLength,
        padString: padString,
        kebobString: kebobString,
        functionToString: functionToString,
        fnToString: fnToString,
        stringify: stringify,
        beforeAfterSubstr: beforeAfterSubstr,
        hostRegex: hostRegex,
        stripLastPathElement: stripLastPathElement,
        splitHash: splitHash,
        splitQuery: splitQuery,
        splitEqual: splitEqual,
        trimHashVal: trimHashVal,
        splitOnDelim: splitOnDelim,
        joinNeighborsR: joinNeighborsR,
        get Category () { return exports.Category; },
        Trace: Trace,
        trace: trace,
        get DefType () { return exports.DefType; },
        Param: Param,
        ParamTypes: ParamTypes,
        StateParams: StateParams,
        ParamType: ParamType,
        PathNode: PathNode,
        PathUtils: PathUtils,
        resolvePolicies: resolvePolicies,
        defaultResolvePolicy: defaultResolvePolicy,
        Resolvable: Resolvable,
        NATIVE_INJECTOR_TOKEN: NATIVE_INJECTOR_TOKEN,
        ResolveContext: ResolveContext,
        resolvablesBuilder: resolvablesBuilder,
        StateBuilder: StateBuilder,
        StateObject: StateObject,
        StateMatcher: StateMatcher,
        StateQueueManager: StateQueueManager,
        StateRegistry: StateRegistry,
        StateService: StateService,
        TargetState: TargetState,
        get TransitionHookPhase () { return exports.TransitionHookPhase; },
        get TransitionHookScope () { return exports.TransitionHookScope; },
        HookBuilder: HookBuilder,
        matchState: matchState,
        RegisteredHook: RegisteredHook,
        makeEvent: makeEvent,
        get RejectType () { return exports.RejectType; },
        Rejection: Rejection,
        Transition: Transition,
        TransitionHook: TransitionHook,
        TransitionEventType: TransitionEventType,
        defaultTransOpts: defaultTransOpts,
        TransitionService: TransitionService,
        UrlRules: UrlRules,
        UrlConfig: UrlConfig,
        UrlMatcher: UrlMatcher,
        ParamFactory: ParamFactory,
        UrlMatcherFactory: UrlMatcherFactory,
        UrlRouter: UrlRouter,
        UrlRuleFactory: UrlRuleFactory,
        BaseUrlRule: BaseUrlRule,
        UrlService: UrlService,
        ViewService: ViewService,
        UIRouterGlobals: UIRouterGlobals,
        UIRouter: UIRouter,
        $q: $q,
        $injector: $injector,
        BaseLocationServices: BaseLocationServices,
        HashLocationService: HashLocationService,
        MemoryLocationService: MemoryLocationService,
        PushStateLocationService: PushStateLocationService,
        MemoryLocationConfig: MemoryLocationConfig,
        BrowserLocationConfig: BrowserLocationConfig,
        keyValsToObjectR: keyValsToObjectR,
        getParams: getParams,
        parseUrl: parseUrl$1,
        buildUrl: buildUrl,
        locationPluginFactory: locationPluginFactory,
        servicesPlugin: servicesPlugin,
        hashLocationPlugin: hashLocationPlugin,
        pushStateLocationPlugin: pushStateLocationPlugin,
        memoryLocationPlugin: memoryLocationPlugin,
        UIRouterPluginBase: UIRouterPluginBase
    });

    /** @internalapi */
    function getNg1ViewConfigFactory() {
        var templateFactory = null;
        return function (path, view) {
            templateFactory = templateFactory || services.$injector.get('$templateFactory');
            return [new Ng1ViewConfig(path, view, templateFactory)];
        };
    }
    /** @internalapi */
    var hasAnyKey = function (keys, obj) { return keys.reduce(function (acc, key) { return acc || isDefined(obj[key]); }, false); };
    /**
     * This is a [[StateBuilder.builder]] function for angular1 `views`.
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * handles the `views` property with logic specific to @uirouter/angularjs (ng1).
     *
     * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
     * and applies the state-level configuration to a view named `$default`.
     *
     * @internalapi
     */
    function ng1ViewsBuilder(state) {
        // Do not process root state
        if (!state.parent)
            return {};
        var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
        // Do not allow a state to have both state-level props and also a `views: {}` property.
        // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.
        // However, the `$default` approach should not be mixed with a separate `views: ` block.
        if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
            throw new Error("State '" + state.name + "' has a 'views' object. " +
                "It cannot also have \"view properties\" at the state level.  " +
                "Move the following properties into a view (in the 'views' object): " +
                (" " + allViewKeys.filter(function (key) { return isDefined(state[key]); }).join(', ')));
        }
        var views = {}, viewsObject = state.views || { $default: pick(state, allViewKeys) };
        forEach(viewsObject, function (config, name) {
            // Account for views: { "": { template... } }
            name = name || '$default';
            // Account for views: { header: "headerComponent" }
            if (isString(config))
                config = { component: config };
            // Make a shallow copy of the config object
            config = extend({}, config);
            // Do not allow a view to mix props for component-style view with props for template/controller-style view
            if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
                throw new Error("Cannot combine: " + compKeys.join('|') + " with: " + nonCompKeys.join('|') + " in stateview: '" + name + "@" + state.name + "'");
            }
            config.resolveAs = config.resolveAs || '$resolve';
            config.$type = 'ng1';
            config.$context = state;
            config.$name = name;
            var normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName;
            config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
            views[name] = config;
        });
        return views;
    }
    /** @hidden */
    var id$1 = 0;
    /** @internalapi */
    var Ng1ViewConfig = /** @class */ (function () {
        function Ng1ViewConfig(path, viewDecl, factory) {
            var _this = this;
            this.path = path;
            this.viewDecl = viewDecl;
            this.factory = factory;
            this.$id = id$1++;
            this.loaded = false;
            this.getTemplate = function (uiView, context) {
                return _this.component
                    ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings)
                    : _this.template;
            };
        }
        Ng1ViewConfig.prototype.load = function () {
            var _this = this;
            var $q = services.$q;
            var context = new ResolveContext(this.path);
            var params = this.path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {});
            var promises = {
                template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),
                controller: $q.when(this.getController(context)),
            };
            return $q.all(promises).then(function (results) {
                trace.traceViewServiceEvent('Loaded', _this);
                _this.controller = results.controller;
                extend(_this, results.template); // Either { template: "tpl" } or { component: "cmpName" }
                return _this;
            });
        };
        /**
         * Gets the controller for a view configuration.
         *
         * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
         */
        Ng1ViewConfig.prototype.getController = function (context) {
            var provider = this.viewDecl.controllerProvider;
            if (!isInjectable(provider))
                return this.viewDecl.controller;
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        return Ng1ViewConfig;
    }());

    /** @publicapi @module view */ /** */
    /**
     * Service which manages loading of templates from a ViewConfig.
     */
    var TemplateFactory = /** @class */ (function () {
        function TemplateFactory() {
            var _this = this;
            /** @hidden */ this._useHttp = ng.version.minor < 3;
            /** @hidden */ this.$get = [
                '$http',
                '$templateCache',
                '$injector',
                function ($http, $templateCache, $injector) {
                    _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');
                    _this.$http = $http;
                    _this.$templateCache = $templateCache;
                    return _this;
                },
            ];
        }
        /** @hidden */
        TemplateFactory.prototype.useHttpService = function (value) {
            this._useHttp = value;
        };
        /**
         * Creates a template from a configuration object.
         *
         * @param config Configuration object for which to load a template.
         * The following properties are search in the specified order, and the first one
         * that is defined is used to create the template:
         *
         * @param params  Parameters to pass to the template function.
         * @param context The resolve context associated with the template's view
         *
         * @return {string|object}  The template html as a string, or a promise for
         * that string,or `null` if no template is configured.
         */
        TemplateFactory.prototype.fromConfig = function (config, params, context) {
            var defaultTemplate = '<ui-view></ui-view>';
            var asTemplate = function (result) { return services.$q.when(result).then(function (str) { return ({ template: str }); }); };
            var asComponent = function (result) { return services.$q.when(result).then(function (str) { return ({ component: str }); }); };
            return isDefined(config.template)
                ? asTemplate(this.fromString(config.template, params))
                : isDefined(config.templateUrl)
                    ? asTemplate(this.fromUrl(config.templateUrl, params))
                    : isDefined(config.templateProvider)
                        ? asTemplate(this.fromProvider(config.templateProvider, params, context))
                        : isDefined(config.component)
                            ? asComponent(config.component)
                            : isDefined(config.componentProvider)
                                ? asComponent(this.fromComponentProvider(config.componentProvider, params, context))
                                : asTemplate(defaultTemplate);
        };
        /**
         * Creates a template from a string or a function returning a string.
         *
         * @param template html template as a string or function that returns an html template as a string.
         * @param params Parameters to pass to the template function.
         *
         * @return {string|object} The template html as a string, or a promise for that
         * string.
         */
        TemplateFactory.prototype.fromString = function (template, params) {
            return isFunction(template) ? template(params) : template;
        };
        /**
         * Loads a template from the a URL via `$http` and `$templateCache`.
         *
         * @param {string|Function} url url of the template to load, or a function
         * that returns a url.
         * @param {Object} params Parameters to pass to the url function.
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        TemplateFactory.prototype.fromUrl = function (url, params) {
            if (isFunction(url))
                url = url(params);
            if (url == null)
                return null;
            if (this._useHttp) {
                return this.$http
                    .get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })
                    .then(function (response) {
                    return response.data;
                });
            }
            return this.$templateRequest(url);
        };
        /**
         * Creates a template by invoking an injectable provider function.
         *
         * @param provider Function to invoke via `locals`
         * @param {Function} injectFn a function used to invoke the template provider
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        TemplateFactory.prototype.fromProvider = function (provider, params, context) {
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        /**
         * Creates a component's template by invoking an injectable provider function.
         *
         * @param provider Function to invoke via `locals`
         * @param {Function} injectFn a function used to invoke the template provider
         * @return {string} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {
            var deps = services.$injector.annotate(provider);
            var providerFn = isArray(provider) ? tail(provider) : provider;
            var resolvable = new Resolvable('', providerFn, deps);
            return resolvable.get(context);
        };
        /**
         * Creates a template from a component's name
         *
         * This implements route-to-component.
         * It works by retrieving the component (directive) metadata from the injector.
         * It analyses the component's bindings, then constructs a template that instantiates the component.
         * The template wires input and output bindings to resolves or from the parent component.
         *
         * @param uiView {object} The parent ui-view (for binding outputs to callbacks)
         * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)
         * @param component {string} Component's name in camel case.
         * @param bindings An object defining the component's bindings: {foo: '<'}
         * @return {string} The template as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {
            bindings = bindings || {};
            // Bind once prefix
            var prefix = ng.version.minor >= 3 ? '::' : '';
            // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`
            var kebob = function (camelCase) {
                var kebobed = kebobString(camelCase);
                return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
            };
            var attributeTpl = function (input) {
                var name = input.name, type = input.type;
                var attrName = kebob(name);
                // If the ui-view has an attribute which matches a binding on the routed component
                // then pass that attribute through to the routed component template.
                // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`
                if (uiView.attr(attrName) && !bindings[name])
                    return attrName + "='" + uiView.attr(attrName) + "'";
                var resolveName = bindings[name] || name;
                // Pre-evaluate the expression for "@" bindings by enclosing in {{ }}
                // some-attr="{{ ::$resolve.someResolveName }}"
                if (type === '@')
                    return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                // Wire "&" callbacks to resolves that return a callback function
                // Get the result of the resolve (should be a function) and annotate it to get its arguments.
                // some-attr="$resolve.someResolveResultName(foo, bar)"
                if (type === '&') {
                    var res = context.getResolvable(resolveName);
                    var fn = res && res.data;
                    var args = (fn && services.$injector.annotate(fn)) || [];
                    // account for array style injection, i.e., ['foo', function(foo) {}]
                    var arrayIdxStr = isArray(fn) ? "[" + (fn.length - 1) + "]" : '';
                    return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(',') + ")'";
                }
                // some-attr="::$resolve.someResolveName"
                return attrName + "='" + prefix + "$resolve." + resolveName + "'";
            };
            var attrs = getComponentBindings(component)
                .map(attributeTpl)
                .join(' ');
            var kebobName = kebob(component);
            return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
        };
        return TemplateFactory;
    }());
    // Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')
    function getComponentBindings(name) {
        var cmpDefs = services.$injector.get(name + 'Directive'); // could be multiple
        if (!cmpDefs || !cmpDefs.length)
            throw new Error("Unable to find component named '" + name + "'");
        return cmpDefs.map(getBindings).reduce(unnestR, []);
    }
    // Given a directive definition, find its object input attributes
    // Use different properties, depending on the type of directive (component, bindToController, normal)
    var getBindings = function (def) {
        if (isObject(def.bindToController))
            return scopeBindings(def.bindToController);
        return scopeBindings(def.scope);
    };
    // for ng 1.2 style, process the scope: { input: "=foo" }
    // for ng 1.3 through ng 1.5, process the component's bindToController: { input: "=foo" } object
    var scopeBindings = function (bindingsObj) {
        return Object.keys(bindingsObj || {})
            // [ 'input', [ '=foo', '=', 'foo' ] ]
            .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })
            // skip malformed values
            .filter(function (tuple) { return isDefined(tuple) && isArray(tuple[1]); })
            // { name: ('foo' || 'input'), type: '=' }
            .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); });
    };

    /** @publicapi @module ng1 */ /** */
    /**
     * The Angular 1 `StateProvider`
     *
     * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely
     * on state.
     *
     * A state corresponds to a "place" in the application in terms of the overall UI and
     * navigation. A state describes (via the controller / template / view properties) what
     * the UI looks like and does at that place.
     *
     * States often have things in common, and the primary way of factoring out these
     * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
     * nested states.
     *
     * The `$stateProvider` provides interfaces to declare these states for your app.
     */
    var StateProvider = /** @class */ (function () {
        function StateProvider(stateRegistry, stateService) {
            this.stateRegistry = stateRegistry;
            this.stateService = stateService;
            createProxyFunctions(val(StateProvider.prototype), this, val(this));
        }
        /**
         * Decorates states when they are registered
         *
         * Allows you to extend (carefully) or override (at your own peril) the
         * `stateBuilder` object used internally by [[StateRegistry]].
         * This can be used to add custom functionality to ui-router,
         * for example inferring templateUrl based on the state name.
         *
         * When passing only a name, it returns the current (original or decorated) builder
         * function that matches `name`.
         *
         * The builder functions that can be decorated are listed below. Though not all
         * necessarily have a good use case for decoration, that is up to you to decide.
         *
         * In addition, users can attach custom decorators, which will generate new
         * properties within the state's internal definition. There is currently no clear
         * use-case for this beyond accessing internal states (i.e. $state.$current),
         * however, expect this to become increasingly relevant as we introduce additional
         * meta-programming features.
         *
         * **Warning**: Decorators should not be interdependent because the order of
         * execution of the builder functions in non-deterministic. Builder functions
         * should only be dependent on the state definition object and super function.
         *
         *
         * Existing builder functions and current return values:
         *
         * - **parent** `{object}` - returns the parent state object.
         * - **data** `{object}` - returns state data, including any inherited data that is not
         *   overridden by own values (if any).
         * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
         *   or `null`.
         * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
         *   navigable).
         * - **params** `{object}` - returns an array of state params that are ensured to
         *   be a super-set of parent's params.
         * - **views** `{object}` - returns a views object where each key is an absolute view
         *   name (i.e. "viewName@stateName") and each value is the config object
         *   (template, controller) for the view. Even when you don't use the views object
         *   explicitly on a state config, one is still created for you internally.
         *   So by decorating this builder function you have access to decorating template
         *   and controller properties.
         * - **ownParams** `{object}` - returns an array of params that belong to the state,
         *   not including any params defined by ancestor states.
         * - **path** `{string}` - returns the full path from the root down to this state.
         *   Needed for state activation.
         * - **includes** `{object}` - returns an object that includes every state that
         *   would pass a `$state.includes()` test.
         *
         * #### Example:
         * Override the internal 'views' builder with a function that takes the state
         * definition, and a reference to the internal function being overridden:
         * ```js
         * $stateProvider.decorator('views', function (state, parent) {
         *   let result = {},
         *       views = parent(state);
         *
         *   angular.forEach(views, function (config, name) {
         *     let autoName = (state.name + '.' + name).replace('.', '/');
         *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
         *     result[name] = config;
         *   });
         *   return result;
         * });
         *
         * $stateProvider.state('home', {
         *   views: {
         *     'contact.list': { controller: 'ListController' },
         *     'contact.item': { controller: 'ItemController' }
         *   }
         * });
         * ```
         *
         *
         * ```js
         * // Auto-populates list and item views with /partials/home/contact/list.html,
         * // and /partials/home/contact/item.html, respectively.
         * $state.go('home');
         * ```
         *
         * @param {string} name The name of the builder function to decorate.
         * @param {object} func A function that is responsible for decorating the original
         * builder function. The function receives two parameters:
         *
         *   - `{object}` - state - The state config object.
         *   - `{object}` - super - The original builder function.
         *
         * @return {object} $stateProvider - $stateProvider instance
         */
        StateProvider.prototype.decorator = function (name, func) {
            return this.stateRegistry.decorator(name, func) || this;
        };
        StateProvider.prototype.state = function (name, definition) {
            if (isObject(name)) {
                definition = name;
            }
            else {
                definition.name = name;
            }
            this.stateRegistry.register(definition);
            return this;
        };
        /**
         * Registers an invalid state handler
         *
         * This is a passthrough to [[StateService.onInvalid]] for ng1.
         */
        StateProvider.prototype.onInvalid = function (callback) {
            return this.stateService.onInvalid(callback);
        };
        return StateProvider;
    }());

    /** @publicapi @module ng1 */ /** */
    /**
     * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
     * `onRetain` callback hooks on a [[Ng1StateDeclaration]].
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
     *
     * @internalapi
     */
    var getStateHookBuilder = function (hookName) {
        return function stateHookBuilder(stateObject, parentFn) {
            var hook = stateObject[hookName];
            var pathname = hookName === 'onExit' ? 'from' : 'to';
            function decoratedNg1Hook(trans, state) {
                var resolveContext = new ResolveContext(trans.treeChanges(pathname));
                var subContext = resolveContext.subContext(state.$$state());
                var locals = extend(getLocals(subContext), { $state$: state, $transition$: trans });
                return services.$injector.invoke(hook, this, locals);
            }
            return hook ? decoratedNg1Hook : undefined;
        };
    };

    /** @publicapi @module ng1 */ /** */
    /**
     * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service
     * @internalapi
     */
    var Ng1LocationServices = /** @class */ (function () {
        function Ng1LocationServices($locationProvider) {
            // .onChange() registry
            this._urlListeners = [];
            this.$locationProvider = $locationProvider;
            var _lp = val($locationProvider);
            createProxyFunctions(_lp, this, _lp, ['hashPrefix']);
        }
        /**
         * Applys ng1-specific path parameter encoding
         *
         * The Angular 1 `$location` service is a bit weird.
         * It doesn't allow slashes to be encoded/decoded bi-directionally.
         *
         * See the writeup at https://github.com/angular-ui/ui-router/issues/2598
         *
         * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F
         *
         * @param router
         */
        Ng1LocationServices.monkeyPatchPathParameterType = function (router) {
            var pathType = router.urlMatcherFactory.type('path');
            pathType.encode = function (x) {
                return x != null ? x.toString().replace(/(~|\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : x;
            };
            pathType.decode = function (x) {
                return x != null ? x.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : x;
            };
        };
        Ng1LocationServices.prototype.dispose = function () { };
        Ng1LocationServices.prototype.onChange = function (callback) {
            var _this = this;
            this._urlListeners.push(callback);
            return function () { return removeFrom(_this._urlListeners)(callback); };
        };
        Ng1LocationServices.prototype.html5Mode = function () {
            var html5Mode = this.$locationProvider.html5Mode();
            html5Mode = isObject(html5Mode) ? html5Mode.enabled : html5Mode;
            return html5Mode && this.$sniffer.history;
        };
        Ng1LocationServices.prototype.baseHref = function () {
            return this._baseHref || (this._baseHref = this.$browser.baseHref() || this.$window.location.pathname);
        };
        Ng1LocationServices.prototype.url = function (newUrl, replace, state) {
            if (replace === void 0) { replace = false; }
            if (isDefined(newUrl))
                this.$location.url(newUrl);
            if (replace)
                this.$location.replace();
            if (state)
                this.$location.state(state);
            return this.$location.url();
        };
        Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser, $window) {
            var _this = this;
            this.$location = $location;
            this.$sniffer = $sniffer;
            this.$browser = $browser;
            this.$window = $window;
            // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange
            $rootScope.$on('$locationChangeSuccess', function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });
            var _loc = val($location);
            // Bind these LocationService functions to $location
            createProxyFunctions(_loc, this, _loc, ['replace', 'path', 'search', 'hash']);
            // Bind these LocationConfig functions to $location
            createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);
        };
        return Ng1LocationServices;
    }());

    /** @publicapi @module url */ /** */
    /**
     * Manages rules for client-side URL
     *
     * ### Deprecation warning:
     * This class is now considered to be an internal API
     * Use the [[UrlService]] instead.
     * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
     *
     * This class manages the router rules for what to do when the URL changes.
     *
     * This provider remains for backwards compatibility.
     *
     * @internalapi
     * @deprecated
     */
    var UrlRouterProvider = /** @class */ (function () {
        /** @hidden */
        function UrlRouterProvider(/** @hidden */ router) {
            this.router = router;
        }
        UrlRouterProvider.injectableHandler = function (router, handler) {
            return function (match) { return services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params }); };
        };
        /** @hidden */
        UrlRouterProvider.prototype.$get = function () {
            var urlService = this.router.urlService;
            this.router.urlRouter.update(true);
            if (!urlService.interceptDeferred)
                urlService.listen();
            return this.router.urlRouter;
        };
        /**
         * Registers a url handler function.
         *
         * Registers a low level url handler (a `rule`).
         * A rule detects specific URL patterns and returns a redirect, or performs some action.
         *
         * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Here's an example of how you might allow case insensitive urls
         *   $urlRouterProvider.rule(function ($injector, $location) {
         *     var path = $location.path(),
         *         normalized = path.toLowerCase();
         *
         *     if (path !== normalized) {
         *       return normalized;
         *     }
         *   });
         * });
         * ```
         *
         * @param ruleFn
         * Handler function that takes `$injector` and `$location` services as arguments.
         * You can use them to detect a url and return a different url as a string.
         *
         * @return [[UrlRouterProvider]] (`this`)
         */
        UrlRouterProvider.prototype.rule = function (ruleFn) {
            var _this = this;
            if (!isFunction(ruleFn))
                throw new Error("'rule' must be a function");
            var match = function () { return ruleFn(services.$injector, _this.router.locationService); };
            var rule = new BaseUrlRule(match, identity);
            this.router.urlService.rules.rule(rule);
            return this;
        };
        /**
         * Defines the path or behavior to use when no url can be matched.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // if the path doesn't match any of the urls you configured
         *   // otherwise will take care of routing the user to the
         *   // specified url
         *   $urlRouterProvider.otherwise('/index');
         *
         *   // Example of using function rule as param
         *   $urlRouterProvider.otherwise(function ($injector, $location) {
         *     return '/a/valid/url';
         *   });
         * });
         * ```
         *
         * @param rule
         * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.
         * The function version is passed two params: `$injector` and `$location` services, and should return a url string.
         *
         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
         */
        UrlRouterProvider.prototype.otherwise = function (rule) {
            var _this = this;
            var urlRules = this.router.urlService.rules;
            if (isString(rule)) {
                urlRules.otherwise(rule);
            }
            else if (isFunction(rule)) {
                urlRules.otherwise(function () { return rule(services.$injector, _this.router.locationService); });
            }
            else {
                throw new Error("'rule' must be a string or function");
            }
            return this;
        };
        /**
         * Registers a handler for a given url matching.
         *
         * If the handler is a string, it is
         * treated as a redirect, and is interpolated according to the syntax of match
         * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
         *
         * If the handler is a function, it is injectable.
         * It gets invoked if `$location` matches.
         * You have the option of inject the match object as `$match`.
         *
         * The handler can return
         *
         * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
         *   will continue trying to find another one that matches.
         * - **string** which is treated as a redirect and passed to `$location.url()`
         * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
         *     if ($state.$current.navigable !== state ||
         *         !equalForKeys($match, $stateParams) {
         *      $state.transitionTo(state, $match, false);
         *     }
         *   });
         * });
         * ```
         *
         * @param what A pattern string to match, compiled as a [[UrlMatcher]].
         * @param handler The path (or function that returns a path) that you want to redirect your user to.
         * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]
         *
         * Note: the handler may also invoke arbitrary code, such as `$state.go()`
         */
        UrlRouterProvider.prototype.when = function (what, handler) {
            if (isArray(handler) || isFunction(handler)) {
                handler = UrlRouterProvider.injectableHandler(this.router, handler);
            }
            this.router.urlService.rules.when(what, handler);
            return this;
        };
        /**
         * Disables monitoring of the URL.
         *
         * Call this method before UI-Router has bootstrapped.
         * It will stop UI-Router from performing the initial url sync.
         *
         * This can be useful to perform some asynchronous initialization before the router starts.
         * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.
         *
         * #### Example:
         * ```js
         * var app = angular.module('app', ['ui.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Prevent $urlRouter from automatically intercepting URL changes;
         *   $urlRouterProvider.deferIntercept();
         * })
         *
         * app.run(function (MyService, $urlRouter, $http) {
         *   $http.get("/stuff").then(function(resp) {
         *     MyService.doStuff(resp.data);
         *     $urlRouter.listen();
         *     $urlRouter.sync();
         *   });
         * });
         * ```
         *
         * @param defer Indicates whether to defer location change interception.
         *        Passing no parameter is equivalent to `true`.
         */
        UrlRouterProvider.prototype.deferIntercept = function (defer) {
            this.router.urlService.deferIntercept(defer);
        };
        return UrlRouterProvider;
    }());

    /**
     * # Angular 1 types
     *
     * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.
     * The customizations to the core types for Angular UI-Router are documented here.
     *
     * The optional [[$resolve]] service is also documented here.
     *
     * @preferred @publicapi @module ng1
     */ /** */
    ng.module('ui.router.angular1', []);
    var mod_init = ng.module('ui.router.init', ['ng']);
    var mod_util = ng.module('ui.router.util', ['ui.router.init']);
    var mod_rtr = ng.module('ui.router.router', ['ui.router.util']);
    var mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
    var mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
    var mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line
    var router = null;
    $uiRouterProvider.$inject = ['$locationProvider'];
    /** This angular 1 provider instantiates a Router and exposes its services via the angular injector */
    function $uiRouterProvider($locationProvider) {
        // Create a new instance of the Router when the $uiRouterProvider is initialized
        router = this.router = new UIRouter();
        router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);
        // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties
        router.stateRegistry.decorator('views', ng1ViewsBuilder);
        router.stateRegistry.decorator('onExit', getStateHookBuilder('onExit'));
        router.stateRegistry.decorator('onRetain', getStateHookBuilder('onRetain'));
        router.stateRegistry.decorator('onEnter', getStateHookBuilder('onEnter'));
        router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());
        var ng1LocationService = (router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider));
        Ng1LocationServices.monkeyPatchPathParameterType(router);
        // backwards compat: also expose router instance as $uiRouterProvider.router
        router['router'] = router;
        router['$get'] = $get;
        $get.$inject = ['$location', '$browser', '$window', '$sniffer', '$rootScope', '$http', '$templateCache'];
        function $get($location, $browser, $window, $sniffer, $rootScope, $http, $templateCache) {
            ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser, $window);
            delete router['router'];
            delete router['$get'];
            return router;
        }
        return router;
    }
    var getProviderFor = function (serviceName) { return [
        '$uiRouterProvider',
        function ($urp) {
            var service = $urp.router[serviceName];
            service['$get'] = function () { return service; };
            return service;
        },
    ]; };
    // This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)
    runBlock.$inject = ['$injector', '$q', '$uiRouter'];
    function runBlock($injector, $q, $uiRouter) {
        services.$injector = $injector;
        services.$q = $q;
        // https://github.com/angular-ui/ui-router/issues/3678
        if (!$injector.hasOwnProperty('strictDi')) {
            try {
                $injector.invoke(function (checkStrictDi) { });
            }
            catch (error) {
                $injector.strictDi = !!/strict mode/.exec(error && error.toString());
            }
        }
        // The $injector is now available.
        // Find any resolvables that had dependency annotation deferred
        $uiRouter.stateRegistry
            .get()
            .map(function (x) { return x.$$state().resolvables; })
            .reduce(unnestR, [])
            .filter(function (x) { return x.deps === 'deferred'; })
            .forEach(function (resolvable) { return (resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi)); });
    }
    // $urlRouter service and $urlRouterProvider
    var getUrlRouterProvider = function (uiRouter) { return (uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter)); };
    // $state service and $stateProvider
    // $urlRouter service and $urlRouterProvider
    var getStateProvider = function () { return extend(router.stateProvider, { $get: function () { return router.stateService; } }); };
    watchDigests.$inject = ['$rootScope'];
    function watchDigests($rootScope) {
        $rootScope.$watch(function () {
            trace.approximateDigests++;
        });
    }
    mod_init.provider('$uiRouter', $uiRouterProvider);
    mod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);
    mod_util.provider('$urlService', getProviderFor('urlService'));
    mod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);
    mod_util.provider('$templateFactory', function () { return new TemplateFactory(); });
    mod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));
    mod_state.provider('$uiRouterGlobals', getProviderFor('globals'));
    mod_state.provider('$transitions', getProviderFor('transitionService'));
    mod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);
    mod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);
    mod_main.factory('$view', function () { return router.viewService; });
    mod_main.service('$trace', function () { return trace; });
    mod_main.run(watchDigests);
    mod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);
    mod_state.run(['$state', function ($state) { }]);
    mod_rtr.run(['$urlRouter', function ($urlRouter) { }]);
    mod_init.run(runBlock);
    /** @hidden TODO: find a place to move this */
    var getLocals = function (ctx) {
        var tokens = ctx.getTokens().filter(isString);
        var tuples = tokens.map(function (key) {
            var resolvable = ctx.getResolvable(key);
            var waitPolicy = ctx.getPolicy(resolvable).async;
            return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];
        });
        return tuples.reduce(applyPairs, {});
    };

    /**
     * # Angular 1 Directives
     *
     * These are the directives included in UI-Router for Angular 1.
     * These directives are used in templates to create viewports and link/navigate to states.
     *
     * @preferred @publicapi @module directives
     */ /** */
    /** @hidden */
    function parseStateRef(ref) {
        var parsed;
        var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        if (paramsOnly)
            ref = '(' + paramsOnly[1] + ')';
        parsed = ref.replace(/\n/g, ' ').match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
        if (!parsed || parsed.length !== 4)
            throw new Error("Invalid state ref '" + ref + "'");
        return { state: parsed[1] || null, paramExpr: parsed[3] || null };
    }
    /** @hidden */
    function stateContext(el) {
        var $uiView = el.parent().inheritedData('$uiView');
        var path = parse('$cfg.path')($uiView);
        return path ? tail(path).state.name : undefined;
    }
    /** @hidden */
    function processedDef($state, $element, def) {
        var uiState = def.uiState || $state.current.name;
        var uiStateOpts = extend(defaultOpts($element, $state), def.uiStateOpts || {});
        var href = $state.href(uiState, def.uiStateParams, uiStateOpts);
        return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };
    }
    /** @hidden */
    function getTypeInfo(el) {
        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === 'FORM';
        return {
            attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',
            isAnchor: el.prop('tagName').toUpperCase() === 'A',
            clickable: !isForm,
        };
    }
    /** @hidden */
    function clickHook(el, $state, $timeout, type, getDef) {
        return function (e) {
            var button = e.which || e.button, target = getDef();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
                // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
                var transition_1 = $timeout(function () {
                    if (!el.attr('disabled')) {
                        $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
                    }
                });
                e.preventDefault();
                // if the state has no URL, ignore one preventDefault from the <a> directive.
                var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function () {
                    if (ignorePreventDefaultCount_1-- <= 0)
                        $timeout.cancel(transition_1);
                };
            }
        };
    }
    /** @hidden */
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: true,
            source: 'sref',
        };
    }
    /** @hidden */
    function bindEvents(element, scope, hookFn, uiStateOpts) {
        var events;
        if (uiStateOpts) {
            events = uiStateOpts.events;
        }
        if (!isArray(events)) {
            events = ['click'];
        }
        var on = element.on ? 'on' : 'bind';
        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var event_1 = events_1[_i];
            element[on](event_1, hookFn);
        }
        scope.$on('$destroy', function () {
            var off = element.off ? 'off' : 'unbind';
            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {
                var event_2 = events_2[_i];
                element[off](event_2, hookFn);
            }
        });
    }
    /**
     * `ui-sref`: A directive for linking to a state
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * ### Linked State
     * The attribute value of the `ui-sref` is the name of the state to link to.
     *
     * #### Example:
     * This will activate the `home` state when the link is clicked.
     * ```html
     * <a ui-sref="home">Home</a>
     * ```
     *
     * ### Relative Links
     * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).
     * You just need to be aware that the path is relative to the state that *created* the link.
     * This allows a state to create a relative `ui-sref` which always targets the same destination.
     *
     * #### Example:
     * Both these links are relative to the parent state, even when a child state is currently active.
     * ```html
     * <a ui-sref=".child1">child 1 state</a>
     * <a ui-sref=".child2">child 2 state</a>
     * ```
     *
     * This link activates the parent state.
     * ```html
     * <a ui-sref="^">Return</a>
     * ```
     *
     * ### hrefs
     * If the linked state has a URL, the directive will automatically generate and
     * update the `href` attribute (using the [[StateService.href]]  method).
     *
     * #### Example:
     * Assuming the `users` state has a url of `/users/`
     * ```html
     * <a ui-sref="users" href="/users/">Users</a>
     * ```
     *
     * ### Parameter Values
     * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.
     * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.
     * The content inside the parentheses is an expression, evaluated to the parameter values.
     *
     * #### Example:
     * This example renders a list of links to users.
     * The state's `userId` parameter value comes from each user's `user.id` property.
     * ```html
     * <li ng-repeat="user in users">
     *   <a ui-sref="users.detail({ userId: user.id })">{{ user.displayName }}</a>
     * </li>
     * ```
     *
     * Note:
     * The parameter values expression is `$watch`ed for updates.
     *
     * ### Transition Options
     * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.
     * Options are restricted to `location`, `inherit`, and `reload`.
     *
     * #### Example:
     * ```html
     * <a ui-sref="home" ui-sref-opts="{ reload: true }">Home</a>
     * ```
     *
     * ### Other DOM Events
     *
     * You can also customize which DOM events to respond to (instead of `click`) by
     * providing an `events` array in the `ui-sref-opts` attribute.
     *
     * #### Example:
     * ```html
     * <input type="text" ui-sref="contacts" ui-sref-opts="{ events: ['change', 'blur'] }">
     * ```
     *
     * ### Highlighting the active link
     * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
     *
     * ### Examples
     * If you have the following template:
     *
     * ```html
     * <a ui-sref="home">Home</a>
     * <a ui-sref="about">About</a>
     * <a ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
     *     </li>
     * </ul>
     * ```
     *
     * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:
     *
     * ```html
     * <a href="#/home" ui-sref="home">Home</a>
     * <a href="#/about" ui-sref="about">About</a>
     * <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
     *     </li>
     * </ul>
     *
     * <a href="#/home" ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
     * ```
     *
     * ### Notes
     *
     * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.
     * #### Example:
     * Sets the `lang` parameter to `en` and remains on the same state.
     *
     * ```html
     * <a ui-sref="{ lang: 'en' }">English</a>
     * ```
     *
     * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
     *
     * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).
     * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.
     */
    var uiSrefDirective;
    uiSrefDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var ref = parseStateRef(attrs.uiSref);
                    rawDef.uiState = ref.state;
                    rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    if (ref.paramExpr) {
                        scope.$watch(ref.paramExpr, function (val) {
                            rawDef.uiStateParams = extend({}, val);
                            update();
                        }, true);
                        rawDef.uiStateParams = extend({}, scope.$eval(ref.paramExpr));
                    }
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    /**
     * `ui-state`: A fully dynamic directive for linking to a state
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**
     *
     * A directive which links to a state (and optionally, parameters).
     * When clicked, this directive activates the linked state with the supplied parameter values.
     *
     * ### Linked State
     * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.
     * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**
     *
     * #### Example:
     * Create a list of links.
     * ```html
     * <li ng-repeat="link in navlinks">
     *   <a ui-state="link.state">{{ link.displayName }}</a>
     * </li>
     * ```
     *
     * ### Relative Links
     * If the expression evaluates to a relative path, it is processed like [[uiSref]].
     * You just need to be aware that the path is relative to the state that *created* the link.
     * This allows a state to create relative `ui-state` which always targets the same destination.
     *
     * ### hrefs
     * If the linked state has a URL, the directive will automatically generate and
     * update the `href` attribute (using the [[StateService.href]]  method).
     *
     * ### Parameter Values
     * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.
     * Param values should be provided using the `ui-state-params` attribute.
     * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.
     *
     * #### Example:
     * This example renders a list of links with param values.
     * The state's `userId` parameter value comes from each user's `user.id` property.
     * ```html
     * <li ng-repeat="link in navlinks">
     *   <a ui-state="link.state" ui-state-params="link.params">{{ link.displayName }}</a>
     * </li>
     * ```
     *
     * ### Transition Options
     * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.
     * Options are restricted to `location`, `inherit`, and `reload`.
     * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.
     *
     * #### Example:
     * ```html
     * <a ui-state="returnto.state" ui-state-opts="{ reload: true }">Home</a>
     * ```
     *
     * ### Other DOM Events
     *
     * You can also customize which DOM events to respond to (instead of `click`) by
     * providing an `events` array in the `ui-state-opts` attribute.
     *
     * #### Example:
     * ```html
     * <input type="text" ui-state="contacts" ui-state-opts="{ events: ['change', 'blur'] }">
     * ```
     *
     * ### Highlighting the active link
     * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
     *
     * ### Notes
     *
     * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.
     *   However, it might be simpler to use [[uiSref]] parameter-only links.
     *
     * #### Example:
     * Sets the `lang` parameter to `en` and remains on the same state.
     *
     * ```html
     * <a ui-state="" ui-state-params="{ lang: 'en' }">English</a>
     * ```
     *
     * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
     * ```
     */
    var uiStateDirective;
    uiStateDirective = [
        '$uiRouter',
        '$timeout',
        function $StateRefDynamicDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: 'A',
                require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function () { return processedDef($state, element, rawDef); };
                    var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];
                    var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return ((acc[attr] = noop), acc); }, {});
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn)
                            unlinkInfoFn();
                        if (active)
                            unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null)
                            attrs.$set(type.attr, def.href);
                    }
                    inputAttrs.forEach(function (field) {
                        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
                        attrs.$observe(field, function (expr) {
                            watchDeregFns[field]();
                            watchDeregFns[field] = scope.$watch(expr, function (newval) {
                                rawDef[field] = newval;
                                update();
                            }, true);
                        });
                    });
                    update();
                    scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable)
                        return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                },
            };
        },
    ];
    /**
     * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active
     *
     * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the
     * related directive's state is active (and remove them when it is inactive).
     *
     * The primary use-case is to highlight the active link in navigation menus,
     * distinguishing it from the inactive menu items.
     *
     * ### Linking to a `ui-sref` or `ui-state`
     * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.
     * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.
     *
     * ### Matching
     *
     * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.
     * This is a "fuzzy match" which uses [[StateService.includes]].
     *
     * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).
     * This is an "exact match" which uses [[StateService.is]].
     *
     * ### Parameter values
     * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.
     * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.
     *
     * #### Example:
     * ```html
     * <li ng-repeat="user in users" ui-sref-active="active">
     *   <a ui-sref="user.details({ userId: user.id })">{{ user.lastName }}</a>
     * </li>
     * ```
     *
     * ### Examples
     *
     * Given the following template:
     * #### Example:
     * ```html
     * <ul>
     *   <li ui-sref-active="active" class="item">
     *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
     *   </li>
     * </ul>
     * ```
     *
     * When the app state is `app.user` (or any child state),
     * and contains the state parameter "user" with value "bilbobaggins",
     * the resulting HTML will appear as (note the 'active' class):
     *
     * ```html
     * <ul>
     *   <li ui-sref-active="active" class="item active">
     *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
     *   </li>
     * </ul>
     * ```
     *
     * ### Glob mode
     *
     * It is possible to pass `ui-sref-active` an expression that evaluates to an object.
     * The objects keys represent active class names and values represent the respective state names/globs.
     * `ui-sref-active` will match if the current active state **includes** any of
     * the specified state names/globs, even the abstract ones.
     *
     * #### Example:
     * Given the following template, with "admin" being an abstract state:
     * ```html
     * <div ui-sref-active="{'active': 'admin.**'}">
     *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
     * </div>
     * ```
     *
     * Arrays are also supported as values in the `ngClass`-like interface.
     * This allows multiple states to add `active` class.
     *
     * #### Example:
     * Given the following template, with "admin.roles" being the current state, the class will be added too:
     * ```html
     * <div ui-sref-active="{'active': ['owner.**', 'admin.**']}">
     *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
     * </div>
     * ```
     *
     * When the current state is "admin.roles" the "active" class will be applied to both the `<div>` and `<a>` elements.
     * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.
     *
     * ### Notes:
     *
     * - The class name is interpolated **once** during the directives link time (any further changes to the
     * interpolated value are ignored).
     *
     * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`
     */
    var uiSrefActiveDirective;
    uiSrefActiveDirective = [
        '$state',
        '$stateParams',
        '$interpolate',
        '$uiRouter',
        function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$element',
                    '$attrs',
                    function ($scope, $element, $attrs) {
                        var states = [];
                        var activeEqClass;
                        var uiSrefActive;
                        // There probably isn't much point in $observing this
                        // uiSrefActive and uiSrefActiveEq share the same directive object with some
                        // slight difference in logic routing
                        activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                        try {
                            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                        }
                        catch (e) {
                            // Do nothing. uiSrefActive is not a valid expression.
                            // Fall back to using $interpolate below
                        }
                        uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                        setStatesFromDefinitionObject(uiSrefActive);
                        // Allow uiSref to communicate with uiSrefActive[Equals]
                        this.$$addStateInfo = function (newState, newParams) {
                            // we already got an explicit state provided by ui-sref-active, so we
                            // shadow the one that comes from ui-sref
                            if (isObject(uiSrefActive) && states.length > 0) {
                                return;
                            }
                            var deregister = addState(newState, newParams, uiSrefActive);
                            update();
                            return deregister;
                        };
                        function updateAfterTransition(trans) {
                            trans.promise.then(update, noop);
                        }
                        $scope.$on('$destroy', setupEventListeners());
                        if ($uiRouter.globals.transition) {
                            updateAfterTransition($uiRouter.globals.transition);
                        }
                        function setupEventListeners() {
                            var deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged);
                            var deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition);
                            var deregisterStateChangeSuccessListener = $scope.$on('$stateChangeSuccess', update);
                            return function cleanUp() {
                                deregisterStatesChangedListener();
                                deregisterOnStartListener();
                                deregisterStateChangeSuccessListener();
                            };
                        }
                        function handleStatesChanged() {
                            setStatesFromDefinitionObject(uiSrefActive);
                        }
                        function setStatesFromDefinitionObject(statesDefinition) {
                            if (isObject(statesDefinition)) {
                                states = [];
                                forEach(statesDefinition, function (stateOrName, activeClass) {
                                    // Helper function to abstract adding state.
                                    var addStateForClass = function (stateOrName, activeClass) {
                                        var ref = parseStateRef(stateOrName);
                                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                    };
                                    if (isString(stateOrName)) {
                                        // If state is string, just add it.
                                        addStateForClass(stateOrName, activeClass);
                                    }
                                    else if (isArray(stateOrName)) {
                                        // If state is an array, iterate over it and add each array item individually.
                                        forEach(stateOrName, function (stateOrName) {
                                            addStateForClass(stateOrName, activeClass);
                                        });
                                    }
                                });
                            }
                        }
                        function addState(stateName, stateParams, activeClass) {
                            var state = $state.get(stateName, stateContext($element));
                            var stateInfo = {
                                state: state || { name: stateName },
                                params: stateParams,
                                activeClass: activeClass,
                            };
                            states.push(stateInfo);
                            return function removeState() {
                                removeFrom(states)(stateInfo);
                            };
                        }
                        // Update route state
                        function update() {
                            var splitClasses = function (str) { return str.split(/\s/).filter(identity); };
                            var getClasses = function (stateList) {
                                return stateList
                                    .map(function (x) { return x.activeClass; })
                                    .map(splitClasses)
                                    .reduce(unnestR, []);
                            };
                            var allClasses = getClasses(states)
                                .concat(splitClasses(activeEqClass))
                                .reduce(uniqR, []);
                            var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));
                            var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;
                            var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
                            var addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);
                            var removeClasses = allClasses.filter(function (cls) { return !inArray(addClasses, cls); });
                            $scope.$evalAsync(function () {
                                addClasses.forEach(function (className) { return $element.addClass(className); });
                                removeClasses.forEach(function (className) { return $element.removeClass(className); });
                            });
                        }
                        update();
                    },
                ],
            };
        },
    ];
    ng
        .module('ui.router.state')
        .directive('uiSref', uiSrefDirective)
        .directive('uiSrefActive', uiSrefActiveDirective)
        .directive('uiSrefActiveEq', uiSrefActiveDirective)
        .directive('uiState', uiStateDirective);

    /** @publicapi @module ng1 */ /** */
    /**
     * `isState` Filter: truthy if the current state is the parameter
     *
     * Translates to [[StateService.is]] `$state.is("stateName")`.
     *
     * #### Example:
     * ```html
     * <div ng-if="'stateName' | isState">show if state is 'stateName'</div>
     * ```
     */
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
        var isFilter = function (state, params, options) {
            return $state.is(state, params, options);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    /**
     * `includedByState` Filter: truthy if the current state includes the parameter
     *
     * Translates to [[StateService.includes]]` $state.is("fullOrPartialStateName")`.
     *
     * #### Example:
     * ```html
     * <div ng-if="'fullOrPartialStateName' | includedByState">show if state includes 'fullOrPartialStateName'</div>
     * ```
     */
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
        var includesFilter = function (state, params, options) {
            return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    ng
        .module('ui.router.state')
        .filter('isState', $IsStateFilter)
        .filter('includedByState', $IncludedByStateFilter);

    /** @publicapi @module directives */ /** */
    /**
     * `ui-view`: A viewport directive which is filled in by a view from the active state.
     *
     * ### Attributes
     *
     * - `name`: (Optional) A view name.
     *   The name should be unique amongst the other views in the same state.
     *   You can have views of the same name that live in different states.
     *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).
     *
     * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.
     *   Uses [[$uiViewScroll]] to do the scrolling.
     *
     * - `onload`: Expression to evaluate whenever the view updates.
     *
     * #### Example:
     * A view can be unnamed or named.
     * ```html
     * <!-- Unnamed -->
     * <div ui-view></div>
     *
     * <!-- Named -->
     * <div ui-view="viewName"></div>
     *
     * <!-- Named (different style) -->
     * <ui-view name="viewName"></ui-view>
     * ```
     *
     * You can only have one unnamed view within any template (or root html). If you are only using a
     * single view and it is unnamed then you can populate it like so:
     *
     * ```html
     * <div ui-view></div>
     * $stateProvider.state("home", {
     *   template: "<h1>HELLO!</h1>"
     * })
     * ```
     *
     * The above is a convenient shortcut equivalent to specifying your view explicitly with the
     * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * ```
     *
     * But typically you'll only use the views property if you name your view or have more than one view
     * in the same template. There's not really a compelling reason to name a view if its the only one,
     * but you could if you wanted, like so:
     *
     * ```html
     * <div ui-view="main"></div>
     * ```
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "main": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * ```
     *
     * Really though, you'll use views to set up multiple views:
     *
     * ```html
     * <div ui-view></div>
     * <div ui-view="chart"></div>
     * <div ui-view="data"></div>
     * ```
     *
     * ```js
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     },
     *     "chart": {
     *       template: "<chart_thing/>"
     *     },
     *     "data": {
     *       template: "<data_thing/>"
     *     }
     *   }
     * })
     * ```
     *
     * #### Examples for `autoscroll`:
     * ```html
     * <!-- If autoscroll present with no expression,
     *      then scroll ui-view into view -->
     * <ui-view autoscroll/>
     *
     * <!-- If autoscroll present with valid expression,
     *      then scroll ui-view into view if expression evaluates to true -->
     * <ui-view autoscroll='true'/>
     * <ui-view autoscroll='false'/>
     * <ui-view autoscroll='scopeVariable'/>
     * ```
     *
     * Resolve data:
     *
     * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
     * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
     *
     * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
     * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
     * depends on `$resolve` data.
     *
     * #### Example:
     * ```js
     * $stateProvider.state('home', {
     *   template: '<my-component user="$resolve.user"></my-component>',
     *   resolve: {
     *     user: function(UserService) { return UserService.fetchUser(); }
     *   }
     * });
     * ```
     */
    var uiView;
    uiView = [
        '$view',
        '$animate',
        '$uiViewScroll',
        '$interpolate',
        '$q',
        function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {
            function getRenderer(attrs, scope) {
                return {
                    enter: function (element, target, cb) {
                        if (ng.version.minor > 2) {
                            $animate.enter(element, null, target).then(cb);
                        }
                        else {
                            $animate.enter(element, null, target, cb);
                        }
                    },
                    leave: function (element, cb) {
                        if (ng.version.minor > 2) {
                            $animate.leave(element).then(cb);
                        }
                        else {
                            $animate.leave(element, cb);
                        }
                    },
                };
            }
            function configsEqual(config1, config2) {
                return config1 === config2;
            }
            var rootData = {
                $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },
                $uiView: {},
            };
            var directive = {
                count: 0,
                restrict: 'ECA',
                terminal: true,
                priority: 400,
                transclude: 'element',
                compile: function (tElement, tAttrs, $transclude) {
                    return function (scope, $element, attrs) {
                        var onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(), inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';
                        var previousEl, currentEl, currentScope, viewConfig, unregister;
                        var activeUIView = {
                            $type: 'ng1',
                            id: directive.count++,
                            name: name,
                            fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,
                            config: null,
                            configUpdated: configUpdatedCallback,
                            get creationContext() {
                                // The context in which this ui-view "tag" was created
                                var fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited);
                                // Allow <ui-view name="foo"><ui-view name="bar"></ui-view></ui-view>
                                // See https://github.com/angular-ui/ui-router/issues/3355
                                var fromParentTag = parse('$uiView.creationContext')(inherited);
                                return fromParentTagConfig || fromParentTag;
                            },
                        };
                        trace.traceUIViewEvent('Linking', activeUIView);
                        function configUpdatedCallback(config) {
                            if (config && !(config instanceof Ng1ViewConfig))
                                return;
                            if (configsEqual(viewConfig, config))
                                return;
                            trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);
                            viewConfig = config;
                            updateView(config);
                        }
                        $element.data('$uiView', { $uiView: activeUIView });
                        updateView();
                        unregister = $view.registerUIView(activeUIView);
                        scope.$on('$destroy', function () {
                            trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);
                            unregister();
                        });
                        function cleanupLastView() {
                            if (previousEl) {
                                trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));
                                previousEl.remove();
                                previousEl = null;
                            }
                            if (currentScope) {
                                trace.traceUIViewEvent('Destroying scope', activeUIView);
                                currentScope.$destroy();
                                currentScope = null;
                            }
                            if (currentEl) {
                                var _viewData_1 = currentEl.data('$uiViewAnim');
                                trace.traceUIViewEvent('Animate out', _viewData_1);
                                renderer.leave(currentEl, function () {
                                    _viewData_1.$$animLeave.resolve();
                                    previousEl = null;
                                });
                                previousEl = currentEl;
                                currentEl = null;
                            }
                        }
                        function updateView(config) {
                            var newScope = scope.$new();
                            var animEnter = $q.defer(), animLeave = $q.defer();
                            var $uiViewData = {
                                $cfg: config,
                                $uiView: activeUIView,
                            };
                            var $uiViewAnim = {
                                $animEnter: animEnter.promise,
                                $animLeave: animLeave.promise,
                                $$animLeave: animLeave,
                            };
                            /**
                             * @ngdoc event
                             * @name ui.router.state.directive:ui-view#$viewContentLoading
                             * @eventOf ui.router.state.directive:ui-view
                             * @eventType emits on ui-view directive scope
                             * @description
                             *
                             * Fired once the view **begins loading**, *before* the DOM is rendered.
                             *
                             * @param {Object} event Event object.
                             * @param {string} viewName Name of the view.
                             */
                            newScope.$emit('$viewContentLoading', name);
                            var cloned = $transclude(newScope, function (clone) {
                                clone.data('$uiViewAnim', $uiViewAnim);
                                clone.data('$uiView', $uiViewData);
                                renderer.enter(clone, $element, function onUIViewEnter() {
                                    animEnter.resolve();
                                    if (currentScope)
                                        currentScope.$emit('$viewContentAnimationEnded');
                                    if ((isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {
                                        $uiViewScroll(clone);
                                    }
                                });
                                cleanupLastView();
                            });
                            currentEl = cloned;
                            currentScope = newScope;
                            /**
                             * @ngdoc event
                             * @name ui.router.state.directive:ui-view#$viewContentLoaded
                             * @eventOf ui.router.state.directive:ui-view
                             * @eventType emits on ui-view directive scope
                             * @description           *
                             * Fired once the view is **loaded**, *after* the DOM is rendered.
                             *
                             * @param {Object} event Event object.
                             */
                            currentScope.$emit('$viewContentLoaded', config || viewConfig);
                            currentScope.$eval(onloadExp);
                        }
                    };
                },
            };
            return directive;
        },
    ];
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];
    /** @hidden */
    function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {
        var getControllerAs = parse('viewDecl.controllerAs');
        var getResolveAs = parse('viewDecl.resolveAs');
        return {
            restrict: 'ECA',
            priority: -400,
            compile: function (tElement) {
                var initial = tElement.html();
                tElement.empty();
                return function (scope, $element) {
                    var data = $element.data('$uiView');
                    if (!data) {
                        $element.html(initial);
                        $compile($element.contents())(scope);
                        return;
                    }
                    var cfg = data.$cfg || { viewDecl: {}, getTemplate: noop };
                    var resolveCtx = cfg.path && new ResolveContext(cfg.path);
                    $element.html(cfg.getTemplate($element, resolveCtx) || initial);
                    trace.traceUIViewFill(data.$uiView, $element.html());
                    var link = $compile($element.contents());
                    var controller = cfg.controller;
                    var controllerAs = getControllerAs(cfg);
                    var resolveAs = getResolveAs(cfg);
                    var locals = resolveCtx && getLocals(resolveCtx);
                    scope[resolveAs] = locals;
                    if (controller) {
                        var controllerInstance = ($controller(controller, extend({}, locals, { $scope: scope, $element: $element })));
                        if (controllerAs) {
                            scope[controllerAs] = controllerInstance;
                            scope[controllerAs][resolveAs] = locals;
                        }
                        // TODO: Use $view service as a central point for registering component-level hooks
                        // Then, when a component is created, tell the $view service, so it can invoke hooks
                        // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
                        // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
                        $element.data('$ngControllerController', controllerInstance);
                        $element.children().data('$ngControllerController', controllerInstance);
                        registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);
                    }
                    // Wait for the component to appear in the DOM
                    if (isString(cfg.component)) {
                        var kebobName = kebobString(cfg.component);
                        var tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", 'i');
                        var getComponentController = function () {
                            var directiveEl = [].slice
                                .call($element[0].children)
                                .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });
                            return directiveEl && ng.element(directiveEl).data("$" + cfg.component + "Controller");
                        };
                        var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {
                            if (!ctrlInstance)
                                return;
                            registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);
                            deregisterWatch_1();
                        });
                    }
                    link(scope);
                };
            },
        };
    }
    /** @hidden */
    var hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';
    /** @hidden incrementing id */
    var _uiCanExitId = 0;
    /** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */
    function registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {
        // Call $onInit() ASAP
        if (isFunction(controllerInstance.$onInit) && !((cfg.viewDecl.component || cfg.viewDecl.componentProvider) && hasComponentImpl)) {
            controllerInstance.$onInit();
        }
        var viewState = tail(cfg.path).state.self;
        var hookOptions = { bind: controllerInstance };
        // Add component-level hook for onUiParamsChanged
        if (isFunction(controllerInstance.uiOnParamsChanged)) {
            var resolveContext = new ResolveContext(cfg.path);
            var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;
            // Fire callback on any successful transition
            var paramsUpdated = function ($transition$) {
                // Exit early if the $transition$ is the same as the view was created within.
                // Exit early if the $transition$ will exit the state the view is for.
                if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)
                    return;
                var toParams = $transition$.params('to');
                var fromParams = $transition$.params('from');
                var getNodeSchema = function (node) { return node.paramSchema; };
                var toSchema = $transition$
                    .treeChanges('to')
                    .map(getNodeSchema)
                    .reduce(unnestR, []);
                var fromSchema = $transition$
                    .treeChanges('from')
                    .map(getNodeSchema)
                    .reduce(unnestR, []);
                // Find the to params that have different values than the from params
                var changedToParams = toSchema.filter(function (param) {
                    var idx = fromSchema.indexOf(param);
                    return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
                });
                // Only trigger callback if a to param has changed or is new
                if (changedToParams.length) {
                    var changedKeys_1 = changedToParams.map(function (x) { return x.id; });
                    // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
                    var newValues = filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });
                    controllerInstance.uiOnParamsChanged(newValues, $transition$);
                }
            };
            $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));
        }
        // Add component-level hook for uiCanExit
        if (isFunction(controllerInstance.uiCanExit)) {
            var id_1 = _uiCanExitId++;
            var cacheProp_1 = '_uiCanExitIds';
            // Returns true if a redirect transition already answered truthy
            var prevTruthyAnswer_1 = function (trans) {
                return !!trans && ((trans[cacheProp_1] && trans[cacheProp_1][id_1] === true) || prevTruthyAnswer_1(trans.redirectedFrom()));
            };
            // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition
            var wrappedHook = function (trans) {
                var promise;
                var ids = (trans[cacheProp_1] = trans[cacheProp_1] || {});
                if (!prevTruthyAnswer_1(trans)) {
                    promise = $q.when(controllerInstance.uiCanExit(trans));
                    promise.then(function (val) { return (ids[id_1] = val !== false); });
                }
                return promise;
            };
            var criteria = { exiting: viewState.name };
            $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));
        }
    }
    ng.module('ui.router.state').directive('uiView', uiView);
    ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

    /** @publicapi @module ng1 */ /** */
    /** @hidden */
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function () {
            useAnchorScroll = true;
        };
        this.$get = [
            '$anchorScroll',
            '$timeout',
            function ($anchorScroll, $timeout) {
                if (useAnchorScroll) {
                    return $anchorScroll;
                }
                return function ($element) {
                    return $timeout(function () {
                        $element[0].scrollIntoView();
                    }, 0, false);
                };
            },
        ];
    }
    ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

    var index$1 = 'ui.router';

    exports.$injector = $injector;
    exports.$q = $q;
    exports.BaseLocationServices = BaseLocationServices;
    exports.BaseUrlRule = BaseUrlRule;
    exports.BrowserLocationConfig = BrowserLocationConfig;
    exports.Glob = Glob;
    exports.HashLocationService = HashLocationService;
    exports.HookBuilder = HookBuilder;
    exports.MemoryLocationConfig = MemoryLocationConfig;
    exports.MemoryLocationService = MemoryLocationService;
    exports.NATIVE_INJECTOR_TOKEN = NATIVE_INJECTOR_TOKEN;
    exports.Ng1ViewConfig = Ng1ViewConfig;
    exports.Param = Param;
    exports.ParamFactory = ParamFactory;
    exports.ParamType = ParamType;
    exports.ParamTypes = ParamTypes;
    exports.PathNode = PathNode;
    exports.PathUtils = PathUtils;
    exports.PushStateLocationService = PushStateLocationService;
    exports.Queue = Queue;
    exports.RegisteredHook = RegisteredHook;
    exports.Rejection = Rejection;
    exports.Resolvable = Resolvable;
    exports.ResolveContext = ResolveContext;
    exports.StateBuilder = StateBuilder;
    exports.StateMatcher = StateMatcher;
    exports.StateObject = StateObject;
    exports.StateParams = StateParams;
    exports.StateProvider = StateProvider;
    exports.StateQueueManager = StateQueueManager;
    exports.StateRegistry = StateRegistry;
    exports.StateService = StateService;
    exports.TargetState = TargetState;
    exports.Trace = Trace;
    exports.Transition = Transition;
    exports.TransitionEventType = TransitionEventType;
    exports.TransitionHook = TransitionHook;
    exports.TransitionService = TransitionService;
    exports.UIRouter = UIRouter;
    exports.UIRouterGlobals = UIRouterGlobals;
    exports.UIRouterPluginBase = UIRouterPluginBase;
    exports.UrlConfig = UrlConfig;
    exports.UrlMatcher = UrlMatcher;
    exports.UrlMatcherFactory = UrlMatcherFactory;
    exports.UrlRouter = UrlRouter;
    exports.UrlRouterProvider = UrlRouterProvider;
    exports.UrlRuleFactory = UrlRuleFactory;
    exports.UrlRules = UrlRules;
    exports.UrlService = UrlService;
    exports.ViewService = ViewService;
    exports._extend = _extend;
    exports._inArray = _inArray;
    exports._pushTo = _pushTo;
    exports._removeFrom = _removeFrom;
    exports.all = all;
    exports.allTrueR = allTrueR;
    exports.ancestors = ancestors;
    exports.and = and;
    exports.any = any;
    exports.anyTrueR = anyTrueR;
    exports.applyPairs = applyPairs;
    exports.arrayTuples = arrayTuples;
    exports.assertFn = assertFn;
    exports.assertMap = assertMap;
    exports.assertPredicate = assertPredicate;
    exports.beforeAfterSubstr = beforeAfterSubstr;
    exports.buildUrl = buildUrl;
    exports.compose = compose;
    exports.copy = copy;
    exports.core = index;
    exports.createProxyFunctions = createProxyFunctions;
    exports.curry = curry;
    exports.default = index$1;
    exports.defaultResolvePolicy = defaultResolvePolicy;
    exports.defaultTransOpts = defaultTransOpts;
    exports.defaults = defaults;
    exports.deregAll = deregAll;
    exports.eq = eq;
    exports.equals = equals;
    exports.extend = extend;
    exports.filter = filter;
    exports.find = find;
    exports.flatten = flatten;
    exports.flattenR = flattenR;
    exports.fnToString = fnToString;
    exports.forEach = forEach;
    exports.fromJson = fromJson;
    exports.functionToString = functionToString;
    exports.getLocals = getLocals;
    exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;
    exports.getParams = getParams;
    exports.hashLocationPlugin = hashLocationPlugin;
    exports.hostRegex = hostRegex;
    exports.identity = identity;
    exports.inArray = inArray;
    exports.inherit = inherit;
    exports.invoke = invoke;
    exports.is = is;
    exports.isArray = isArray;
    exports.isDate = isDate;
    exports.isDefined = isDefined;
    exports.isFunction = isFunction;
    exports.isInjectable = isInjectable;
    exports.isNull = isNull;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isPromise = isPromise;
    exports.isRegExp = isRegExp;
    exports.isString = isString;
    exports.isUndefined = isUndefined;
    exports.joinNeighborsR = joinNeighborsR;
    exports.kebobString = kebobString;
    exports.keyValsToObjectR = keyValsToObjectR;
    exports.locationPluginFactory = locationPluginFactory;
    exports.makeEvent = makeEvent;
    exports.makeStub = makeStub;
    exports.map = map;
    exports.mapObj = mapObj;
    exports.matchState = matchState;
    exports.maxLength = maxLength;
    exports.memoryLocationPlugin = memoryLocationPlugin;
    exports.mergeR = mergeR;
    exports.ng1ViewsBuilder = ng1ViewsBuilder;
    exports.noop = noop;
    exports.not = not;
    exports.omit = omit;
    exports.or = or;
    exports.padString = padString;
    exports.pairs = pairs;
    exports.parse = parse;
    exports.parseUrl = parseUrl$1;
    exports.pattern = pattern;
    exports.pick = pick;
    exports.pipe = pipe;
    exports.pluck = pluck;
    exports.prop = prop;
    exports.propEq = propEq;
    exports.pushR = pushR;
    exports.pushStateLocationPlugin = pushStateLocationPlugin;
    exports.pushTo = pushTo;
    exports.removeFrom = removeFrom;
    exports.resolvablesBuilder = resolvablesBuilder;
    exports.resolvePolicies = resolvePolicies;
    exports.root = root;
    exports.services = services;
    exports.servicesPlugin = servicesPlugin;
    exports.silenceUncaughtInPromise = silenceUncaughtInPromise;
    exports.silentRejection = silentRejection;
    exports.splitEqual = splitEqual;
    exports.splitHash = splitHash;
    exports.splitOnDelim = splitOnDelim;
    exports.splitQuery = splitQuery;
    exports.stringify = stringify;
    exports.stripLastPathElement = stripLastPathElement;
    exports.tail = tail;
    exports.toJson = toJson;
    exports.trace = trace;
    exports.trimHashVal = trimHashVal;
    exports.uniqR = uniqR;
    exports.unnest = unnest;
    exports.unnestR = unnestR;
    exports.val = val;
    exports.values = values;
    exports.watchDigests = watchDigests;

    Object.defineProperty(exports, '__esModule', { value: true });

})));


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5taW4uanMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9hbmd1bGFyLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL2hvZi50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi9wcmVkaWNhdGVzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9jb21tb24vQHVpcm91dGVyL2NvcmUvY29tbW9uL2NvcmVzZXJ2aWNlcy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi9jb21tb24udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2NvbW1vbi9AdWlyb3V0ZXIvY29yZS9jb21tb24vZ2xvYi50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi9xdWV1ZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdHJhbnNpdGlvbi9AdWlyb3V0ZXIvY29yZS90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnkudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2NvbW1vbi9AdWlyb3V0ZXIvY29yZS9jb21tb24vc3RyaW5ncy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi9zYWZlQ29uc29sZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vY29tbW9uL0B1aXJvdXRlci9jb3JlL2NvbW1vbi90cmFjZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcGFyYW1zL0B1aXJvdXRlci9jb3JlL3BhcmFtcy9wYXJhbVR5cGUudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3BhcmFtcy9AdWlyb3V0ZXIvY29yZS9wYXJhbXMvcGFyYW0udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3BhcmFtcy9AdWlyb3V0ZXIvY29yZS9wYXJhbXMvcGFyYW1UeXBlcy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcGFyYW1zL0B1aXJvdXRlci9jb3JlL3BhcmFtcy9zdGF0ZVBhcmFtcy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcGF0aC9AdWlyb3V0ZXIvY29yZS9wYXRoL3BhdGhOb2RlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9zdGF0ZS9AdWlyb3V0ZXIvY29yZS9zdGF0ZS90YXJnZXRTdGF0ZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcGF0aC9AdWlyb3V0ZXIvY29yZS9wYXRoL3BhdGhVdGlscy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcmVzb2x2ZS9AdWlyb3V0ZXIvY29yZS9yZXNvbHZlL2ludGVyZmFjZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vcmVzb2x2ZS9AdWlyb3V0ZXIvY29yZS9yZXNvbHZlL3Jlc29sdmFibGUudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3Jlc29sdmUvQHVpcm91dGVyL2NvcmUvcmVzb2x2ZS9yZXNvbHZlQ29udGV4dC50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vc3RhdGUvQHVpcm91dGVyL2NvcmUvc3RhdGUvc3RhdGVCdWlsZGVyLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9zdGF0ZS9AdWlyb3V0ZXIvY29yZS9zdGF0ZS9zdGF0ZU9iamVjdC50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vc3RhdGUvQHVpcm91dGVyL2NvcmUvc3RhdGUvc3RhdGVNYXRjaGVyLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9zdGF0ZS9AdWlyb3V0ZXIvY29yZS9zdGF0ZS9zdGF0ZVF1ZXVlTWFuYWdlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vc3RhdGUvQHVpcm91dGVyL2NvcmUvc3RhdGUvc3RhdGVSZWdpc3RyeS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdHJhbnNpdGlvbi9AdWlyb3V0ZXIvY29yZS90cmFuc2l0aW9uL2ludGVyZmFjZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdHJhbnNpdGlvbi9AdWlyb3V0ZXIvY29yZS90cmFuc2l0aW9uL3RyYW5zaXRpb25Ib29rLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vaG9va1JlZ2lzdHJ5LnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vaG9va0J1aWxkZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3RyYW5zaXRpb24vQHVpcm91dGVyL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS91cmwvQHVpcm91dGVyL2NvcmUvdXJsL3VybE1hdGNoZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3VybC9AdWlyb3V0ZXIvY29yZS91cmwvdXJsTWF0Y2hlckZhY3RvcnkudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3VybC9AdWlyb3V0ZXIvY29yZS91cmwvdXJsUnVsZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdXJsL0B1aXJvdXRlci9jb3JlL3VybC91cmxSb3V0ZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3ZpZXcvQHVpcm91dGVyL2NvcmUvdmlldy92aWV3LnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9AdWlyb3V0ZXIvY29yZS9nbG9iYWxzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS91cmwvQHVpcm91dGVyL2NvcmUvdXJsL3VybFJ1bGVzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS91cmwvQHVpcm91dGVyL2NvcmUvdXJsL3VybENvbmZpZy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdXJsL0B1aXJvdXRlci9jb3JlL3VybC91cmxTZXJ2aWNlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9AdWlyb3V0ZXIvY29yZS9yb3V0ZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL2NvcmVSZXNvbHZhYmxlcy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3MvcmVkaXJlY3RUby50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3Mvb25FbnRlckV4aXRSZXRhaW4udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL3Jlc29sdmUudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL3ZpZXdzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9ob29rcy9AdWlyb3V0ZXIvY29yZS9ob29rcy91cGRhdGVHbG9iYWxzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS9ob29rcy9AdWlyb3V0ZXIvY29yZS9ob29rcy91cmwudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL2xhenlMb2FkLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vdHJhbnNpdGlvbkV2ZW50VHlwZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vaG9va3MvQHVpcm91dGVyL2NvcmUvaG9va3MvaWdub3JlZFRyYW5zaXRpb24udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL2hvb2tzL0B1aXJvdXRlci9jb3JlL2hvb2tzL2ludmFsaWRUcmFuc2l0aW9uLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS90cmFuc2l0aW9uL0B1aXJvdXRlci9jb3JlL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3N0YXRlL0B1aXJvdXRlci9jb3JlL3N0YXRlL3N0YXRlU2VydmljZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL3EudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3ZhbmlsbGEvQHVpcm91dGVyL2NvcmUvdmFuaWxsYS9pbmplY3Rvci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL3V0aWxzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliLWVzbS92YW5pbGxhL0B1aXJvdXRlci9jb3JlL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL2hhc2hMb2NhdGlvblNlcnZpY2UudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3ZhbmlsbGEvQHVpcm91dGVyL2NvcmUvdmFuaWxsYS9tZW1vcnlMb2NhdGlvblNlcnZpY2UudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3ZhbmlsbGEvQHVpcm91dGVyL2NvcmUvdmFuaWxsYS9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL3ZhbmlsbGEvQHVpcm91dGVyL2NvcmUvdmFuaWxsYS9tZW1vcnlMb2NhdGlvbkNvbmZpZy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vdmFuaWxsYS9AdWlyb3V0ZXIvY29yZS92YW5pbGxhL3BsdWdpbnMudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWItZXNtL0B1aXJvdXRlci9jb3JlL2ludGVyZmFjZS50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi1lc20vQHVpcm91dGVyL2NvcmUvaW5kZXgudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9zdGF0ZWJ1aWxkZXJzL3ZpZXdzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvdGVtcGxhdGVGYWN0b3J5LnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvc3RhdGVQcm92aWRlci50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL3N0YXRlYnVpbGRlcnMvb25FbnRlckV4aXRSZXRhaW4udHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9sb2NhdGlvblNlcnZpY2VzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvdXJsUm91dGVyUHJvdmlkZXIudHMiLCJAdWlyb3V0ZXIvYW5ndWxhcmpzL3NyYy9zZXJ2aWNlcy50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL2RpcmVjdGl2ZXMvc3RhdGVEaXJlY3RpdmVzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvc3RhdGVGaWx0ZXJzLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvZGlyZWN0aXZlcy92aWV3RGlyZWN0aXZlLnRzIiwiQHVpcm91dGVyL2FuZ3VsYXJqcy9zcmMvdmlld1Njcm9sbC50cyIsIkB1aXJvdXRlci9hbmd1bGFyanMvc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbIm5nX2Zyb21faW1wb3J0Lm1vZHVsZSIsInRoaXMiLCJhbmd1bGFyIiwiUmVqZWN0VHlwZSIsIkNhdGVnb3J5IiwiRGVmVHlwZSIsIlRyYW5zaXRpb25Ib29rUGhhc2UiLCJUcmFuc2l0aW9uSG9va1Njb3BlIiwicGFyc2VVcmwiLCJfX2V4dGVuZHMiLCJpZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztJQ0ZBO0FBQ0EsSUFFQSxlQUFlLElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQztJQUM5QyxlQUFlLEFBQU8sSUFBTSxFQUFFLEdBQUcsY0FBYyxJQUFJQSxxQkFBcUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxDQUFDOztJQ0ozRzs7Ozs7Ozs7Ozs7Ozs7SUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0EsYUFBZ0IsS0FBSyxDQUFDLEVBQVk7UUFDaEMsT0FBTyxTQUFTLE9BQU87WUFDckIsSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUU7Z0JBQ2pDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDbEM7WUFDRCxJQUFNLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbkQsT0FBTyxPQUFPLENBQUMsSUFBSSxPQUFaLE9BQU8sa0JBQU0sSUFBSSxHQUFLLElBQUksR0FBRTtTQUNwQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7QUFNQSxhQUFnQixPQUFPO1FBQ3JCLElBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQztRQUN2QixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUNYLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFB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O1NBQ3hGO0lBQ0gsQ0FBQztBQUVEQSxNQUFPLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBTyxNQUFNLENBQUMsQ0FBQztBQUNuRUEsTUFBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQU8sa0JBQWtCLENBQUMsQ0FBQzs7SUM5aEIvRTtBQUNBLElBZUE7SUFDQSxTQUFTLG1CQUFtQjtRQUMxQixJQUFJLGVBQWUsR0FBRyxLQUFLLENBQUM7UUFFNUIsSUFBSSxDQUFDLGVBQWUsR0FBRztZQUNyQixlQUFlLEdBQUcsSUFBSSxDQUFDO1NBQ3hCLENBQUM7UUFFRixJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ1YsZUFBZTtZQUNmLFVBQVU7WUFDVixVQUFTLGFBQW1DLEVBQUUsUUFBeUI7Z0JBQ3JFLElBQUksZUFBZSxFQUFFO29CQUNuQixPQUFPLGFBQWEsQ0FBQztpQkFDdEI7Z0JBRUQsT0FBTyxVQUFTLFFBQWdCO29CQUM5QixPQUFPLFFBQVEsQ0FDYjt3QkFDRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7cUJBQzlCLEVBQ0QsQ0FBQyxFQUNELEtBQUssQ0FDTixDQUFDO2lCQUNILENBQUM7YUFDSDtTQUNGLENBQUM7SUFDSixDQUFDO0FBRURBLE1BQU8sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUEyQixtQkFBbUIsQ0FBQyxDQUFDOztBQzdCMUcsa0JBQWUsV0FBVyxDQUFDIiwiZmlsZSI6InZlbmRvci0xNTgyNjY3MjcyNjI5Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBqUXVlcnkgdjMuNC4xIHwgKGMpIEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xuIWZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWUuZG9jdW1lbnQ/dChlLCEwKTpmdW5jdGlvbihlKXtpZighZS5kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO3JldHVybiB0KGUpfTp0KGUpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKEMsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9W10sRT1DLmRvY3VtZW50LHI9T2JqZWN0LmdldFByb3RvdHlwZU9mLHM9dC5zbGljZSxnPXQuY29uY2F0LHU9dC5wdXNoLGk9dC5pbmRleE9mLG49e30sbz1uLnRvU3RyaW5nLHY9bi5oYXNPd25Qcm9wZXJ0eSxhPXYudG9TdHJpbmcsbD1hLmNhbGwoT2JqZWN0KSx5PXt9LG09ZnVuY3Rpb24oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmXCJudW1iZXJcIiE9dHlwZW9mIGUubm9kZVR5cGV9LHg9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUmJmU9PT1lLndpbmRvd30sYz17dHlwZTohMCxzcmM6ITAsbm9uY2U6ITAsbm9Nb2R1bGU6ITB9O2Z1bmN0aW9uIGIoZSx0LG4pe3ZhciByLGksbz0obj1ufHxFKS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2lmKG8udGV4dD1lLHQpZm9yKHIgaW4gYykoaT10W3JdfHx0LmdldEF0dHJpYnV0ZSYmdC5nZXRBdHRyaWJ1dGUocikpJiZvLnNldEF0dHJpYnV0ZShyLGkpO24uaGVhZC5hcHBlbmRDaGlsZChvKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pfWZ1bmN0aW9uIHcoZSl7cmV0dXJuIG51bGw9PWU/ZStcIlwiOlwib2JqZWN0XCI9PXR5cGVvZiBlfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP25bby5jYWxsKGUpXXx8XCJvYmplY3RcIjp0eXBlb2YgZX12YXIgZj1cIjMuNC4xXCIsaz1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgay5mbi5pbml0KGUsdCl9LHA9L15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO2Z1bmN0aW9uIGQoZSl7dmFyIHQ9ISFlJiZcImxlbmd0aFwiaW4gZSYmZS5sZW5ndGgsbj13KGUpO3JldHVybiFtKGUpJiYheChlKSYmKFwiYXJyYXlcIj09PW58fDA9PT10fHxcIm51bWJlclwiPT10eXBlb2YgdCYmMDx0JiZ0LTEgaW4gZSl9ay5mbj1rLnByb3RvdHlwZT17anF1ZXJ5OmYsY29uc3RydWN0b3I6ayxsZW5ndGg6MCx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHMuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP3MuY2FsbCh0aGlzKTplPDA/dGhpc1tlK3RoaXMubGVuZ3RoXTp0aGlzW2VdfSxwdXNoU3RhY2s6ZnVuY3Rpb24oZSl7dmFyIHQ9ay5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksZSk7cmV0dXJuIHQucHJldk9iamVjdD10aGlzLHR9LGVhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIGsuZWFjaCh0aGlzLGUpfSxtYXA6ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGsubWFwKHRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5jYWxsKGUsdCxlKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2socy5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmxlbmd0aCxuPStlKyhlPDA/dDowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soMDw9biYmbjx0P1t0aGlzW25dXTpbXSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IoKX0scHVzaDp1LHNvcnQ6dC5zb3J0LHNwbGljZTp0LnNwbGljZX0say5leHRlbmQ9ay5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgZSx0LG4scixpLG8sYT1hcmd1bWVudHNbMF18fHt9LHM9MSx1PWFyZ3VtZW50cy5sZW5ndGgsbD0hMTtmb3IoXCJib29sZWFuXCI9PXR5cGVvZiBhJiYobD1hLGE9YXJndW1lbnRzW3NdfHx7fSxzKyspLFwib2JqZWN0XCI9PXR5cGVvZiBhfHxtKGEpfHwoYT17fSkscz09PXUmJihhPXRoaXMscy0tKTtzPHU7cysrKWlmKG51bGwhPShlPWFyZ3VtZW50c1tzXSkpZm9yKHQgaW4gZSlyPWVbdF0sXCJfX3Byb3RvX19cIiE9PXQmJmEhPT1yJiYobCYmciYmKGsuaXNQbGFpbk9iamVjdChyKXx8KGk9QXJyYXkuaXNBcnJheShyKSkpPyhuPWFbdF0sbz1pJiYhQXJyYXkuaXNBcnJheShuKT9bXTppfHxrLmlzUGxhaW5PYmplY3Qobik/bjp7fSxpPSExLGFbdF09ay5leHRlbmQobCxvLHIpKTp2b2lkIDAhPT1yJiYoYVt0XT1yKSk7cmV0dXJuIGF9LGsuZXh0ZW5kKHtleHBhbmRvOlwialF1ZXJ5XCIrKGYrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksaXNSZWFkeTohMCxlcnJvcjpmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoZSl9LG5vb3A6ZnVuY3Rpb24oKXt9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQsbjtyZXR1cm4hKCFlfHxcIltvYmplY3QgT2JqZWN0XVwiIT09by5jYWxsKGUpKSYmKCEodD1yKGUpKXx8XCJmdW5jdGlvblwiPT10eXBlb2Yobj12LmNhbGwodCxcImNvbnN0cnVjdG9yXCIpJiZ0LmNvbnN0cnVjdG9yKSYmYS5jYWxsKG4pPT09bCl9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQ7Zm9yKHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH0sZ2xvYmFsRXZhbDpmdW5jdGlvbihlLHQpe2IoZSx7bm9uY2U6dCYmdC5ub25jZX0pfSxlYWNoOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj0wO2lmKGQoZSkpe2ZvcihuPWUubGVuZ3RoO3I8bjtyKyspaWYoITE9PT10LmNhbGwoZVtyXSxyLGVbcl0pKWJyZWFrfWVsc2UgZm9yKHIgaW4gZSlpZighMT09PXQuY2FsbChlW3JdLHIsZVtyXSkpYnJlYWs7cmV0dXJuIGV9LHRyaW06ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjooZStcIlwiKS5yZXBsYWNlKHAsXCJcIil9LG1ha2VBcnJheTpmdW5jdGlvbihlLHQpe3ZhciBuPXR8fFtdO3JldHVybiBudWxsIT1lJiYoZChPYmplY3QoZSkpP2subWVyZ2UobixcInN0cmluZ1wiPT10eXBlb2YgZT9bZV06ZSk6dS5jYWxsKG4sZSkpLG59LGluQXJyYXk6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBudWxsPT10Py0xOmkuY2FsbCh0LGUsbil9LG1lcmdlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPSt0Lmxlbmd0aCxyPTAsaT1lLmxlbmd0aDtyPG47cisrKWVbaSsrXT10W3JdO3JldHVybiBlLmxlbmd0aD1pLGV9LGdyZXA6ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1bXSxpPTAsbz1lLmxlbmd0aCxhPSFuO2k8bztpKyspIXQoZVtpXSxpKSE9PWEmJnIucHVzaChlW2ldKTtyZXR1cm4gcn0sbWFwOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89MCxhPVtdO2lmKGQoZSkpZm9yKHI9ZS5sZW5ndGg7bzxyO28rKyludWxsIT0oaT10KGVbb10sbyxuKSkmJmEucHVzaChpKTtlbHNlIGZvcihvIGluIGUpbnVsbCE9KGk9dChlW29dLG8sbikpJiZhLnB1c2goaSk7cmV0dXJuIGcuYXBwbHkoW10sYSl9LGd1aWQ6MSxzdXBwb3J0Onl9KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihrLmZuW1N5bWJvbC5pdGVyYXRvcl09dFtTeW1ib2wuaXRlcmF0b3JdKSxrLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLHQpe25bXCJbb2JqZWN0IFwiK3QrXCJdXCJdPXQudG9Mb3dlckNhc2UoKX0pO3ZhciBoPWZ1bmN0aW9uKG4pe3ZhciBlLGQsYixvLGksaCxmLGcsdyx1LGwsVCxDLGEsRSx2LHMsYyx5LGs9XCJzaXp6bGVcIisxKm5ldyBEYXRlLG09bi5kb2N1bWVudCxTPTAscj0wLHA9dWUoKSx4PXVlKCksTj11ZSgpLEE9dWUoKSxEPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9PT10JiYobD0hMCksMH0saj17fS5oYXNPd25Qcm9wZXJ0eSx0PVtdLHE9dC5wb3AsTD10LnB1c2gsSD10LnB1c2gsTz10LnNsaWNlLFA9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspaWYoZVtuXT09PXQpcmV0dXJuIG47cmV0dXJuLTF9LFI9XCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLE09XCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLEk9XCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFc9XCJcXFxcW1wiK00rXCIqKFwiK0krXCIpKD86XCIrTStcIiooWypeJHwhfl0/PSlcIitNK1wiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIrSStcIikpfClcIitNK1wiKlxcXFxdXCIsJD1cIjooXCIrSStcIikoPzpcXFxcKCgoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXwoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIrVytcIikqKXwuKilcXFxcKXwpXCIsRj1uZXcgUmVnRXhwKE0rXCIrXCIsXCJnXCIpLEI9bmV3IFJlZ0V4cChcIl5cIitNK1wiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIitNK1wiKyRcIixcImdcIiksXz1uZXcgUmVnRXhwKFwiXlwiK00rXCIqLFwiK00rXCIqXCIpLHo9bmV3IFJlZ0V4cChcIl5cIitNK1wiKihbPit+XXxcIitNK1wiKVwiK00rXCIqXCIpLFU9bmV3IFJlZ0V4cChNK1wifD5cIiksWD1uZXcgUmVnRXhwKCQpLFY9bmV3IFJlZ0V4cChcIl5cIitJK1wiJFwiKSxHPXtJRDpuZXcgUmVnRXhwKFwiXiMoXCIrSStcIilcIiksQ0xBU1M6bmV3IFJlZ0V4cChcIl5cXFxcLihcIitJK1wiKVwiKSxUQUc6bmV3IFJlZ0V4cChcIl4oXCIrSStcInxbKl0pXCIpLEFUVFI6bmV3IFJlZ0V4cChcIl5cIitXKSxQU0VVRE86bmV3IFJlZ0V4cChcIl5cIiskKSxDSElMRDpuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIitNK1wiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIrTStcIiooPzooWystXXwpXCIrTStcIiooXFxcXGQrKXwpKVwiK00rXCIqXFxcXCl8KVwiLFwiaVwiKSxib29sOm5ldyBSZWdFeHAoXCJeKD86XCIrUitcIikkXCIsXCJpXCIpLG5lZWRzQ29udGV4dDpuZXcgUmVnRXhwKFwiXlwiK00rXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiK00rXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiK00rXCIqXFxcXCl8KSg/PVteLV18JClcIixcImlcIil9LFk9L0hUTUwkL2ksUT0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLEo9L15oXFxkJC9pLEs9L15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxaPS9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLGVlPS9bK35dLyx0ZT1uZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIrTStcIj98KFwiK00rXCIpfC4pXCIsXCJpZ1wiKSxuZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9XCIweFwiK3QtNjU1MzY7cmV0dXJuIHIhPXJ8fG4/dDpyPDA/U3RyaW5nLmZyb21DaGFyQ29kZShyKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKHI+PjEwfDU1Mjk2LDEwMjMmcnw1NjMyMCl9LHJlPS8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLGllPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ/XCJcXDBcIj09PWU/XCJcXHVmZmZkXCI6ZS5zbGljZSgwLC0xKStcIlxcXFxcIitlLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSkudG9TdHJpbmcoMTYpK1wiIFwiOlwiXFxcXFwiK2V9LG9lPWZ1bmN0aW9uKCl7VCgpfSxhZT1iZShmdW5jdGlvbihlKXtyZXR1cm4hMD09PWUuZGlzYWJsZWQmJlwiZmllbGRzZXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKX0se2RpcjpcInBhcmVudE5vZGVcIixuZXh0OlwibGVnZW5kXCJ9KTt0cnl7SC5hcHBseSh0PU8uY2FsbChtLmNoaWxkTm9kZXMpLG0uY2hpbGROb2RlcyksdFttLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZX1jYXRjaChlKXtIPXthcHBseTp0Lmxlbmd0aD9mdW5jdGlvbihlLHQpe0wuYXBwbHkoZSxPLmNhbGwodCkpfTpmdW5jdGlvbihlLHQpe3ZhciBuPWUubGVuZ3RoLHI9MDt3aGlsZShlW24rK109dFtyKytdKTtlLmxlbmd0aD1uLTF9fX1mdW5jdGlvbiBzZSh0LGUsbixyKXt2YXIgaSxvLGEscyx1LGwsYyxmPWUmJmUub3duZXJEb2N1bWVudCxwPWU/ZS5ub2RlVHlwZTo5O2lmKG49bnx8W10sXCJzdHJpbmdcIiE9dHlwZW9mIHR8fCF0fHwxIT09cCYmOSE9PXAmJjExIT09cClyZXR1cm4gbjtpZighciYmKChlP2Uub3duZXJEb2N1bWVudHx8ZTptKSE9PUMmJlQoZSksZT1lfHxDLEUpKXtpZigxMSE9PXAmJih1PVouZXhlYyh0KSkpaWYoaT11WzFdKXtpZig5PT09cCl7aWYoIShhPWUuZ2V0RWxlbWVudEJ5SWQoaSkpKXJldHVybiBuO2lmKGEuaWQ9PT1pKXJldHVybiBuLnB1c2goYSksbn1lbHNlIGlmKGYmJihhPWYuZ2V0RWxlbWVudEJ5SWQoaSkpJiZ5KGUsYSkmJmEuaWQ9PT1pKXJldHVybiBuLnB1c2goYSksbn1lbHNle2lmKHVbMl0pcmV0dXJuIEguYXBwbHkobixlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQpKSxuO2lmKChpPXVbM10pJiZkLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJmUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSlyZXR1cm4gSC5hcHBseShuLGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShpKSksbn1pZihkLnFzYSYmIUFbdCtcIiBcIl0mJighdnx8IXYudGVzdCh0KSkmJigxIT09cHx8XCJvYmplY3RcIiE9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpe2lmKGM9dCxmPWUsMT09PXAmJlUudGVzdCh0KSl7KHM9ZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk/cz1zLnJlcGxhY2UocmUsaWUpOmUuc2V0QXR0cmlidXRlKFwiaWRcIixzPWspLG89KGw9aCh0KSkubGVuZ3RoO3doaWxlKG8tLSlsW29dPVwiI1wiK3MrXCIgXCIreGUobFtvXSk7Yz1sLmpvaW4oXCIsXCIpLGY9ZWUudGVzdCh0KSYmeWUoZS5wYXJlbnROb2RlKXx8ZX10cnl7cmV0dXJuIEguYXBwbHkobixmLnF1ZXJ5U2VsZWN0b3JBbGwoYykpLG59Y2F0Y2goZSl7QSh0LCEwKX1maW5hbGx5e3M9PT1rJiZlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpfX19cmV0dXJuIGcodC5yZXBsYWNlKEIsXCIkMVwiKSxlLG4scil9ZnVuY3Rpb24gdWUoKXt2YXIgcj1bXTtyZXR1cm4gZnVuY3Rpb24gZSh0LG4pe3JldHVybiByLnB1c2godCtcIiBcIik+Yi5jYWNoZUxlbmd0aCYmZGVsZXRlIGVbci5zaGlmdCgpXSxlW3QrXCIgXCJdPW59fWZ1bmN0aW9uIGxlKGUpe3JldHVybiBlW2tdPSEwLGV9ZnVuY3Rpb24gY2UoZSl7dmFyIHQ9Qy5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7dHJ5e3JldHVybiEhZSh0KX1jYXRjaChlKXtyZXR1cm4hMX1maW5hbGx5e3QucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLHQ9bnVsbH19ZnVuY3Rpb24gZmUoZSx0KXt2YXIgbj1lLnNwbGl0KFwifFwiKSxyPW4ubGVuZ3RoO3doaWxlKHItLSliLmF0dHJIYW5kbGVbbltyXV09dH1mdW5jdGlvbiBwZShlLHQpe3ZhciBuPXQmJmUscj1uJiYxPT09ZS5ub2RlVHlwZSYmMT09PXQubm9kZVR5cGUmJmUuc291cmNlSW5kZXgtdC5zb3VyY2VJbmRleDtpZihyKXJldHVybiByO2lmKG4pd2hpbGUobj1uLm5leHRTaWJsaW5nKWlmKG49PT10KXJldHVybi0xO3JldHVybiBlPzE6LTF9ZnVuY3Rpb24gZGUodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVyblwiaW5wdXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmZS50eXBlPT09dH19ZnVuY3Rpb24gaGUobil7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oXCJpbnB1dFwiPT09dHx8XCJidXR0b25cIj09PXQpJiZlLnR5cGU9PT1ufX1mdW5jdGlvbiBnZSh0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuXCJmb3JtXCJpbiBlP2UucGFyZW50Tm9kZSYmITE9PT1lLmRpc2FibGVkP1wibGFiZWxcImluIGU/XCJsYWJlbFwiaW4gZS5wYXJlbnROb2RlP2UucGFyZW50Tm9kZS5kaXNhYmxlZD09PXQ6ZS5kaXNhYmxlZD09PXQ6ZS5pc0Rpc2FibGVkPT09dHx8ZS5pc0Rpc2FibGVkIT09IXQmJmFlKGUpPT09dDplLmRpc2FibGVkPT09dDpcImxhYmVsXCJpbiBlJiZlLmRpc2FibGVkPT09dH19ZnVuY3Rpb24gdmUoYSl7cmV0dXJuIGxlKGZ1bmN0aW9uKG8pe3JldHVybiBvPStvLGxlKGZ1bmN0aW9uKGUsdCl7dmFyIG4scj1hKFtdLGUubGVuZ3RoLG8pLGk9ci5sZW5ndGg7d2hpbGUoaS0tKWVbbj1yW2ldXSYmKGVbbl09ISh0W25dPWVbbl0pKX0pfSl9ZnVuY3Rpb24geWUoZSl7cmV0dXJuIGUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lJiZlfWZvcihlIGluIGQ9c2Uuc3VwcG9ydD17fSxpPXNlLmlzWE1MPWZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZXNwYWNlVVJJLG49KGUub3duZXJEb2N1bWVudHx8ZSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiFZLnRlc3QodHx8biYmbi5ub2RlTmFtZXx8XCJIVE1MXCIpfSxUPXNlLnNldERvY3VtZW50PWZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lP2Uub3duZXJEb2N1bWVudHx8ZTptO3JldHVybiByIT09QyYmOT09PXIubm9kZVR5cGUmJnIuZG9jdW1lbnRFbGVtZW50JiYoYT0oQz1yKS5kb2N1bWVudEVsZW1lbnQsRT0haShDKSxtIT09QyYmKG49Qy5kZWZhdWx0VmlldykmJm4udG9wIT09biYmKG4uYWRkRXZlbnRMaXN0ZW5lcj9uLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIixvZSwhMSk6bi5hdHRhY2hFdmVudCYmbi5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsb2UpKSxkLmF0dHJpYnV0ZXM9Y2UoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NOYW1lPVwiaVwiLCFlLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKX0pLGQuZ2V0RWxlbWVudHNCeVRhZ05hbWU9Y2UoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwZW5kQ2hpbGQoQy5jcmVhdGVDb21tZW50KFwiXCIpKSwhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RofSksZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPUsudGVzdChDLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLGQuZ2V0QnlJZD1jZShmdW5jdGlvbihlKXtyZXR1cm4gYS5hcHBlbmRDaGlsZChlKS5pZD1rLCFDLmdldEVsZW1lbnRzQnlOYW1lfHwhQy5nZXRFbGVtZW50c0J5TmFtZShrKS5sZW5ndGh9KSxkLmdldEJ5SWQ/KGIuZmlsdGVyLklEPWZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZSh0ZSxuZSk7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZShcImlkXCIpPT09dH19LGIuZmluZC5JRD1mdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRCeUlkJiZFKXt2YXIgbj10LmdldEVsZW1lbnRCeUlkKGUpO3JldHVybiBuP1tuXTpbXX19KTooYi5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS5yZXBsYWNlKHRlLG5lKTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSYmZS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7cmV0dXJuIHQmJnQudmFsdWU9PT1ufX0sYi5maW5kLklEPWZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQmJkUpe3ZhciBuLHIsaSxvPXQuZ2V0RWxlbWVudEJ5SWQoZSk7aWYobyl7aWYoKG49by5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpJiZuLnZhbHVlPT09ZSlyZXR1cm5bb107aT10LmdldEVsZW1lbnRzQnlOYW1lKGUpLHI9MDt3aGlsZShvPWlbcisrXSlpZigobj1vLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKSkmJm4udmFsdWU9PT1lKXJldHVybltvXX1yZXR1cm5bXX19KSxiLmZpbmQuVEFHPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWU/ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgdC5nZXRFbGVtZW50c0J5VGFnTmFtZT90LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpOmQucXNhP3QucXVlcnlTZWxlY3RvckFsbChlKTp2b2lkIDB9OmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1bXSxpPTAsbz10LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpO2lmKFwiKlwiPT09ZSl7d2hpbGUobj1vW2krK10pMT09PW4ubm9kZVR5cGUmJnIucHVzaChuKTtyZXR1cm4gcn1yZXR1cm4gb30sYi5maW5kLkNMQVNTPWQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZnVuY3Rpb24oZSx0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZFKXJldHVybiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSl9LHM9W10sdj1bXSwoZC5xc2E9Sy50ZXN0KEMucXVlcnlTZWxlY3RvckFsbCkpJiYoY2UoZnVuY3Rpb24oZSl7YS5hcHBlbmRDaGlsZChlKS5pbm5lckhUTUw9XCI8YSBpZD0nXCIraytcIic+PC9hPjxzZWxlY3QgaWQ9J1wiK2srXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIixlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgmJnYucHVzaChcIlsqXiRdPVwiK00rXCIqKD86Jyd8XFxcIlxcXCIpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RofHx2LnB1c2goXCJcXFxcW1wiK00rXCIqKD86dmFsdWV8XCIrUitcIilcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIitrK1wiLV1cIikubGVuZ3RofHx2LnB1c2goXCJ+PVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGh8fHYucHVzaChcIjpjaGVja2VkXCIpLGUucXVlcnlTZWxlY3RvckFsbChcImEjXCIraytcIisqXCIpLmxlbmd0aHx8di5wdXNoKFwiLiMuK1srfl1cIil9KSxjZShmdW5jdGlvbihlKXtlLmlubmVySFRNTD1cIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+PHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO3ZhciB0PUMuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO3Quc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiaGlkZGVuXCIpLGUuYXBwZW5kQ2hpbGQodCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwiRFwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGgmJnYucHVzaChcIm5hbWVcIitNK1wiKlsqXiR8IX5dPz1cIiksMiE9PWUucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCYmdi5wdXNoKFwiOmVuYWJsZWRcIixcIjpkaXNhYmxlZFwiKSxhLmFwcGVuZENoaWxkKGUpLmRpc2FibGVkPSEwLDIhPT1lLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoJiZ2LnB1c2goXCI6ZW5hYmxlZFwiLFwiOmRpc2FibGVkXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIiksdi5wdXNoKFwiLC4qOlwiKX0pKSwoZC5tYXRjaGVzU2VsZWN0b3I9Sy50ZXN0KGM9YS5tYXRjaGVzfHxhLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8YS5tb3pNYXRjaGVzU2VsZWN0b3J8fGEub01hdGNoZXNTZWxlY3Rvcnx8YS5tc01hdGNoZXNTZWxlY3RvcikpJiZjZShmdW5jdGlvbihlKXtkLmRpc2Nvbm5lY3RlZE1hdGNoPWMuY2FsbChlLFwiKlwiKSxjLmNhbGwoZSxcIltzIT0nJ106eFwiKSxzLnB1c2goXCIhPVwiLCQpfSksdj12Lmxlbmd0aCYmbmV3IFJlZ0V4cCh2LmpvaW4oXCJ8XCIpKSxzPXMubGVuZ3RoJiZuZXcgUmVnRXhwKHMuam9pbihcInxcIikpLHQ9Sy50ZXN0KGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24pLHk9dHx8Sy50ZXN0KGEuY29udGFpbnMpP2Z1bmN0aW9uKGUsdCl7dmFyIG49OT09PWUubm9kZVR5cGU/ZS5kb2N1bWVudEVsZW1lbnQ6ZSxyPXQmJnQucGFyZW50Tm9kZTtyZXR1cm4gZT09PXJ8fCEoIXJ8fDEhPT1yLm5vZGVUeXBlfHwhKG4uY29udGFpbnM/bi5jb250YWlucyhyKTplLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uJiYxNiZlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpKSl9OmZ1bmN0aW9uKGUsdCl7aWYodCl3aGlsZSh0PXQucGFyZW50Tm9kZSlpZih0PT09ZSlyZXR1cm4hMDtyZXR1cm4hMX0sRD10P2Z1bmN0aW9uKGUsdCl7aWYoZT09PXQpcmV0dXJuIGw9ITAsMDt2YXIgbj0hZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbi0hdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gbnx8KDEmKG49KGUub3duZXJEb2N1bWVudHx8ZSk9PT0odC5vd25lckRvY3VtZW50fHx0KT9lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpOjEpfHwhZC5zb3J0RGV0YWNoZWQmJnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSk9PT1uP2U9PT1DfHxlLm93bmVyRG9jdW1lbnQ9PT1tJiZ5KG0sZSk/LTE6dD09PUN8fHQub3duZXJEb2N1bWVudD09PW0mJnkobSx0KT8xOnU/UCh1LGUpLVAodSx0KTowOjQmbj8tMToxKX06ZnVuY3Rpb24oZSx0KXtpZihlPT09dClyZXR1cm4gbD0hMCwwO3ZhciBuLHI9MCxpPWUucGFyZW50Tm9kZSxvPXQucGFyZW50Tm9kZSxhPVtlXSxzPVt0XTtpZighaXx8IW8pcmV0dXJuIGU9PT1DPy0xOnQ9PT1DPzE6aT8tMTpvPzE6dT9QKHUsZSktUCh1LHQpOjA7aWYoaT09PW8pcmV0dXJuIHBlKGUsdCk7bj1lO3doaWxlKG49bi5wYXJlbnROb2RlKWEudW5zaGlmdChuKTtuPXQ7d2hpbGUobj1uLnBhcmVudE5vZGUpcy51bnNoaWZ0KG4pO3doaWxlKGFbcl09PT1zW3JdKXIrKztyZXR1cm4gcj9wZShhW3JdLHNbcl0pOmFbcl09PT1tPy0xOnNbcl09PT1tPzE6MH0pLEN9LHNlLm1hdGNoZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gc2UoZSxudWxsLG51bGwsdCl9LHNlLm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihlLHQpe2lmKChlLm93bmVyRG9jdW1lbnR8fGUpIT09QyYmVChlKSxkLm1hdGNoZXNTZWxlY3RvciYmRSYmIUFbdCtcIiBcIl0mJighc3x8IXMudGVzdCh0KSkmJighdnx8IXYudGVzdCh0KSkpdHJ5e3ZhciBuPWMuY2FsbChlLHQpO2lmKG58fGQuZGlzY29ubmVjdGVkTWF0Y2h8fGUuZG9jdW1lbnQmJjExIT09ZS5kb2N1bWVudC5ub2RlVHlwZSlyZXR1cm4gbn1jYXRjaChlKXtBKHQsITApfXJldHVybiAwPHNlKHQsQyxudWxsLFtlXSkubGVuZ3RofSxzZS5jb250YWlucz1mdW5jdGlvbihlLHQpe3JldHVybihlLm93bmVyRG9jdW1lbnR8fGUpIT09QyYmVChlKSx5KGUsdCl9LHNlLmF0dHI9ZnVuY3Rpb24oZSx0KXsoZS5vd25lckRvY3VtZW50fHxlKSE9PUMmJlQoZSk7dmFyIG49Yi5hdHRySGFuZGxlW3QudG9Mb3dlckNhc2UoKV0scj1uJiZqLmNhbGwoYi5hdHRySGFuZGxlLHQudG9Mb3dlckNhc2UoKSk/bihlLHQsIUUpOnZvaWQgMDtyZXR1cm4gdm9pZCAwIT09cj9yOmQuYXR0cmlidXRlc3x8IUU/ZS5nZXRBdHRyaWJ1dGUodCk6KHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSYmci5zcGVjaWZpZWQ/ci52YWx1ZTpudWxsfSxzZS5lc2NhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuKGUrXCJcIikucmVwbGFjZShyZSxpZSl9LHNlLmVycm9yPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiK2UpfSxzZS51bmlxdWVTb3J0PWZ1bmN0aW9uKGUpe3ZhciB0LG49W10scj0wLGk9MDtpZihsPSFkLmRldGVjdER1cGxpY2F0ZXMsdT0hZC5zb3J0U3RhYmxlJiZlLnNsaWNlKDApLGUuc29ydChEKSxsKXt3aGlsZSh0PWVbaSsrXSl0PT09ZVtpXSYmKHI9bi5wdXNoKGkpKTt3aGlsZShyLS0pZS5zcGxpY2UobltyXSwxKX1yZXR1cm4gdT1udWxsLGV9LG89c2UuZ2V0VGV4dD1mdW5jdGlvbihlKXt2YXIgdCxuPVwiXCIscj0wLGk9ZS5ub2RlVHlwZTtpZihpKXtpZigxPT09aXx8OT09PWl8fDExPT09aSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUudGV4dENvbnRlbnQpcmV0dXJuIGUudGV4dENvbnRlbnQ7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKW4rPW8oZSl9ZWxzZSBpZigzPT09aXx8ND09PWkpcmV0dXJuIGUubm9kZVZhbHVlfWVsc2Ugd2hpbGUodD1lW3IrK10pbis9byh0KTtyZXR1cm4gbn0sKGI9c2Uuc2VsZWN0b3JzPXtjYWNoZUxlbmd0aDo1MCxjcmVhdGVQc2V1ZG86bGUsbWF0Y2g6RyxhdHRySGFuZGxlOnt9LGZpbmQ6e30scmVsYXRpdmU6e1wiPlwiOntkaXI6XCJwYXJlbnROb2RlXCIsZmlyc3Q6ITB9LFwiIFwiOntkaXI6XCJwYXJlbnROb2RlXCJ9LFwiK1wiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIixmaXJzdDohMH0sXCJ+XCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wifX0scHJlRmlsdGVyOntBVFRSOmZ1bmN0aW9uKGUpe3JldHVybiBlWzFdPWVbMV0ucmVwbGFjZSh0ZSxuZSksZVszXT0oZVszXXx8ZVs0XXx8ZVs1XXx8XCJcIikucmVwbGFjZSh0ZSxuZSksXCJ+PVwiPT09ZVsyXSYmKGVbM109XCIgXCIrZVszXStcIiBcIiksZS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihlKXtyZXR1cm4gZVsxXT1lWzFdLnRvTG93ZXJDYXNlKCksXCJudGhcIj09PWVbMV0uc2xpY2UoMCwzKT8oZVszXXx8c2UuZXJyb3IoZVswXSksZVs0XT0rKGVbNF0/ZVs1XSsoZVs2XXx8MSk6MiooXCJldmVuXCI9PT1lWzNdfHxcIm9kZFwiPT09ZVszXSkpLGVbNV09KyhlWzddK2VbOF18fFwib2RkXCI9PT1lWzNdKSk6ZVszXSYmc2UuZXJyb3IoZVswXSksZX0sUFNFVURPOmZ1bmN0aW9uKGUpe3ZhciB0LG49IWVbNl0mJmVbMl07cmV0dXJuIEcuQ0hJTEQudGVzdChlWzBdKT9udWxsOihlWzNdP2VbMl09ZVs0XXx8ZVs1XXx8XCJcIjpuJiZYLnRlc3QobikmJih0PWgobiwhMCkpJiYodD1uLmluZGV4T2YoXCIpXCIsbi5sZW5ndGgtdCktbi5sZW5ndGgpJiYoZVswXT1lWzBdLnNsaWNlKDAsdCksZVsyXT1uLnNsaWNlKDAsdCkpLGUuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UodGUsbmUpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCIqXCI9PT1lP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT10fX0sQ0xBU1M6ZnVuY3Rpb24oZSl7dmFyIHQ9cFtlK1wiIFwiXTtyZXR1cm4gdHx8KHQ9bmV3IFJlZ0V4cChcIihefFwiK00rXCIpXCIrZStcIihcIitNK1wifCQpXCIpKSYmcChlLGZ1bmN0aW9uKGUpe3JldHVybiB0LnRlc3QoXCJzdHJpbmdcIj09dHlwZW9mIGUuY2xhc3NOYW1lJiZlLmNsYXNzTmFtZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKG4scixpKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9c2UuYXR0cihlLG4pO3JldHVybiBudWxsPT10P1wiIT1cIj09PXI6IXJ8fCh0Kz1cIlwiLFwiPVwiPT09cj90PT09aTpcIiE9XCI9PT1yP3QhPT1pOlwiXj1cIj09PXI/aSYmMD09PXQuaW5kZXhPZihpKTpcIio9XCI9PT1yP2kmJi0xPHQuaW5kZXhPZihpKTpcIiQ9XCI9PT1yP2kmJnQuc2xpY2UoLWkubGVuZ3RoKT09PWk6XCJ+PVwiPT09cj8tMTwoXCIgXCIrdC5yZXBsYWNlKEYsXCIgXCIpK1wiIFwiKS5pbmRleE9mKGkpOlwifD1cIj09PXImJih0PT09aXx8dC5zbGljZSgwLGkubGVuZ3RoKzEpPT09aStcIi1cIikpfX0sQ0hJTEQ6ZnVuY3Rpb24oaCxlLHQsZyx2KXt2YXIgeT1cIm50aFwiIT09aC5zbGljZSgwLDMpLG09XCJsYXN0XCIhPT1oLnNsaWNlKC00KSx4PVwib2YtdHlwZVwiPT09ZTtyZXR1cm4gMT09PWcmJjA9PT12P2Z1bmN0aW9uKGUpe3JldHVybiEhZS5wYXJlbnROb2RlfTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGw9eSE9PW0/XCJuZXh0U2libGluZ1wiOlwicHJldmlvdXNTaWJsaW5nXCIsYz1lLnBhcmVudE5vZGUsZj14JiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkscD0hbiYmIXgsZD0hMTtpZihjKXtpZih5KXt3aGlsZShsKXthPWU7d2hpbGUoYT1hW2xdKWlmKHg/YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ZjoxPT09YS5ub2RlVHlwZSlyZXR1cm4hMTt1PWw9XCJvbmx5XCI9PT1oJiYhdSYmXCJuZXh0U2libGluZ1wifXJldHVybiEwfWlmKHU9W20/Yy5maXJzdENoaWxkOmMubGFzdENoaWxkXSxtJiZwKXtkPShzPShyPShpPShvPShhPWMpW2tdfHwoYVtrXT17fSkpW2EudW5pcXVlSURdfHwob1thLnVuaXF1ZUlEXT17fSkpW2hdfHxbXSlbMF09PT1TJiZyWzFdKSYmclsyXSxhPXMmJmMuY2hpbGROb2Rlc1tzXTt3aGlsZShhPSsrcyYmYSYmYVtsXXx8KGQ9cz0wKXx8dS5wb3AoKSlpZigxPT09YS5ub2RlVHlwZSYmKytkJiZhPT09ZSl7aVtoXT1bUyxzLGRdO2JyZWFrfX1lbHNlIGlmKHAmJihkPXM9KHI9KGk9KG89KGE9ZSlba118fChhW2tdPXt9KSlbYS51bmlxdWVJRF18fChvW2EudW5pcXVlSURdPXt9KSlbaF18fFtdKVswXT09PVMmJnJbMV0pLCExPT09ZCl3aGlsZShhPSsrcyYmYSYmYVtsXXx8KGQ9cz0wKXx8dS5wb3AoKSlpZigoeD9hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1mOjE9PT1hLm5vZGVUeXBlKSYmKytkJiYocCYmKChpPShvPWFba118fChhW2tdPXt9KSlbYS51bmlxdWVJRF18fChvW2EudW5pcXVlSURdPXt9KSlbaF09W1MsZF0pLGE9PT1lKSlicmVhaztyZXR1cm4oZC09dik9PT1nfHxkJWc9PTAmJjA8PWQvZ319fSxQU0VVRE86ZnVuY3Rpb24oZSxvKXt2YXIgdCxhPWIucHNldWRvc1tlXXx8Yi5zZXRGaWx0ZXJzW2UudG9Mb3dlckNhc2UoKV18fHNlLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIitlKTtyZXR1cm4gYVtrXT9hKG8pOjE8YS5sZW5ndGg/KHQ9W2UsZSxcIlwiLG9dLGIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpP2xlKGZ1bmN0aW9uKGUsdCl7dmFyIG4scj1hKGUsbyksaT1yLmxlbmd0aDt3aGlsZShpLS0pZVtuPVAoZSxyW2ldKV09ISh0W25dPXJbaV0pfSk6ZnVuY3Rpb24oZSl7cmV0dXJuIGEoZSwwLHQpfSk6YX19LHBzZXVkb3M6e25vdDpsZShmdW5jdGlvbihlKXt2YXIgcj1bXSxpPVtdLHM9ZihlLnJlcGxhY2UoQixcIiQxXCIpKTtyZXR1cm4gc1trXT9sZShmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvPXMoZSxudWxsLHIsW10pLGE9ZS5sZW5ndGg7d2hpbGUoYS0tKShpPW9bYV0pJiYoZVthXT0hKHRbYV09aSkpfSk6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiByWzBdPWUscyhyLG51bGwsbixpKSxyWzBdPW51bGwsIWkucG9wKCl9fSksaGFzOmxlKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gMDxzZSh0LGUpLmxlbmd0aH19KSxjb250YWluczpsZShmdW5jdGlvbih0KXtyZXR1cm4gdD10LnJlcGxhY2UodGUsbmUpLGZ1bmN0aW9uKGUpe3JldHVybi0xPChlLnRleHRDb250ZW50fHxvKGUpKS5pbmRleE9mKHQpfX0pLGxhbmc6bGUoZnVuY3Rpb24obil7cmV0dXJuIFYudGVzdChufHxcIlwiKXx8c2UuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIituKSxuPW4ucmVwbGFjZSh0ZSxuZSkudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihlKXt2YXIgdDtkb3tpZih0PUU/ZS5sYW5nOmUuZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIil8fGUuZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSlyZXR1cm4odD10LnRvTG93ZXJDYXNlKCkpPT09bnx8MD09PXQuaW5kZXhPZihuK1wiLVwiKX13aGlsZSgoZT1lLnBhcmVudE5vZGUpJiYxPT09ZS5ub2RlVHlwZSk7cmV0dXJuITF9fSksdGFyZ2V0OmZ1bmN0aW9uKGUpe3ZhciB0PW4ubG9jYXRpb24mJm4ubG9jYXRpb24uaGFzaDtyZXR1cm4gdCYmdC5zbGljZSgxKT09PWUuaWR9LHJvb3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1hfSxmb2N1czpmdW5jdGlvbihlKXtyZXR1cm4gZT09PUMuYWN0aXZlRWxlbWVudCYmKCFDLmhhc0ZvY3VzfHxDLmhhc0ZvY3VzKCkpJiYhIShlLnR5cGV8fGUuaHJlZnx8fmUudGFiSW5kZXgpfSxlbmFibGVkOmdlKCExKSxkaXNhYmxlZDpnZSghMCksY2hlY2tlZDpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09dCYmISFlLmNoZWNrZWR8fFwib3B0aW9uXCI9PT10JiYhIWUuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGUpe3JldHVybiBlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCEwPT09ZS5zZWxlY3RlZH0sZW1wdHk6ZnVuY3Rpb24oZSl7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKWlmKGUubm9kZVR5cGU8NilyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiFiLnBzZXVkb3MuZW1wdHkoZSl9LGhlYWRlcjpmdW5jdGlvbihlKXtyZXR1cm4gSi50ZXN0KGUubm9kZU5hbWUpfSxpbnB1dDpmdW5jdGlvbihlKXtyZXR1cm4gUS50ZXN0KGUubm9kZU5hbWUpfSxidXR0b246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PXQmJlwiYnV0dG9uXCI9PT1lLnR5cGV8fFwiYnV0dG9uXCI9PT10fSx0ZXh0OmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVyblwiaW5wdXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmXCJ0ZXh0XCI9PT1lLnR5cGUmJihudWxsPT0odD1lLmdldEF0dHJpYnV0ZShcInR5cGVcIikpfHxcInRleHRcIj09PXQudG9Mb3dlckNhc2UoKSl9LGZpcnN0OnZlKGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDp2ZShmdW5jdGlvbihlLHQpe3JldHVyblt0LTFdfSksZXE6dmUoZnVuY3Rpb24oZSx0LG4pe3JldHVybltuPDA/bit0Om5dfSksZXZlbjp2ZShmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLG9kZDp2ZShmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0xO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLGx0OnZlKGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9bjwwP24rdDp0PG4/dDpuOzA8PS0tcjspZS5wdXNoKHIpO3JldHVybiBlfSksZ3Q6dmUoZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1uPDA/bit0Om47KytyPHQ7KWUucHVzaChyKTtyZXR1cm4gZX0pfX0pLnBzZXVkb3MubnRoPWIucHNldWRvcy5lcSx7cmFkaW86ITAsY2hlY2tib3g6ITAsZmlsZTohMCxwYXNzd29yZDohMCxpbWFnZTohMH0pYi5wc2V1ZG9zW2VdPWRlKGUpO2ZvcihlIGlue3N1Ym1pdDohMCxyZXNldDohMH0pYi5wc2V1ZG9zW2VdPWhlKGUpO2Z1bmN0aW9uIG1lKCl7fWZ1bmN0aW9uIHhlKGUpe2Zvcih2YXIgdD0wLG49ZS5sZW5ndGgscj1cIlwiO3Q8bjt0Kyspcis9ZVt0XS52YWx1ZTtyZXR1cm4gcn1mdW5jdGlvbiBiZShzLGUsdCl7dmFyIHU9ZS5kaXIsbD1lLm5leHQsYz1sfHx1LGY9dCYmXCJwYXJlbnROb2RlXCI9PT1jLHA9cisrO3JldHVybiBlLmZpcnN0P2Z1bmN0aW9uKGUsdCxuKXt3aGlsZShlPWVbdV0paWYoMT09PWUubm9kZVR5cGV8fGYpcmV0dXJuIHMoZSx0LG4pO3JldHVybiExfTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGE9W1MscF07aWYobil7d2hpbGUoZT1lW3VdKWlmKCgxPT09ZS5ub2RlVHlwZXx8ZikmJnMoZSx0LG4pKXJldHVybiEwfWVsc2Ugd2hpbGUoZT1lW3VdKWlmKDE9PT1lLm5vZGVUeXBlfHxmKWlmKGk9KG89ZVtrXXx8KGVba109e30pKVtlLnVuaXF1ZUlEXXx8KG9bZS51bmlxdWVJRF09e30pLGwmJmw9PT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpZT1lW3VdfHxlO2Vsc2V7aWYoKHI9aVtjXSkmJnJbMF09PT1TJiZyWzFdPT09cClyZXR1cm4gYVsyXT1yWzJdO2lmKChpW2NdPWEpWzJdPXMoZSx0LG4pKXJldHVybiEwfXJldHVybiExfX1mdW5jdGlvbiB3ZShpKXtyZXR1cm4gMTxpLmxlbmd0aD9mdW5jdGlvbihlLHQsbil7dmFyIHI9aS5sZW5ndGg7d2hpbGUoci0tKWlmKCFpW3JdKGUsdCxuKSlyZXR1cm4hMTtyZXR1cm4hMH06aVswXX1mdW5jdGlvbiBUZShlLHQsbixyLGkpe2Zvcih2YXIgbyxhPVtdLHM9MCx1PWUubGVuZ3RoLGw9bnVsbCE9dDtzPHU7cysrKShvPWVbc10pJiYobiYmIW4obyxyLGkpfHwoYS5wdXNoKG8pLGwmJnQucHVzaChzKSkpO3JldHVybiBhfWZ1bmN0aW9uIENlKGQsaCxnLHYseSxlKXtyZXR1cm4gdiYmIXZba10mJih2PUNlKHYpKSx5JiYheVtrXSYmKHk9Q2UoeSxlKSksbGUoZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHM9W10sdT1bXSxsPXQubGVuZ3RoLGM9ZXx8ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj0wLGk9dC5sZW5ndGg7cjxpO3IrKylzZShlLHRbcl0sbik7cmV0dXJuIG59KGh8fFwiKlwiLG4ubm9kZVR5cGU/W25dOm4sW10pLGY9IWR8fCFlJiZoP2M6VGUoYyxzLGQsbixyKSxwPWc/eXx8KGU/ZDpsfHx2KT9bXTp0OmY7aWYoZyYmZyhmLHAsbixyKSx2KXtpPVRlKHAsdSksdihpLFtdLG4sciksbz1pLmxlbmd0aDt3aGlsZShvLS0pKGE9aVtvXSkmJihwW3Vbb11dPSEoZlt1W29dXT1hKSl9aWYoZSl7aWYoeXx8ZCl7aWYoeSl7aT1bXSxvPXAubGVuZ3RoO3doaWxlKG8tLSkoYT1wW29dKSYmaS5wdXNoKGZbb109YSk7eShudWxsLHA9W10saSxyKX1vPXAubGVuZ3RoO3doaWxlKG8tLSkoYT1wW29dKSYmLTE8KGk9eT9QKGUsYSk6c1tvXSkmJihlW2ldPSEodFtpXT1hKSl9fWVsc2UgcD1UZShwPT09dD9wLnNwbGljZShsLHAubGVuZ3RoKTpwKSx5P3kobnVsbCx0LHAscik6SC5hcHBseSh0LHApfSl9ZnVuY3Rpb24gRWUoZSl7Zm9yKHZhciBpLHQsbixyPWUubGVuZ3RoLG89Yi5yZWxhdGl2ZVtlWzBdLnR5cGVdLGE9b3x8Yi5yZWxhdGl2ZVtcIiBcIl0scz1vPzE6MCx1PWJlKGZ1bmN0aW9uKGUpe3JldHVybiBlPT09aX0sYSwhMCksbD1iZShmdW5jdGlvbihlKXtyZXR1cm4tMTxQKGksZSl9LGEsITApLGM9W2Z1bmN0aW9uKGUsdCxuKXt2YXIgcj0hbyYmKG58fHQhPT13KXx8KChpPXQpLm5vZGVUeXBlP3UoZSx0LG4pOmwoZSx0LG4pKTtyZXR1cm4gaT1udWxsLHJ9XTtzPHI7cysrKWlmKHQ9Yi5yZWxhdGl2ZVtlW3NdLnR5cGVdKWM9W2JlKHdlKGMpLHQpXTtlbHNle2lmKCh0PWIuZmlsdGVyW2Vbc10udHlwZV0uYXBwbHkobnVsbCxlW3NdLm1hdGNoZXMpKVtrXSl7Zm9yKG49KytzO248cjtuKyspaWYoYi5yZWxhdGl2ZVtlW25dLnR5cGVdKWJyZWFrO3JldHVybiBDZSgxPHMmJndlKGMpLDE8cyYmeGUoZS5zbGljZSgwLHMtMSkuY29uY2F0KHt2YWx1ZTpcIiBcIj09PWVbcy0yXS50eXBlP1wiKlwiOlwiXCJ9KSkucmVwbGFjZShCLFwiJDFcIiksdCxzPG4mJkVlKGUuc2xpY2UocyxuKSksbjxyJiZFZShlPWUuc2xpY2UobikpLG48ciYmeGUoZSkpfWMucHVzaCh0KX1yZXR1cm4gd2UoYyl9cmV0dXJuIG1lLnByb3RvdHlwZT1iLmZpbHRlcnM9Yi5wc2V1ZG9zLGIuc2V0RmlsdGVycz1uZXcgbWUsaD1zZS50b2tlbml6ZT1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGEscyx1LGw9eFtlK1wiIFwiXTtpZihsKXJldHVybiB0PzA6bC5zbGljZSgwKTthPWUscz1bXSx1PWIucHJlRmlsdGVyO3doaWxlKGEpe2ZvcihvIGluIG4mJiEocj1fLmV4ZWMoYSkpfHwociYmKGE9YS5zbGljZShyWzBdLmxlbmd0aCl8fGEpLHMucHVzaChpPVtdKSksbj0hMSwocj16LmV4ZWMoYSkpJiYobj1yLnNoaWZ0KCksaS5wdXNoKHt2YWx1ZTpuLHR5cGU6clswXS5yZXBsYWNlKEIsXCIgXCIpfSksYT1hLnNsaWNlKG4ubGVuZ3RoKSksYi5maWx0ZXIpIShyPUdbb10uZXhlYyhhKSl8fHVbb10mJiEocj11W29dKHIpKXx8KG49ci5zaGlmdCgpLGkucHVzaCh7dmFsdWU6bix0eXBlOm8sbWF0Y2hlczpyfSksYT1hLnNsaWNlKG4ubGVuZ3RoKSk7aWYoIW4pYnJlYWt9cmV0dXJuIHQ/YS5sZW5ndGg6YT9zZS5lcnJvcihlKTp4KGUscykuc2xpY2UoMCl9LGY9c2UuY29tcGlsZT1mdW5jdGlvbihlLHQpe3ZhciBuLHYseSxtLHgscixpPVtdLG89W10sYT1OW2UrXCIgXCJdO2lmKCFhKXt0fHwodD1oKGUpKSxuPXQubGVuZ3RoO3doaWxlKG4tLSkoYT1FZSh0W25dKSlba10/aS5wdXNoKGEpOm8ucHVzaChhKTsoYT1OKGUsKHY9byxtPTA8KHk9aSkubGVuZ3RoLHg9MDx2Lmxlbmd0aCxyPWZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIG8sYSxzLHU9MCxsPVwiMFwiLGM9ZSYmW10sZj1bXSxwPXcsZD1lfHx4JiZiLmZpbmQuVEFHKFwiKlwiLGkpLGg9Uys9bnVsbD09cD8xOk1hdGgucmFuZG9tKCl8fC4xLGc9ZC5sZW5ndGg7Zm9yKGkmJih3PXQ9PT1DfHx0fHxpKTtsIT09ZyYmbnVsbCE9KG89ZFtsXSk7bCsrKXtpZih4JiZvKXthPTAsdHx8by5vd25lckRvY3VtZW50PT09Q3x8KFQobyksbj0hRSk7d2hpbGUocz12W2ErK10paWYocyhvLHR8fEMsbikpe3IucHVzaChvKTticmVha31pJiYoUz1oKX1tJiYoKG89IXMmJm8pJiZ1LS0sZSYmYy5wdXNoKG8pKX1pZih1Kz1sLG0mJmwhPT11KXthPTA7d2hpbGUocz15W2ErK10pcyhjLGYsdCxuKTtpZihlKXtpZigwPHUpd2hpbGUobC0tKWNbbF18fGZbbF18fChmW2xdPXEuY2FsbChyKSk7Zj1UZShmKX1ILmFwcGx5KHIsZiksaSYmIWUmJjA8Zi5sZW5ndGgmJjE8dSt5Lmxlbmd0aCYmc2UudW5pcXVlU29ydChyKX1yZXR1cm4gaSYmKFM9aCx3PXApLGN9LG0/bGUocik6cikpKS5zZWxlY3Rvcj1lfXJldHVybiBhfSxnPXNlLnNlbGVjdD1mdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9XCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSxjPSFyJiZoKGU9bC5zZWxlY3Rvcnx8ZSk7aWYobj1ufHxbXSwxPT09Yy5sZW5ndGgpe2lmKDI8KG89Y1swXT1jWzBdLnNsaWNlKDApKS5sZW5ndGgmJlwiSURcIj09PShhPW9bMF0pLnR5cGUmJjk9PT10Lm5vZGVUeXBlJiZFJiZiLnJlbGF0aXZlW29bMV0udHlwZV0pe2lmKCEodD0oYi5maW5kLklEKGEubWF0Y2hlc1swXS5yZXBsYWNlKHRlLG5lKSx0KXx8W10pWzBdKSlyZXR1cm4gbjtsJiYodD10LnBhcmVudE5vZGUpLGU9ZS5zbGljZShvLnNoaWZ0KCkudmFsdWUubGVuZ3RoKX1pPUcubmVlZHNDb250ZXh0LnRlc3QoZSk/MDpvLmxlbmd0aDt3aGlsZShpLS0pe2lmKGE9b1tpXSxiLnJlbGF0aXZlW3M9YS50eXBlXSlicmVhaztpZigodT1iLmZpbmRbc10pJiYocj11KGEubWF0Y2hlc1swXS5yZXBsYWNlKHRlLG5lKSxlZS50ZXN0KG9bMF0udHlwZSkmJnllKHQucGFyZW50Tm9kZSl8fHQpKSl7aWYoby5zcGxpY2UoaSwxKSwhKGU9ci5sZW5ndGgmJnhlKG8pKSlyZXR1cm4gSC5hcHBseShuLHIpLG47YnJlYWt9fX1yZXR1cm4obHx8ZihlLGMpKShyLHQsIUUsbiwhdHx8ZWUudGVzdChlKSYmeWUodC5wYXJlbnROb2RlKXx8dCksbn0sZC5zb3J0U3RhYmxlPWsuc3BsaXQoXCJcIikuc29ydChEKS5qb2luKFwiXCIpPT09ayxkLmRldGVjdER1cGxpY2F0ZXM9ISFsLFQoKSxkLnNvcnREZXRhY2hlZD1jZShmdW5jdGlvbihlKXtyZXR1cm4gMSZlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKEMuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKX0pLGNlKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxhIGhyZWY9JyMnPjwvYT5cIixcIiNcIj09PWUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpfSl8fGZlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLGZ1bmN0aW9uKGUsdCxuKXtpZighbilyZXR1cm4gZS5nZXRBdHRyaWJ1dGUodCxcInR5cGVcIj09PXQudG9Mb3dlckNhc2UoKT8xOjIpfSksZC5hdHRyaWJ1dGVzJiZjZShmdW5jdGlvbihlKXtyZXR1cm4gZS5pbm5lckhUTUw9XCI8aW5wdXQvPlwiLGUuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIpLFwiXCI9PT1lLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIil9KXx8ZmUoXCJ2YWx1ZVwiLGZ1bmN0aW9uKGUsdCxuKXtpZighbiYmXCJpbnB1dFwiPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXJldHVybiBlLmRlZmF1bHRWYWx1ZX0pLGNlKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpfSl8fGZlKFIsZnVuY3Rpb24oZSx0LG4pe3ZhciByO2lmKCFuKXJldHVybiEwPT09ZVt0XT90LnRvTG93ZXJDYXNlKCk6KHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSYmci5zcGVjaWZpZWQ/ci52YWx1ZTpudWxsfSksc2V9KEMpO2suZmluZD1oLGsuZXhwcj1oLnNlbGVjdG9ycyxrLmV4cHJbXCI6XCJdPWsuZXhwci5wc2V1ZG9zLGsudW5pcXVlU29ydD1rLnVuaXF1ZT1oLnVuaXF1ZVNvcnQsay50ZXh0PWguZ2V0VGV4dCxrLmlzWE1MRG9jPWguaXNYTUwsay5jb250YWlucz1oLmNvbnRhaW5zLGsuZXNjYXBlU2VsZWN0b3I9aC5lc2NhcGU7dmFyIFQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVtdLGk9dm9pZCAwIT09bjt3aGlsZSgoZT1lW3RdKSYmOSE9PWUubm9kZVR5cGUpaWYoMT09PWUubm9kZVR5cGUpe2lmKGkmJmsoZSkuaXMobikpYnJlYWs7ci5wdXNoKGUpfXJldHVybiByfSxTPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPVtdO2U7ZT1lLm5leHRTaWJsaW5nKTE9PT1lLm5vZGVUeXBlJiZlIT09dCYmbi5wdXNoKGUpO3JldHVybiBufSxOPWsuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7ZnVuY3Rpb24gQShlLHQpe3JldHVybiBlLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT10LnRvTG93ZXJDYXNlKCl9dmFyIEQ9L148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2k7ZnVuY3Rpb24gaihlLG4scil7cmV0dXJuIG0obik/ay5ncmVwKGUsZnVuY3Rpb24oZSx0KXtyZXR1cm4hIW4uY2FsbChlLHQsZSkhPT1yfSk6bi5ub2RlVHlwZT9rLmdyZXAoZSxmdW5jdGlvbihlKXtyZXR1cm4gZT09PW4hPT1yfSk6XCJzdHJpbmdcIiE9dHlwZW9mIG4/ay5ncmVwKGUsZnVuY3Rpb24oZSl7cmV0dXJuLTE8aS5jYWxsKG4sZSkhPT1yfSk6ay5maWx0ZXIobixlLHIpfWsuZmlsdGVyPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdO3JldHVybiBuJiYoZT1cIjpub3QoXCIrZStcIilcIiksMT09PXQubGVuZ3RoJiYxPT09ci5ub2RlVHlwZT9rLmZpbmQubWF0Y2hlc1NlbGVjdG9yKHIsZSk/W3JdOltdOmsuZmluZC5tYXRjaGVzKGUsay5ncmVwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT1lLm5vZGVUeXBlfSkpfSxrLmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihlKXt2YXIgdCxuLHI9dGhpcy5sZW5ndGgsaT10aGlzO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiB0aGlzLnB1c2hTdGFjayhrKGUpLmZpbHRlcihmdW5jdGlvbigpe2Zvcih0PTA7dDxyO3QrKylpZihrLmNvbnRhaW5zKGlbdF0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKG49dGhpcy5wdXNoU3RhY2soW10pLHQ9MDt0PHI7dCsrKWsuZmluZChlLGlbdF0sbik7cmV0dXJuIDE8cj9rLnVuaXF1ZVNvcnQobik6bn0sZmlsdGVyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1c2hTdGFjayhqKHRoaXMsZXx8W10sITEpKX0sbm90OmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1c2hTdGFjayhqKHRoaXMsZXx8W10sITApKX0saXM6ZnVuY3Rpb24oZSl7cmV0dXJuISFqKHRoaXMsXCJzdHJpbmdcIj09dHlwZW9mIGUmJk4udGVzdChlKT9rKGUpOmV8fFtdLCExKS5sZW5ndGh9fSk7dmFyIHEsTD0vXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLzsoay5mbi5pbml0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpO2lmKCFlKXJldHVybiB0aGlzO2lmKG49bnx8cSxcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoIShyPVwiPFwiPT09ZVswXSYmXCI+XCI9PT1lW2UubGVuZ3RoLTFdJiYzPD1lLmxlbmd0aD9bbnVsbCxlLG51bGxdOkwuZXhlYyhlKSl8fCFyWzFdJiZ0KXJldHVybiF0fHx0LmpxdWVyeT8odHx8bikuZmluZChlKTp0aGlzLmNvbnN0cnVjdG9yKHQpLmZpbmQoZSk7aWYoclsxXSl7aWYodD10IGluc3RhbmNlb2Ygaz90WzBdOnQsay5tZXJnZSh0aGlzLGsucGFyc2VIVE1MKHJbMV0sdCYmdC5ub2RlVHlwZT90Lm93bmVyRG9jdW1lbnR8fHQ6RSwhMCkpLEQudGVzdChyWzFdKSYmay5pc1BsYWluT2JqZWN0KHQpKWZvcihyIGluIHQpbSh0aGlzW3JdKT90aGlzW3JdKHRbcl0pOnRoaXMuYXR0cihyLHRbcl0pO3JldHVybiB0aGlzfXJldHVybihpPUUuZ2V0RWxlbWVudEJ5SWQoclsyXSkpJiYodGhpc1swXT1pLHRoaXMubGVuZ3RoPTEpLHRoaXN9cmV0dXJuIGUubm9kZVR5cGU/KHRoaXNbMF09ZSx0aGlzLmxlbmd0aD0xLHRoaXMpOm0oZSk/dm9pZCAwIT09bi5yZWFkeT9uLnJlYWR5KGUpOmUoayk6ay5tYWtlQXJyYXkoZSx0aGlzKX0pLnByb3RvdHlwZT1rLmZuLHE9ayhFKTt2YXIgSD0vXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxPPXtjaGlsZHJlbjohMCxjb250ZW50czohMCxuZXh0OiEwLHByZXY6ITB9O2Z1bmN0aW9uIFAoZSx0KXt3aGlsZSgoZT1lW3RdKSYmMSE9PWUubm9kZVR5cGUpO3JldHVybiBlfWsuZm4uZXh0ZW5kKHtoYXM6ZnVuY3Rpb24oZSl7dmFyIHQ9ayhlLHRoaXMpLG49dC5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTxuO2UrKylpZihrLmNvbnRhaW5zKHRoaXMsdFtlXSkpcmV0dXJuITB9KX0sY2xvc2VzdDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MCxpPXRoaXMubGVuZ3RoLG89W10sYT1cInN0cmluZ1wiIT10eXBlb2YgZSYmayhlKTtpZighTi50ZXN0KGUpKWZvcig7cjxpO3IrKylmb3Iobj10aGlzW3JdO24mJm4hPT10O249bi5wYXJlbnROb2RlKWlmKG4ubm9kZVR5cGU8MTEmJihhPy0xPGEuaW5kZXgobik6MT09PW4ubm9kZVR5cGUmJmsuZmluZC5tYXRjaGVzU2VsZWN0b3IobixlKSkpe28ucHVzaChuKTticmVha31yZXR1cm4gdGhpcy5wdXNoU3RhY2soMTxvLmxlbmd0aD9rLnVuaXF1ZVNvcnQobyk6byl9LGluZGV4OmZ1bmN0aW9uKGUpe3JldHVybiBlP1wic3RyaW5nXCI9PXR5cGVvZiBlP2kuY2FsbChrKGUpLHRoaXNbMF0pOmkuY2FsbCh0aGlzLGUuanF1ZXJ5P2VbMF06ZSk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoOi0xfSxhZGQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soay51bmlxdWVTb3J0KGsubWVyZ2UodGhpcy5nZXQoKSxrKGUsdCkpKSl9LGFkZEJhY2s6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWRkKG51bGw9PWU/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpfX0pLGsuZWFjaCh7cGFyZW50OmZ1bmN0aW9uKGUpe3ZhciB0PWUucGFyZW50Tm9kZTtyZXR1cm4gdCYmMTEhPT10Lm5vZGVUeXBlP3Q6bnVsbH0scGFyZW50czpmdW5jdGlvbihlKXtyZXR1cm4gVChlLFwicGFyZW50Tm9kZVwiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gVChlLFwicGFyZW50Tm9kZVwiLG4pfSxuZXh0OmZ1bmN0aW9uKGUpe3JldHVybiBQKGUsXCJuZXh0U2libGluZ1wiKX0scHJldjpmdW5jdGlvbihlKXtyZXR1cm4gUChlLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0QWxsOmZ1bmN0aW9uKGUpe3JldHVybiBUKGUsXCJuZXh0U2libGluZ1wiKX0scHJldkFsbDpmdW5jdGlvbihlKXtyZXR1cm4gVChlLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0VW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBUKGUsXCJuZXh0U2libGluZ1wiLG4pfSxwcmV2VW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBUKGUsXCJwcmV2aW91c1NpYmxpbmdcIixuKX0sc2libGluZ3M6ZnVuY3Rpb24oZSl7cmV0dXJuIFMoKGUucGFyZW50Tm9kZXx8e30pLmZpcnN0Q2hpbGQsZSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGUpe3JldHVybiBTKGUuZmlyc3RDaGlsZCl9LGNvbnRlbnRzOmZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmNvbnRlbnREb2N1bWVudD9lLmNvbnRlbnREb2N1bWVudDooQShlLFwidGVtcGxhdGVcIikmJihlPWUuY29udGVudHx8ZSksay5tZXJnZShbXSxlLmNoaWxkTm9kZXMpKX19LGZ1bmN0aW9uKHIsaSl7ay5mbltyXT1mdW5jdGlvbihlLHQpe3ZhciBuPWsubWFwKHRoaXMsaSxlKTtyZXR1cm5cIlVudGlsXCIhPT1yLnNsaWNlKC01KSYmKHQ9ZSksdCYmXCJzdHJpbmdcIj09dHlwZW9mIHQmJihuPWsuZmlsdGVyKHQsbikpLDE8dGhpcy5sZW5ndGgmJihPW3JdfHxrLnVuaXF1ZVNvcnQobiksSC50ZXN0KHIpJiZuLnJldmVyc2UoKSksdGhpcy5wdXNoU3RhY2sobil9fSk7dmFyIFI9L1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nO2Z1bmN0aW9uIE0oZSl7cmV0dXJuIGV9ZnVuY3Rpb24gSShlKXt0aHJvdyBlfWZ1bmN0aW9uIFcoZSx0LG4scil7dmFyIGk7dHJ5e2UmJm0oaT1lLnByb21pc2UpP2kuY2FsbChlKS5kb25lKHQpLmZhaWwobik6ZSYmbShpPWUudGhlbik/aS5jYWxsKGUsdCxuKTp0LmFwcGx5KHZvaWQgMCxbZV0uc2xpY2UocikpfWNhdGNoKGUpe24uYXBwbHkodm9pZCAwLFtlXSl9fWsuQ2FsbGJhY2tzPWZ1bmN0aW9uKHIpe3ZhciBlLG47cj1cInN0cmluZ1wiPT10eXBlb2Ygcj8oZT1yLG49e30say5lYWNoKGUubWF0Y2goUil8fFtdLGZ1bmN0aW9uKGUsdCl7blt0XT0hMH0pLG4pOmsuZXh0ZW5kKHt9LHIpO3ZhciBpLHQsbyxhLHM9W10sdT1bXSxsPS0xLGM9ZnVuY3Rpb24oKXtmb3IoYT1hfHxyLm9uY2Usbz1pPSEwO3UubGVuZ3RoO2w9LTEpe3Q9dS5zaGlmdCgpO3doaWxlKCsrbDxzLmxlbmd0aCkhMT09PXNbbF0uYXBwbHkodFswXSx0WzFdKSYmci5zdG9wT25GYWxzZSYmKGw9cy5sZW5ndGgsdD0hMSl9ci5tZW1vcnl8fCh0PSExKSxpPSExLGEmJihzPXQ/W106XCJcIil9LGY9e2FkZDpmdW5jdGlvbigpe3JldHVybiBzJiYodCYmIWkmJihsPXMubGVuZ3RoLTEsdS5wdXNoKHQpKSxmdW5jdGlvbiBuKGUpe2suZWFjaChlLGZ1bmN0aW9uKGUsdCl7bSh0KT9yLnVuaXF1ZSYmZi5oYXModCl8fHMucHVzaCh0KTp0JiZ0Lmxlbmd0aCYmXCJzdHJpbmdcIiE9PXcodCkmJm4odCl9KX0oYXJndW1lbnRzKSx0JiYhaSYmYygpKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gay5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihlLHQpe3ZhciBuO3doaWxlKC0xPChuPWsuaW5BcnJheSh0LHMsbikpKXMuc3BsaWNlKG4sMSksbjw9bCYmbC0tfSksdGhpc30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiBlPy0xPGsuaW5BcnJheShlLHMpOjA8cy5sZW5ndGh9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHMmJihzPVtdKSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGE9dT1bXSxzPXQ9XCJcIix0aGlzfSxkaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiFzfSxsb2NrOmZ1bmN0aW9uKCl7cmV0dXJuIGE9dT1bXSx0fHxpfHwocz10PVwiXCIpLHRoaXN9LGxvY2tlZDpmdW5jdGlvbigpe3JldHVybiEhYX0sZmlyZVdpdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYXx8KHQ9W2UsKHQ9dHx8W10pLnNsaWNlP3Quc2xpY2UoKTp0XSx1LnB1c2godCksaXx8YygpKSx0aGlzfSxmaXJlOmZ1bmN0aW9uKCl7cmV0dXJuIGYuZmlyZVdpdGgodGhpcyxhcmd1bWVudHMpLHRoaXN9LGZpcmVkOmZ1bmN0aW9uKCl7cmV0dXJuISFvfX07cmV0dXJuIGZ9LGsuZXh0ZW5kKHtEZWZlcnJlZDpmdW5jdGlvbihlKXt2YXIgbz1bW1wibm90aWZ5XCIsXCJwcm9ncmVzc1wiLGsuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLGsuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLDJdLFtcInJlc29sdmVcIixcImRvbmVcIixrLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLGsuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksMCxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLGsuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksay5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwxLFwicmVqZWN0ZWRcIl1dLGk9XCJwZW5kaW5nXCIsYT17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIHMuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSxcImNhdGNoXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGEudGhlbihudWxsLGUpfSxwaXBlOmZ1bmN0aW9uKCl7dmFyIGk9YXJndW1lbnRzO3JldHVybiBrLkRlZmVycmVkKGZ1bmN0aW9uKHIpe2suZWFjaChvLGZ1bmN0aW9uKGUsdCl7dmFyIG49bShpW3RbNF1dKSYmaVt0WzRdXTtzW3RbMV1dKGZ1bmN0aW9uKCl7dmFyIGU9biYmbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmbShlLnByb21pc2UpP2UucHJvbWlzZSgpLnByb2dyZXNzKHIubm90aWZ5KS5kb25lKHIucmVzb2x2ZSkuZmFpbChyLnJlamVjdCk6clt0WzBdK1wiV2l0aFwiXSh0aGlzLG4/W2VdOmFyZ3VtZW50cyl9KX0pLGk9bnVsbH0pLnByb21pc2UoKX0sdGhlbjpmdW5jdGlvbih0LG4scil7dmFyIHU9MDtmdW5jdGlvbiBsKGksbyxhLHMpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMscj1hcmd1bWVudHMsZT1mdW5jdGlvbigpe3ZhciBlLHQ7aWYoIShpPHUpKXtpZigoZT1hLmFwcGx5KG4scikpPT09by5wcm9taXNlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiKTt0PWUmJihcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZSkmJmUudGhlbixtKHQpP3M/dC5jYWxsKGUsbCh1LG8sTSxzKSxsKHUsbyxJLHMpKToodSsrLHQuY2FsbChlLGwodSxvLE0scyksbCh1LG8sSSxzKSxsKHUsbyxNLG8ubm90aWZ5V2l0aCkpKTooYSE9PU0mJihuPXZvaWQgMCxyPVtlXSksKHN8fG8ucmVzb2x2ZVdpdGgpKG4scikpfX0sdD1zP2U6ZnVuY3Rpb24oKXt0cnl7ZSgpfWNhdGNoKGUpe2suRGVmZXJyZWQuZXhjZXB0aW9uSG9vayYmay5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGUsdC5zdGFja1RyYWNlKSx1PD1pKzEmJihhIT09SSYmKG49dm9pZCAwLHI9W2VdKSxvLnJlamVjdFdpdGgobixyKSl9fTtpP3QoKTooay5EZWZlcnJlZC5nZXRTdGFja0hvb2smJih0LnN0YWNrVHJhY2U9ay5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksQy5zZXRUaW1lb3V0KHQpKX19cmV0dXJuIGsuRGVmZXJyZWQoZnVuY3Rpb24oZSl7b1swXVszXS5hZGQobCgwLGUsbShyKT9yOk0sZS5ub3RpZnlXaXRoKSksb1sxXVszXS5hZGQobCgwLGUsbSh0KT90Ok0pKSxvWzJdWzNdLmFkZChsKDAsZSxtKG4pP246SSkpfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP2suZXh0ZW5kKGUsYSk6YX19LHM9e307cmV0dXJuIGsuZWFjaChvLGZ1bmN0aW9uKGUsdCl7dmFyIG49dFsyXSxyPXRbNV07YVt0WzFdXT1uLmFkZCxyJiZuLmFkZChmdW5jdGlvbigpe2k9cn0sb1szLWVdWzJdLmRpc2FibGUsb1szLWVdWzNdLmRpc2FibGUsb1swXVsyXS5sb2NrLG9bMF1bM10ubG9jayksbi5hZGQodFszXS5maXJlKSxzW3RbMF1dPWZ1bmN0aW9uKCl7cmV0dXJuIHNbdFswXStcIldpdGhcIl0odGhpcz09PXM/dm9pZCAwOnRoaXMsYXJndW1lbnRzKSx0aGlzfSxzW3RbMF0rXCJXaXRoXCJdPW4uZmlyZVdpdGh9KSxhLnByb21pc2UocyksZSYmZS5jYWxsKHMscyksc30sd2hlbjpmdW5jdGlvbihlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHQ9bixyPUFycmF5KHQpLGk9cy5jYWxsKGFyZ3VtZW50cyksbz1rLkRlZmVycmVkKCksYT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7clt0XT10aGlzLGlbdF09MTxhcmd1bWVudHMubGVuZ3RoP3MuY2FsbChhcmd1bWVudHMpOmUsLS1ufHxvLnJlc29sdmVXaXRoKHIsaSl9fTtpZihuPD0xJiYoVyhlLG8uZG9uZShhKHQpKS5yZXNvbHZlLG8ucmVqZWN0LCFuKSxcInBlbmRpbmdcIj09PW8uc3RhdGUoKXx8bShpW3RdJiZpW3RdLnRoZW4pKSlyZXR1cm4gby50aGVuKCk7d2hpbGUodC0tKVcoaVt0XSxhKHQpLG8ucmVqZWN0KTtyZXR1cm4gby5wcm9taXNlKCl9fSk7dmFyICQ9L14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87ay5EZWZlcnJlZC5leGNlcHRpb25Ib29rPWZ1bmN0aW9uKGUsdCl7Qy5jb25zb2xlJiZDLmNvbnNvbGUud2FybiYmZSYmJC50ZXN0KGUubmFtZSkmJkMuY29uc29sZS53YXJuKFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIrZS5tZXNzYWdlLGUuc3RhY2ssdCl9LGsucmVhZHlFeGNlcHRpb249ZnVuY3Rpb24oZSl7Qy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZX0pfTt2YXIgRj1rLkRlZmVycmVkKCk7ZnVuY3Rpb24gQigpe0UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixCKSxDLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsQiksay5yZWFkeSgpfWsuZm4ucmVhZHk9ZnVuY3Rpb24oZSl7cmV0dXJuIEYudGhlbihlKVtcImNhdGNoXCJdKGZ1bmN0aW9uKGUpe2sucmVhZHlFeGNlcHRpb24oZSl9KSx0aGlzfSxrLmV4dGVuZCh7aXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxyZWFkeTpmdW5jdGlvbihlKXsoITA9PT1lPy0tay5yZWFkeVdhaXQ6ay5pc1JlYWR5KXx8KGsuaXNSZWFkeT0hMCkhPT1lJiYwPC0tay5yZWFkeVdhaXR8fEYucmVzb2x2ZVdpdGgoRSxba10pfX0pLGsucmVhZHkudGhlbj1GLnRoZW4sXCJjb21wbGV0ZVwiPT09RS5yZWFkeVN0YXRlfHxcImxvYWRpbmdcIiE9PUUucmVhZHlTdGF0ZSYmIUUuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsP0Muc2V0VGltZW91dChrLnJlYWR5KTooRS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLEIpLEMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixCKSk7dmFyIF89ZnVuY3Rpb24oZSx0LG4scixpLG8sYSl7dmFyIHM9MCx1PWUubGVuZ3RoLGw9bnVsbD09bjtpZihcIm9iamVjdFwiPT09dyhuKSlmb3IocyBpbiBpPSEwLG4pXyhlLHQscyxuW3NdLCEwLG8sYSk7ZWxzZSBpZih2b2lkIDAhPT1yJiYoaT0hMCxtKHIpfHwoYT0hMCksbCYmKGE/KHQuY2FsbChlLHIpLHQ9bnVsbCk6KGw9dCx0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbC5jYWxsKGsoZSksbil9KSksdCkpZm9yKDtzPHU7cysrKXQoZVtzXSxuLGE/cjpyLmNhbGwoZVtzXSxzLHQoZVtzXSxuKSkpO3JldHVybiBpP2U6bD90LmNhbGwoZSk6dT90KGVbMF0sbik6b30sej0vXi1tcy0vLFU9Ly0oW2Etel0pL2c7ZnVuY3Rpb24gWChlLHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9ZnVuY3Rpb24gVihlKXtyZXR1cm4gZS5yZXBsYWNlKHosXCJtcy1cIikucmVwbGFjZShVLFgpfXZhciBHPWZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS5ub2RlVHlwZXx8OT09PWUubm9kZVR5cGV8fCErZS5ub2RlVHlwZX07ZnVuY3Rpb24gWSgpe3RoaXMuZXhwYW5kbz1rLmV4cGFuZG8rWS51aWQrK31ZLnVpZD0xLFkucHJvdG90eXBlPXtjYWNoZTpmdW5jdGlvbihlKXt2YXIgdD1lW3RoaXMuZXhwYW5kb107cmV0dXJuIHR8fCh0PXt9LEcoZSkmJihlLm5vZGVUeXBlP2VbdGhpcy5leHBhbmRvXT10Ok9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHRoaXMuZXhwYW5kbyx7dmFsdWU6dCxjb25maWd1cmFibGU6ITB9KSkpLHR9LHNldDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT10aGlzLmNhY2hlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KWlbVih0KV09bjtlbHNlIGZvcihyIGluIHQpaVtWKHIpXT10W3JdO3JldHVybiBpfSxnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dD90aGlzLmNhY2hlKGUpOmVbdGhpcy5leHBhbmRvXSYmZVt0aGlzLmV4cGFuZG9dW1YodCldfSxhY2Nlc3M6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT10fHx0JiZcInN0cmluZ1wiPT10eXBlb2YgdCYmdm9pZCAwPT09bj90aGlzLmdldChlLHQpOih0aGlzLnNldChlLHQsbiksdm9pZCAwIT09bj9uOnQpfSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWVbdGhpcy5leHBhbmRvXTtpZih2b2lkIDAhPT1yKXtpZih2b2lkIDAhPT10KXtuPSh0PUFycmF5LmlzQXJyYXkodCk/dC5tYXAoVik6KHQ9Vih0KSlpbiByP1t0XTp0Lm1hdGNoKFIpfHxbXSkubGVuZ3RoO3doaWxlKG4tLSlkZWxldGUgclt0W25dXX0odm9pZCAwPT09dHx8ay5pc0VtcHR5T2JqZWN0KHIpKSYmKGUubm9kZVR5cGU/ZVt0aGlzLmV4cGFuZG9dPXZvaWQgMDpkZWxldGUgZVt0aGlzLmV4cGFuZG9dKX19LGhhc0RhdGE6ZnVuY3Rpb24oZSl7dmFyIHQ9ZVt0aGlzLmV4cGFuZG9dO3JldHVybiB2b2lkIDAhPT10JiYhay5pc0VtcHR5T2JqZWN0KHQpfX07dmFyIFE9bmV3IFksSj1uZXcgWSxLPS9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxaPS9bQS1aXS9nO2Z1bmN0aW9uIGVlKGUsdCxuKXt2YXIgcixpO2lmKHZvaWQgMD09PW4mJjE9PT1lLm5vZGVUeXBlKWlmKHI9XCJkYXRhLVwiK3QucmVwbGFjZShaLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCksXCJzdHJpbmdcIj09dHlwZW9mKG49ZS5nZXRBdHRyaWJ1dGUocikpKXt0cnl7bj1cInRydWVcIj09PShpPW4pfHxcImZhbHNlXCIhPT1pJiYoXCJudWxsXCI9PT1pP251bGw6aT09PStpK1wiXCI/K2k6Sy50ZXN0KGkpP0pTT04ucGFyc2UoaSk6aSl9Y2F0Y2goZSl7fUouc2V0KGUsdCxuKX1lbHNlIG49dm9pZCAwO3JldHVybiBufWsuZXh0ZW5kKHtoYXNEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiBKLmhhc0RhdGEoZSl8fFEuaGFzRGF0YShlKX0sZGF0YTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIEouYWNjZXNzKGUsdCxuKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihlLHQpe0oucmVtb3ZlKGUsdCl9LF9kYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gUS5hY2Nlc3MoZSx0LG4pfSxfcmVtb3ZlRGF0YTpmdW5jdGlvbihlLHQpe1EucmVtb3ZlKGUsdCl9fSksay5mbi5leHRlbmQoe2RhdGE6ZnVuY3Rpb24obixlKXt2YXIgdCxyLGksbz10aGlzWzBdLGE9byYmby5hdHRyaWJ1dGVzO2lmKHZvaWQgMD09PW4pe2lmKHRoaXMubGVuZ3RoJiYoaT1KLmdldChvKSwxPT09by5ub2RlVHlwZSYmIVEuZ2V0KG8sXCJoYXNEYXRhQXR0cnNcIikpKXt0PWEubGVuZ3RoO3doaWxlKHQtLSlhW3RdJiYwPT09KHI9YVt0XS5uYW1lKS5pbmRleE9mKFwiZGF0YS1cIikmJihyPVYoci5zbGljZSg1KSksZWUobyxyLGlbcl0pKTtRLnNldChvLFwiaGFzRGF0YUF0dHJzXCIsITApfXJldHVybiBpfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBuP3RoaXMuZWFjaChmdW5jdGlvbigpe0ouc2V0KHRoaXMsbil9KTpfKHRoaXMsZnVuY3Rpb24oZSl7dmFyIHQ7aWYobyYmdm9pZCAwPT09ZSlyZXR1cm4gdm9pZCAwIT09KHQ9Si5nZXQobyxuKSk/dDp2b2lkIDAhPT0odD1lZShvLG4pKT90OnZvaWQgMDt0aGlzLmVhY2goZnVuY3Rpb24oKXtKLnNldCh0aGlzLG4sZSl9KX0sbnVsbCxlLDE8YXJndW1lbnRzLmxlbmd0aCxudWxsLCEwKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Si5yZW1vdmUodGhpcyxlKX0pfX0pLGsuZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoZSlyZXR1cm4gdD0odHx8XCJmeFwiKStcInF1ZXVlXCIscj1RLmdldChlLHQpLG4mJighcnx8QXJyYXkuaXNBcnJheShuKT9yPVEuYWNjZXNzKGUsdCxrLm1ha2VBcnJheShuKSk6ci5wdXNoKG4pKSxyfHxbXX0sZGVxdWV1ZTpmdW5jdGlvbihlLHQpe3Q9dHx8XCJmeFwiO3ZhciBuPWsucXVldWUoZSx0KSxyPW4ubGVuZ3RoLGk9bi5zaGlmdCgpLG89ay5fcXVldWVIb29rcyhlLHQpO1wiaW5wcm9ncmVzc1wiPT09aSYmKGk9bi5zaGlmdCgpLHItLSksaSYmKFwiZnhcIj09PXQmJm4udW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIG8uc3RvcCxpLmNhbGwoZSxmdW5jdGlvbigpe2suZGVxdWV1ZShlLHQpfSxvKSksIXImJm8mJm8uZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihlLHQpe3ZhciBuPXQrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIFEuZ2V0KGUsbil8fFEuYWNjZXNzKGUsbix7ZW1wdHk6ay5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKXtRLnJlbW92ZShlLFt0K1wicXVldWVcIixuXSl9KX0pfX0pLGsuZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbih0LG4pe3ZhciBlPTI7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIHQmJihuPXQsdD1cImZ4XCIsZS0tKSxhcmd1bWVudHMubGVuZ3RoPGU/ay5xdWV1ZSh0aGlzWzBdLHQpOnZvaWQgMD09PW4/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1rLnF1ZXVlKHRoaXMsdCxuKTtrLl9xdWV1ZUhvb2tzKHRoaXMsdCksXCJmeFwiPT09dCYmXCJpbnByb2dyZXNzXCIhPT1lWzBdJiZrLmRlcXVldWUodGhpcyx0KX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtrLmRlcXVldWUodGhpcyxlKX0pfSxjbGVhclF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnF1ZXVlKGV8fFwiZnhcIixbXSl9LHByb21pc2U6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTEsaT1rLkRlZmVycmVkKCksbz10aGlzLGE9dGhpcy5sZW5ndGgscz1mdW5jdGlvbigpey0tcnx8aS5yZXNvbHZlV2l0aChvLFtvXSl9O1wic3RyaW5nXCIhPXR5cGVvZiBlJiYodD1lLGU9dm9pZCAwKSxlPWV8fFwiZnhcIjt3aGlsZShhLS0pKG49US5nZXQob1thXSxlK1wicXVldWVIb29rc1wiKSkmJm4uZW1wdHkmJihyKyssbi5lbXB0eS5hZGQocykpO3JldHVybiBzKCksaS5wcm9taXNlKHQpfX0pO3ZhciB0ZT0vWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2UsbmU9bmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIrdGUrXCIpKFthLXolXSopJFwiLFwiaVwiKSxyZT1bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0saWU9RS5kb2N1bWVudEVsZW1lbnQsb2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGsuY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfSxhZT17Y29tcG9zZWQ6ITB9O2llLmdldFJvb3ROb2RlJiYob2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGsuY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfHxlLmdldFJvb3ROb2RlKGFlKT09PWUub3duZXJEb2N1bWVudH0pO3ZhciBzZT1mdW5jdGlvbihlLHQpe3JldHVyblwibm9uZVwiPT09KGU9dHx8ZSkuc3R5bGUuZGlzcGxheXx8XCJcIj09PWUuc3R5bGUuZGlzcGxheSYmb2UoZSkmJlwibm9uZVwiPT09ay5jc3MoZSxcImRpc3BsYXlcIil9LHVlPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYT17fTtmb3IobyBpbiB0KWFbb109ZS5zdHlsZVtvXSxlLnN0eWxlW29dPXRbb107Zm9yKG8gaW4gaT1uLmFwcGx5KGUscnx8W10pLHQpZS5zdHlsZVtvXT1hW29dO3JldHVybiBpfTtmdW5jdGlvbiBsZShlLHQsbixyKXt2YXIgaSxvLGE9MjAscz1yP2Z1bmN0aW9uKCl7cmV0dXJuIHIuY3VyKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIGsuY3NzKGUsdCxcIlwiKX0sdT1zKCksbD1uJiZuWzNdfHwoay5jc3NOdW1iZXJbdF0/XCJcIjpcInB4XCIpLGM9ZS5ub2RlVHlwZSYmKGsuY3NzTnVtYmVyW3RdfHxcInB4XCIhPT1sJiYrdSkmJm5lLmV4ZWMoay5jc3MoZSx0KSk7aWYoYyYmY1szXSE9PWwpe3UvPTIsbD1sfHxjWzNdLGM9K3V8fDE7d2hpbGUoYS0tKWsuc3R5bGUoZSx0LGMrbCksKDEtbykqKDEtKG89cygpL3V8fC41KSk8PTAmJihhPTApLGMvPW87Yyo9MixrLnN0eWxlKGUsdCxjK2wpLG49bnx8W119cmV0dXJuIG4mJihjPStjfHwrdXx8MCxpPW5bMV0/YysoblsxXSsxKSpuWzJdOituWzJdLHImJihyLnVuaXQ9bCxyLnN0YXJ0PWMsci5lbmQ9aSkpLGl9dmFyIGNlPXt9O2Z1bmN0aW9uIGZlKGUsdCl7Zm9yKHZhciBuLHIsaSxvLGEscyx1LGw9W10sYz0wLGY9ZS5sZW5ndGg7YzxmO2MrKykocj1lW2NdKS5zdHlsZSYmKG49ci5zdHlsZS5kaXNwbGF5LHQ/KFwibm9uZVwiPT09biYmKGxbY109US5nZXQocixcImRpc3BsYXlcIil8fG51bGwsbFtjXXx8KHIuc3R5bGUuZGlzcGxheT1cIlwiKSksXCJcIj09PXIuc3R5bGUuZGlzcGxheSYmc2UocikmJihsW2NdPSh1PWE9bz12b2lkIDAsYT0oaT1yKS5vd25lckRvY3VtZW50LHM9aS5ub2RlTmFtZSwodT1jZVtzXSl8fChvPWEuYm9keS5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQocykpLHU9ay5jc3MobyxcImRpc3BsYXlcIiksby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pLFwibm9uZVwiPT09dSYmKHU9XCJibG9ja1wiKSxjZVtzXT11KSkpKTpcIm5vbmVcIiE9PW4mJihsW2NdPVwibm9uZVwiLFEuc2V0KHIsXCJkaXNwbGF5XCIsbikpKTtmb3IoYz0wO2M8ZjtjKyspbnVsbCE9bFtjXSYmKGVbY10uc3R5bGUuZGlzcGxheT1sW2NdKTtyZXR1cm4gZX1rLmZuLmV4dGVuZCh7c2hvdzpmdW5jdGlvbigpe3JldHVybiBmZSh0aGlzLCEwKX0saGlkZTpmdW5jdGlvbigpe3JldHVybiBmZSh0aGlzKX0sdG9nZ2xlOmZ1bmN0aW9uKGUpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgZT9lP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpOnRoaXMuZWFjaChmdW5jdGlvbigpe3NlKHRoaXMpP2sodGhpcykuc2hvdygpOmsodGhpcykuaGlkZSgpfSl9fSk7dmFyIHBlPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLGRlPS88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSxoZT0vXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLGdlPXtvcHRpb246WzEsXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXCI8L3NlbGVjdD5cIl0sdGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSxjb2w6WzIsXCI8dGFibGU+PGNvbGdyb3VwPlwiLFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sX2RlZmF1bHQ6WzAsXCJcIixcIlwiXX07ZnVuY3Rpb24gdmUoZSx0KXt2YXIgbjtyZXR1cm4gbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZT9lLmdldEVsZW1lbnRzQnlUYWdOYW1lKHR8fFwiKlwiKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5xdWVyeVNlbGVjdG9yQWxsP2UucXVlcnlTZWxlY3RvckFsbCh0fHxcIipcIik6W10sdm9pZCAwPT09dHx8dCYmQShlLHQpP2subWVyZ2UoW2VdLG4pOm59ZnVuY3Rpb24geWUoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspUS5zZXQoZVtuXSxcImdsb2JhbEV2YWxcIiwhdHx8US5nZXQodFtuXSxcImdsb2JhbEV2YWxcIikpfWdlLm9wdGdyb3VwPWdlLm9wdGlvbixnZS50Ym9keT1nZS50Zm9vdD1nZS5jb2xncm91cD1nZS5jYXB0aW9uPWdlLnRoZWFkLGdlLnRoPWdlLnRkO3ZhciBtZSx4ZSxiZT0vPHwmIz9cXHcrOy87ZnVuY3Rpb24gd2UoZSx0LG4scixpKXtmb3IodmFyIG8sYSxzLHUsbCxjLGY9dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkscD1bXSxkPTAsaD1lLmxlbmd0aDtkPGg7ZCsrKWlmKChvPWVbZF0pfHwwPT09bylpZihcIm9iamVjdFwiPT09dyhvKSlrLm1lcmdlKHAsby5ub2RlVHlwZT9bb106byk7ZWxzZSBpZihiZS50ZXN0KG8pKXthPWF8fGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxzPShkZS5leGVjKG8pfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSx1PWdlW3NdfHxnZS5fZGVmYXVsdCxhLmlubmVySFRNTD11WzFdK2suaHRtbFByZWZpbHRlcihvKSt1WzJdLGM9dVswXTt3aGlsZShjLS0pYT1hLmxhc3RDaGlsZDtrLm1lcmdlKHAsYS5jaGlsZE5vZGVzKSwoYT1mLmZpcnN0Q2hpbGQpLnRleHRDb250ZW50PVwiXCJ9ZWxzZSBwLnB1c2godC5jcmVhdGVUZXh0Tm9kZShvKSk7Zi50ZXh0Q29udGVudD1cIlwiLGQ9MDt3aGlsZShvPXBbZCsrXSlpZihyJiYtMTxrLmluQXJyYXkobyxyKSlpJiZpLnB1c2gobyk7ZWxzZSBpZihsPW9lKG8pLGE9dmUoZi5hcHBlbmRDaGlsZChvKSxcInNjcmlwdFwiKSxsJiZ5ZShhKSxuKXtjPTA7d2hpbGUobz1hW2MrK10paGUudGVzdChvLnR5cGV8fFwiXCIpJiZuLnB1c2gobyl9cmV0dXJuIGZ9bWU9RS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwoeGU9RS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcInJhZGlvXCIpLHhlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcImNoZWNrZWRcIikseGUuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwidFwiKSxtZS5hcHBlbmRDaGlsZCh4ZSkseS5jaGVja0Nsb25lPW1lLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxtZS5pbm5lckhUTUw9XCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCIseS5ub0Nsb25lQ2hlY2tlZD0hIW1lLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTt2YXIgVGU9L15rZXkvLENlPS9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxFZT0vXihbXi5dKikoPzpcXC4oLispfCkvO2Z1bmN0aW9uIGtlKCl7cmV0dXJuITB9ZnVuY3Rpb24gU2UoKXtyZXR1cm4hMX1mdW5jdGlvbiBOZShlLHQpe3JldHVybiBlPT09ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIEUuYWN0aXZlRWxlbWVudH1jYXRjaChlKXt9fSgpPT0oXCJmb2N1c1wiPT09dCl9ZnVuY3Rpb24gQWUoZSx0LG4scixpLG8pe3ZhciBhLHM7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpe2ZvcihzIGluXCJzdHJpbmdcIiE9dHlwZW9mIG4mJihyPXJ8fG4sbj12b2lkIDApLHQpQWUoZSxzLG4scix0W3NdLG8pO3JldHVybiBlfWlmKG51bGw9PXImJm51bGw9PWk/KGk9bixyPW49dm9pZCAwKTpudWxsPT1pJiYoXCJzdHJpbmdcIj09dHlwZW9mIG4/KGk9cixyPXZvaWQgMCk6KGk9cixyPW4sbj12b2lkIDApKSwhMT09PWkpaT1TZTtlbHNlIGlmKCFpKXJldHVybiBlO3JldHVybiAxPT09byYmKGE9aSwoaT1mdW5jdGlvbihlKXtyZXR1cm4gaygpLm9mZihlKSxhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLmd1aWQ9YS5ndWlkfHwoYS5ndWlkPWsuZ3VpZCsrKSksZS5lYWNoKGZ1bmN0aW9uKCl7ay5ldmVudC5hZGQodGhpcyx0LGkscixuKX0pfWZ1bmN0aW9uIERlKGUsaSxvKXtvPyhRLnNldChlLGksITEpLGsuZXZlbnQuYWRkKGUsaSx7bmFtZXNwYWNlOiExLGhhbmRsZXI6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPVEuZ2V0KHRoaXMsaSk7aWYoMSZlLmlzVHJpZ2dlciYmdGhpc1tpXSl7aWYoci5sZW5ndGgpKGsuZXZlbnQuc3BlY2lhbFtpXXx8e30pLmRlbGVnYXRlVHlwZSYmZS5zdG9wUHJvcGFnYXRpb24oKTtlbHNlIGlmKHI9cy5jYWxsKGFyZ3VtZW50cyksUS5zZXQodGhpcyxpLHIpLHQ9byh0aGlzLGkpLHRoaXNbaV0oKSxyIT09KG49US5nZXQodGhpcyxpKSl8fHQ/US5zZXQodGhpcyxpLCExKTpuPXt9LHIhPT1uKXJldHVybiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSxuLnZhbHVlfWVsc2Ugci5sZW5ndGgmJihRLnNldCh0aGlzLGkse3ZhbHVlOmsuZXZlbnQudHJpZ2dlcihrLmV4dGVuZChyWzBdLGsuRXZlbnQucHJvdG90eXBlKSxyLnNsaWNlKDEpLHRoaXMpfSksZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSl9fSkpOnZvaWQgMD09PVEuZ2V0KGUsaSkmJmsuZXZlbnQuYWRkKGUsaSxrZSl9ay5ldmVudD17Z2xvYmFsOnt9LGFkZDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvLGEscyx1LGwsYyxmLHAsZCxoLGcsdj1RLmdldCh0KTtpZih2KXtuLmhhbmRsZXImJihuPShvPW4pLmhhbmRsZXIsaT1vLnNlbGVjdG9yKSxpJiZrLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGllLGkpLG4uZ3VpZHx8KG4uZ3VpZD1rLmd1aWQrKyksKHU9di5ldmVudHMpfHwodT12LmV2ZW50cz17fSksKGE9di5oYW5kbGUpfHwoYT12LmhhbmRsZT1mdW5jdGlvbihlKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgayYmay5ldmVudC50cmlnZ2VyZWQhPT1lLnR5cGU/ay5ldmVudC5kaXNwYXRjaC5hcHBseSh0LGFyZ3VtZW50cyk6dm9pZCAwfSksbD0oZT0oZXx8XCJcIikubWF0Y2goUil8fFtcIlwiXSkubGVuZ3RoO3doaWxlKGwtLSlkPWc9KHM9RWUuZXhlYyhlW2xdKXx8W10pWzFdLGg9KHNbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZCYmKGY9ay5ldmVudC5zcGVjaWFsW2RdfHx7fSxkPShpP2YuZGVsZWdhdGVUeXBlOmYuYmluZFR5cGUpfHxkLGY9ay5ldmVudC5zcGVjaWFsW2RdfHx7fSxjPWsuZXh0ZW5kKHt0eXBlOmQsb3JpZ1R5cGU6ZyxkYXRhOnIsaGFuZGxlcjpuLGd1aWQ6bi5ndWlkLHNlbGVjdG9yOmksbmVlZHNDb250ZXh0OmkmJmsuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChpKSxuYW1lc3BhY2U6aC5qb2luKFwiLlwiKX0sbyksKHA9dVtkXSl8fCgocD11W2RdPVtdKS5kZWxlZ2F0ZUNvdW50PTAsZi5zZXR1cCYmITEhPT1mLnNldHVwLmNhbGwodCxyLGgsYSl8fHQuYWRkRXZlbnRMaXN0ZW5lciYmdC5hZGRFdmVudExpc3RlbmVyKGQsYSkpLGYuYWRkJiYoZi5hZGQuY2FsbCh0LGMpLGMuaGFuZGxlci5ndWlkfHwoYy5oYW5kbGVyLmd1aWQ9bi5ndWlkKSksaT9wLnNwbGljZShwLmRlbGVnYXRlQ291bnQrKywwLGMpOnAucHVzaChjKSxrLmV2ZW50Lmdsb2JhbFtkXT0hMCl9fSxyZW1vdmU6ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgbyxhLHMsdSxsLGMsZixwLGQsaCxnLHY9US5oYXNEYXRhKGUpJiZRLmdldChlKTtpZih2JiYodT12LmV2ZW50cykpe2w9KHQ9KHR8fFwiXCIpLm1hdGNoKFIpfHxbXCJcIl0pLmxlbmd0aDt3aGlsZShsLS0paWYoZD1nPShzPUVlLmV4ZWModFtsXSl8fFtdKVsxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQpe2Y9ay5ldmVudC5zcGVjaWFsW2RdfHx7fSxwPXVbZD0ocj9mLmRlbGVnYXRlVHlwZTpmLmJpbmRUeXBlKXx8ZF18fFtdLHM9c1syXSYmbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK2guam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpLGE9bz1wLmxlbmd0aDt3aGlsZShvLS0pYz1wW29dLCFpJiZnIT09Yy5vcmlnVHlwZXx8biYmbi5ndWlkIT09Yy5ndWlkfHxzJiYhcy50ZXN0KGMubmFtZXNwYWNlKXx8ciYmciE9PWMuc2VsZWN0b3ImJihcIioqXCIhPT1yfHwhYy5zZWxlY3Rvcil8fChwLnNwbGljZShvLDEpLGMuc2VsZWN0b3ImJnAuZGVsZWdhdGVDb3VudC0tLGYucmVtb3ZlJiZmLnJlbW92ZS5jYWxsKGUsYykpO2EmJiFwLmxlbmd0aCYmKGYudGVhcmRvd24mJiExIT09Zi50ZWFyZG93bi5jYWxsKGUsaCx2LmhhbmRsZSl8fGsucmVtb3ZlRXZlbnQoZSxkLHYuaGFuZGxlKSxkZWxldGUgdVtkXSl9ZWxzZSBmb3IoZCBpbiB1KWsuZXZlbnQucmVtb3ZlKGUsZCt0W2xdLG4sciwhMCk7ay5pc0VtcHR5T2JqZWN0KHUpJiZRLnJlbW92ZShlLFwiaGFuZGxlIGV2ZW50c1wiKX19LGRpc3BhdGNoOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLG8sYSxzPWsuZXZlbnQuZml4KGUpLHU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLGw9KFEuZ2V0KHRoaXMsXCJldmVudHNcIil8fHt9KVtzLnR5cGVdfHxbXSxjPWsuZXZlbnQuc3BlY2lhbFtzLnR5cGVdfHx7fTtmb3IodVswXT1zLHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXVbdF09YXJndW1lbnRzW3RdO2lmKHMuZGVsZWdhdGVUYXJnZXQ9dGhpcywhYy5wcmVEaXNwYXRjaHx8ITEhPT1jLnByZURpc3BhdGNoLmNhbGwodGhpcyxzKSl7YT1rLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyxzLGwpLHQ9MDt3aGlsZSgoaT1hW3QrK10pJiYhcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtzLmN1cnJlbnRUYXJnZXQ9aS5lbGVtLG49MDt3aGlsZSgobz1pLmhhbmRsZXJzW24rK10pJiYhcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKXMucm5hbWVzcGFjZSYmITEhPT1vLm5hbWVzcGFjZSYmIXMucm5hbWVzcGFjZS50ZXN0KG8ubmFtZXNwYWNlKXx8KHMuaGFuZGxlT2JqPW8scy5kYXRhPW8uZGF0YSx2b2lkIDAhPT0ocj0oKGsuZXZlbnQuc3BlY2lhbFtvLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8by5oYW5kbGVyKS5hcHBseShpLmVsZW0sdSkpJiYhMT09PShzLnJlc3VsdD1yKSYmKHMucHJldmVudERlZmF1bHQoKSxzLnN0b3BQcm9wYWdhdGlvbigpKSl9cmV0dXJuIGMucG9zdERpc3BhdGNoJiZjLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMscykscy5yZXN1bHR9fSxoYW5kbGVyczpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGEscz1bXSx1PXQuZGVsZWdhdGVDb3VudCxsPWUudGFyZ2V0O2lmKHUmJmwubm9kZVR5cGUmJiEoXCJjbGlja1wiPT09ZS50eXBlJiYxPD1lLmJ1dHRvbikpZm9yKDtsIT09dGhpcztsPWwucGFyZW50Tm9kZXx8dGhpcylpZigxPT09bC5ub2RlVHlwZSYmKFwiY2xpY2tcIiE9PWUudHlwZXx8ITAhPT1sLmRpc2FibGVkKSl7Zm9yKG89W10sYT17fSxuPTA7bjx1O24rKyl2b2lkIDA9PT1hW2k9KHI9dFtuXSkuc2VsZWN0b3IrXCIgXCJdJiYoYVtpXT1yLm5lZWRzQ29udGV4dD8tMTxrKGksdGhpcykuaW5kZXgobCk6ay5maW5kKGksdGhpcyxudWxsLFtsXSkubGVuZ3RoKSxhW2ldJiZvLnB1c2gocik7by5sZW5ndGgmJnMucHVzaCh7ZWxlbTpsLGhhbmRsZXJzOm99KX1yZXR1cm4gbD10aGlzLHU8dC5sZW5ndGgmJnMucHVzaCh7ZWxlbTpsLGhhbmRsZXJzOnQuc2xpY2UodSl9KSxzfSxhZGRQcm9wOmZ1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGsuRXZlbnQucHJvdG90eXBlLHQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDptKGUpP2Z1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiBlKHRoaXMub3JpZ2luYWxFdmVudCl9OmZ1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbdF19LHNldDpmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSl9fSl9LGZpeDpmdW5jdGlvbihlKXtyZXR1cm4gZVtrLmV4cGFuZG9dP2U6bmV3IGsuRXZlbnQoZSl9LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxjbGljazp7c2V0dXA6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpc3x8ZTtyZXR1cm4gcGUudGVzdCh0LnR5cGUpJiZ0LmNsaWNrJiZBKHQsXCJpbnB1dFwiKSYmRGUodCxcImNsaWNrXCIsa2UpLCExfSx0cmlnZ2VyOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXN8fGU7cmV0dXJuIHBlLnRlc3QodC50eXBlKSYmdC5jbGljayYmQSh0LFwiaW5wdXRcIikmJkRlKHQsXCJjbGlja1wiKSwhMH0sX2RlZmF1bHQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQ7cmV0dXJuIHBlLnRlc3QodC50eXBlKSYmdC5jbGljayYmQSh0LFwiaW5wdXRcIikmJlEuZ2V0KHQsXCJjbGlja1wiKXx8QSh0LFwiYVwiKX19LGJlZm9yZXVubG9hZDp7cG9zdERpc3BhdGNoOmZ1bmN0aW9uKGUpe3ZvaWQgMCE9PWUucmVzdWx0JiZlLm9yaWdpbmFsRXZlbnQmJihlLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9ZS5yZXN1bHQpfX19fSxrLnJlbW92ZUV2ZW50PWZ1bmN0aW9uKGUsdCxuKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXImJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LG4pfSxrLkV2ZW50PWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2Ygay5FdmVudCkpcmV0dXJuIG5ldyBrLkV2ZW50KGUsdCk7ZSYmZS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9ZSx0aGlzLnR5cGU9ZS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWUuZGVmYXVsdFByZXZlbnRlZHx8dm9pZCAwPT09ZS5kZWZhdWx0UHJldmVudGVkJiYhMT09PWUucmV0dXJuVmFsdWU/a2U6U2UsdGhpcy50YXJnZXQ9ZS50YXJnZXQmJjM9PT1lLnRhcmdldC5ub2RlVHlwZT9lLnRhcmdldC5wYXJlbnROb2RlOmUudGFyZ2V0LHRoaXMuY3VycmVudFRhcmdldD1lLmN1cnJlbnRUYXJnZXQsdGhpcy5yZWxhdGVkVGFyZ2V0PWUucmVsYXRlZFRhcmdldCk6dGhpcy50eXBlPWUsdCYmay5leHRlbmQodGhpcyx0KSx0aGlzLnRpbWVTdGFtcD1lJiZlLnRpbWVTdGFtcHx8RGF0ZS5ub3coKSx0aGlzW2suZXhwYW5kb109ITB9LGsuRXZlbnQucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjprLkV2ZW50LGlzRGVmYXVsdFByZXZlbnRlZDpTZSxpc1Byb3BhZ2F0aW9uU3RvcHBlZDpTZSxpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpTZSxpc1NpbXVsYXRlZDohMSxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1rZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5wcmV2ZW50RGVmYXVsdCgpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1rZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5zdG9wUHJvcGFnYXRpb24oKX0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9a2UsZSYmIXRoaXMuaXNTaW11bGF0ZWQmJmUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdGhpcy5zdG9wUHJvcGFnYXRpb24oKX19LGsuZWFjaCh7YWx0S2V5OiEwLGJ1YmJsZXM6ITAsY2FuY2VsYWJsZTohMCxjaGFuZ2VkVG91Y2hlczohMCxjdHJsS2V5OiEwLGRldGFpbDohMCxldmVudFBoYXNlOiEwLG1ldGFLZXk6ITAscGFnZVg6ITAscGFnZVk6ITAsc2hpZnRLZXk6ITAsdmlldzohMCxcImNoYXJcIjohMCxjb2RlOiEwLGNoYXJDb2RlOiEwLGtleTohMCxrZXlDb2RlOiEwLGJ1dHRvbjohMCxidXR0b25zOiEwLGNsaWVudFg6ITAsY2xpZW50WTohMCxvZmZzZXRYOiEwLG9mZnNldFk6ITAscG9pbnRlcklkOiEwLHBvaW50ZXJUeXBlOiEwLHNjcmVlblg6ITAsc2NyZWVuWTohMCx0YXJnZXRUb3VjaGVzOiEwLHRvRWxlbWVudDohMCx0b3VjaGVzOiEwLHdoaWNoOmZ1bmN0aW9uKGUpe3ZhciB0PWUuYnV0dG9uO3JldHVybiBudWxsPT1lLndoaWNoJiZUZS50ZXN0KGUudHlwZSk/bnVsbCE9ZS5jaGFyQ29kZT9lLmNoYXJDb2RlOmUua2V5Q29kZTohZS53aGljaCYmdm9pZCAwIT09dCYmQ2UudGVzdChlLnR5cGUpPzEmdD8xOjImdD8zOjQmdD8yOjA6ZS53aGljaH19LGsuZXZlbnQuYWRkUHJvcCksay5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24oZSx0KXtrLmV2ZW50LnNwZWNpYWxbZV09e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIERlKHRoaXMsZSxOZSksITF9LHRyaWdnZXI6ZnVuY3Rpb24oKXtyZXR1cm4gRGUodGhpcyxlKSwhMH0sZGVsZWdhdGVUeXBlOnR9fSksay5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIscG9pbnRlcmVudGVyOlwicG9pbnRlcm92ZXJcIixwb2ludGVybGVhdmU6XCJwb2ludGVyb3V0XCJ9LGZ1bmN0aW9uKGUsaSl7ay5ldmVudC5zcGVjaWFsW2VdPXtkZWxlZ2F0ZVR5cGU6aSxiaW5kVHlwZTppLGhhbmRsZTpmdW5jdGlvbihlKXt2YXIgdCxuPWUucmVsYXRlZFRhcmdldCxyPWUuaGFuZGxlT2JqO3JldHVybiBuJiYobj09PXRoaXN8fGsuY29udGFpbnModGhpcyxuKSl8fChlLnR5cGU9ci5vcmlnVHlwZSx0PXIuaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyksZS50eXBlPWkpLHR9fX0pLGsuZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gQWUodGhpcyxlLHQsbixyKX0sb25lOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBBZSh0aGlzLGUsdCxuLHIsMSl9LG9mZjpmdW5jdGlvbihlLHQsbil7dmFyIHIsaTtpZihlJiZlLnByZXZlbnREZWZhdWx0JiZlLmhhbmRsZU9iailyZXR1cm4gcj1lLmhhbmRsZU9iaixrKGUuZGVsZWdhdGVUYXJnZXQpLm9mZihyLm5hbWVzcGFjZT9yLm9yaWdUeXBlK1wiLlwiK3IubmFtZXNwYWNlOnIub3JpZ1R5cGUsci5zZWxlY3RvcixyLmhhbmRsZXIpLHRoaXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe2ZvcihpIGluIGUpdGhpcy5vZmYoaSx0LGVbaV0pO3JldHVybiB0aGlzfXJldHVybiExIT09dCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdHx8KG49dCx0PXZvaWQgMCksITE9PT1uJiYobj1TZSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7ay5ldmVudC5yZW1vdmUodGhpcyxlLG4sdCl9KX19KTt2YXIgamU9LzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2kscWU9LzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksTGU9L2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxIZT0vXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7ZnVuY3Rpb24gT2UoZSx0KXtyZXR1cm4gQShlLFwidGFibGVcIikmJkEoMTEhPT10Lm5vZGVUeXBlP3Q6dC5maXJzdENoaWxkLFwidHJcIikmJmsoZSkuY2hpbGRyZW4oXCJ0Ym9keVwiKVswXXx8ZX1mdW5jdGlvbiBQZShlKXtyZXR1cm4gZS50eXBlPShudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKStcIi9cIitlLnR5cGUsZX1mdW5jdGlvbiBSZShlKXtyZXR1cm5cInRydWUvXCI9PT0oZS50eXBlfHxcIlwiKS5zbGljZSgwLDUpP2UudHlwZT1lLnR5cGUuc2xpY2UoNSk6ZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLGV9ZnVuY3Rpb24gTWUoZSx0KXt2YXIgbixyLGksbyxhLHMsdSxsO2lmKDE9PT10Lm5vZGVUeXBlKXtpZihRLmhhc0RhdGEoZSkmJihvPVEuYWNjZXNzKGUpLGE9US5zZXQodCxvKSxsPW8uZXZlbnRzKSlmb3IoaSBpbiBkZWxldGUgYS5oYW5kbGUsYS5ldmVudHM9e30sbClmb3Iobj0wLHI9bFtpXS5sZW5ndGg7bjxyO24rKylrLmV2ZW50LmFkZCh0LGksbFtpXVtuXSk7Si5oYXNEYXRhKGUpJiYocz1KLmFjY2VzcyhlKSx1PWsuZXh0ZW5kKHt9LHMpLEouc2V0KHQsdSkpfX1mdW5jdGlvbiBJZShuLHIsaSxvKXtyPWcuYXBwbHkoW10scik7dmFyIGUsdCxhLHMsdSxsLGM9MCxmPW4ubGVuZ3RoLHA9Zi0xLGQ9clswXSxoPW0oZCk7aWYoaHx8MTxmJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmIXkuY2hlY2tDbG9uZSYmTGUudGVzdChkKSlyZXR1cm4gbi5lYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW4uZXEoZSk7aCYmKHJbMF09ZC5jYWxsKHRoaXMsZSx0Lmh0bWwoKSkpLEllKHQscixpLG8pfSk7aWYoZiYmKHQ9KGU9d2UocixuWzBdLm93bmVyRG9jdW1lbnQsITEsbixvKSkuZmlyc3RDaGlsZCwxPT09ZS5jaGlsZE5vZGVzLmxlbmd0aCYmKGU9dCksdHx8bykpe2ZvcihzPShhPWsubWFwKHZlKGUsXCJzY3JpcHRcIiksUGUpKS5sZW5ndGg7YzxmO2MrKyl1PWUsYyE9PXAmJih1PWsuY2xvbmUodSwhMCwhMCkscyYmay5tZXJnZShhLHZlKHUsXCJzY3JpcHRcIikpKSxpLmNhbGwobltjXSx1LGMpO2lmKHMpZm9yKGw9YVthLmxlbmd0aC0xXS5vd25lckRvY3VtZW50LGsubWFwKGEsUmUpLGM9MDtjPHM7YysrKXU9YVtjXSxoZS50ZXN0KHUudHlwZXx8XCJcIikmJiFRLmFjY2Vzcyh1LFwiZ2xvYmFsRXZhbFwiKSYmay5jb250YWlucyhsLHUpJiYodS5zcmMmJlwibW9kdWxlXCIhPT0odS50eXBlfHxcIlwiKS50b0xvd2VyQ2FzZSgpP2suX2V2YWxVcmwmJiF1Lm5vTW9kdWxlJiZrLl9ldmFsVXJsKHUuc3JjLHtub25jZTp1Lm5vbmNlfHx1LmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpfSk6Yih1LnRleHRDb250ZW50LnJlcGxhY2UoSGUsXCJcIiksdSxsKSl9cmV0dXJuIG59ZnVuY3Rpb24gV2UoZSx0LG4pe2Zvcih2YXIgcixpPXQ/ay5maWx0ZXIodCxlKTplLG89MDtudWxsIT0ocj1pW29dKTtvKyspbnx8MSE9PXIubm9kZVR5cGV8fGsuY2xlYW5EYXRhKHZlKHIpKSxyLnBhcmVudE5vZGUmJihuJiZvZShyKSYmeWUodmUocixcInNjcmlwdFwiKSksci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIpKTtyZXR1cm4gZX1rLmV4dGVuZCh7aHRtbFByZWZpbHRlcjpmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKGplLFwiPCQxPjwvJDI+XCIpfSxjbG9uZTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGwsYz1lLmNsb25lTm9kZSghMCksZj1vZShlKTtpZighKHkubm9DbG9uZUNoZWNrZWR8fDEhPT1lLm5vZGVUeXBlJiYxMSE9PWUubm9kZVR5cGV8fGsuaXNYTUxEb2MoZSkpKWZvcihhPXZlKGMpLHI9MCxpPShvPXZlKGUpKS5sZW5ndGg7cjxpO3IrKylzPW9bcl0sdT1hW3JdLHZvaWQgMCxcImlucHV0XCI9PT0obD11Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpJiZwZS50ZXN0KHMudHlwZSk/dS5jaGVja2VkPXMuY2hlY2tlZDpcImlucHV0XCIhPT1sJiZcInRleHRhcmVhXCIhPT1sfHwodS5kZWZhdWx0VmFsdWU9cy5kZWZhdWx0VmFsdWUpO2lmKHQpaWYobilmb3Iobz1vfHx2ZShlKSxhPWF8fHZlKGMpLHI9MCxpPW8ubGVuZ3RoO3I8aTtyKyspTWUob1tyXSxhW3JdKTtlbHNlIE1lKGUsYyk7cmV0dXJuIDA8KGE9dmUoYyxcInNjcmlwdFwiKSkubGVuZ3RoJiZ5ZShhLCFmJiZ2ZShlLFwic2NyaXB0XCIpKSxjfSxjbGVhbkRhdGE6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG4scixpPWsuZXZlbnQuc3BlY2lhbCxvPTA7dm9pZCAwIT09KG49ZVtvXSk7bysrKWlmKEcobikpe2lmKHQ9bltRLmV4cGFuZG9dKXtpZih0LmV2ZW50cylmb3IociBpbiB0LmV2ZW50cylpW3JdP2suZXZlbnQucmVtb3ZlKG4scik6ay5yZW1vdmVFdmVudChuLHIsdC5oYW5kbGUpO25bUS5leHBhbmRvXT12b2lkIDB9bltKLmV4cGFuZG9dJiYobltKLmV4cGFuZG9dPXZvaWQgMCl9fX0pLGsuZm4uZXh0ZW5kKHtkZXRhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIFdlKHRoaXMsZSwhMCl9LHJlbW92ZTpmdW5jdGlvbihlKXtyZXR1cm4gV2UodGhpcyxlKX0sdGV4dDpmdW5jdGlvbihlKXtyZXR1cm4gXyh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lP2sudGV4dCh0aGlzKTp0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpezEhPT10aGlzLm5vZGVUeXBlJiYxMSE9PXRoaXMubm9kZVR5cGUmJjkhPT10aGlzLm5vZGVUeXBlfHwodGhpcy50ZXh0Q29udGVudD1lKX0pfSxudWxsLGUsYXJndW1lbnRzLmxlbmd0aCl9LGFwcGVuZDpmdW5jdGlvbigpe3JldHVybiBJZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXsxIT09dGhpcy5ub2RlVHlwZSYmMTEhPT10aGlzLm5vZGVUeXBlJiY5IT09dGhpcy5ub2RlVHlwZXx8T2UodGhpcyxlKS5hcHBlbmRDaGlsZChlKX0pfSxwcmVwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEllKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgdD1PZSh0aGlzLGUpO3QuaW5zZXJ0QmVmb3JlKGUsdC5maXJzdENoaWxkKX19KX0sYmVmb3JlOmZ1bmN0aW9uKCl7cmV0dXJuIEllKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHRoaXMpfSl9LGFmdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIEllKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHRoaXMubmV4dFNpYmxpbmcpfSl9LGVtcHR5OmZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQ9MDtudWxsIT0oZT10aGlzW3RdKTt0KyspMT09PWUubm9kZVR5cGUmJihrLmNsZWFuRGF0YSh2ZShlLCExKSksZS50ZXh0Q29udGVudD1cIlwiKTtyZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1udWxsIT1lJiZlLHQ9bnVsbD09dD9lOnQsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gay5jbG9uZSh0aGlzLGUsdCl9KX0saHRtbDpmdW5jdGlvbihlKXtyZXR1cm4gXyh0aGlzLGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXNbMF18fHt9LG49MCxyPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWUmJjE9PT10Lm5vZGVUeXBlKXJldHVybiB0LmlubmVySFRNTDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmIXFlLnRlc3QoZSkmJiFnZVsoZGUuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKXtlPWsuaHRtbFByZWZpbHRlcihlKTt0cnl7Zm9yKDtuPHI7bisrKTE9PT0odD10aGlzW25dfHx7fSkubm9kZVR5cGUmJihrLmNsZWFuRGF0YSh2ZSh0LCExKSksdC5pbm5lckhUTUw9ZSk7dD0wfWNhdGNoKGUpe319dCYmdGhpcy5lbXB0eSgpLmFwcGVuZChlKX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbigpe3ZhciBuPVtdO3JldHVybiBJZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXt2YXIgdD10aGlzLnBhcmVudE5vZGU7ay5pbkFycmF5KHRoaXMsbik8MCYmKGsuY2xlYW5EYXRhKHZlKHRoaXMpKSx0JiZ0LnJlcGxhY2VDaGlsZChlLHRoaXMpKX0sbil9fSksay5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGUsYSl7ay5mbltlXT1mdW5jdGlvbihlKXtmb3IodmFyIHQsbj1bXSxyPWsoZSksaT1yLmxlbmd0aC0xLG89MDtvPD1pO28rKyl0PW89PT1pP3RoaXM6dGhpcy5jbG9uZSghMCksayhyW29dKVthXSh0KSx1LmFwcGx5KG4sdC5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG4pfX0pO3ZhciAkZT1uZXcgUmVnRXhwKFwiXihcIit0ZStcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSxGZT1mdW5jdGlvbihlKXt2YXIgdD1lLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7cmV0dXJuIHQmJnQub3BlbmVyfHwodD1DKSx0LmdldENvbXB1dGVkU3R5bGUoZSl9LEJlPW5ldyBSZWdFeHAocmUuam9pbihcInxcIiksXCJpXCIpO2Z1bmN0aW9uIF9lKGUsdCxuKXt2YXIgcixpLG8sYSxzPWUuc3R5bGU7cmV0dXJuKG49bnx8RmUoZSkpJiYoXCJcIiE9PShhPW4uZ2V0UHJvcGVydHlWYWx1ZSh0KXx8blt0XSl8fG9lKGUpfHwoYT1rLnN0eWxlKGUsdCkpLCF5LnBpeGVsQm94U3R5bGVzKCkmJiRlLnRlc3QoYSkmJkJlLnRlc3QodCkmJihyPXMud2lkdGgsaT1zLm1pbldpZHRoLG89cy5tYXhXaWR0aCxzLm1pbldpZHRoPXMubWF4V2lkdGg9cy53aWR0aD1hLGE9bi53aWR0aCxzLndpZHRoPXIscy5taW5XaWR0aD1pLHMubWF4V2lkdGg9bykpLHZvaWQgMCE9PWE/YStcIlwiOmF9ZnVuY3Rpb24gemUoZSx0KXtyZXR1cm57Z2V0OmZ1bmN0aW9uKCl7aWYoIWUoKSlyZXR1cm4odGhpcy5nZXQ9dCkuYXBwbHkodGhpcyxhcmd1bWVudHMpO2RlbGV0ZSB0aGlzLmdldH19fSFmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtpZih1KXtzLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7bWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCIsdS5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO21hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NjAlO3RvcDoxJVwiLGllLmFwcGVuZENoaWxkKHMpLmFwcGVuZENoaWxkKHUpO3ZhciBlPUMuZ2V0Q29tcHV0ZWRTdHlsZSh1KTtuPVwiMSVcIiE9PWUudG9wLGE9MTI9PT10KGUubWFyZ2luTGVmdCksdS5zdHlsZS5yaWdodD1cIjYwJVwiLG89MzY9PT10KGUucmlnaHQpLHI9MzY9PT10KGUud2lkdGgpLHUuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGk9MTI9PT10KHUub2Zmc2V0V2lkdGgvMyksaWUucmVtb3ZlQ2hpbGQocyksdT1udWxsfX1mdW5jdGlvbiB0KGUpe3JldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZSkpfXZhciBuLHIsaSxvLGEscz1FLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdT1FLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dS5zdHlsZSYmKHUuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJjb250ZW50LWJveFwiLHUuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cIlwiLHkuY2xlYXJDbG9uZVN0eWxlPVwiY29udGVudC1ib3hcIj09PXUuc3R5bGUuYmFja2dyb3VuZENsaXAsay5leHRlbmQoeSx7Ym94U2l6aW5nUmVsaWFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLHJ9LHBpeGVsQm94U3R5bGVzOmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxvfSxwaXhlbFBvc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxufSxyZWxpYWJsZU1hcmdpbkxlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLGF9LHNjcm9sbGJveFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLGl9fSkpfSgpO3ZhciBVZT1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl0sWGU9RS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFZlPXt9O2Z1bmN0aW9uIEdlKGUpe3ZhciB0PWsuY3NzUHJvcHNbZV18fFZlW2VdO3JldHVybiB0fHwoZSBpbiBYZT9lOlZlW2VdPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0udG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLG49VWUubGVuZ3RoO3doaWxlKG4tLSlpZigoZT1VZVtuXSt0KWluIFhlKXJldHVybiBlfShlKXx8ZSl9dmFyIFllPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxRZT0vXi0tLyxKZT17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sS2U9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifTtmdW5jdGlvbiBaZShlLHQsbil7dmFyIHI9bmUuZXhlYyh0KTtyZXR1cm4gcj9NYXRoLm1heCgwLHJbMl0tKG58fDApKSsoclszXXx8XCJweFwiKTp0fWZ1bmN0aW9uIGV0KGUsdCxuLHIsaSxvKXt2YXIgYT1cIndpZHRoXCI9PT10PzE6MCxzPTAsdT0wO2lmKG49PT0ocj9cImJvcmRlclwiOlwiY29udGVudFwiKSlyZXR1cm4gMDtmb3IoO2E8NDthKz0yKVwibWFyZ2luXCI9PT1uJiYodSs9ay5jc3MoZSxuK3JlW2FdLCEwLGkpKSxyPyhcImNvbnRlbnRcIj09PW4mJih1LT1rLmNzcyhlLFwicGFkZGluZ1wiK3JlW2FdLCEwLGkpKSxcIm1hcmdpblwiIT09biYmKHUtPWsuY3NzKGUsXCJib3JkZXJcIityZVthXStcIldpZHRoXCIsITAsaSkpKToodSs9ay5jc3MoZSxcInBhZGRpbmdcIityZVthXSwhMCxpKSxcInBhZGRpbmdcIiE9PW4/dSs9ay5jc3MoZSxcImJvcmRlclwiK3JlW2FdK1wiV2lkdGhcIiwhMCxpKTpzKz1rLmNzcyhlLFwiYm9yZGVyXCIrcmVbYV0rXCJXaWR0aFwiLCEwLGkpKTtyZXR1cm4hciYmMDw9byYmKHUrPU1hdGgubWF4KDAsTWF0aC5jZWlsKGVbXCJvZmZzZXRcIit0WzBdLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKV0tby11LXMtLjUpKXx8MCksdX1mdW5jdGlvbiB0dChlLHQsbil7dmFyIHI9RmUoZSksaT0oIXkuYm94U2l6aW5nUmVsaWFibGUoKXx8bikmJlwiYm9yZGVyLWJveFwiPT09ay5jc3MoZSxcImJveFNpemluZ1wiLCExLHIpLG89aSxhPV9lKGUsdCxyKSxzPVwib2Zmc2V0XCIrdFswXS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSk7aWYoJGUudGVzdChhKSl7aWYoIW4pcmV0dXJuIGE7YT1cImF1dG9cIn1yZXR1cm4oIXkuYm94U2l6aW5nUmVsaWFibGUoKSYmaXx8XCJhdXRvXCI9PT1hfHwhcGFyc2VGbG9hdChhKSYmXCJpbmxpbmVcIj09PWsuY3NzKGUsXCJkaXNwbGF5XCIsITEscikpJiZlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoJiYoaT1cImJvcmRlci1ib3hcIj09PWsuY3NzKGUsXCJib3hTaXppbmdcIiwhMSxyKSwobz1zIGluIGUpJiYoYT1lW3NdKSksKGE9cGFyc2VGbG9hdChhKXx8MCkrZXQoZSx0LG58fChpP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpLG8scixhKStcInB4XCJ9ZnVuY3Rpb24gbnQoZSx0LG4scixpKXtyZXR1cm4gbmV3IG50LnByb3RvdHlwZS5pbml0KGUsdCxuLHIsaSl9ay5leHRlbmQoe2Nzc0hvb2tzOntvcGFjaXR5OntnZXQ6ZnVuY3Rpb24oZSx0KXtpZih0KXt2YXIgbj1fZShlLFwib3BhY2l0eVwiKTtyZXR1cm5cIlwiPT09bj9cIjFcIjpufX19fSxjc3NOdW1iZXI6e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGNvbHVtbkNvdW50OiEwLGZpbGxPcGFjaXR5OiEwLGZsZXhHcm93OiEwLGZsZXhTaHJpbms6ITAsZm9udFdlaWdodDohMCxncmlkQXJlYTohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGdyaWRSb3c6ITAsZ3JpZFJvd0VuZDohMCxncmlkUm93U3RhcnQ6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwfSxjc3NQcm9wczp7fSxzdHlsZTpmdW5jdGlvbihlLHQsbixyKXtpZihlJiYzIT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJmUuc3R5bGUpe3ZhciBpLG8sYSxzPVYodCksdT1RZS50ZXN0KHQpLGw9ZS5zdHlsZTtpZih1fHwodD1HZShzKSksYT1rLmNzc0hvb2tzW3RdfHxrLmNzc0hvb2tzW3NdLHZvaWQgMD09PW4pcmV0dXJuIGEmJlwiZ2V0XCJpbiBhJiZ2b2lkIDAhPT0oaT1hLmdldChlLCExLHIpKT9pOmxbdF07XCJzdHJpbmdcIj09PShvPXR5cGVvZiBuKSYmKGk9bmUuZXhlYyhuKSkmJmlbMV0mJihuPWxlKGUsdCxpKSxvPVwibnVtYmVyXCIpLG51bGwhPW4mJm49PW4mJihcIm51bWJlclwiIT09b3x8dXx8KG4rPWkmJmlbM118fChrLmNzc051bWJlcltzXT9cIlwiOlwicHhcIikpLHkuY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09bnx8MCE9PXQuaW5kZXhPZihcImJhY2tncm91bmRcIil8fChsW3RdPVwiaW5oZXJpdFwiKSxhJiZcInNldFwiaW4gYSYmdm9pZCAwPT09KG49YS5zZXQoZSxuLHIpKXx8KHU/bC5zZXRQcm9wZXJ0eSh0LG4pOmxbdF09bikpfX0sY3NzOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzPVYodCk7cmV0dXJuIFFlLnRlc3QodCl8fCh0PUdlKHMpKSwoYT1rLmNzc0hvb2tzW3RdfHxrLmNzc0hvb2tzW3NdKSYmXCJnZXRcImluIGEmJihpPWEuZ2V0KGUsITAsbikpLHZvaWQgMD09PWkmJihpPV9lKGUsdCxyKSksXCJub3JtYWxcIj09PWkmJnQgaW4gS2UmJihpPUtlW3RdKSxcIlwiPT09bnx8bj8obz1wYXJzZUZsb2F0KGkpLCEwPT09bnx8aXNGaW5pdGUobyk/b3x8MDppKTppfX0pLGsuZWFjaChbXCJoZWlnaHRcIixcIndpZHRoXCJdLGZ1bmN0aW9uKGUsdSl7ay5jc3NIb29rc1t1XT17Z2V0OmZ1bmN0aW9uKGUsdCxuKXtpZih0KXJldHVybiFZZS50ZXN0KGsuY3NzKGUsXCJkaXNwbGF5XCIpKXx8ZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCYmZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aD90dChlLHUsbik6dWUoZSxKZSxmdW5jdGlvbigpe3JldHVybiB0dChlLHUsbil9KX0sc2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpPUZlKGUpLG89IXkuc2Nyb2xsYm94U2l6ZSgpJiZcImFic29sdXRlXCI9PT1pLnBvc2l0aW9uLGE9KG98fG4pJiZcImJvcmRlci1ib3hcIj09PWsuY3NzKGUsXCJib3hTaXppbmdcIiwhMSxpKSxzPW4/ZXQoZSx1LG4sYSxpKTowO3JldHVybiBhJiZvJiYocy09TWF0aC5jZWlsKGVbXCJvZmZzZXRcIit1WzBdLnRvVXBwZXJDYXNlKCkrdS5zbGljZSgxKV0tcGFyc2VGbG9hdChpW3VdKS1ldChlLHUsXCJib3JkZXJcIiwhMSxpKS0uNSkpLHMmJihyPW5lLmV4ZWModCkpJiZcInB4XCIhPT0oclszXXx8XCJweFwiKSYmKGUuc3R5bGVbdV09dCx0PWsuY3NzKGUsdSkpLFplKDAsdCxzKX19fSksay5jc3NIb29rcy5tYXJnaW5MZWZ0PXplKHkucmVsaWFibGVNYXJnaW5MZWZ0LGZ1bmN0aW9uKGUsdCl7aWYodClyZXR1cm4ocGFyc2VGbG9hdChfZShlLFwibWFyZ2luTGVmdFwiKSl8fGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdC11ZShlLHttYXJnaW5MZWZ0OjB9LGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdH0pKStcInB4XCJ9KSxrLmVhY2goe21hcmdpbjpcIlwiLHBhZGRpbmc6XCJcIixib3JkZXI6XCJXaWR0aFwifSxmdW5jdGlvbihpLG8pe2suY3NzSG9va3NbaStvXT17ZXhwYW5kOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49e30scj1cInN0cmluZ1wiPT10eXBlb2YgZT9lLnNwbGl0KFwiIFwiKTpbZV07dDw0O3QrKyluW2krcmVbdF0rb109clt0XXx8clt0LTJdfHxyWzBdO3JldHVybiBufX0sXCJtYXJnaW5cIiE9PWkmJihrLmNzc0hvb2tzW2krb10uc2V0PVplKX0pLGsuZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gXyh0aGlzLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89e30sYT0wO2lmKEFycmF5LmlzQXJyYXkodCkpe2ZvcihyPUZlKGUpLGk9dC5sZW5ndGg7YTxpO2ErKylvW3RbYV1dPWsuY3NzKGUsdFthXSwhMSxyKTtyZXR1cm4gb31yZXR1cm4gdm9pZCAwIT09bj9rLnN0eWxlKGUsdCxuKTprLmNzcyhlLHQpfSxlLHQsMTxhcmd1bWVudHMubGVuZ3RoKX19KSwoKGsuVHdlZW49bnQpLnByb3RvdHlwZT17Y29uc3RydWN0b3I6bnQsaW5pdDpmdW5jdGlvbihlLHQsbixyLGksbyl7dGhpcy5lbGVtPWUsdGhpcy5wcm9wPW4sdGhpcy5lYXNpbmc9aXx8ay5lYXNpbmcuX2RlZmF1bHQsdGhpcy5vcHRpb25zPXQsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPXIsdGhpcy51bml0PW98fChrLmNzc051bWJlcltuXT9cIlwiOlwicHhcIil9LGN1cjpmdW5jdGlvbigpe3ZhciBlPW50LnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBlJiZlLmdldD9lLmdldCh0aGlzKTpudC5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpfSxydW46ZnVuY3Rpb24oZSl7dmFyIHQsbj1udC5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5vcHRpb25zLmR1cmF0aW9uP3RoaXMucG9zPXQ9ay5lYXNpbmdbdGhpcy5lYXNpbmddKGUsdGhpcy5vcHRpb25zLmR1cmF0aW9uKmUsMCwxLHRoaXMub3B0aW9ucy5kdXJhdGlvbik6dGhpcy5wb3M9dD1lLHRoaXMubm93PSh0aGlzLmVuZC10aGlzLnN0YXJ0KSp0K3RoaXMuc3RhcnQsdGhpcy5vcHRpb25zLnN0ZXAmJnRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLHRoaXMubm93LHRoaXMpLG4mJm4uc2V0P24uc2V0KHRoaXMpOm50LnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyksdGhpc319KS5pbml0LnByb3RvdHlwZT1udC5wcm90b3R5cGUsKG50LnByb3BIb29rcz17X2RlZmF1bHQ6e2dldDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gMSE9PWUuZWxlbS5ub2RlVHlwZXx8bnVsbCE9ZS5lbGVtW2UucHJvcF0mJm51bGw9PWUuZWxlbS5zdHlsZVtlLnByb3BdP2UuZWxlbVtlLnByb3BdOih0PWsuY3NzKGUuZWxlbSxlLnByb3AsXCJcIikpJiZcImF1dG9cIiE9PXQ/dDowfSxzZXQ6ZnVuY3Rpb24oZSl7ay5meC5zdGVwW2UucHJvcF0/ay5meC5zdGVwW2UucHJvcF0oZSk6MSE9PWUuZWxlbS5ub2RlVHlwZXx8IWsuY3NzSG9va3NbZS5wcm9wXSYmbnVsbD09ZS5lbGVtLnN0eWxlW0dlKGUucHJvcCldP2UuZWxlbVtlLnByb3BdPWUubm93Omsuc3R5bGUoZS5lbGVtLGUucHJvcCxlLm5vdytlLnVuaXQpfX19KS5zY3JvbGxUb3A9bnQucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihlKXtlLmVsZW0ubm9kZVR5cGUmJmUuZWxlbS5wYXJlbnROb2RlJiYoZS5lbGVtW2UucHJvcF09ZS5ub3cpfX0say5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihlKXtyZXR1cm4gZX0sc3dpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuLjUtTWF0aC5jb3MoZSpNYXRoLlBJKS8yfSxfZGVmYXVsdDpcInN3aW5nXCJ9LGsuZng9bnQucHJvdG90eXBlLmluaXQsay5meC5zdGVwPXt9O3ZhciBydCxpdCxvdCxhdCxzdD0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sdXQ9L3F1ZXVlSG9va3MkLztmdW5jdGlvbiBsdCgpe2l0JiYoITE9PT1FLmhpZGRlbiYmQy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/Qy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobHQpOkMuc2V0VGltZW91dChsdCxrLmZ4LmludGVydmFsKSxrLmZ4LnRpY2soKSl9ZnVuY3Rpb24gY3QoKXtyZXR1cm4gQy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cnQ9dm9pZCAwfSkscnQ9RGF0ZS5ub3coKX1mdW5jdGlvbiBmdChlLHQpe3ZhciBuLHI9MCxpPXtoZWlnaHQ6ZX07Zm9yKHQ9dD8xOjA7cjw0O3IrPTItdClpW1wibWFyZ2luXCIrKG49cmVbcl0pXT1pW1wicGFkZGluZ1wiK25dPWU7cmV0dXJuIHQmJihpLm9wYWNpdHk9aS53aWR0aD1lKSxpfWZ1bmN0aW9uIHB0KGUsdCxuKXtmb3IodmFyIHIsaT0oZHQudHdlZW5lcnNbdF18fFtdKS5jb25jYXQoZHQudHdlZW5lcnNbXCIqXCJdKSxvPTAsYT1pLmxlbmd0aDtvPGE7bysrKWlmKHI9aVtvXS5jYWxsKG4sdCxlKSlyZXR1cm4gcn1mdW5jdGlvbiBkdChvLGUsdCl7dmFyIG4sYSxyPTAsaT1kdC5wcmVmaWx0ZXJzLmxlbmd0aCxzPWsuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24oKXtkZWxldGUgdS5lbGVtfSksdT1mdW5jdGlvbigpe2lmKGEpcmV0dXJuITE7Zm9yKHZhciBlPXJ0fHxjdCgpLHQ9TWF0aC5tYXgoMCxsLnN0YXJ0VGltZStsLmR1cmF0aW9uLWUpLG49MS0odC9sLmR1cmF0aW9ufHwwKSxyPTAsaT1sLnR3ZWVucy5sZW5ndGg7cjxpO3IrKylsLnR3ZWVuc1tyXS5ydW4obik7cmV0dXJuIHMubm90aWZ5V2l0aChvLFtsLG4sdF0pLG48MSYmaT90OihpfHxzLm5vdGlmeVdpdGgobyxbbCwxLDBdKSxzLnJlc29sdmVXaXRoKG8sW2xdKSwhMSl9LGw9cy5wcm9taXNlKHtlbGVtOm8scHJvcHM6ay5leHRlbmQoe30sZSksb3B0czprLmV4dGVuZCghMCx7c3BlY2lhbEVhc2luZzp7fSxlYXNpbmc6ay5lYXNpbmcuX2RlZmF1bHR9LHQpLG9yaWdpbmFsUHJvcGVydGllczplLG9yaWdpbmFsT3B0aW9uczp0LHN0YXJ0VGltZTpydHx8Y3QoKSxkdXJhdGlvbjp0LmR1cmF0aW9uLHR3ZWVuczpbXSxjcmVhdGVUd2VlbjpmdW5jdGlvbihlLHQpe3ZhciBuPWsuVHdlZW4obyxsLm9wdHMsZSx0LGwub3B0cy5zcGVjaWFsRWFzaW5nW2VdfHxsLm9wdHMuZWFzaW5nKTtyZXR1cm4gbC50d2VlbnMucHVzaChuKSxufSxzdG9wOmZ1bmN0aW9uKGUpe3ZhciB0PTAsbj1lP2wudHdlZW5zLmxlbmd0aDowO2lmKGEpcmV0dXJuIHRoaXM7Zm9yKGE9ITA7dDxuO3QrKylsLnR3ZWVuc1t0XS5ydW4oMSk7cmV0dXJuIGU/KHMubm90aWZ5V2l0aChvLFtsLDEsMF0pLHMucmVzb2x2ZVdpdGgobyxbbCxlXSkpOnMucmVqZWN0V2l0aChvLFtsLGVdKSx0aGlzfX0pLGM9bC5wcm9wcztmb3IoIWZ1bmN0aW9uKGUsdCl7dmFyIG4scixpLG8sYTtmb3IobiBpbiBlKWlmKGk9dFtyPVYobildLG89ZVtuXSxBcnJheS5pc0FycmF5KG8pJiYoaT1vWzFdLG89ZVtuXT1vWzBdKSxuIT09ciYmKGVbcl09byxkZWxldGUgZVtuXSksKGE9ay5jc3NIb29rc1tyXSkmJlwiZXhwYW5kXCJpbiBhKWZvcihuIGluIG89YS5leHBhbmQobyksZGVsZXRlIGVbcl0sbyluIGluIGV8fChlW25dPW9bbl0sdFtuXT1pKTtlbHNlIHRbcl09aX0oYyxsLm9wdHMuc3BlY2lhbEVhc2luZyk7cjxpO3IrKylpZihuPWR0LnByZWZpbHRlcnNbcl0uY2FsbChsLG8sYyxsLm9wdHMpKXJldHVybiBtKG4uc3RvcCkmJihrLl9xdWV1ZUhvb2tzKGwuZWxlbSxsLm9wdHMucXVldWUpLnN0b3A9bi5zdG9wLmJpbmQobikpLG47cmV0dXJuIGsubWFwKGMscHQsbCksbShsLm9wdHMuc3RhcnQpJiZsLm9wdHMuc3RhcnQuY2FsbChvLGwpLGwucHJvZ3Jlc3MobC5vcHRzLnByb2dyZXNzKS5kb25lKGwub3B0cy5kb25lLGwub3B0cy5jb21wbGV0ZSkuZmFpbChsLm9wdHMuZmFpbCkuYWx3YXlzKGwub3B0cy5hbHdheXMpLGsuZngudGltZXIoay5leHRlbmQodSx7ZWxlbTpvLGFuaW06bCxxdWV1ZTpsLm9wdHMucXVldWV9KSksbH1rLkFuaW1hdGlvbj1rLmV4dGVuZChkdCx7dHdlZW5lcnM6e1wiKlwiOltmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuY3JlYXRlVHdlZW4oZSx0KTtyZXR1cm4gbGUobi5lbGVtLGUsbmUuZXhlYyh0KSxuKSxufV19LHR3ZWVuZXI6ZnVuY3Rpb24oZSx0KXttKGUpPyh0PWUsZT1bXCIqXCJdKTplPWUubWF0Y2goUik7Zm9yKHZhciBuLHI9MCxpPWUubGVuZ3RoO3I8aTtyKyspbj1lW3JdLGR0LnR3ZWVuZXJzW25dPWR0LnR3ZWVuZXJzW25dfHxbXSxkdC50d2VlbmVyc1tuXS51bnNoaWZ0KHQpfSxwcmVmaWx0ZXJzOltmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGwsYyxmPVwid2lkdGhcImluIHR8fFwiaGVpZ2h0XCJpbiB0LHA9dGhpcyxkPXt9LGg9ZS5zdHlsZSxnPWUubm9kZVR5cGUmJnNlKGUpLHY9US5nZXQoZSxcImZ4c2hvd1wiKTtmb3IociBpbiBuLnF1ZXVlfHwobnVsbD09KGE9ay5fcXVldWVIb29rcyhlLFwiZnhcIikpLnVucXVldWVkJiYoYS51bnF1ZXVlZD0wLHM9YS5lbXB0eS5maXJlLGEuZW1wdHkuZmlyZT1mdW5jdGlvbigpe2EudW5xdWV1ZWR8fHMoKX0pLGEudW5xdWV1ZWQrKyxwLmFsd2F5cyhmdW5jdGlvbigpe3AuYWx3YXlzKGZ1bmN0aW9uKCl7YS51bnF1ZXVlZC0tLGsucXVldWUoZSxcImZ4XCIpLmxlbmd0aHx8YS5lbXB0eS5maXJlKCl9KX0pKSx0KWlmKGk9dFtyXSxzdC50ZXN0KGkpKXtpZihkZWxldGUgdFtyXSxvPW98fFwidG9nZ2xlXCI9PT1pLGk9PT0oZz9cImhpZGVcIjpcInNob3dcIikpe2lmKFwic2hvd1wiIT09aXx8IXZ8fHZvaWQgMD09PXZbcl0pY29udGludWU7Zz0hMH1kW3JdPXYmJnZbcl18fGsuc3R5bGUoZSxyKX1pZigodT0hay5pc0VtcHR5T2JqZWN0KHQpKXx8IWsuaXNFbXB0eU9iamVjdChkKSlmb3IociBpbiBmJiYxPT09ZS5ub2RlVHlwZSYmKG4ub3ZlcmZsb3c9W2gub3ZlcmZsb3csaC5vdmVyZmxvd1gsaC5vdmVyZmxvd1ldLG51bGw9PShsPXYmJnYuZGlzcGxheSkmJihsPVEuZ2V0KGUsXCJkaXNwbGF5XCIpKSxcIm5vbmVcIj09PShjPWsuY3NzKGUsXCJkaXNwbGF5XCIpKSYmKGw/Yz1sOihmZShbZV0sITApLGw9ZS5zdHlsZS5kaXNwbGF5fHxsLGM9ay5jc3MoZSxcImRpc3BsYXlcIiksZmUoW2VdKSkpLChcImlubGluZVwiPT09Y3x8XCJpbmxpbmUtYmxvY2tcIj09PWMmJm51bGwhPWwpJiZcIm5vbmVcIj09PWsuY3NzKGUsXCJmbG9hdFwiKSYmKHV8fChwLmRvbmUoZnVuY3Rpb24oKXtoLmRpc3BsYXk9bH0pLG51bGw9PWwmJihjPWguZGlzcGxheSxsPVwibm9uZVwiPT09Yz9cIlwiOmMpKSxoLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIikpLG4ub3ZlcmZsb3cmJihoLm92ZXJmbG93PVwiaGlkZGVuXCIscC5hbHdheXMoZnVuY3Rpb24oKXtoLm92ZXJmbG93PW4ub3ZlcmZsb3dbMF0saC5vdmVyZmxvd1g9bi5vdmVyZmxvd1sxXSxoLm92ZXJmbG93WT1uLm92ZXJmbG93WzJdfSkpLHU9ITEsZCl1fHwodj9cImhpZGRlblwiaW4gdiYmKGc9di5oaWRkZW4pOnY9US5hY2Nlc3MoZSxcImZ4c2hvd1wiLHtkaXNwbGF5Omx9KSxvJiYodi5oaWRkZW49IWcpLGcmJmZlKFtlXSwhMCkscC5kb25lKGZ1bmN0aW9uKCl7Zm9yKHIgaW4gZ3x8ZmUoW2VdKSxRLnJlbW92ZShlLFwiZnhzaG93XCIpLGQpay5zdHlsZShlLHIsZFtyXSl9KSksdT1wdChnP3Zbcl06MCxyLHApLHIgaW4gdnx8KHZbcl09dS5zdGFydCxnJiYodS5lbmQ9dS5zdGFydCx1LnN0YXJ0PTApKX1dLHByZWZpbHRlcjpmdW5jdGlvbihlLHQpe3Q/ZHQucHJlZmlsdGVycy51bnNoaWZ0KGUpOmR0LnByZWZpbHRlcnMucHVzaChlKX19KSxrLnNwZWVkPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1lJiZcIm9iamVjdFwiPT10eXBlb2YgZT9rLmV4dGVuZCh7fSxlKTp7Y29tcGxldGU6bnx8IW4mJnR8fG0oZSkmJmUsZHVyYXRpb246ZSxlYXNpbmc6biYmdHx8dCYmIW0odCkmJnR9O3JldHVybiBrLmZ4Lm9mZj9yLmR1cmF0aW9uPTA6XCJudW1iZXJcIiE9dHlwZW9mIHIuZHVyYXRpb24mJihyLmR1cmF0aW9uIGluIGsuZnguc3BlZWRzP3IuZHVyYXRpb249ay5meC5zcGVlZHNbci5kdXJhdGlvbl06ci5kdXJhdGlvbj1rLmZ4LnNwZWVkcy5fZGVmYXVsdCksbnVsbCE9ci5xdWV1ZSYmITAhPT1yLnF1ZXVlfHwoci5xdWV1ZT1cImZ4XCIpLHIub2xkPXIuY29tcGxldGUsci5jb21wbGV0ZT1mdW5jdGlvbigpe20oci5vbGQpJiZyLm9sZC5jYWxsKHRoaXMpLHIucXVldWUmJmsuZGVxdWV1ZSh0aGlzLHIucXVldWUpfSxyfSxrLmZuLmV4dGVuZCh7ZmFkZVRvOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLmZpbHRlcihzZSkuY3NzKFwib3BhY2l0eVwiLDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtvcGFjaXR5OnR9LGUsbixyKX0sYW5pbWF0ZTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1rLmlzRW1wdHlPYmplY3QodCksbz1rLnNwZWVkKGUsbixyKSxhPWZ1bmN0aW9uKCl7dmFyIGU9ZHQodGhpcyxrLmV4dGVuZCh7fSx0KSxvKTsoaXx8US5nZXQodGhpcyxcImZpbmlzaFwiKSkmJmUuc3RvcCghMCl9O3JldHVybiBhLmZpbmlzaD1hLGl8fCExPT09by5xdWV1ZT90aGlzLmVhY2goYSk6dGhpcy5xdWV1ZShvLnF1ZXVlLGEpfSxzdG9wOmZ1bmN0aW9uKGksZSxvKXt2YXIgYT1mdW5jdGlvbihlKXt2YXIgdD1lLnN0b3A7ZGVsZXRlIGUuc3RvcCx0KG8pfTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgaSYmKG89ZSxlPWksaT12b2lkIDApLGUmJiExIT09aSYmdGhpcy5xdWV1ZShpfHxcImZ4XCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPSEwLHQ9bnVsbCE9aSYmaStcInF1ZXVlSG9va3NcIixuPWsudGltZXJzLHI9US5nZXQodGhpcyk7aWYodClyW3RdJiZyW3RdLnN0b3AmJmEoclt0XSk7ZWxzZSBmb3IodCBpbiByKXJbdF0mJnJbdF0uc3RvcCYmdXQudGVzdCh0KSYmYShyW3RdKTtmb3IodD1uLmxlbmd0aDt0LS07KW5bdF0uZWxlbSE9PXRoaXN8fG51bGwhPWkmJm5bdF0ucXVldWUhPT1pfHwoblt0XS5hbmltLnN0b3AobyksZT0hMSxuLnNwbGljZSh0LDEpKTshZSYmb3x8ay5kZXF1ZXVlKHRoaXMsaSl9KX0sZmluaXNoOmZ1bmN0aW9uKGEpe3JldHVybiExIT09YSYmKGE9YXx8XCJmeFwiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZSx0PVEuZ2V0KHRoaXMpLG49dFthK1wicXVldWVcIl0scj10W2ErXCJxdWV1ZUhvb2tzXCJdLGk9ay50aW1lcnMsbz1uP24ubGVuZ3RoOjA7Zm9yKHQuZmluaXNoPSEwLGsucXVldWUodGhpcyxhLFtdKSxyJiZyLnN0b3AmJnIuc3RvcC5jYWxsKHRoaXMsITApLGU9aS5sZW5ndGg7ZS0tOylpW2VdLmVsZW09PT10aGlzJiZpW2VdLnF1ZXVlPT09YSYmKGlbZV0uYW5pbS5zdG9wKCEwKSxpLnNwbGljZShlLDEpKTtmb3IoZT0wO2U8bztlKyspbltlXSYmbltlXS5maW5pc2gmJm5bZV0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIHQuZmluaXNofSl9fSksay5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihlLHIpe3ZhciBpPWsuZm5bcl07ay5mbltyXT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIG51bGw9PWV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9pLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoZnQociwhMCksZSx0LG4pfX0pLGsuZWFjaCh7c2xpZGVEb3duOmZ0KFwic2hvd1wiKSxzbGlkZVVwOmZ0KFwiaGlkZVwiKSxzbGlkZVRvZ2dsZTpmdChcInRvZ2dsZVwiKSxmYWRlSW46e29wYWNpdHk6XCJzaG93XCJ9LGZhZGVPdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LGZhZGVUb2dnbGU6e29wYWNpdHk6XCJ0b2dnbGVcIn19LGZ1bmN0aW9uKGUscil7ay5mbltlXT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuYW5pbWF0ZShyLGUsdCxuKX19KSxrLnRpbWVycz1bXSxrLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgZSx0PTAsbj1rLnRpbWVycztmb3IocnQ9RGF0ZS5ub3coKTt0PG4ubGVuZ3RoO3QrKykoZT1uW3RdKSgpfHxuW3RdIT09ZXx8bi5zcGxpY2UodC0tLDEpO24ubGVuZ3RofHxrLmZ4LnN0b3AoKSxydD12b2lkIDB9LGsuZngudGltZXI9ZnVuY3Rpb24oZSl7ay50aW1lcnMucHVzaChlKSxrLmZ4LnN0YXJ0KCl9LGsuZnguaW50ZXJ2YWw9MTMsay5meC5zdGFydD1mdW5jdGlvbigpe2l0fHwoaXQ9ITAsbHQoKSl9LGsuZnguc3RvcD1mdW5jdGlvbigpe2l0PW51bGx9LGsuZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LGsuZm4uZGVsYXk9ZnVuY3Rpb24ocixlKXtyZXR1cm4gcj1rLmZ4JiZrLmZ4LnNwZWVkc1tyXXx8cixlPWV8fFwiZnhcIix0aGlzLnF1ZXVlKGUsZnVuY3Rpb24oZSx0KXt2YXIgbj1DLnNldFRpbWVvdXQoZSxyKTt0LnN0b3A9ZnVuY3Rpb24oKXtDLmNsZWFyVGltZW91dChuKX19KX0sb3Q9RS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYXQ9RS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLmFwcGVuZENoaWxkKEUuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSksb3QudHlwZT1cImNoZWNrYm94XCIseS5jaGVja09uPVwiXCIhPT1vdC52YWx1ZSx5Lm9wdFNlbGVjdGVkPWF0LnNlbGVjdGVkLChvdD1FLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkudmFsdWU9XCJ0XCIsb3QudHlwZT1cInJhZGlvXCIseS5yYWRpb1ZhbHVlPVwidFwiPT09b3QudmFsdWU7dmFyIGh0LGd0PWsuZXhwci5hdHRySGFuZGxlO2suZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIF8odGhpcyxrLmF0dHIsZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2sucmVtb3ZlQXR0cih0aGlzLGUpfSl9fSksay5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz1lLm5vZGVUeXBlO2lmKDMhPT1vJiY4IT09byYmMiE9PW8pcmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUuZ2V0QXR0cmlidXRlP2sucHJvcChlLHQsbik6KDE9PT1vJiZrLmlzWE1MRG9jKGUpfHwoaT1rLmF0dHJIb29rc1t0LnRvTG93ZXJDYXNlKCldfHwoay5leHByLm1hdGNoLmJvb2wudGVzdCh0KT9odDp2b2lkIDApKSx2b2lkIDAhPT1uP251bGw9PT1uP3ZvaWQgay5yZW1vdmVBdHRyKGUsdCk6aSYmXCJzZXRcImluIGkmJnZvaWQgMCE9PShyPWkuc2V0KGUsbix0KSk/cjooZS5zZXRBdHRyaWJ1dGUodCxuK1wiXCIpLG4pOmkmJlwiZ2V0XCJpbiBpJiZudWxsIT09KHI9aS5nZXQoZSx0KSk/cjpudWxsPT0ocj1rLmZpbmQuYXR0cihlLHQpKT92b2lkIDA6cil9LGF0dHJIb29rczp7dHlwZTp7c2V0OmZ1bmN0aW9uKGUsdCl7aWYoIXkucmFkaW9WYWx1ZSYmXCJyYWRpb1wiPT09dCYmQShlLFwiaW5wdXRcIikpe3ZhciBuPWUudmFsdWU7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLHQpLG4mJihlLnZhbHVlPW4pLHR9fX19LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTAsaT10JiZ0Lm1hdGNoKFIpO2lmKGkmJjE9PT1lLm5vZGVUeXBlKXdoaWxlKG49aVtyKytdKWUucmVtb3ZlQXR0cmlidXRlKG4pfX0pLGh0PXtzZXQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiExPT09dD9rLnJlbW92ZUF0dHIoZSxuKTplLnNldEF0dHJpYnV0ZShuLG4pLG59fSxrLmVhY2goay5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLGZ1bmN0aW9uKGUsdCl7dmFyIGE9Z3RbdF18fGsuZmluZC5hdHRyO2d0W3RdPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89dC50b0xvd2VyQ2FzZSgpO3JldHVybiBufHwoaT1ndFtvXSxndFtvXT1yLHI9bnVsbCE9YShlLHQsbik/bzpudWxsLGd0W29dPWkpLHJ9fSk7dmFyIHZ0PS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2kseXQ9L14oPzphfGFyZWEpJC9pO2Z1bmN0aW9uIG10KGUpe3JldHVybihlLm1hdGNoKFIpfHxbXSkuam9pbihcIiBcIil9ZnVuY3Rpb24geHQoZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwifWZ1bmN0aW9uIGJ0KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2U6XCJzdHJpbmdcIj09dHlwZW9mIGUmJmUubWF0Y2goUil8fFtdfWsuZm4uZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIF8odGhpcyxrLnByb3AsZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2RlbGV0ZSB0aGlzW2sucHJvcEZpeFtlXXx8ZV19KX19KSxrLmV4dGVuZCh7cHJvcDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPWUubm9kZVR5cGU7aWYoMyE9PW8mJjghPT1vJiYyIT09bylyZXR1cm4gMT09PW8mJmsuaXNYTUxEb2MoZSl8fCh0PWsucHJvcEZpeFt0XXx8dCxpPWsucHJvcEhvb2tzW3RdKSx2b2lkIDAhPT1uP2kmJlwic2V0XCJpbiBpJiZ2b2lkIDAhPT0ocj1pLnNldChlLG4sdCkpP3I6ZVt0XT1uOmkmJlwiZ2V0XCJpbiBpJiZudWxsIT09KHI9aS5nZXQoZSx0KSk/cjplW3RdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ay5maW5kLmF0dHIoZSxcInRhYmluZGV4XCIpO3JldHVybiB0P3BhcnNlSW50KHQsMTApOnZ0LnRlc3QoZS5ub2RlTmFtZSl8fHl0LnRlc3QoZS5ub2RlTmFtZSkmJmUuaHJlZj8wOi0xfX19LHByb3BGaXg6e1wiZm9yXCI6XCJodG1sRm9yXCIsXCJjbGFzc1wiOlwiY2xhc3NOYW1lXCJ9fSkseS5vcHRTZWxlY3RlZHx8KGsucHJvcEhvb2tzLnNlbGVjdGVkPXtnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJlbnROb2RlO3JldHVybiB0JiZ0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LG51bGx9LHNldDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7dCYmKHQuc2VsZWN0ZWRJbmRleCx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KX19KSxrLmVhY2goW1widGFiSW5kZXhcIixcInJlYWRPbmx5XCIsXCJtYXhMZW5ndGhcIixcImNlbGxTcGFjaW5nXCIsXCJjZWxsUGFkZGluZ1wiLFwicm93U3BhblwiLFwiY29sU3BhblwiLFwidXNlTWFwXCIsXCJmcmFtZUJvcmRlclwiLFwiY29udGVudEVkaXRhYmxlXCJdLGZ1bmN0aW9uKCl7ay5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV09dGhpc30pLGsuZm4uZXh0ZW5kKHthZGRDbGFzczpmdW5jdGlvbih0KXt2YXIgZSxuLHIsaSxvLGEscyx1PTA7aWYobSh0KSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2sodGhpcykuYWRkQ2xhc3ModC5jYWxsKHRoaXMsZSx4dCh0aGlzKSkpfSk7aWYoKGU9YnQodCkpLmxlbmd0aCl3aGlsZShuPXRoaXNbdSsrXSlpZihpPXh0KG4pLHI9MT09PW4ubm9kZVR5cGUmJlwiIFwiK210KGkpK1wiIFwiKXthPTA7d2hpbGUobz1lW2ErK10pci5pbmRleE9mKFwiIFwiK28rXCIgXCIpPDAmJihyKz1vK1wiIFwiKTtpIT09KHM9bXQocikpJiZuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIscyl9cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKHQpe3ZhciBlLG4scixpLG8sYSxzLHU9MDtpZihtKHQpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oZSl7ayh0aGlzKS5yZW1vdmVDbGFzcyh0LmNhbGwodGhpcyxlLHh0KHRoaXMpKSl9KTtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIixcIlwiKTtpZigoZT1idCh0KSkubGVuZ3RoKXdoaWxlKG49dGhpc1t1KytdKWlmKGk9eHQobikscj0xPT09bi5ub2RlVHlwZSYmXCIgXCIrbXQoaSkrXCIgXCIpe2E9MDt3aGlsZShvPWVbYSsrXSl3aGlsZSgtMTxyLmluZGV4T2YoXCIgXCIrbytcIiBcIikpcj1yLnJlcGxhY2UoXCIgXCIrbytcIiBcIixcIiBcIik7aSE9PShzPW10KHIpKSYmbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLHMpfXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihpLHQpe3ZhciBvPXR5cGVvZiBpLGE9XCJzdHJpbmdcIj09PW98fEFycmF5LmlzQXJyYXkoaSk7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0JiZhP3Q/dGhpcy5hZGRDbGFzcyhpKTp0aGlzLnJlbW92ZUNsYXNzKGkpOm0oaSk/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2sodGhpcykudG9nZ2xlQ2xhc3MoaS5jYWxsKHRoaXMsZSx4dCh0aGlzKSx0KSx0KX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlLHQsbixyO2lmKGEpe3Q9MCxuPWsodGhpcykscj1idChpKTt3aGlsZShlPXJbdCsrXSluLmhhc0NsYXNzKGUpP24ucmVtb3ZlQ2xhc3MoZSk6bi5hZGRDbGFzcyhlKX1lbHNlIHZvaWQgMCE9PWkmJlwiYm9vbGVhblwiIT09b3x8KChlPXh0KHRoaXMpKSYmUS5zZXQodGhpcyxcIl9fY2xhc3NOYW1lX19cIixlKSx0aGlzLnNldEF0dHJpYnV0ZSYmdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGV8fCExPT09aT9cIlwiOlEuZ2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIpfHxcIlwiKSl9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPTA7dD1cIiBcIitlK1wiIFwiO3doaWxlKG49dGhpc1tyKytdKWlmKDE9PT1uLm5vZGVUeXBlJiYtMTwoXCIgXCIrbXQoeHQobikpK1wiIFwiKS5pbmRleE9mKHQpKXJldHVybiEwO3JldHVybiExfX0pO3ZhciB3dD0vXFxyL2c7ay5mbi5leHRlbmQoe3ZhbDpmdW5jdGlvbihuKXt2YXIgcixlLGksdD10aGlzWzBdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPW0obiksdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3ZhciB0OzE9PT10aGlzLm5vZGVUeXBlJiYobnVsbD09KHQ9aT9uLmNhbGwodGhpcyxlLGsodGhpcykudmFsKCkpOm4pP3Q9XCJcIjpcIm51bWJlclwiPT10eXBlb2YgdD90Kz1cIlwiOkFycmF5LmlzQXJyYXkodCkmJih0PWsubWFwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjplK1wiXCJ9KSksKHI9ay52YWxIb29rc1t0aGlzLnR5cGVdfHxrLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pJiZcInNldFwiaW4gciYmdm9pZCAwIT09ci5zZXQodGhpcyx0LFwidmFsdWVcIil8fCh0aGlzLnZhbHVlPXQpKX0pKTp0PyhyPWsudmFsSG9va3NbdC50eXBlXXx8ay52YWxIb29rc1t0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSYmXCJnZXRcImluIHImJnZvaWQgMCE9PShlPXIuZ2V0KHQsXCJ2YWx1ZVwiKSk/ZTpcInN0cmluZ1wiPT10eXBlb2YoZT10LnZhbHVlKT9lLnJlcGxhY2Uod3QsXCJcIik6bnVsbD09ZT9cIlwiOmU6dm9pZCAwfX0pLGsuZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ay5maW5kLmF0dHIoZSxcInZhbHVlXCIpO3JldHVybiBudWxsIT10P3Q6bXQoay50ZXh0KGUpKX19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPWUub3B0aW9ucyxvPWUuc2VsZWN0ZWRJbmRleCxhPVwic2VsZWN0LW9uZVwiPT09ZS50eXBlLHM9YT9udWxsOltdLHU9YT9vKzE6aS5sZW5ndGg7Zm9yKHI9bzwwP3U6YT9vOjA7cjx1O3IrKylpZigoKG49aVtyXSkuc2VsZWN0ZWR8fHI9PT1vKSYmIW4uZGlzYWJsZWQmJighbi5wYXJlbnROb2RlLmRpc2FibGVkfHwhQShuLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKHQ9ayhuKS52YWwoKSxhKXJldHVybiB0O3MucHVzaCh0KX1yZXR1cm4gc30sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPWUub3B0aW9ucyxvPWsubWFrZUFycmF5KHQpLGE9aS5sZW5ndGg7d2hpbGUoYS0tKSgocj1pW2FdKS5zZWxlY3RlZD0tMTxrLmluQXJyYXkoay52YWxIb29rcy5vcHRpb24uZ2V0KHIpLG8pKSYmKG49ITApO3JldHVybiBufHwoZS5zZWxlY3RlZEluZGV4PS0xKSxvfX19fSksay5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe2sudmFsSG9va3NbdGhpc109e3NldDpmdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIGUuY2hlY2tlZD0tMTxrLmluQXJyYXkoayhlKS52YWwoKSx0KX19LHkuY2hlY2tPbnx8KGsudmFsSG9va3NbdGhpc10uZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT09ZS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9cIm9uXCI6ZS52YWx1ZX0pfSkseS5mb2N1c2luPVwib25mb2N1c2luXCJpbiBDO3ZhciBUdD0vXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sQ3Q9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKX07ay5leHRlbmQoay5ldmVudCx7dHJpZ2dlcjpmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscyx1LGwsYyxmLHA9W258fEVdLGQ9di5jYWxsKGUsXCJ0eXBlXCIpP2UudHlwZTplLGg9di5jYWxsKGUsXCJuYW1lc3BhY2VcIik/ZS5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpOltdO2lmKG89Zj1hPW49bnx8RSwzIT09bi5ub2RlVHlwZSYmOCE9PW4ubm9kZVR5cGUmJiFUdC50ZXN0KGQray5ldmVudC50cmlnZ2VyZWQpJiYoLTE8ZC5pbmRleE9mKFwiLlwiKSYmKGQ9KGg9ZC5zcGxpdChcIi5cIikpLnNoaWZ0KCksaC5zb3J0KCkpLHU9ZC5pbmRleE9mKFwiOlwiKTwwJiZcIm9uXCIrZCwoZT1lW2suZXhwYW5kb10/ZTpuZXcgay5FdmVudChkLFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlKSkuaXNUcmlnZ2VyPXI/MjozLGUubmFtZXNwYWNlPWguam9pbihcIi5cIiksZS5ybmFtZXNwYWNlPWUubmFtZXNwYWNlP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLGUucmVzdWx0PXZvaWQgMCxlLnRhcmdldHx8KGUudGFyZ2V0PW4pLHQ9bnVsbD09dD9bZV06ay5tYWtlQXJyYXkodCxbZV0pLGM9ay5ldmVudC5zcGVjaWFsW2RdfHx7fSxyfHwhYy50cmlnZ2VyfHwhMSE9PWMudHJpZ2dlci5hcHBseShuLHQpKSl7aWYoIXImJiFjLm5vQnViYmxlJiYheChuKSl7Zm9yKHM9Yy5kZWxlZ2F0ZVR5cGV8fGQsVHQudGVzdChzK2QpfHwobz1vLnBhcmVudE5vZGUpO287bz1vLnBhcmVudE5vZGUpcC5wdXNoKG8pLGE9bzthPT09KG4ub3duZXJEb2N1bWVudHx8RSkmJnAucHVzaChhLmRlZmF1bHRWaWV3fHxhLnBhcmVudFdpbmRvd3x8Qyl9aT0wO3doaWxlKChvPXBbaSsrXSkmJiFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpZj1vLGUudHlwZT0xPGk/czpjLmJpbmRUeXBlfHxkLChsPShRLmdldChvLFwiZXZlbnRzXCIpfHx7fSlbZS50eXBlXSYmUS5nZXQobyxcImhhbmRsZVwiKSkmJmwuYXBwbHkobyx0KSwobD11JiZvW3VdKSYmbC5hcHBseSYmRyhvKSYmKGUucmVzdWx0PWwuYXBwbHkobyx0KSwhMT09PWUucmVzdWx0JiZlLnByZXZlbnREZWZhdWx0KCkpO3JldHVybiBlLnR5cGU9ZCxyfHxlLmlzRGVmYXVsdFByZXZlbnRlZCgpfHxjLl9kZWZhdWx0JiYhMSE9PWMuX2RlZmF1bHQuYXBwbHkocC5wb3AoKSx0KXx8IUcobil8fHUmJm0obltkXSkmJiF4KG4pJiYoKGE9blt1XSkmJihuW3VdPW51bGwpLGsuZXZlbnQudHJpZ2dlcmVkPWQsZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpJiZmLmFkZEV2ZW50TGlzdGVuZXIoZCxDdCksbltkXSgpLGUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSYmZi5yZW1vdmVFdmVudExpc3RlbmVyKGQsQ3QpLGsuZXZlbnQudHJpZ2dlcmVkPXZvaWQgMCxhJiYoblt1XT1hKSksZS5yZXN1bHR9fSxzaW11bGF0ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI9ay5leHRlbmQobmV3IGsuRXZlbnQsbix7dHlwZTplLGlzU2ltdWxhdGVkOiEwfSk7ay5ldmVudC50cmlnZ2VyKHIsbnVsbCx0KX19KSxrLmZuLmV4dGVuZCh7dHJpZ2dlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtrLmV2ZW50LnRyaWdnZXIoZSx0LHRoaXMpfSl9LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpc1swXTtpZihuKXJldHVybiBrLmV2ZW50LnRyaWdnZXIoZSx0LG4sITApfX0pLHkuZm9jdXNpbnx8ay5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24obixyKXt2YXIgaT1mdW5jdGlvbihlKXtrLmV2ZW50LnNpbXVsYXRlKHIsZS50YXJnZXQsay5ldmVudC5maXgoZSkpfTtrLmV2ZW50LnNwZWNpYWxbcl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLHQ9US5hY2Nlc3MoZSxyKTt0fHxlLmFkZEV2ZW50TGlzdGVuZXIobixpLCEwKSxRLmFjY2VzcyhlLHIsKHR8fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcyx0PVEuYWNjZXNzKGUsciktMTt0P1EuYWNjZXNzKGUscix0KTooZS5yZW1vdmVFdmVudExpc3RlbmVyKG4saSwhMCksUS5yZW1vdmUoZSxyKSl9fX0pO3ZhciBFdD1DLmxvY2F0aW9uLGt0PURhdGUubm93KCksU3Q9L1xcPy87ay5wYXJzZVhNTD1mdW5jdGlvbihlKXt2YXIgdDtpZighZXx8XCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIG51bGw7dHJ5e3Q9KG5ldyBDLkRPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGUsXCJ0ZXh0L3htbFwiKX1jYXRjaChlKXt0PXZvaWQgMH1yZXR1cm4gdCYmIXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGh8fGsuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrZSksdH07dmFyIE50PS9cXFtcXF0kLyxBdD0vXFxyP1xcbi9nLER0PS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxqdD0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gcXQobixlLHIsaSl7dmFyIHQ7aWYoQXJyYXkuaXNBcnJheShlKSlrLmVhY2goZSxmdW5jdGlvbihlLHQpe3J8fE50LnRlc3Qobik/aShuLHQpOnF0KG4rXCJbXCIrKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT10P2U6XCJcIikrXCJdXCIsdCxyLGkpfSk7ZWxzZSBpZihyfHxcIm9iamVjdFwiIT09dyhlKSlpKG4sZSk7ZWxzZSBmb3IodCBpbiBlKXF0KG4rXCJbXCIrdCtcIl1cIixlW3RdLHIsaSl9ay5wYXJhbT1mdW5jdGlvbihlLHQpe3ZhciBuLHI9W10saT1mdW5jdGlvbihlLHQpe3ZhciBuPW0odCk/dCgpOnQ7cltyLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChudWxsPT1uP1wiXCI6bil9O2lmKG51bGw9PWUpcmV0dXJuXCJcIjtpZihBcnJheS5pc0FycmF5KGUpfHxlLmpxdWVyeSYmIWsuaXNQbGFpbk9iamVjdChlKSlrLmVhY2goZSxmdW5jdGlvbigpe2kodGhpcy5uYW1lLHRoaXMudmFsdWUpfSk7ZWxzZSBmb3IobiBpbiBlKXF0KG4sZVtuXSx0LGkpO3JldHVybiByLmpvaW4oXCImXCIpfSxrLmZuLmV4dGVuZCh7c2VyaWFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIGsucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKX0sc2VyaWFsaXplQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgZT1rLnByb3AodGhpcyxcImVsZW1lbnRzXCIpO3JldHVybiBlP2subWFrZUFycmF5KGUpOnRoaXN9KS5maWx0ZXIoZnVuY3Rpb24oKXt2YXIgZT10aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSYmIWsodGhpcykuaXMoXCI6ZGlzYWJsZWRcIikmJmp0LnRlc3QodGhpcy5ub2RlTmFtZSkmJiFEdC50ZXN0KGUpJiYodGhpcy5jaGVja2VkfHwhcGUudGVzdChlKSl9KS5tYXAoZnVuY3Rpb24oZSx0KXt2YXIgbj1rKHRoaXMpLnZhbCgpO3JldHVybiBudWxsPT1uP251bGw6QXJyYXkuaXNBcnJheShuKT9rLm1hcChuLGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOnQubmFtZSx2YWx1ZTplLnJlcGxhY2UoQXQsXCJcXHJcXG5cIil9fSk6e25hbWU6dC5uYW1lLHZhbHVlOm4ucmVwbGFjZShBdCxcIlxcclxcblwiKX19KS5nZXQoKX19KTt2YXIgTHQ9LyUyMC9nLEh0PS8jLiokLyxPdD0vKFs/Jl0pXz1bXiZdKi8sUHQ9L14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9nbSxSdD0vXig/OkdFVHxIRUFEKSQvLE10PS9eXFwvXFwvLyxJdD17fSxXdD17fSwkdD1cIiovXCIuY29uY2F0KFwiKlwiKSxGdD1FLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2Z1bmN0aW9uIEJ0KG8pe3JldHVybiBmdW5jdGlvbihlLHQpe1wic3RyaW5nXCIhPXR5cGVvZiBlJiYodD1lLGU9XCIqXCIpO3ZhciBuLHI9MCxpPWUudG9Mb3dlckNhc2UoKS5tYXRjaChSKXx8W107aWYobSh0KSl3aGlsZShuPWlbcisrXSlcIitcIj09PW5bMF0/KG49bi5zbGljZSgxKXx8XCIqXCIsKG9bbl09b1tuXXx8W10pLnVuc2hpZnQodCkpOihvW25dPW9bbl18fFtdKS5wdXNoKHQpfX1mdW5jdGlvbiBfdCh0LGksbyxhKXt2YXIgcz17fSx1PXQ9PT1XdDtmdW5jdGlvbiBsKGUpe3ZhciByO3JldHVybiBzW2VdPSEwLGsuZWFjaCh0W2VdfHxbXSxmdW5jdGlvbihlLHQpe3ZhciBuPXQoaSxvLGEpO3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBufHx1fHxzW25dP3U/IShyPW4pOnZvaWQgMDooaS5kYXRhVHlwZXMudW5zaGlmdChuKSxsKG4pLCExKX0pLHJ9cmV0dXJuIGwoaS5kYXRhVHlwZXNbMF0pfHwhc1tcIipcIl0mJmwoXCIqXCIpfWZ1bmN0aW9uIHp0KGUsdCl7dmFyIG4scixpPWsuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zfHx7fTtmb3IobiBpbiB0KXZvaWQgMCE9PXRbbl0mJigoaVtuXT9lOnJ8fChyPXt9KSlbbl09dFtuXSk7cmV0dXJuIHImJmsuZXh0ZW5kKCEwLGUsciksZX1GdC5ocmVmPUV0LmhyZWYsay5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOkV0LmhyZWYsdHlwZTpcIkdFVFwiLGlzTG9jYWw6L14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8udGVzdChFdC5wcm90b2NvbCksZ2xvYmFsOiEwLHByb2Nlc3NEYXRhOiEwLGFzeW5jOiEwLGNvbnRlbnRUeXBlOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsYWNjZXB0czp7XCIqXCI6JHQsdGV4dDpcInRleHQvcGxhaW5cIixodG1sOlwidGV4dC9odG1sXCIseG1sOlwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLGpzb246XCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIn0sY29udGVudHM6e3htbDovXFxieG1sXFxiLyxodG1sOi9cXGJodG1sLyxqc29uOi9cXGJqc29uXFxiL30scmVzcG9uc2VGaWVsZHM6e3htbDpcInJlc3BvbnNlWE1MXCIsdGV4dDpcInJlc3BvbnNlVGV4dFwiLGpzb246XCJyZXNwb25zZUpTT05cIn0sY29udmVydGVyczp7XCIqIHRleHRcIjpTdHJpbmcsXCJ0ZXh0IGh0bWxcIjohMCxcInRleHQganNvblwiOkpTT04ucGFyc2UsXCJ0ZXh0IHhtbFwiOmsucGFyc2VYTUx9LGZsYXRPcHRpb25zOnt1cmw6ITAsY29udGV4dDohMH19LGFqYXhTZXR1cDpmdW5jdGlvbihlLHQpe3JldHVybiB0P3p0KHp0KGUsay5hamF4U2V0dGluZ3MpLHQpOnp0KGsuYWpheFNldHRpbmdzLGUpfSxhamF4UHJlZmlsdGVyOkJ0KEl0KSxhamF4VHJhbnNwb3J0OkJ0KFd0KSxhamF4OmZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGUmJih0PWUsZT12b2lkIDApLHQ9dHx8e307dmFyIGMsZixwLG4sZCxyLGgsZyxpLG8sdj1rLmFqYXhTZXR1cCh7fSx0KSx5PXYuY29udGV4dHx8dixtPXYuY29udGV4dCYmKHkubm9kZVR5cGV8fHkuanF1ZXJ5KT9rKHkpOmsuZXZlbnQseD1rLkRlZmVycmVkKCksYj1rLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLHc9di5zdGF0dXNDb2RlfHx7fSxhPXt9LHM9e30sdT1cImNhbmNlbGVkXCIsVD17cmVhZHlTdGF0ZTowLGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKGgpe2lmKCFuKXtuPXt9O3doaWxlKHQ9UHQuZXhlYyhwKSluW3RbMV0udG9Mb3dlckNhc2UoKStcIiBcIl09KG5bdFsxXS50b0xvd2VyQ2FzZSgpK1wiIFwiXXx8W10pLmNvbmNhdCh0WzJdKX10PW5bZS50b0xvd2VyQ2FzZSgpK1wiIFwiXX1yZXR1cm4gbnVsbD09dD9udWxsOnQuam9pbihcIiwgXCIpfSxnZXRBbGxSZXNwb25zZUhlYWRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gaD9wOm51bGx9LHNldFJlcXVlc3RIZWFkZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09aCYmKGU9c1tlLnRvTG93ZXJDYXNlKCldPXNbZS50b0xvd2VyQ2FzZSgpXXx8ZSxhW2VdPXQpLHRoaXN9LG92ZXJyaWRlTWltZVR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWgmJih2Lm1pbWVUeXBlPWUpLHRoaXN9LHN0YXR1c0NvZGU6ZnVuY3Rpb24oZSl7dmFyIHQ7aWYoZSlpZihoKVQuYWx3YXlzKGVbVC5zdGF0dXNdKTtlbHNlIGZvcih0IGluIGUpd1t0XT1bd1t0XSxlW3RdXTtyZXR1cm4gdGhpc30sYWJvcnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZXx8dTtyZXR1cm4gYyYmYy5hYm9ydCh0KSxsKDAsdCksdGhpc319O2lmKHgucHJvbWlzZShUKSx2LnVybD0oKGV8fHYudXJsfHxFdC5ocmVmKStcIlwiKS5yZXBsYWNlKE10LEV0LnByb3RvY29sK1wiLy9cIiksdi50eXBlPXQubWV0aG9kfHx0LnR5cGV8fHYubWV0aG9kfHx2LnR5cGUsdi5kYXRhVHlwZXM9KHYuZGF0YVR5cGV8fFwiKlwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKFIpfHxbXCJcIl0sbnVsbD09di5jcm9zc0RvbWFpbil7cj1FLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO3RyeXtyLmhyZWY9di51cmwsci5ocmVmPXIuaHJlZix2LmNyb3NzRG9tYWluPUZ0LnByb3RvY29sK1wiLy9cIitGdC5ob3N0IT1yLnByb3RvY29sK1wiLy9cIityLmhvc3R9Y2F0Y2goZSl7di5jcm9zc0RvbWFpbj0hMH19aWYodi5kYXRhJiZ2LnByb2Nlc3NEYXRhJiZcInN0cmluZ1wiIT10eXBlb2Ygdi5kYXRhJiYodi5kYXRhPWsucGFyYW0odi5kYXRhLHYudHJhZGl0aW9uYWwpKSxfdChJdCx2LHQsVCksaClyZXR1cm4gVDtmb3IoaSBpbihnPWsuZXZlbnQmJnYuZ2xvYmFsKSYmMD09ay5hY3RpdmUrKyYmay5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLHYudHlwZT12LnR5cGUudG9VcHBlckNhc2UoKSx2Lmhhc0NvbnRlbnQ9IVJ0LnRlc3Qodi50eXBlKSxmPXYudXJsLnJlcGxhY2UoSHQsXCJcIiksdi5oYXNDb250ZW50P3YuZGF0YSYmdi5wcm9jZXNzRGF0YSYmMD09PSh2LmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiYodi5kYXRhPXYuZGF0YS5yZXBsYWNlKEx0LFwiK1wiKSk6KG89di51cmwuc2xpY2UoZi5sZW5ndGgpLHYuZGF0YSYmKHYucHJvY2Vzc0RhdGF8fFwic3RyaW5nXCI9PXR5cGVvZiB2LmRhdGEpJiYoZis9KFN0LnRlc3QoZik/XCImXCI6XCI/XCIpK3YuZGF0YSxkZWxldGUgdi5kYXRhKSwhMT09PXYuY2FjaGUmJihmPWYucmVwbGFjZShPdCxcIiQxXCIpLG89KFN0LnRlc3QoZik/XCImXCI6XCI/XCIpK1wiXz1cIitrdCsrK28pLHYudXJsPWYrbyksdi5pZk1vZGlmaWVkJiYoay5sYXN0TW9kaWZpZWRbZl0mJlQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsay5sYXN0TW9kaWZpZWRbZl0pLGsuZXRhZ1tmXSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLGsuZXRhZ1tmXSkpLCh2LmRhdGEmJnYuaGFzQ29udGVudCYmITEhPT12LmNvbnRlbnRUeXBlfHx0LmNvbnRlbnRUeXBlKSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsdi5jb250ZW50VHlwZSksVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsdi5kYXRhVHlwZXNbMF0mJnYuYWNjZXB0c1t2LmRhdGFUeXBlc1swXV0/di5hY2NlcHRzW3YuZGF0YVR5cGVzWzBdXSsoXCIqXCIhPT12LmRhdGFUeXBlc1swXT9cIiwgXCIrJHQrXCI7IHE9MC4wMVwiOlwiXCIpOnYuYWNjZXB0c1tcIipcIl0pLHYuaGVhZGVycylULnNldFJlcXVlc3RIZWFkZXIoaSx2LmhlYWRlcnNbaV0pO2lmKHYuYmVmb3JlU2VuZCYmKCExPT09di5iZWZvcmVTZW5kLmNhbGwoeSxULHYpfHxoKSlyZXR1cm4gVC5hYm9ydCgpO2lmKHU9XCJhYm9ydFwiLGIuYWRkKHYuY29tcGxldGUpLFQuZG9uZSh2LnN1Y2Nlc3MpLFQuZmFpbCh2LmVycm9yKSxjPV90KFd0LHYsdCxUKSl7aWYoVC5yZWFkeVN0YXRlPTEsZyYmbS50cmlnZ2VyKFwiYWpheFNlbmRcIixbVCx2XSksaClyZXR1cm4gVDt2LmFzeW5jJiYwPHYudGltZW91dCYmKGQ9Qy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VC5hYm9ydChcInRpbWVvdXRcIil9LHYudGltZW91dCkpO3RyeXtoPSExLGMuc2VuZChhLGwpfWNhdGNoKGUpe2lmKGgpdGhyb3cgZTtsKC0xLGUpfX1lbHNlIGwoLTEsXCJObyBUcmFuc3BvcnRcIik7ZnVuY3Rpb24gbChlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9dDtofHwoaD0hMCxkJiZDLmNsZWFyVGltZW91dChkKSxjPXZvaWQgMCxwPXJ8fFwiXCIsVC5yZWFkeVN0YXRlPTA8ZT80OjAsaT0yMDA8PWUmJmU8MzAwfHwzMDQ9PT1lLG4mJihzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzPWUuY29udGVudHMsdT1lLmRhdGFUeXBlczt3aGlsZShcIipcIj09PXVbMF0pdS5zaGlmdCgpLHZvaWQgMD09PXImJihyPWUubWltZVR5cGV8fHQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO2lmKHIpZm9yKGkgaW4gcylpZihzW2ldJiZzW2ldLnRlc3Qocikpe3UudW5zaGlmdChpKTticmVha31pZih1WzBdaW4gbilvPXVbMF07ZWxzZXtmb3IoaSBpbiBuKXtpZighdVswXXx8ZS5jb252ZXJ0ZXJzW2krXCIgXCIrdVswXV0pe289aTticmVha31hfHwoYT1pKX1vPW98fGF9aWYobylyZXR1cm4gbyE9PXVbMF0mJnUudW5zaGlmdChvKSxuW29dfSh2LFQsbikpLHM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsdSxsPXt9LGM9ZS5kYXRhVHlwZXMuc2xpY2UoKTtpZihjWzFdKWZvcihhIGluIGUuY29udmVydGVycylsW2EudG9Mb3dlckNhc2UoKV09ZS5jb252ZXJ0ZXJzW2FdO289Yy5zaGlmdCgpO3doaWxlKG8paWYoZS5yZXNwb25zZUZpZWxkc1tvXSYmKG5bZS5yZXNwb25zZUZpZWxkc1tvXV09dCksIXUmJnImJmUuZGF0YUZpbHRlciYmKHQ9ZS5kYXRhRmlsdGVyKHQsZS5kYXRhVHlwZSkpLHU9byxvPWMuc2hpZnQoKSlpZihcIipcIj09PW8pbz11O2Vsc2UgaWYoXCIqXCIhPT11JiZ1IT09byl7aWYoIShhPWxbdStcIiBcIitvXXx8bFtcIiogXCIrb10pKWZvcihpIGluIGwpaWYoKHM9aS5zcGxpdChcIiBcIikpWzFdPT09byYmKGE9bFt1K1wiIFwiK3NbMF1dfHxsW1wiKiBcIitzWzBdXSkpeyEwPT09YT9hPWxbaV06ITAhPT1sW2ldJiYobz1zWzBdLGMudW5zaGlmdChzWzFdKSk7YnJlYWt9aWYoITAhPT1hKWlmKGEmJmVbXCJ0aHJvd3NcIl0pdD1hKHQpO2Vsc2UgdHJ5e3Q9YSh0KX1jYXRjaChlKXtyZXR1cm57c3RhdGU6XCJwYXJzZXJlcnJvclwiLGVycm9yOmE/ZTpcIk5vIGNvbnZlcnNpb24gZnJvbSBcIit1K1wiIHRvIFwiK299fX1yZXR1cm57c3RhdGU6XCJzdWNjZXNzXCIsZGF0YTp0fX0odixzLFQsaSksaT8odi5pZk1vZGlmaWVkJiYoKHU9VC5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIikpJiYoay5sYXN0TW9kaWZpZWRbZl09dSksKHU9VC5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIikpJiYoay5ldGFnW2ZdPXUpKSwyMDQ9PT1lfHxcIkhFQURcIj09PXYudHlwZT9sPVwibm9jb250ZW50XCI6MzA0PT09ZT9sPVwibm90bW9kaWZpZWRcIjoobD1zLnN0YXRlLG89cy5kYXRhLGk9IShhPXMuZXJyb3IpKSk6KGE9bCwhZSYmbHx8KGw9XCJlcnJvclwiLGU8MCYmKGU9MCkpKSxULnN0YXR1cz1lLFQuc3RhdHVzVGV4dD0odHx8bCkrXCJcIixpP3gucmVzb2x2ZVdpdGgoeSxbbyxsLFRdKTp4LnJlamVjdFdpdGgoeSxbVCxsLGFdKSxULnN0YXR1c0NvZGUodyksdz12b2lkIDAsZyYmbS50cmlnZ2VyKGk/XCJhamF4U3VjY2Vzc1wiOlwiYWpheEVycm9yXCIsW1QsdixpP286YV0pLGIuZmlyZVdpdGgoeSxbVCxsXSksZyYmKG0udHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFtULHZdKSwtLWsuYWN0aXZlfHxrLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiBUfSxnZXRKU09OOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gay5nZXQoZSx0LG4sXCJqc29uXCIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gay5nZXQoZSx2b2lkIDAsdCxcInNjcmlwdFwiKX19KSxrLmVhY2goW1wiZ2V0XCIsXCJwb3N0XCJdLGZ1bmN0aW9uKGUsaSl7a1tpXT1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gbSh0KSYmKHI9cnx8bixuPXQsdD12b2lkIDApLGsuYWpheChrLmV4dGVuZCh7dXJsOmUsdHlwZTppLGRhdGFUeXBlOnIsZGF0YTp0LHN1Y2Nlc3M6bn0say5pc1BsYWluT2JqZWN0KGUpJiZlKSl9fSksay5fZXZhbFVybD1mdW5jdGlvbihlLHQpe3JldHVybiBrLmFqYXgoe3VybDplLHR5cGU6XCJHRVRcIixkYXRhVHlwZTpcInNjcmlwdFwiLGNhY2hlOiEwLGFzeW5jOiExLGdsb2JhbDohMSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oKXt9fSxkYXRhRmlsdGVyOmZ1bmN0aW9uKGUpe2suZ2xvYmFsRXZhbChlLHQpfX0pfSxrLmZuLmV4dGVuZCh7d3JhcEFsbDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gdGhpc1swXSYmKG0oZSkmJihlPWUuY2FsbCh0aGlzWzBdKSksdD1rKGUsdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksdGhpc1swXS5wYXJlbnROb2RlJiZ0Lmluc2VydEJlZm9yZSh0aGlzWzBdKSx0Lm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXM7d2hpbGUoZS5maXJzdEVsZW1lbnRDaGlsZCllPWUuZmlyc3RFbGVtZW50Q2hpbGQ7cmV0dXJuIGV9KS5hcHBlbmQodGhpcykpLHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihuKXtyZXR1cm4gbShuKT90aGlzLmVhY2goZnVuY3Rpb24oZSl7ayh0aGlzKS53cmFwSW5uZXIobi5jYWxsKHRoaXMsZSkpfSk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9ayh0aGlzKSx0PWUuY29udGVudHMoKTt0Lmxlbmd0aD90LndyYXBBbGwobik6ZS5hcHBlbmQobil9KX0sd3JhcDpmdW5jdGlvbih0KXt2YXIgbj1tKHQpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oZSl7ayh0aGlzKS53cmFwQWxsKG4/dC5jYWxsKHRoaXMsZSk6dCl9KX0sdW53cmFwOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnBhcmVudChlKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKXtrKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KSx0aGlzfX0pLGsuZXhwci5wc2V1ZG9zLmhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4hay5leHByLnBzZXVkb3MudmlzaWJsZShlKX0say5leHByLnBzZXVkb3MudmlzaWJsZT1mdW5jdGlvbihlKXtyZXR1cm4hIShlLm9mZnNldFdpZHRofHxlLm9mZnNldEhlaWdodHx8ZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCl9LGsuYWpheFNldHRpbmdzLnhocj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IEMuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goZSl7fX07dmFyIFV0PXswOjIwMCwxMjIzOjIwNH0sWHQ9ay5hamF4U2V0dGluZ3MueGhyKCk7eS5jb3JzPSEhWHQmJlwid2l0aENyZWRlbnRpYWxzXCJpbiBYdCx5LmFqYXg9WHQ9ISFYdCxrLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oaSl7dmFyIG8sYTtpZih5LmNvcnN8fFh0JiYhaS5jcm9zc0RvbWFpbilyZXR1cm57c2VuZDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9aS54aHIoKTtpZihyLm9wZW4oaS50eXBlLGkudXJsLGkuYXN5bmMsaS51c2VybmFtZSxpLnBhc3N3b3JkKSxpLnhockZpZWxkcylmb3IobiBpbiBpLnhockZpZWxkcylyW25dPWkueGhyRmllbGRzW25dO2ZvcihuIGluIGkubWltZVR5cGUmJnIub3ZlcnJpZGVNaW1lVHlwZSYmci5vdmVycmlkZU1pbWVUeXBlKGkubWltZVR5cGUpLGkuY3Jvc3NEb21haW58fGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdfHwoZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl09XCJYTUxIdHRwUmVxdWVzdFwiKSxlKXIuc2V0UmVxdWVzdEhlYWRlcihuLGVbbl0pO289ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7byYmKG89YT1yLm9ubG9hZD1yLm9uZXJyb3I9ci5vbmFib3J0PXIub250aW1lb3V0PXIub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsXCJhYm9ydFwiPT09ZT9yLmFib3J0KCk6XCJlcnJvclwiPT09ZT9cIm51bWJlclwiIT10eXBlb2Ygci5zdGF0dXM/dCgwLFwiZXJyb3JcIik6dChyLnN0YXR1cyxyLnN0YXR1c1RleHQpOnQoVXRbci5zdGF0dXNdfHxyLnN0YXR1cyxyLnN0YXR1c1RleHQsXCJ0ZXh0XCIhPT0oci5yZXNwb25zZVR5cGV8fFwidGV4dFwiKXx8XCJzdHJpbmdcIiE9dHlwZW9mIHIucmVzcG9uc2VUZXh0P3tiaW5hcnk6ci5yZXNwb25zZX06e3RleHQ6ci5yZXNwb25zZVRleHR9LHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKX19LHIub25sb2FkPW8oKSxhPXIub25lcnJvcj1yLm9udGltZW91dD1vKFwiZXJyb3JcIiksdm9pZCAwIT09ci5vbmFib3J0P3Iub25hYm9ydD1hOnIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ND09PXIucmVhZHlTdGF0ZSYmQy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7byYmYSgpfSl9LG89byhcImFib3J0XCIpO3RyeXtyLnNlbmQoaS5oYXNDb250ZW50JiZpLmRhdGF8fG51bGwpfWNhdGNoKGUpe2lmKG8pdGhyb3cgZX19LGFib3J0OmZ1bmN0aW9uKCl7byYmbygpfX19KSxrLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oZSl7ZS5jcm9zc0RvbWFpbiYmKGUuY29udGVudHMuc2NyaXB0PSExKX0pLGsuYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6XCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwifSxjb250ZW50czp7c2NyaXB0Oi9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGUpe3JldHVybiBrLmdsb2JhbEV2YWwoZSksZX19fSksay5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oZSl7dm9pZCAwPT09ZS5jYWNoZSYmKGUuY2FjaGU9ITEpLGUuY3Jvc3NEb21haW4mJihlLnR5cGU9XCJHRVRcIil9KSxrLmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihuKXt2YXIgcixpO2lmKG4uY3Jvc3NEb21haW58fG4uc2NyaXB0QXR0cnMpcmV0dXJue3NlbmQ6ZnVuY3Rpb24oZSx0KXtyPWsoXCI8c2NyaXB0PlwiKS5hdHRyKG4uc2NyaXB0QXR0cnN8fHt9KS5wcm9wKHtjaGFyc2V0Om4uc2NyaXB0Q2hhcnNldCxzcmM6bi51cmx9KS5vbihcImxvYWQgZXJyb3JcIixpPWZ1bmN0aW9uKGUpe3IucmVtb3ZlKCksaT1udWxsLGUmJnQoXCJlcnJvclwiPT09ZS50eXBlPzQwNDoyMDAsZS50eXBlKX0pLEUuaGVhZC5hcHBlbmRDaGlsZChyWzBdKX0sYWJvcnQ6ZnVuY3Rpb24oKXtpJiZpKCl9fX0pO3ZhciBWdCxHdD1bXSxZdD0vKD0pXFw/KD89JnwkKXxcXD9cXD8vO2suYWpheFNldHVwKHtqc29ucDpcImNhbGxiYWNrXCIsanNvbnBDYWxsYmFjazpmdW5jdGlvbigpe3ZhciBlPUd0LnBvcCgpfHxrLmV4cGFuZG8rXCJfXCIra3QrKztyZXR1cm4gdGhpc1tlXT0hMCxlfX0pLGsuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIixmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGE9ITEhPT1lLmpzb25wJiYoWXQudGVzdChlLnVybCk/XCJ1cmxcIjpcInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYwPT09KGUuY29udGVudFR5cGV8fFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikmJll0LnRlc3QoZS5kYXRhKSYmXCJkYXRhXCIpO2lmKGF8fFwianNvbnBcIj09PWUuZGF0YVR5cGVzWzBdKXJldHVybiByPWUuanNvbnBDYWxsYmFjaz1tKGUuanNvbnBDYWxsYmFjayk/ZS5qc29ucENhbGxiYWNrKCk6ZS5qc29ucENhbGxiYWNrLGE/ZVthXT1lW2FdLnJlcGxhY2UoWXQsXCIkMVwiK3IpOiExIT09ZS5qc29ucCYmKGUudXJsKz0oU3QudGVzdChlLnVybCk/XCImXCI6XCI/XCIpK2UuanNvbnArXCI9XCIrciksZS5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4gb3x8ay5lcnJvcihyK1wiIHdhcyBub3QgY2FsbGVkXCIpLG9bMF19LGUuZGF0YVR5cGVzWzBdPVwianNvblwiLGk9Q1tyXSxDW3JdPWZ1bmN0aW9uKCl7bz1hcmd1bWVudHN9LG4uYWx3YXlzKGZ1bmN0aW9uKCl7dm9pZCAwPT09aT9rKEMpLnJlbW92ZVByb3Aocik6Q1tyXT1pLGVbcl0mJihlLmpzb25wQ2FsbGJhY2s9dC5qc29ucENhbGxiYWNrLEd0LnB1c2gocikpLG8mJm0oaSkmJmkob1swXSksbz1pPXZvaWQgMH0pLFwic2NyaXB0XCJ9KSx5LmNyZWF0ZUhUTUxEb2N1bWVudD0oKFZ0PUUuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHkpLmlubmVySFRNTD1cIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCIsMj09PVZ0LmNoaWxkTm9kZXMubGVuZ3RoKSxrLnBhcnNlSFRNTD1mdW5jdGlvbihlLHQsbil7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGU/W106KFwiYm9vbGVhblwiPT10eXBlb2YgdCYmKG49dCx0PSExKSx0fHwoeS5jcmVhdGVIVE1MRG9jdW1lbnQ/KChyPSh0PUUuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpKS5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKSkuaHJlZj1FLmxvY2F0aW9uLmhyZWYsdC5oZWFkLmFwcGVuZENoaWxkKHIpKTp0PUUpLG89IW4mJltdLChpPUQuZXhlYyhlKSk/W3QuY3JlYXRlRWxlbWVudChpWzFdKV06KGk9d2UoW2VdLHQsbyksbyYmby5sZW5ndGgmJmsobykucmVtb3ZlKCksay5tZXJnZShbXSxpLmNoaWxkTm9kZXMpKSk7dmFyIHIsaSxvfSxrLmZuLmxvYWQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhPXRoaXMscz1lLmluZGV4T2YoXCIgXCIpO3JldHVybi0xPHMmJihyPW10KGUuc2xpY2UocykpLGU9ZS5zbGljZSgwLHMpKSxtKHQpPyhuPXQsdD12b2lkIDApOnQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYoaT1cIlBPU1RcIiksMDxhLmxlbmd0aCYmay5hamF4KHt1cmw6ZSx0eXBlOml8fFwiR0VUXCIsZGF0YVR5cGU6XCJodG1sXCIsZGF0YTp0fSkuZG9uZShmdW5jdGlvbihlKXtvPWFyZ3VtZW50cyxhLmh0bWwocj9rKFwiPGRpdj5cIikuYXBwZW5kKGsucGFyc2VIVE1MKGUpKS5maW5kKHIpOmUpfSkuYWx3YXlzKG4mJmZ1bmN0aW9uKGUsdCl7YS5lYWNoKGZ1bmN0aW9uKCl7bi5hcHBseSh0aGlzLG98fFtlLnJlc3BvbnNlVGV4dCx0LGVdKX0pfSksdGhpc30say5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oZSx0KXtrLmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKHQsZSl9fSksay5leHByLnBzZXVkb3MuYW5pbWF0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGsuZ3JlcChrLnRpbWVycyxmdW5jdGlvbihlKXtyZXR1cm4gdD09PWUuZWxlbX0pLmxlbmd0aH0say5vZmZzZXQ9e3NldE9mZnNldDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGw9ay5jc3MoZSxcInBvc2l0aW9uXCIpLGM9ayhlKSxmPXt9O1wic3RhdGljXCI9PT1sJiYoZS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpLHM9Yy5vZmZzZXQoKSxvPWsuY3NzKGUsXCJ0b3BcIiksdT1rLmNzcyhlLFwibGVmdFwiKSwoXCJhYnNvbHV0ZVwiPT09bHx8XCJmaXhlZFwiPT09bCkmJi0xPChvK3UpLmluZGV4T2YoXCJhdXRvXCIpPyhhPShyPWMucG9zaXRpb24oKSkudG9wLGk9ci5sZWZ0KTooYT1wYXJzZUZsb2F0KG8pfHwwLGk9cGFyc2VGbG9hdCh1KXx8MCksbSh0KSYmKHQ9dC5jYWxsKGUsbixrLmV4dGVuZCh7fSxzKSkpLG51bGwhPXQudG9wJiYoZi50b3A9dC50b3Atcy50b3ArYSksbnVsbCE9dC5sZWZ0JiYoZi5sZWZ0PXQubGVmdC1zLmxlZnQraSksXCJ1c2luZ1wiaW4gdD90LnVzaW5nLmNhbGwoZSxmKTpjLmNzcyhmKX19LGsuZm4uZXh0ZW5kKHtvZmZzZXQ6ZnVuY3Rpb24odCl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdm9pZCAwPT09dD90aGlzOnRoaXMuZWFjaChmdW5jdGlvbihlKXtrLm9mZnNldC5zZXRPZmZzZXQodGhpcyx0LGUpfSk7dmFyIGUsbixyPXRoaXNbMF07cmV0dXJuIHI/ci5nZXRDbGllbnRSZWN0cygpLmxlbmd0aD8oZT1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49ci5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LHt0b3A6ZS50b3Arbi5wYWdlWU9mZnNldCxsZWZ0OmUubGVmdCtuLnBhZ2VYT2Zmc2V0fSk6e3RvcDowLGxlZnQ6MH06dm9pZCAwfSxwb3NpdGlvbjpmdW5jdGlvbigpe2lmKHRoaXNbMF0pe3ZhciBlLHQsbixyPXRoaXNbMF0saT17dG9wOjAsbGVmdDowfTtpZihcImZpeGVkXCI9PT1rLmNzcyhyLFwicG9zaXRpb25cIikpdD1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2Vsc2V7dD10aGlzLm9mZnNldCgpLG49ci5vd25lckRvY3VtZW50LGU9ci5vZmZzZXRQYXJlbnR8fG4uZG9jdW1lbnRFbGVtZW50O3doaWxlKGUmJihlPT09bi5ib2R5fHxlPT09bi5kb2N1bWVudEVsZW1lbnQpJiZcInN0YXRpY1wiPT09ay5jc3MoZSxcInBvc2l0aW9uXCIpKWU9ZS5wYXJlbnROb2RlO2UmJmUhPT1yJiYxPT09ZS5ub2RlVHlwZSYmKChpPWsoZSkub2Zmc2V0KCkpLnRvcCs9ay5jc3MoZSxcImJvcmRlclRvcFdpZHRoXCIsITApLGkubGVmdCs9ay5jc3MoZSxcImJvcmRlckxlZnRXaWR0aFwiLCEwKSl9cmV0dXJue3RvcDp0LnRvcC1pLnRvcC1rLmNzcyhyLFwibWFyZ2luVG9wXCIsITApLGxlZnQ6dC5sZWZ0LWkubGVmdC1rLmNzcyhyLFwibWFyZ2luTGVmdFwiLCEwKX19fSxvZmZzZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9mZnNldFBhcmVudDt3aGlsZShlJiZcInN0YXRpY1wiPT09ay5jc3MoZSxcInBvc2l0aW9uXCIpKWU9ZS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGV8fGllfSl9fSksay5lYWNoKHtzY3JvbGxMZWZ0OlwicGFnZVhPZmZzZXRcIixzY3JvbGxUb3A6XCJwYWdlWU9mZnNldFwifSxmdW5jdGlvbih0LGkpe3ZhciBvPVwicGFnZVlPZmZzZXRcIj09PWk7ay5mblt0XT1mdW5jdGlvbihlKXtyZXR1cm4gXyh0aGlzLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZih4KGUpP3I9ZTo5PT09ZS5ub2RlVHlwZSYmKHI9ZS5kZWZhdWx0Vmlldyksdm9pZCAwPT09bilyZXR1cm4gcj9yW2ldOmVbdF07cj9yLnNjcm9sbFRvKG8/ci5wYWdlWE9mZnNldDpuLG8/bjpyLnBhZ2VZT2Zmc2V0KTplW3RdPW59LHQsZSxhcmd1bWVudHMubGVuZ3RoKX19KSxrLmVhY2goW1widG9wXCIsXCJsZWZ0XCJdLGZ1bmN0aW9uKGUsbil7ay5jc3NIb29rc1tuXT16ZSh5LnBpeGVsUG9zaXRpb24sZnVuY3Rpb24oZSx0KXtpZih0KXJldHVybiB0PV9lKGUsbiksJGUudGVzdCh0KT9rKGUpLnBvc2l0aW9uKClbbl0rXCJweFwiOnR9KX0pLGsuZWFjaCh7SGVpZ2h0OlwiaGVpZ2h0XCIsV2lkdGg6XCJ3aWR0aFwifSxmdW5jdGlvbihhLHMpe2suZWFjaCh7cGFkZGluZzpcImlubmVyXCIrYSxjb250ZW50OnMsXCJcIjpcIm91dGVyXCIrYX0sZnVuY3Rpb24ocixvKXtrLmZuW29dPWZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aCYmKHJ8fFwiYm9vbGVhblwiIT10eXBlb2YgZSksaT1yfHwoITA9PT1lfHwhMD09PXQ/XCJtYXJnaW5cIjpcImJvcmRlclwiKTtyZXR1cm4gXyh0aGlzLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtyZXR1cm4geChlKT8wPT09by5pbmRleE9mKFwib3V0ZXJcIik/ZVtcImlubmVyXCIrYV06ZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIithXTo5PT09ZS5ub2RlVHlwZT8ocj1lLmRvY3VtZW50RWxlbWVudCxNYXRoLm1heChlLmJvZHlbXCJzY3JvbGxcIithXSxyW1wic2Nyb2xsXCIrYV0sZS5ib2R5W1wib2Zmc2V0XCIrYV0scltcIm9mZnNldFwiK2FdLHJbXCJjbGllbnRcIithXSkpOnZvaWQgMD09PW4/ay5jc3MoZSx0LGkpOmsuc3R5bGUoZSx0LG4saSl9LHMsbj9lOnZvaWQgMCxuKX19KX0pLGsuZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSxuKXtrLmZuW25dPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA8YXJndW1lbnRzLmxlbmd0aD90aGlzLm9uKG4sbnVsbCxlLHQpOnRoaXMudHJpZ2dlcihuKX19KSxrLmZuLmV4dGVuZCh7aG92ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGUpLm1vdXNlbGVhdmUodHx8ZSl9fSksay5mbi5leHRlbmQoe2JpbmQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLm9uKGUsbnVsbCx0LG4pfSx1bmJpbmQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vZmYoZSxudWxsLHQpfSxkZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbih0LGUsbixyKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGUsXCIqKlwiKTp0aGlzLm9mZih0LGV8fFwiKipcIixuKX19KSxrLnByb3h5PWZ1bmN0aW9uKGUsdCl7dmFyIG4scixpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYobj1lW3RdLHQ9ZSxlPW4pLG0oZSkpcmV0dXJuIHI9cy5jYWxsKGFyZ3VtZW50cywyKSwoaT1mdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHR8fHRoaXMsci5jb25jYXQocy5jYWxsKGFyZ3VtZW50cykpKX0pLmd1aWQ9ZS5ndWlkPWUuZ3VpZHx8ay5ndWlkKyssaX0say5ob2xkUmVhZHk9ZnVuY3Rpb24oZSl7ZT9rLnJlYWR5V2FpdCsrOmsucmVhZHkoITApfSxrLmlzQXJyYXk9QXJyYXkuaXNBcnJheSxrLnBhcnNlSlNPTj1KU09OLnBhcnNlLGsubm9kZU5hbWU9QSxrLmlzRnVuY3Rpb249bSxrLmlzV2luZG93PXgsay5jYW1lbENhc2U9VixrLnR5cGU9dyxrLm5vdz1EYXRlLm5vdyxrLmlzTnVtZXJpYz1mdW5jdGlvbihlKXt2YXIgdD1rLnR5cGUoZSk7cmV0dXJuKFwibnVtYmVyXCI9PT10fHxcInN0cmluZ1wiPT09dCkmJiFpc05hTihlLXBhcnNlRmxvYXQoZSkpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZShcImpxdWVyeVwiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KTt2YXIgUXQ9Qy5qUXVlcnksSnQ9Qy4kO3JldHVybiBrLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIEMuJD09PWsmJihDLiQ9SnQpLGUmJkMualF1ZXJ5PT09ayYmKEMualF1ZXJ5PVF0KSxrfSxlfHwoQy5qUXVlcnk9Qy4kPWspLGt9KTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgbmcxICovIC8qKiAqL1xuaW1wb3J0ICogYXMgbmdfZnJvbV9pbXBvcnQgZnJvbSAnYW5ndWxhcic7XG4vKiogQGhpZGRlbiAqLyBkZWNsYXJlIHZhciBhbmd1bGFyO1xuLyoqIEBoaWRkZW4gKi8gY29uc3QgbmdfZnJvbV9nbG9iYWwgPSBhbmd1bGFyO1xuLyoqIEBoaWRkZW4gKi8gZXhwb3J0IGNvbnN0IG5nID0gbmdfZnJvbV9pbXBvcnQgJiYgbmdfZnJvbV9pbXBvcnQubW9kdWxlID8gbmdfZnJvbV9pbXBvcnQgOiBuZ19mcm9tX2dsb2JhbDtcbiIsIi8qKlxuICogSGlnaGVyIG9yZGVyIGZ1bmN0aW9uc1xuICpcbiAqIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9ob2ZcbiAqLyAvKiogKi9cblxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi9jb21tb24nO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGZvciBbUGFydGlhbCBBcHBsaWNhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbF9hcHBsaWNhdGlvbikgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICpcbiAqIEdpdmVuIGEgZnVuY3Rpb24gd2l0aCBOIHBhcmFtZXRlcnMsIHJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBzdXBwb3J0cyBwYXJ0aWFsIGFwcGxpY2F0aW9uLlxuICogVGhlIG5ldyBmdW5jdGlvbiBhY2NlcHRzIGFueXdoZXJlIGZyb20gMSB0byBOIHBhcmFtZXRlcnMuICBXaGVuIHRoYXQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggTSBwYXJhbWV0ZXJzLFxuICogd2hlcmUgTSBpcyBsZXNzIHRoYW4gTiwgaXQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLiAgSXQgY29udGludWVzIHRvXG4gKiBhY2NlcHQgbW9yZSBwYXJhbWV0ZXJzIHVudGlsIGFsbCBOIHBhcmFtZXRlcnMgaGF2ZSBiZWVuIHN1cHBsaWVkLlxuICpcbiAqXG4gKiBUaGlzIGNvbnRyaXZlZCBleGFtcGxlIHVzZXMgYSBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbiBhcyBhbiBwcmVkaWNhdGUsIHdoaWNoIHJldHVybnMgdHJ1ZVxuICogaWYgYW4gb2JqZWN0IGlzIGZvdW5kIGluIGJvdGggYXJyYXlzLlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogLy8gcmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBpcyBpbiBib3RoIG9mIHRoZSB0d28gYXJyYXlzXG4gKiBmdW5jdGlvbiBpbkJvdGgoYXJyYXkxLCBhcnJheTIsIG9iamVjdCkge1xuICogICByZXR1cm4gYXJyYXkxLmluZGV4T2Yob2JqZWN0KSAhPT0gLTEgJiZcbiAqICAgICAgICAgIGFycmF5Mi5pbmRleE9mKG9iamVjdCkgIT09IDE7XG4gKiB9XG4gKiBsZXQgb2JqMSwgb2JqMiwgb2JqMywgb2JqNCwgb2JqNSwgb2JqNiwgb2JqN1xuICogbGV0IGZvb3MgPSBbb2JqMSwgb2JqM11cbiAqIGxldCBiYXJzID0gW29iajMsIG9iajQsIG9iajVdXG4gKlxuICogLy8gQSBjdXJyaWVkIFwiY29weVwiIG9mIGluQm90aFxuICogbGV0IGN1cnJpZWRJbkJvdGggPSBjdXJyeShpbkJvdGgpO1xuICogLy8gUGFydGlhbGx5IGFwcGx5IGJvdGggdGhlIGFycmF5MSBhbmQgYXJyYXkyXG4gKiBsZXQgaW5Gb29zQW5kQmFycyA9IGN1cnJpZWRJbkJvdGgoZm9vcywgYmFycyk7XG4gKlxuICogLy8gU3VwcGx5IHRoZSBmaW5hbCBhcmd1bWVudDsgc2luY2UgYWxsIGFyZ3VtZW50cyBhcmVcbiAqIC8vIHN1cHBsaWVkLCB0aGUgb3JpZ2luYWwgaW5Cb3RoIGZ1bmN0aW9uIGlzIHRoZW4gY2FsbGVkLlxuICogbGV0IG9iajFJbkJvdGggPSBpbkZvb3NBbmRCYXJzKG9iajEpOyAvLyBmYWxzZVxuICpcbiAqIC8vIFVzZSB0aGUgaW5Gb29zQW5kQmFycyBhcyBhIHByZWRpY2F0ZS5cbiAqIC8vIEZpbHRlciwgb24gZWFjaCBpdGVyYXRpb24sIHN1cHBsaWVzIHRoZSBmaW5hbCBhcmd1bWVudFxuICogbGV0IGFsbE9ianMgPSBbIG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYsIG9iajcgXTtcbiAqIGxldCBmb3VuZEluQm90aCA9IGFsbE9ianMuZmlsdGVyKGluRm9vc0FuZEJhcnMpOyAvLyBbIG9iajMgXVxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBmblxuICogQHJldHVybnMgeyp8ZnVuY3Rpb24oKTogKCp8YW55KX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1cnJ5KGZuOiBGdW5jdGlvbik6IEZ1bmN0aW9uIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWQoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gZm4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGN1cnJpZWQuYmluZCh0aGlzLCAuLi5hcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHZhcmFyZ3MgbGlzdCBvZiBmdW5jdGlvbnMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMsIHJpZ2h0LXRvLWxlZnRcbiAqIGdpdmVuOiBmKHgpLCBnKHgpLCBoKHgpXG4gKiBsZXQgY29tcG9zZWQgPSBjb21wb3NlKGYsZyxoKVxuICogdGhlbiwgY29tcG9zZWQgaXM6IGYoZyhoKHgpKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gIGNvbnN0IHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGkgPSBzdGFydCxcbiAgICAgIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHZhcmFyZ3MgbGlzdCBvZiBmdW5jdGlvbnMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIGNvbXBvc2VzIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMsIGxlZnQtdG8tcmlnaHRcbiAqIGdpdmVuOiBmKHgpLCBnKHgpLCBoKHgpXG4gKiBsZXQgcGlwZWQgPSBwaXBlKGYsZyxoKTtcbiAqIHRoZW4sIHBpcGVkIGlzOiBoKGcoZih4KSkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXBlKC4uLmZ1bmNzOiBGdW5jdGlvbltdKTogKG9iajogYW55KSA9PiBhbnkge1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhhdCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdFxuICogbGV0IG9iaiA9IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfTtcbiAqIGxldCBnZXROYW1lID0gcHJvcChcIm5hbWVcIik7XG4gKiBnZXROYW1lKG9iaikgPT09IFwiYmxhcmdcIlxuICovXG5leHBvcnQgY29uc3QgcHJvcCA9IChuYW1lOiBzdHJpbmcpID0+IChvYmo6IGFueSkgPT4gb2JqICYmIG9ialtuYW1lXTtcblxuLyoqXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUgYW5kIGEgdmFsdWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIGJhc2VkIG9uIHdoZXRoZXJcbiAqIHRoZSBwYXNzZWQgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoYXQgbWF0Y2hlcyB0aGUgdmFsdWVcbiAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3BFcShcIm5hbWVcIiwgXCJibGFyZ1wiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gdHJ1ZVxuICovXG5leHBvcnQgY29uc3QgcHJvcEVxID0gY3VycnkoKG5hbWU6IHN0cmluZywgX3ZhbDogYW55LCBvYmo6IGFueSkgPT4gb2JqICYmIG9ialtuYW1lXSA9PT0gX3ZhbCk7XG5cbi8qKlxuICogR2l2ZW4gYSBkb3R0ZWQgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gKiBsZXQgb2JqID0geyBpZDogMSwgbmVzdGVkT2JqOiB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH0sIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3AoXCJuZXN0ZWRPYmoubmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKiBsZXQgcHJvcE5vdEZvdW5kID0gcHJvcChcInRoaXMucHJvcGVydHkuZG9lc250LmV4aXN0XCIpO1xuICogcHJvcE5vdEZvdW5kKG9iaikgPT09IHVuZGVmaW5lZFxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSAobmFtZTogc3RyaW5nKSA9PiBwaXBlLmFwcGx5KG51bGwsIG5hbWUuc3BsaXQoJy4nKS5tYXAocHJvcCkpO1xuXG4vKipcbiAqIEdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZSwgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9wcG9zaXRlIChmYWxzZXkgb3IgdHJ1dGh5KSB2YWx1ZSBnaXZlbiB0aGUgc2FtZSBpbnB1dHNcbiAqL1xuZXhwb3J0IGNvbnN0IG5vdDogKGZuOiBQcmVkaWNhdGU8YW55PikgPT4gUHJlZGljYXRlPGFueT4gPSAoZm46IFByZWRpY2F0ZTxhbnk+KSA9PiAoLi4uYXJnczogYW55W10pID0+XG4gICFmbi5hcHBseShudWxsLCBhcmdzKTtcblxuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxuICogaWYgYm90aCBmdW5jdGlvbnMgcmV0dXJuIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYW5kKGZuMTogUHJlZGljYXRlPGFueT4sIGZuMjogUHJlZGljYXRlPGFueT4pOiBQcmVkaWNhdGU8YW55PiB7XG4gIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IGZuMS5hcHBseShudWxsLCBhcmdzKSAmJiBmbjIuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbi8qKlxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnV0aHlcbiAqIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcihmbjE6IFByZWRpY2F0ZTxhbnk+LCBmbjI6IFByZWRpY2F0ZTxhbnk+KTogUHJlZGljYXRlPGFueT4ge1xuICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiBmbjEuYXBwbHkobnVsbCwgYXJncykgfHwgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFsbCB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgbWF0Y2ggYSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZm4xIGEgcHJlZGljYXRlIGZ1bmN0aW9uIGBmbjFgXG4gKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGFuIGFycmF5IGFuZCByZXR1cm5zIHRydWUgaWYgYGZuMWAgaXMgdHJ1ZSBmb3IgYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICovXG5leHBvcnQgY29uc3QgYWxsID0gKGZuMTogUHJlZGljYXRlPGFueT4pID0+IChhcnI6IGFueVtdKSA9PiBhcnIucmVkdWNlKChiLCB4KSA9PiBiICYmICEhZm4xKHgpLCB0cnVlKSBhcyBib29sZWFuO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuZXhwb3J0IGNvbnN0IGFueSA9IChmbjE6IFByZWRpY2F0ZTxhbnk+KSA9PiAoYXJyOiBhbnlbXSkgPT4gYXJyLnJlZHVjZSgoYiwgeCkgPT4gYiB8fCAhIWZuMSh4KSwgZmFsc2UpIGFzIGJvb2xlYW47XG5cbi8qKiBHaXZlbiBhIGNsYXNzLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb2YgdGhhdCBjbGFzcyAqL1xuZXhwb3J0IGNvbnN0IGlzID0gPFQ+KGN0b3I6IHsgbmV3ICguLi5hcmdzKTogVCB9KSA9PiAob2JqOiBhbnkpOiBvYmogaXMgVCA9PlxuICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBjdG9yKSB8fCBvYmogaW5zdGFuY2VvZiBjdG9yO1xuXG4vKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIFByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbm90aGVyIHZhbHVlIGlzID09PSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgdmFsdWUgKi9cbmV4cG9ydCBjb25zdCBlcTogKGNvbXA6IGFueSkgPT4gUHJlZGljYXRlPGFueT4gPSAodmFsdWU6IGFueSkgPT4gKG90aGVyOiBhbnkpID0+IHZhbHVlID09PSBvdGhlcjtcblxuLyoqIEdpdmVuIGEgdmFsdWUsIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSB2YWx1ZSAqL1xuZXhwb3J0IGNvbnN0IHZhbCA9IDxUPih2OiBUKSA9PiAoKSA9PiB2O1xuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlKGZuTmFtZTogc3RyaW5nKTogRnVuY3Rpb247XG5leHBvcnQgZnVuY3Rpb24gaW52b2tlKGZuTmFtZTogc3RyaW5nLCBhcmdzOiBhbnlbXSk6IEZ1bmN0aW9uO1xuZXhwb3J0IGZ1bmN0aW9uIGludm9rZShmbk5hbWU6IHN0cmluZywgYXJncz86IGFueVtdKTogRnVuY3Rpb24ge1xuICByZXR1cm4gKG9iajogYW55KSA9PiBvYmpbZm5OYW1lXS5hcHBseShvYmosIGFyZ3MpO1xufVxuXG4vKipcbiAqIFNvcnRhIGxpa2UgUGF0dGVybiBNYXRjaGluZyAoYSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGNvbmRpdGlvbmFsIGNvbnN0cnVjdClcbiAqXG4gKiBTZWUgaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9QYXR0ZXJuTWF0Y2hpbmdcbiAqXG4gKiBUaGlzIGlzIGEgY29uZGl0aW9uYWwgY29uc3RydWN0IHdoaWNoIGFsbG93cyBhIHNlcmllcyBvZiBwcmVkaWNhdGVzIGFuZCBvdXRwdXQgZnVuY3Rpb25zXG4gKiB0byBiZSBjaGVja2VkIGFuZCB0aGVuIGFwcGxpZWQuICBFYWNoIHByZWRpY2F0ZSByZWNlaXZlcyB0aGUgaW5wdXQuICBJZiB0aGUgcHJlZGljYXRlXG4gKiByZXR1cm5zIHRydXRoeSwgdGhlbiBpdHMgbWF0Y2hpbmcgb3V0cHV0IGZ1bmN0aW9uIChtYXBwaW5nIGZ1bmN0aW9uKSBpcyBwcm92aWRlZCB3aXRoXG4gKiB0aGUgaW5wdXQgYW5kLCB0aGVuIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gKlxuICogRWFjaCBjb21iaW5hdGlvbiAoMi10dXBsZSkgb2YgcHJlZGljYXRlICsgb3V0cHV0IGZ1bmN0aW9uIHNob3VsZCBiZSBwbGFjZWQgaW4gYW4gYXJyYXlcbiAqIG9mIHNpemUgMjogWyBwcmVkaWNhdGUsIG1hcEZuIF1cbiAqXG4gKiBUaGVzZSAyLXR1cGxlcyBzaG91bGQgYmUgcHV0IGluIGFuIG91dGVyIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiAvLyBIZXJlJ3MgYSAyLXR1cGxlIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBpc1N0cmluZyBwcmVkaWNhdGVcbiAqIC8vIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaW5wdXRcbiAqIGxldCBmaXJzdFR1cGxlID0gWyBhbmd1bGFyLmlzU3RyaW5nLCAoaW5wdXQpID0+IGBIZXJlcyB5b3VyIHN0cmluZyAke2lucHV0fWAgXTtcbiAqXG4gKiAvLyBTZWNvbmQgdHVwbGU6IHByZWRpY2F0ZSBcImlzTnVtYmVyXCIsIG1hcGZuIHJldHVybnMgYSBkZXNjcmlwdGlvblxuICogbGV0IHNlY29uZFR1cGxlID0gWyBhbmd1bGFyLmlzTnVtYmVyLCAoaW5wdXQpID0+IGAoJHtpbnB1dH0pIFRoYXQncyBhIG51bWJlciFgIF07XG4gKlxuICogbGV0IHRoaXJkID0gWyAoaW5wdXQpID0+IGlucHV0ID09PSBudWxsLCAgKGlucHV0KSA9PiBgT2gsIG51bGwuLi5gIF07XG4gKlxuICogbGV0IGZvdXJ0aCA9IFsgKGlucHV0KSA9PiBpbnB1dCA9PT0gdW5kZWZpbmVkLCAgKGlucHV0KSA9PiBgbm90ZGVmaW5lZGAgXTtcbiAqXG4gKiBsZXQgZGVzY3JpcHRpb25PZiA9IHBhdHRlcm4oWyBmaXJzdFR1cGxlLCBzZWNvbmRUdXBsZSwgdGhpcmQsIGZvdXJ0aCBdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhkZXNjcmlwdGlvbk9mKHVuZGVmaW5lZCkpOyAvLyAnbm90ZGVmaW5lZCdcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YoNTUpKTsgLy8gJyg1NSkgVGhhdCdzIGEgbnVtYmVyISdcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YoXCJmb29cIikpOyAvLyAnSGVyZSdzIHlvdXIgc3RyaW5nIGZvbydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgQSAyRCBhcnJheS4gIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgc2hvdWxkIGJlIGFuIGFycmF5LCBhIDItdHVwbGUsXG4gKiB3aXRoIGEgUHJlZGljYXRlIGFuZCBhIG1hcHBpbmcvb3V0cHV0IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oYW55KTogKn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0OiBGdW5jdGlvbltdW10pOiBGdW5jdGlvbiB7XG4gIHJldHVybiBmdW5jdGlvbih4OiBhbnkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cnVjdFtpXVswXSh4KSkgcmV0dXJuIHN0cnVjdFtpXVsxXSh4KTtcbiAgICB9XG4gIH07XG59XG4iLCIvKiogUHJlZGljYXRlc1xuICpcbiAqIFRoZXNlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUvZmFsc2UgYmFzZWQgb24gdGhlIGlucHV0LlxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25fcHJlZGljYXRlc1xuICovIC8qKiAqL1xuaW1wb3J0IHsgYW5kLCBub3QsIHBpcGUsIHByb3AsIG9yIH0gZnJvbSAnLi9ob2YnO1xuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi9jb21tb24nOyAvLyBoYXMgb3IgaXMgdXNpbmdcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuXG5jb25zdCB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0aXMgPSAodDogc3RyaW5nKSA9PiAoeDogYW55KSA9PiB0eXBlb2YgeCA9PT0gdDtcbmV4cG9ydCBjb25zdCBpc1VuZGVmaW5lZCA9IHRpcygndW5kZWZpbmVkJyk7XG5leHBvcnQgY29uc3QgaXNEZWZpbmVkID0gbm90KGlzVW5kZWZpbmVkKTtcbmV4cG9ydCBjb25zdCBpc051bGwgPSAobzogYW55KSA9PiBvID09PSBudWxsO1xuZXhwb3J0IGNvbnN0IGlzTnVsbE9yVW5kZWZpbmVkID0gb3IoaXNOdWxsLCBpc1VuZGVmaW5lZCk7XG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbjogKHg6IGFueSkgPT4geCBpcyBGdW5jdGlvbiA9IDxhbnk+dGlzKCdmdW5jdGlvbicpO1xuZXhwb3J0IGNvbnN0IGlzTnVtYmVyOiAoeDogYW55KSA9PiB4IGlzIG51bWJlciA9IDxhbnk+dGlzKCdudW1iZXInKTtcbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IDwoeDogYW55KSA9PiB4IGlzIHN0cmluZz50aXMoJ3N0cmluZycpO1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHg6IGFueSkgPT4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5leHBvcnQgY29uc3QgaXNEYXRlOiAoeDogYW55KSA9PiB4IGlzIERhdGUgPSA8YW55PigoeDogYW55KSA9PiB0b1N0ci5jYWxsKHgpID09PSAnW29iamVjdCBEYXRlXScpO1xuZXhwb3J0IGNvbnN0IGlzUmVnRXhwOiAoeDogYW55KSA9PiB4IGlzIFJlZ0V4cCA9IDxhbnk+KCh4OiBhbnkpID0+IHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKTtcblxuLyoqXG4gKiBQcmVkaWNhdGUgd2hpY2ggY2hlY2tzIGlmIGEgdmFsdWUgaXMgaW5qZWN0YWJsZVxuICpcbiAqIEEgdmFsdWUgaXMgXCJpbmplY3RhYmxlXCIgaWYgaXQgaXMgYSBmdW5jdGlvbiwgb3IgaWYgaXQgaXMgYW4gbmcxIGFycmF5LW5vdGF0aW9uLXN0eWxlIGFycmF5XG4gKiB3aGVyZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheSBhcmUgU3RyaW5ncywgZXhjZXB0IHRoZSBsYXN0IG9uZSwgd2hpY2ggaXMgYSBGdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbmplY3RhYmxlKHZhbDogYW55KSB7XG4gIGlmIChpc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCkge1xuICAgIGNvbnN0IGhlYWQgPSB2YWwuc2xpY2UoMCwgLTEpLFxuICAgICAgdGFpbCA9IHZhbC5zbGljZSgtMSk7XG4gICAgcmV0dXJuICEoaGVhZC5maWx0ZXIobm90KGlzU3RyaW5nKSkubGVuZ3RoIHx8IHRhaWwuZmlsdGVyKG5vdChpc0Z1bmN0aW9uKSkubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gaXNGdW5jdGlvbih2YWwpO1xufVxuXG4vKipcbiAqIFByZWRpY2F0ZSB3aGljaCBjaGVja3MgaWYgYSB2YWx1ZSBsb29rcyBsaWtlIGEgUHJvbWlzZVxuICpcbiAqIEl0IGlzIHByb2JhYmx5IGEgUHJvbWlzZSBpZiBpdCdzIGFuIG9iamVjdCwgYW5kIGl0IGhhcyBhIGB0aGVuYCBwcm9wZXJ0eSB3aGljaCBpcyBhIEZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSA8KHg6IGFueSkgPT4geCBpcyBQcm9taXNlPGFueT4+YW5kKFxuICBpc09iamVjdCxcbiAgcGlwZShcbiAgICBwcm9wKCd0aGVuJyksXG4gICAgaXNGdW5jdGlvblxuICApXG4pO1xuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBpcyBhIHN0dWIgZm9yIGNvcmUgc2VydmljZXMgc3VjaCBhcyBEZXBlbmRlbmN5IEluamVjdGlvbiBvciBCcm93c2VyIExvY2F0aW9uLlxuICogQ29yZSBzZXJ2aWNlcyBtYXkgYmUgaW1wbGVtZW50ZWQgYnkgYSBzcGVjaWZpYyBmcmFtZXdvcmssIHN1Y2ggYXMgbmcxIG9yIG5nMiwgb3IgYmUgcHVyZSBqYXZhc2NyaXB0LlxuICpcbiAqIEBwdWJsaWNhcGkgQG1vZHVsZSBjb21tb25cbiAqLyAvKiogKi9cbmltcG9ydCB7IElJbmplY3RhYmxlLCBPYmogfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFVybENvbmZpZywgVXJsU2VydmljZSB9IGZyb20gJy4uL3VybCc7XG5cbmNvbnN0IG5vSW1wbCA9IChmbm5hbWU6IHN0cmluZykgPT4gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYE5vIGltcGxlbWVudGF0aW9uIGZvciAke2ZubmFtZX0uIFRoZSBmcmFtZXdvcmsgc3BlY2lmaWMgY29kZSBkaWQgbm90IGltcGxlbWVudCB0aGlzIG1ldGhvZC5gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYWtlU3R1YiA9IDxUPihzZXJ2aWNlOiBzdHJpbmcsIG1ldGhvZHM6IChrZXlvZiBUKVtdKTogVCA9PlxuICBtZXRob2RzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICgoYWNjW2tleV0gPSBub0ltcGwoYCR7c2VydmljZX0uJHtrZXl9KClgKSBhcyBhbnkpLCBhY2MpLCB7fSBhcyBUKTtcblxuY29uc3Qgc2VydmljZXM6IENvcmVTZXJ2aWNlcyA9IHtcbiAgJHE6IHVuZGVmaW5lZCxcbiAgJGluamVjdG9yOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlICRRTGlrZURlZmVycmVkIHtcbiAgcmVzb2x2ZTogKHZhbD86IGFueSkgPT4gdm9pZDtcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuICBwcm9taXNlOiBQcm9taXNlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgJFFMaWtlIHtcbiAgd2hlbjxUPih2YWx1ZT86IFQgfCBQcm9taXNlTGlrZTxUPik6IFByb21pc2U8VD47XG4gIHJlamVjdDxUPihyZWFzb246IGFueSk6IFByb21pc2U8VD47XG4gIGRlZmVyKCk6ICRRTGlrZURlZmVycmVkO1xuICBhbGwocHJvbWlzZXM6IHsgW2tleTogc3RyaW5nXTogUHJvbWlzZTxhbnk+IH0pOiBQcm9taXNlPGFueT47XG4gIGFsbChwcm9taXNlczogUHJvbWlzZTxhbnk+W10pOiBQcm9taXNlPGFueVtdPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSAkSW5qZWN0b3JMaWtlIHtcbiAgc3RyaWN0RGk/OiBib29sZWFuO1xuICBnZXQodG9rZW46IGFueSk6IGFueTtcbiAgZ2V0PFQ+KHRva2VuOiBhbnkpOiBUO1xuICBoYXModG9rZW46IGFueSk6IGJvb2xlYW47XG4gIGludm9rZShmbjogSUluamVjdGFibGUsIGNvbnRleHQ/OiBhbnksIGxvY2Fscz86IE9iaik6IGFueTtcbiAgYW5ub3RhdGUoZm46IElJbmplY3RhYmxlLCBzdHJpY3REaT86IGJvb2xlYW4pOiBhbnlbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb3JlU2VydmljZXMge1xuICAkcTogJFFMaWtlO1xuICAkaW5qZWN0b3I6ICRJbmplY3Rvckxpa2U7XG59XG5cbi8qKlxuICogSGFuZGxlcyBsb3cgbGV2ZWwgVVJMIHJlYWQvd3JpdGVcbiAqXG4gKiBUaGlzIHNlcnZpY2UgaGFuZGxlcyBsb3cgbGV2ZWwgcmVhZHMgYW5kIHVwZGF0ZXMgb2YgdGhlIFVSTCBhbmQgbGlzdGVucyBmb3IgdXJsIGNoYW5nZXMuXG4gKiBJbXBsZW1lbnRvcnMgc2hvdWxkIHBhc3MgdGhlc2UgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBVUkwgbWVjaGFuaXNtLlxuICogVGhlIHVuZGVybHlpbmcgVVJMIG1lY2hhbmlzbSBtaWdodCBiZSBicm93c2VyIEFQSXMsIGZyYW1ld29yayBBUElzLCBvciBzb21lIDNyZCBwYXJ0eSBVUkwgbWFuYWdlbWVudCBsaWJyYXJ5LlxuICpcbiAqIFVJLVJvdXRlciBDb3JlIGluY2x1ZGVzIHRocmVlIGJhc2ljIGltcGxlbWVudGF0aW9uczpcbiAqXG4gKiAtIFtbUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXV1cbiAqIC0gW1tIYXNoTG9jYXRpb25TZXJ2aWNlXV1cbiAqIC0gW1tNZW1vcnlMb2NhdGlvblNlcnZpY2VdXVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uU2VydmljZXMgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqIFNlZTogW1tVcmxTZXJ2aWNlLnVybF1dICovIHVybDogVXJsU2VydmljZVsndXJsJ107XG4gIC8qKiBTZWU6IFtbVXJsU2VydmljZS5wYXRoXV0gKi8gcGF0aDogVXJsU2VydmljZVsncGF0aCddO1xuICAvKiogU2VlOiBbW1VybFNlcnZpY2Uuc2VhcmNoXV0gKi8gc2VhcmNoOiBVcmxTZXJ2aWNlWydzZWFyY2gnXTtcbiAgLyoqIFNlZTogW1tVcmxTZXJ2aWNlLmhhc2hdXSAqLyBoYXNoOiBVcmxTZXJ2aWNlWydoYXNoJ107XG4gIC8qKiBTZWU6IFtbVXJsU2VydmljZS5vbkNoYW5nZV1dICovIG9uQ2hhbmdlOiBVcmxTZXJ2aWNlWydvbkNoYW5nZSddO1xufVxuXG4vKipcbiAqIFJldHVybnMgbG93IGxldmVsIFVSTCBjb25maWd1cmF0aW9uIGFuZCBtZXRhZGF0YVxuICpcbiAqIFRoaXMgc2VydmljZSByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2NhdGlvbiBjb25maWd1cmF0aW9uLlxuICogVGhpcyBzZXJ2aWNlIGlzIHByaW1hcmlseSB1c2VkIHdoZW4gYnVpbGRpbmcgVVJMcyAoZS5nLiwgZm9yIGBocmVmc2ApXG4gKlxuICogSW1wbGVtZW50b3JzIHNob3VsZCBwYXNzIHRoZXNlIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgVVJMIEFQSXMuXG4gKiBUaGUgdW5kZXJseWluZyBVUkwgbWVjaGFuaXNtIG1pZ2h0IGJlIGJyb3dzZXIgQVBJcywgZnJhbWV3b3JrIEFQSXMsIG9yIHNvbWUgM3JkIHBhcnR5IFVSTCBtYW5hZ2VtZW50IGxpYnJhcnkuXG4gKlxuICogVUktUm91dGVyIENvcmUgaW5jbHVkZXMgdHdvIGJhc2ljIGltcGxlbWVudGF0aW9uczpcbiAqXG4gKiAtIFtbQnJvd3NlckxvY2F0aW9uQ29uZmlnXV1cbiAqIC0gW1tNZW1vcnlMb2NhdGlvbkNvbmZpZ11dXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb25Db25maWcgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqIFNlZTogW1tVcmxDb25maWcucG9ydF1dICovIHBvcnQ6IFVybENvbmZpZ1sncG9ydCddO1xuICAvKiogU2VlOiBbW1VybENvbmZpZy5wcm90b2NvbF1dICovIHByb3RvY29sOiBVcmxDb25maWdbJ3Byb3RvY29sJ107XG4gIC8qKiBTZWU6IFtbVXJsQ29uZmlnLmhvc3RdXSAqLyBob3N0OiBVcmxDb25maWdbJ2hvc3QnXTtcbiAgLyoqIFNlZTogW1tVcmxDb25maWcuYmFzZUhyZWZdXSAqLyBiYXNlSHJlZjogVXJsQ29uZmlnWydiYXNlSHJlZiddO1xuICAvKiogU2VlOiBbW1VybENvbmZpZy5odG1sNU1vZGVdXSAqLyBodG1sNU1vZGU6IFVybENvbmZpZ1snaHRtbDVNb2RlJ107XG4gIC8qKiBTZWU6IFtbVXJsQ29uZmlnLmhhc2hQcmVmaXhdXSAqLyBoYXNoUHJlZml4OiBVcmxDb25maWdbJ2hhc2hQcmVmaXgnXTtcbn1cblxuZXhwb3J0IHsgc2VydmljZXMgfTtcbiIsIi8qKlxuICogUmFuZG9tIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIFVJLVJvdXRlciBjb2RlXG4gKlxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAcHJlZmVycmVkIEBwdWJsaWNhcGkgQG1vZHVsZSBjb21tb25cbiAqLyAvKiogKi9cbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc0FycmF5LCBpc1JlZ0V4cCwgaXNEYXRlIH0gZnJvbSAnLi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IGFsbCwgYW55LCBwcm9wLCBjdXJyeSwgbm90IH0gZnJvbSAnLi9ob2YnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcblxuZGVjbGFyZSBjb25zdCBnbG9iYWw7XG5leHBvcnQgY29uc3Qgcm9vdDogYW55ID1cbiAgKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZikgfHxcbiAgKHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwpIHx8XG4gIHRoaXM7XG5jb25zdCBhbmd1bGFyID0gcm9vdC5hbmd1bGFyIHx8IHt9O1xuXG5leHBvcnQgY29uc3QgZnJvbUpzb24gPSBhbmd1bGFyLmZyb21Kc29uIHx8IEpTT04ucGFyc2UuYmluZChKU09OKTtcbmV4cG9ydCBjb25zdCB0b0pzb24gPSBhbmd1bGFyLnRvSnNvbiB8fCBKU09OLnN0cmluZ2lmeS5iaW5kKEpTT04pO1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSBhbmd1bGFyLmZvckVhY2ggfHwgX2ZvckVhY2g7XG5leHBvcnQgY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiB8fCBfZXh0ZW5kO1xuZXhwb3J0IGNvbnN0IGVxdWFscyA9IGFuZ3VsYXIuZXF1YWxzIHx8IF9lcXVhbHM7XG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeDogYW55KSB7XG4gIHJldHVybiB4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKTogYW55IHt9XG5cbmV4cG9ydCB0eXBlIE1hcHBlcjxYLCBUPiA9ICh4OiBYLCBrZXk/OiBzdHJpbmcgfCBudW1iZXIpID0+IFQ7XG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkTWFwPFQ+IHtcbiAgW2tleTogc3RyaW5nXTogVDtcbn1cbmV4cG9ydCB0eXBlIFByZWRpY2F0ZTxYPiA9ICh4PzogWCkgPT4gYm9vbGVhbjtcbmV4cG9ydCB0eXBlIFByZWRpY2F0ZUJpbmFyeTxYLCBZPiA9ICh4PzogWCwgeT86IFkpID0+IGJvb2xlYW47XG4vKipcbiAqIEFuIG5nMS1zdHlsZSBpbmplY3RhYmxlXG4gKlxuICogVGhpcyBjb3VsZCBiZSBhIChub24tbWluaWZpZWQpIGZ1bmN0aW9uIHN1Y2ggYXM6XG4gKiBgYGBqc1xuICogZnVuY3Rpb24gaW5qZWN0YWJsZUZ1bmN0aW9uKFNvbWVEZXBlbmRlbmN5KSB7XG4gKlxuICogfVxuICogYGBgXG4gKlxuICogb3IgYW4gZXhwbGljaXRseSBhbm5vdGF0ZWQgZnVuY3Rpb24gKG1pbmlmeSBzYWZlKVxuICogYGBganNcbiAqIGluamVjdGFibGVGdW5jdGlvbi4kaW5qZWN0ID0gWyAnU29tZURlcGVuZGVuY3knIF07XG4gKiBmdW5jdGlvbiBpbmplY3RhYmxlRnVuY3Rpb24oU29tZURlcGVuZGVuY3kpIHtcbiAqXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBvciBhbiBhcnJheSBzdHlsZSBhbm5vdGF0ZWQgZnVuY3Rpb24gKG1pbmlmeSBzYWZlKVxuICogYGBganNcbiAqIFsnU29tZURlcGVuZGVuY3knLCBmdW5jdGlvbiBpbmplY3RhYmxlRnVuY3Rpb24oU29tZURlcGVuZGVuY3kpIHtcbiAqXG4gKiB9XTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNhcGlcbiAqL1xuZXhwb3J0IHR5cGUgSUluamVjdGFibGUgPSBGdW5jdGlvbiB8IGFueVtdO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9iaiBleHRlbmRzIE9iamVjdCB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgcHJveHkgZnVuY3Rpb25zIG9uIHRoZSBgdG9gIG9iamVjdCB3aGljaCBwYXNzIHRocm91Z2ggdG8gdGhlIGBmcm9tYCBvYmplY3QuXG4gKlxuICogRm9yIGVhY2gga2V5IGluIGBmbk5hbWVzYCwgY3JlYXRlcyBhIHByb3h5IGZ1bmN0aW9uIG9uIHRoZSBgdG9gIG9iamVjdC5cbiAqIFRoZSBwcm94eSBmdW5jdGlvbiBjYWxscyB0aGUgcmVhbCBmdW5jdGlvbiBvbiB0aGUgYGZyb21gIG9iamVjdC5cbiAqXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYW4gbmV3IGNsYXNzIGluc3RhbmNlIHdob3NlIGZ1bmN0aW9ucyBhcmUgcHJlYm91bmQgdG8gdGhlIG5ldydkIG9iamVjdC5cbiAqIGBgYGpzXG4gKiBjbGFzcyBGb28ge1xuICogICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gKiAgICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIEZvby5wcm90b3R5cGUgdG8gJ3RoaXMnLFxuICogICAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXG4gKiAgICAgYmluZEZ1bmN0aW9ucyhGb28ucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcbiAqICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICogICB9XG4gKlxuICogICBsb2coKSB7XG4gKiAgICAgY29uc29sZS5sb2codGhpcy5kYXRhKTtcbiAqICAgfVxuICogfVxuICpcbiAqIGxldCBteUZvbyA9IG5ldyBGb28oWzEsMiwzXSk7XG4gKiB2YXIgbG9naXQgPSBteUZvby5sb2c7XG4gKiBsb2dpdCgpOyAvLyBsb2dzIFsxLCAyLCAzXSBmcm9tIHRoZSBteUZvbyAndGhpcycgaW5zdGFuY2VcbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgYm91bmQgdmVyc2lvbiBvZiBhIHNlcnZpY2UgZnVuY3Rpb24sIGFuZCBjb3BpZXMgaXQgdG8gYW5vdGhlciBvYmplY3RcbiAqIGBgYFxuICpcbiAqIHZhciBTb21lU2VydmljZSA9IHtcbiAqICAgdGhpcy5kYXRhID0gWzMsIDQsIDVdO1xuICogICB0aGlzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBDb25zdHJ1Y3RvciBmblxuICogZnVuY3Rpb24gT3RoZXJUaGluZygpIHtcbiAqICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIFNvbWVTZXJ2aWNlIHRvIFNvbWVTZXJ2aWNlLFxuICogICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xuICogICBiaW5kRnVuY3Rpb25zKFNvbWVTZXJ2aWNlLCB0aGlzLCBTb21lU2VydmljZSk7XG4gKiB9XG4gKlxuICogbGV0IG15T3RoZXJUaGluZyA9IG5ldyBPdGhlclRoaW5nKCk7XG4gKiBteU90aGVyVGhpbmcubG9nKCk7IC8vIGxvZ3MgWzMsIDQsIDVdIGZyb20gU29tZVNlcnZpY2UncyAndGhpcydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzb3VyY2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNvdXJjZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9ucyB0byBiZSBib3VuZFxuICogQHBhcmFtIHRhcmdldCBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIGJvdW5kIGZ1bmN0aW9uc1xuICogQHBhcmFtIGJpbmQgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9iamVjdCB3aGljaCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgYm91bmQgdG9cbiAqIEBwYXJhbSBmbk5hbWVzIFRoZSBmdW5jdGlvbiBuYW1lcyB3aGljaCB3aWxsIGJlIGJvdW5kIChEZWZhdWx0cyB0byBhbGwgdGhlIGZ1bmN0aW9ucyBmb3VuZCBvbiB0aGUgJ2Zyb20nIG9iamVjdClcbiAqIEBwYXJhbSBsYXRlYmluZCBJZiB0cnVlLCB0aGUgYmluZGluZyBvZiB0aGUgZnVuY3Rpb24gaXMgZGVsYXllZCB1bnRpbCB0aGUgZmlyc3QgdGltZSBpdCdzIGludm9rZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3h5RnVuY3Rpb25zKFxuICBzb3VyY2U6IEZ1bmN0aW9uLFxuICB0YXJnZXQ6IE9iaixcbiAgYmluZDogRnVuY3Rpb24sXG4gIGZuTmFtZXM/OiBzdHJpbmdbXSxcbiAgbGF0ZWJpbmQgPSBmYWxzZVxuKTogT2JqIHtcbiAgY29uc3QgYmluZEZ1bmN0aW9uID0gZm5OYW1lID0+IHNvdXJjZSgpW2ZuTmFtZV0uYmluZChiaW5kKCkpO1xuXG4gIGNvbnN0IG1ha2VMYXRlUmViaW5kRm4gPSBmbk5hbWUgPT5cbiAgICBmdW5jdGlvbiBsYXRlUmViaW5kRnVuY3Rpb24oKSB7XG4gICAgICB0YXJnZXRbZm5OYW1lXSA9IGJpbmRGdW5jdGlvbihmbk5hbWUpO1xuICAgICAgcmV0dXJuIHRhcmdldFtmbk5hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICBmbk5hbWVzID0gZm5OYW1lcyB8fCBPYmplY3Qua2V5cyhzb3VyY2UoKSk7XG5cbiAgcmV0dXJuIGZuTmFtZXMucmVkdWNlKChhY2MsIG5hbWUpID0+IHtcbiAgICBhY2NbbmFtZV0gPSBsYXRlYmluZCA/IG1ha2VMYXRlUmViaW5kRm4obmFtZSkgOiBiaW5kRnVuY3Rpb24obmFtZSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgdGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGhlbHBlci5cbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdoaWNoIGhhcyBgcGFyZW50YCBvYmplY3QgYXMgaXRzIHByb3RvdHlwZSwgYW5kIHRoZW4gY29waWVzIHRoZSBwcm9wZXJ0aWVzIGZyb20gYGV4dHJhYCBvbnRvIGl0XG4gKi9cbmV4cG9ydCBjb25zdCBpbmhlcml0ID0gKHBhcmVudDogT2JqLCBleHRyYT86IE9iaikgPT4gZXh0ZW5kKE9iamVjdC5jcmVhdGUocGFyZW50KSwgZXh0cmEpO1xuXG4vKiogR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGZvdW5kIGluIHRoZSBhcnJheSwgKHVzaW5nIGluZGV4T2YpICovXG5leHBvcnQgY29uc3QgaW5BcnJheTogdHlwZW9mIF9pbkFycmF5ID0gY3VycnkoX2luQXJyYXkpIGFzIGFueTtcbmV4cG9ydCBmdW5jdGlvbiBfaW5BcnJheShhcnJheTogYW55W10sIG9iajogYW55KTogYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBfaW5BcnJheShhcnJheTogYW55W10pOiAob2JqOiBhbnkpID0+IGJvb2xlYW47XG5leHBvcnQgZnVuY3Rpb24gX2luQXJyYXkoYXJyYXksIG9iaj8pOiBhbnkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihvYmopICE9PSAtMTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSwgYW5kIGFuIGl0ZW0sIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBhcnJheSwgaXQgcmVtb3ZlcyBpdCAoaW4tcGxhY2UpLlxuICogVGhlIHNhbWUgYXJyYXkgaXMgcmV0dXJuZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUZyb206IHR5cGVvZiBfcmVtb3ZlRnJvbSA9IGN1cnJ5KF9yZW1vdmVGcm9tKSBhcyBhbnk7XG5leHBvcnQgZnVuY3Rpb24gX3JlbW92ZUZyb208VD4oYXJyYXk6IFRbXSwgb2JqOiBUKTogVFtdO1xuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmVGcm9tPFQ+KGFycmF5OiBUW10pOiAob2JqOiBUKSA9PiBUW107XG5leHBvcnQgZnVuY3Rpb24gX3JlbW92ZUZyb20oYXJyYXksIG9iaj8pIHtcbiAgY29uc3QgaWR4ID0gYXJyYXkuaW5kZXhPZihvYmopO1xuICBpZiAoaWR4ID49IDApIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKiBwdXNoZXMgYSB2YWx1ZXMgdG8gYW4gYXJyYXkgYW5kIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnQgY29uc3QgcHVzaFRvOiB0eXBlb2YgX3B1c2hUbyA9IGN1cnJ5KF9wdXNoVG8pIGFzIGFueTtcbmV4cG9ydCBmdW5jdGlvbiBfcHVzaFRvPFQ+KGFycjogVFtdLCB2YWw6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIF9wdXNoVG88VD4oYXJyOiBUW10pOiAodmFsOiBUKSA9PiBUO1xuZXhwb3J0IGZ1bmN0aW9uIF9wdXNoVG8oYXJyLCB2YWw/KTogYW55IHtcbiAgcmV0dXJuIGFyci5wdXNoKHZhbCksIHZhbDtcbn1cblxuLyoqIEdpdmVuIGFuIGFycmF5IG9mIChkZXJlZ2lzdHJhdGlvbikgZnVuY3Rpb25zLCBjYWxscyBhbGwgZnVuY3Rpb25zIGFuZCByZW1vdmVzIGVhY2ggb25lIGZyb20gdGhlIHNvdXJjZSBhcnJheSAqL1xuZXhwb3J0IGNvbnN0IGRlcmVnQWxsID0gKGZ1bmN0aW9uczogRnVuY3Rpb25bXSkgPT5cbiAgZnVuY3Rpb25zLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIGZuKCk7XG4gICAgcmVtb3ZlRnJvbShmdW5jdGlvbnMsIGZuKTtcbiAgfSk7XG4vKipcbiAqIEFwcGxpZXMgYSBzZXQgb2YgZGVmYXVsdHMgdG8gYW4gb3B0aW9ucyBvYmplY3QuICBUaGUgb3B0aW9ucyBvYmplY3QgaXMgZmlsdGVyZWRcbiAqIHRvIG9ubHkgdGhvc2UgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgZGVmYXVsdHNMaXN0LlxuICogRWFybGllciBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QgdGFrZSBwcmVjZWRlbmNlIHdoZW4gYXBwbHlpbmcgZGVmYXVsdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRzLCAuLi5kZWZhdWx0c0xpc3Q6IE9ialtdKSB7XG4gIGNvbnN0IGRlZmF1bHRWYWxzID0gZXh0ZW5kKHt9LCAuLi5kZWZhdWx0c0xpc3QucmV2ZXJzZSgpKTtcbiAgcmV0dXJuIGV4dGVuZChkZWZhdWx0VmFscywgcGljayhvcHRzIHx8IHt9LCBPYmplY3Qua2V5cyhkZWZhdWx0VmFscykpKTtcbn1cblxuLyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaW50byBhIHNpbmdsZSBvYmplY3QsIHVzaW5nIGV4dGVuZCAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlUiA9IChtZW1vOiBPYmosIGl0ZW06IE9iaikgPT4gZXh0ZW5kKG1lbW8sIGl0ZW0pO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBiZXR3ZWVuIHR3byBzdGF0ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpcnN0IFRoZSBmaXJzdCBzdGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgVGhlIHNlY29uZCBzdGF0ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIG5hbWVzIGluIGRlc2NlbmRpbmcgb3JkZXIsIG5vdCBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmNlc3RvcnMoZmlyc3Q6IFN0YXRlT2JqZWN0LCBzZWNvbmQ6IFN0YXRlT2JqZWN0KSB7XG4gIGNvbnN0IHBhdGg6IFN0YXRlT2JqZWN0W10gPSBbXTtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgZm9yIChjb25zdCBuIGluIGZpcnN0LnBhdGgpIHtcbiAgICBpZiAoZmlyc3QucGF0aFtuXSAhPT0gc2Vjb25kLnBhdGhbbl0pIGJyZWFrO1xuICAgIHBhdGgucHVzaChmaXJzdC5wYXRoW25dKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYFxuICogdmFyIGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9O1xuICogdmFyIGFiID0gcGljayhmb28sIFsnYScsICdiJ10pOyAvLyB7IGE6IDEsIGI6IDIgfVxuICogYGBgXG4gKiBAcGFyYW0gb2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gcHJvcE5hbWVzIGFuIEFycmF5IG9mIHN0cmluZ3MsIHdoaWNoIGFyZSB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydHkgbmFtZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqOiBPYmosIHByb3BOYW1lczogc3RyaW5nW10pOiBPYmoge1xuICBjb25zdCBvYmpDb3B5ID0ge307XG4gIGZvciAoY29uc3QgX3Byb3AgaW4gb2JqKSB7XG4gICAgaWYgKHByb3BOYW1lcy5pbmRleE9mKF9wcm9wKSAhPT0gLTEpIHtcbiAgICAgIG9iakNvcHlbX3Byb3BdID0gb2JqW19wcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iakNvcHk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9taXR0aW5nIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBvbWl0KGZvbywgWydhJywgJ2InXSk7IC8vIHsgYzogMyB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5leHBvcnQgZnVuY3Rpb24gb21pdChvYmo6IE9iaiwgcHJvcE5hbWVzOiBzdHJpbmdbXSk6IE9iaiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgLmZpbHRlcihub3QoaW5BcnJheShwcm9wTmFtZXMpKSlcbiAgICAucmVkdWNlKChhY2MsIGtleSkgPT4gKChhY2Nba2V5XSA9IG9ialtrZXldKSwgYWNjKSwge30pO1xufVxuXG4vKiogR2l2ZW4gYW4gYXJyYXkgb2Ygb2JqZWN0cywgbWFwcyBlYWNoIGVsZW1lbnQgdG8gYSBuYW1lZCBwcm9wZXJ0eSBvZiB0aGUgZWxlbWVudC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbHVjazxUPihjb2xsZWN0aW9uOiBPYmpbXSwgcHJvcE5hbWU6IHN0cmluZyk6IFRbXTtcbi8qKiBHaXZlbiBhbiBvYmplY3QsIG1hcHMgZWFjaCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHRvIGEgbmFtZWQgcHJvcGVydHkgb2YgdGhlIHByb3BlcnR5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb246IHsgW2tleTogc3RyaW5nXTogYW55IH0sIHByb3BOYW1lOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuLyoqXG4gKiBNYXBzIGFuIGFycmF5LCBvciBvYmplY3QgdG8gYSBwcm9wZXJ0eSAoYnkgbmFtZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb246IGFueSwgcHJvcE5hbWU6IHN0cmluZyk6IGFueSB7XG4gIHJldHVybiBtYXAoY29sbGVjdGlvbiwgPE1hcHBlcjxhbnksIHN0cmluZz4+cHJvcChwcm9wTmFtZSkpO1xufVxuXG4vKiogR2l2ZW4gYW4gYXJyYXkgb2Ygb2JqZWN0cywgcmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG9ubHkgdGhlIGVsZW1lbnRzIHdoaWNoIHBhc3NlZCB0aGUgY2FsbGJhY2sgcHJlZGljYXRlICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQ+KGNvbGxlY3Rpb246IFRbXSwgY2FsbGJhY2s6ICh0OiBULCBrZXk/OiBudW1iZXIpID0+IGJvb2xlYW4pOiBUW107XG4vKiogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIG9ubHkgdGhvc2UgcHJvcGVydGllcyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgcHJlZGljYXRlICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQ+KGNvbGxlY3Rpb246IFR5cGVkTWFwPFQ+LCBjYWxsYmFjazogKHQ6IFQsIGtleT86IHN0cmluZykgPT4gYm9vbGVhbik6IFR5cGVkTWFwPFQ+O1xuLyoqIEZpbHRlcnMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0J3MgcHJvcGVydGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcjxUPihjb2xsZWN0aW9uOiBhbnksIGNhbGxiYWNrOiBGdW5jdGlvbik6IFQge1xuICBjb25zdCBhcnIgPSBpc0FycmF5KGNvbGxlY3Rpb24pLFxuICAgIHJlc3VsdDogYW55ID0gYXJyID8gW10gOiB7fTtcbiAgY29uc3QgYWNjZXB0ID0gYXJyID8geCA9PiByZXN1bHQucHVzaCh4KSA6ICh4LCBrZXkpID0+IChyZXN1bHRba2V5XSA9IHgpO1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpIGFjY2VwdChpdGVtLCBpKTtcbiAgfSk7XG4gIHJldHVybiA8VD5yZXN1bHQ7XG59XG5cbi8qKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiB0aGUgZmlyc3QgcHJvcGVydHkgb2YgdGhhdCBvYmplY3Qgd2hpY2ggcGFzc2VkIHRoZSBjYWxsYmFjayBwcmVkaWNhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQ+KGNvbGxlY3Rpb246IFR5cGVkTWFwPFQ+LCBjYWxsYmFjazogUHJlZGljYXRlPFQ+KTogVDtcbi8qKiBHaXZlbiBhbiBhcnJheSBvZiBvYmplY3RzLCByZXR1cm5zIHRoZSBmaXJzdCBvYmplY3Qgd2hpY2ggcGFzc2VkIHRoZSBjYWxsYmFjayBwcmVkaWNhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQ+KGNvbGxlY3Rpb246IFRbXSwgY2FsbGJhY2s6IFByZWRpY2F0ZTxUPik6IFQ7XG4vKiogRmluZHMgYW4gb2JqZWN0IGZyb20gYW4gYXJyYXksIG9yIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb246IGFueSwgY2FsbGJhY2s6IGFueSkge1xuICBsZXQgcmVzdWx0O1xuXG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgIGlmIChyZXN1bHQpIHJldHVybjtcbiAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpIHJlc3VsdCA9IGl0ZW07XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRyYW5zZm9ybWVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbiAqL1xuZXhwb3J0IGxldCBtYXBPYmo6IDxULCBVPihcbiAgY29sbGVjdGlvbjogeyBba2V5OiBzdHJpbmddOiBUIH0sXG4gIGNhbGxiYWNrOiBNYXBwZXI8VCwgVT4sXG4gIHRhcmdldD86IHR5cGVvZiBjb2xsZWN0aW9uXG4pID0+IHsgW2tleTogc3RyaW5nXTogVSB9ID0gbWFwO1xuLyoqIEdpdmVuIGFuIGFycmF5LCByZXR1cm5zIGEgbmV3IGFycmF5LCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgdHJhbnNmb3JtZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KGNvbGxlY3Rpb246IFRbXSwgY2FsbGJhY2s6IE1hcHBlcjxULCBVPiwgdGFyZ2V0PzogdHlwZW9mIGNvbGxlY3Rpb24pOiBVW107XG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KFxuICBjb2xsZWN0aW9uOiB7IFtrZXk6IHN0cmluZ106IFQgfSxcbiAgY2FsbGJhY2s6IE1hcHBlcjxULCBVPixcbiAgdGFyZ2V0PzogdHlwZW9mIGNvbGxlY3Rpb25cbik6IHsgW2tleTogc3RyaW5nXTogVSB9O1xuLyoqIE1hcHMgYW4gYXJyYXkgb3Igb2JqZWN0IHByb3BlcnRpZXMgdXNpbmcgYSBjYWxsYmFjayBmdW5jdGlvbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uOiBhbnksIGNhbGxiYWNrOiBhbnksIHRhcmdldDogdHlwZW9mIGNvbGxlY3Rpb24pOiBhbnkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgKGlzQXJyYXkoY29sbGVjdGlvbikgPyBbXSA6IHt9KTtcbiAgZm9yRWFjaChjb2xsZWN0aW9uLCAoaXRlbSwgaSkgPT4gKHRhcmdldFtpXSA9IGNhbGxiYWNrKGl0ZW0sIGkpKSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm4gaXRzIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfVxuICogbGV0IHZhbHMgPSB2YWx1ZXMoZm9vKTsgLy8gWyAxLCAyLCAzIF1cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdmFsdWVzOiAoPFQ+KG9iajogVHlwZWRNYXA8VD4pID0+IFRbXSkgPSAob2JqOiBPYmopID0+IE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiBvYmpba2V5XSk7XG5cbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgdmFsdWVzIGFyZSB0cnV0aHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCB2YWxzID0gWyAxLCB0cnVlLCB7fSwgXCJoZWxsbyB3b3JsZFwiXTtcbiAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gdHJ1ZVxuICpcbiAqIHZhbHMucHVzaCgwKTtcbiAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYWxsVHJ1ZVIgPSAobWVtbzogYm9vbGVhbiwgZWxlbTogYW55KSA9PiBtZW1vICYmIGVsZW07XG5cbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgdmFsdWVzIGFyZSB0cnV0aHkuXG4gKlxuICogICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCB2YWxzID0gWyAwLCBudWxsLCB1bmRlZmluZWQgXTtcbiAqIHZhbHMucmVkdWNlKGFueVRydWVSLCB0cnVlKTsgLy8gZmFsc2VcbiAqXG4gKiB2YWxzLnB1c2goXCJoZWxsbyB3b3JsZFwiKTtcbiAqIHZhbHMucmVkdWNlKGFueVRydWVSLCB0cnVlKTsgLy8gdHJ1ZVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBhbnlUcnVlUiA9IChtZW1vOiBib29sZWFuLCBlbGVtOiBhbnkpID0+IG1lbW8gfHwgZWxlbTtcblxuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggdW4tbmVzdHMgYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgWyBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdIF1cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdW5uZXN0UiA9IChtZW1vOiBhbnlbXSwgZWxlbTogYW55W10pID0+IG1lbW8uY29uY2F0KGVsZW0pO1xuXG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCByZWN1cnNpdmVseSB1bi1uZXN0cyBhbGwgYXJyYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG4gKiBpbnB1dC5yZWR1Y2UodW5uZXN0UiwgW10pIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlblIgPSAobWVtbzogYW55W10sIGVsZW06IGFueSkgPT5cbiAgaXNBcnJheShlbGVtKSA/IG1lbW8uY29uY2F0KGVsZW0ucmVkdWNlKGZsYXR0ZW5SLCBbXSkpIDogcHVzaFIobWVtbywgZWxlbSk7XG5cbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcHVzaGVzIGFuIG9iamVjdCB0byBhbiBhcnJheSwgdGhlbiByZXR1cm5zIHRoZSBhcnJheS5cbiAqIE1vc3RseSBqdXN0IGZvciBbW2ZsYXR0ZW5SXV0gYW5kIFtbdW5pcVJdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaFIoYXJyOiBhbnlbXSwgb2JqOiBhbnkpIHtcbiAgYXJyLnB1c2gob2JqKTtcbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IGZpbHRlcnMgb3V0IGR1cGxpY2F0ZXMgKi9cbmV4cG9ydCBjb25zdCB1bmlxUiA9IDxUPihhY2M6IFRbXSwgdG9rZW46IFQpOiBUW10gPT4gKGluQXJyYXkoYWNjLCB0b2tlbikgPyBhY2MgOiBwdXNoUihhY2MsIHRva2VuKSk7XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzIHVubmVzdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogdW5uZXN0KGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1bm5lc3QgPSAoYXJyOiBhbnlbXSkgPT4gYXJyLnJlZHVjZSh1bm5lc3RSLCBbXSk7XG4vKipcbiAqIFJldHVybiBhIGNvbXBsZXRlbHkgZmxhdHRlbmVkIHZlcnNpb24gb2YgYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG4gKiBmbGF0dGVuKGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW4gPSAoYXJyOiBhbnlbXSkgPT4gYXJyLnJlZHVjZShmbGF0dGVuUiwgW10pO1xuXG4vKipcbiAqIEdpdmVuIGEgLmZpbHRlciBQcmVkaWNhdGUsIGJ1aWxkcyBhIC5maWx0ZXIgUHJlZGljYXRlIHdoaWNoIHRocm93cyBhbiBlcnJvciBpZiBhbnkgZWxlbWVudHMgZG8gbm90IHBhc3MuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlzTnVtYmVyID0gKG9iaikgPT4gdHlwZW9mKG9iaikgPT09ICdudW1iZXInO1xuICogbGV0IGFsbE51bWJlcnMgPSBbIDEsIDIsIDMsIDQsIDUgXTtcbiAqIGFsbE51bWJlcnMuZmlsdGVyKGFzc2VydFByZWRpY2F0ZShpc051bWJlcikpOyAvL09LXG4gKlxuICogbGV0IG9uZVN0cmluZyA9IFsgMSwgMiwgMywgNCwgXCI1XCIgXTtcbiAqIG9uZVN0cmluZy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyLCBcIk5vdCBhbGwgbnVtYmVyc1wiKSk7IC8vIHRocm93cyBFcnJvcihcIlwiTm90IGFsbCBudW1iZXJzXCJcIik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydFByZWRpY2F0ZTogPFQ+KHByZWRpY2F0ZTogUHJlZGljYXRlPFQ+LCBlcnJNc2c6IHN0cmluZyB8IEZ1bmN0aW9uKSA9PiBQcmVkaWNhdGU8VD4gPSBhc3NlcnRGbjtcbi8qKlxuICogR2l2ZW4gYSAubWFwIGZ1bmN0aW9uLCBidWlsZHMgYSAubWFwIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBhbiBlcnJvciBpZiBhbnkgbWFwcGVkIGVsZW1lbnRzIGRvIG5vdCBwYXNzIGEgdHJ1dGh5bmVzcyB0ZXN0LlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIHZhciBkYXRhID0geyBmb286IDEsIGJhcjogMiB9O1xuICpcbiAqIGxldCBrZXlzID0gWyAnZm9vJywgJ2JhcicgXVxuICogbGV0IHZhbHVlcyA9IGtleXMubWFwKGFzc2VydE1hcChrZXkgPT4gZGF0YVtrZXldLCBcIktleSBub3QgZm91bmRcIikpO1xuICogLy8gdmFsdWVzIGlzIFsxLCAyXVxuICpcbiAqIGxldCBrZXlzID0gWyAnZm9vJywgJ2JhcicsICdiYXonIF1cbiAqIGxldCB2YWx1ZXMgPSBrZXlzLm1hcChhc3NlcnRNYXAoa2V5ID0+IGRhdGFba2V5XSwgXCJLZXkgbm90IGZvdW5kXCIpKTtcbiAqIC8vIHRocm93cyBFcnJvcihcIktleSBub3QgZm91bmRcIilcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYXNzZXJ0TWFwOiA8VCwgVT4obWFwRm46ICh0OiBUKSA9PiBVLCBlcnJNc2c6IHN0cmluZyB8IEZ1bmN0aW9uKSA9PiAodDogVCkgPT4gVSA9IGFzc2VydEZuO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZuKHByZWRpY2F0ZU9yTWFwOiBGdW5jdGlvbiwgZXJyTXNnOiBzdHJpbmcgfCBGdW5jdGlvbiA9ICdhc3NlcnQgZmFpbHVyZScpOiBhbnkge1xuICByZXR1cm4gb2JqID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBwcmVkaWNhdGVPck1hcChvYmopO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoaXNGdW5jdGlvbihlcnJNc2cpID8gKDxGdW5jdGlvbj5lcnJNc2cpKG9iaikgOiBlcnJNc2cpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIExpa2UgXy5wYWlyczogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm5zIGFuIGFycmF5IG9mIGtleS92YWx1ZSBwYWlyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBwYWlycyh7IGZvbzogXCJGT09cIiwgYmFyOiBcIkJBUiB9KSAvLyBbIFsgXCJmb29cIiwgXCJGT09cIiBdLCBbIFwiYmFyXCI6IFwiQkFSXCIgXSBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhaXJzID0gKG9iajogT2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLm1hcChrZXkgPT4gW2tleSwgb2JqW2tleV1dKTtcblxuLyoqXG4gKiBHaXZlbiB0d28gb3IgbW9yZSBwYXJhbGxlbCBhcnJheXMsIHJldHVybnMgYW4gYXJyYXkgb2YgdHVwbGVzIHdoZXJlXG4gKiBlYWNoIHR1cGxlIGlzIGNvbXBvc2VkIG9mIFsgYVtpXSwgYltpXSwgLi4uIHpbaV0gXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgZm9vID0gWyAwLCAyLCA0LCA2IF07XG4gKiBsZXQgYmFyID0gWyAxLCAzLCA1LCA3IF07XG4gKiBsZXQgYmF6ID0gWyAxMCwgMzAsIDUwLCA3MCBdO1xuICogYXJyYXlUdXBsZXMoZm9vLCBiYXIpOyAgICAgICAvLyBbIFswLCAxXSwgWzIsIDNdLCBbNCwgNV0sIFs2LCA3XSBdXG4gKiBhcnJheVR1cGxlcyhmb28sIGJhciwgYmF6KTsgIC8vIFsgWzAsIDEsIDEwXSwgWzIsIDMsIDMwXSwgWzQsIDUsIDUwXSwgWzYsIDcsIDcwXSBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VHVwbGVzKC4uLmFyZ3M6IGFueVtdKTogYW55W10ge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgY29uc3QgbWF4QXJyYXlMZW4gPSBhcmdzLnJlZHVjZSgobWluLCBhcnIpID0+IE1hdGgubWluKGFyci5sZW5ndGgsIG1pbiksIDkwMDcxOTkyNTQ3NDA5OTEpOyAvLyBha2EgMl41MyDiiJIgMSBha2EgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBcnJheUxlbjsgaSsrKSB7XG4gICAgLy8gVGhpcyBpcyBhIGhvdCBmdW5jdGlvblxuICAgIC8vIFVucm9sbCB3aGVuIHRoZXJlIGFyZSAxLTQgYXJndW1lbnRzXG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV1dKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldLCBhcmdzWzJdW2ldXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXSwgYXJnc1szXVtpXV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyZ3MubWFwKGFycmF5ID0+IGFycmF5W2ldKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIGJ1aWxkcyBhbiBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXG4gKlxuICogRWFjaCBpdGVyYXRpb24gc2V0cyB0aGUga2V5L3ZhbCBwYWlyIG9uIHRoZSBtZW1vIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBtZW1vIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gKlxuICogRWFjaCBrZXlWYWx1ZVR1cGxlIHNob3VsZCBiZSBhbiBhcnJheSB3aXRoIHZhbHVlcyBbIGtleTogc3RyaW5nLCB2YWx1ZTogYW55IF1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIHBhaXJzID0gWyBbXCJmb29rZXlcIiwgXCJmb292YWxcIl0sIFtcImJhcmtleVwiLCBcImJhcnZhbFwiXSBdXG4gKlxuICogdmFyIHBhaXJzVG9PYmogPSBwYWlycy5yZWR1Y2UoKG1lbW8sIHBhaXIpID0+IGFwcGx5UGFpcnMobWVtbywgcGFpciksIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqXG4gKiAvLyBPciwgbW9yZSBzaW1wbHk6XG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZShhcHBseVBhaXJzLCB7fSlcbiAqIC8vIHBhaXJzVG9PYmogPT0geyBmb29rZXk6IFwiZm9vdmFsXCIsIGJhcmtleTogXCJiYXJ2YWxcIiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFpcnMobWVtbzogVHlwZWRNYXA8YW55Piwga2V5VmFsVHVwbGU6IGFueVtdKSB7XG4gIGxldCBrZXk6IHN0cmluZywgdmFsdWU6IGFueTtcbiAgaWYgKGlzQXJyYXkoa2V5VmFsVHVwbGUpKSBba2V5LCB2YWx1ZV0gPSBrZXlWYWxUdXBsZTtcbiAgaWYgKCFpc1N0cmluZyhrZXkpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVycyB0byBhcHBseVBhaXJzJyk7XG4gIG1lbW9ba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gbWVtbztcbn1cblxuLyoqIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gdGFpbDxUPihhcnI6IFRbXSk6IFQge1xuICByZXR1cm4gKGFyci5sZW5ndGggJiYgYXJyW2Fyci5sZW5ndGggLSAxXSkgfHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIHNoYWxsb3cgY29weSBmcm9tIHNyYyB0byBkZXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYzogT2JqLCBkZXN0PzogT2JqKSB7XG4gIGlmIChkZXN0KSBPYmplY3Qua2V5cyhkZXN0KS5mb3JFYWNoKGtleSA9PiBkZWxldGUgZGVzdFtrZXldKTtcbiAgaWYgKCFkZXN0KSBkZXN0ID0ge307XG4gIHJldHVybiBleHRlbmQoZGVzdCwgc3JjKTtcbn1cblxuLyoqIE5haXZlIGZvckVhY2ggaW1wbGVtZW50YXRpb24gd29ya3Mgd2l0aCBPYmplY3RzIG9yIEFycmF5cyAqL1xuZnVuY3Rpb24gX2ZvckVhY2gob2JqOiBhbnlbXSB8IGFueSwgY2I6IChlbCwgaWR4PykgPT4gdm9pZCwgX3RoaXM6IE9iaikge1xuICBpZiAoaXNBcnJheShvYmopKSByZXR1cm4gb2JqLmZvckVhY2goY2IsIF90aGlzKTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiBjYihvYmpba2V5XSwga2V5KSk7XG59XG5cbi8qKiBMaWtlIE9iamVjdC5hc3NpZ24oKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9leHRlbmQodG9PYmo6IE9iaiwgLi4uZnJvbU9ianM6IE9ialtdKTogYW55O1xuZXhwb3J0IGZ1bmN0aW9uIF9leHRlbmQodG9PYmo6IE9iaik6IGFueSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICghb2JqKSBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgdG9PYmpba2V5c1tqXV0gPSBvYmpba2V5c1tqXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvT2JqO1xufVxuXG5mdW5jdGlvbiBfZXF1YWxzKG8xOiBhbnksIG8yOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKG8xID09PSBvMikgcmV0dXJuIHRydWU7XG4gIGlmIChvMSA9PT0gbnVsbCB8fCBvMiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAobzEgIT09IG8xICYmIG8yICE9PSBvMikgcmV0dXJuIHRydWU7IC8vIE5hTiA9PT0gTmFOXG4gIGNvbnN0IHQxID0gdHlwZW9mIG8xLFxuICAgIHQyID0gdHlwZW9mIG8yO1xuICBpZiAodDEgIT09IHQyIHx8IHQxICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IHR1cCA9IFtvMSwgbzJdO1xuICBpZiAoYWxsKGlzQXJyYXkpKHR1cCkpIHJldHVybiBfYXJyYXlzRXEobzEsIG8yKTtcbiAgaWYgKGFsbChpc0RhdGUpKHR1cCkpIHJldHVybiBvMS5nZXRUaW1lKCkgPT09IG8yLmdldFRpbWUoKTtcbiAgaWYgKGFsbChpc1JlZ0V4cCkodHVwKSkgcmV0dXJuIG8xLnRvU3RyaW5nKCkgPT09IG8yLnRvU3RyaW5nKCk7XG4gIGlmIChhbGwoaXNGdW5jdGlvbikodHVwKSkgcmV0dXJuIHRydWU7IC8vIG1laFxuXG4gIGNvbnN0IHByZWRpY2F0ZXMgPSBbaXNGdW5jdGlvbiwgaXNBcnJheSwgaXNEYXRlLCBpc1JlZ0V4cF07XG4gIGlmIChwcmVkaWNhdGVzLm1hcChhbnkpLnJlZHVjZSgoYiwgZm4pID0+IGIgfHwgISFmbih0dXApLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBrZXlzOiB7IFtpOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gIGZvciAoY29uc3Qga2V5IGluIG8xKSB7XG4gICAgaWYgKCFfZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAga2V5c1trZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBvMikge1xuICAgIGlmICgha2V5c1trZXldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2FycmF5c0VxKGExOiBhbnlbXSwgYTI6IGFueVtdKSB7XG4gIGlmIChhMS5sZW5ndGggIT09IGEyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYXJyYXlUdXBsZXMoYTEsIGEyKS5yZWR1Y2UoKGIsIHQpID0+IGIgJiYgX2VxdWFscyh0WzBdLCB0WzFdKSwgdHJ1ZSk7XG59XG5cbi8vIGlzc3VlICMyNjc2XG5leHBvcnQgY29uc3Qgc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlID0gKHByb21pc2U6IFByb21pc2U8YW55PikgPT4gcHJvbWlzZS5jYXRjaChlID0+IDApICYmIHByb21pc2U7XG5leHBvcnQgY29uc3Qgc2lsZW50UmVqZWN0aW9uID0gKGVycm9yOiBhbnkpID0+IHNpbGVuY2VVbmNhdWdodEluUHJvbWlzZShzZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpKTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgY29yZSAqL1xuLyoqXG4gKiBNYXRjaGVzIHN0YXRlIG5hbWVzIHVzaW5nIGdsb2ItbGlrZSBwYXR0ZXJuIHN0cmluZ3MuXG4gKlxuICogR2xvYnMgY2FuIGJlIHVzZWQgaW4gc3BlY2lmaWMgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSBbW1N0YXRlU2VydmljZS5pc11dXG4gKiAtIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV1cbiAqIC0gVGhlIGZpcnN0IGFyZ3VtZW50IHRvIEhvb2sgUmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBsaWtlIFtbVHJhbnNpdGlvblNlcnZpY2Uub25TdGFydF1dXG4gKiAgICAtIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBhbmQgW1tIb29rTWF0Y2hDcml0ZXJpb25dXVxuICpcbiAqIEEgYEdsb2JgIHN0cmluZyBpcyBhIHBhdHRlcm4gd2hpY2ggbWF0Y2hlcyBzdGF0ZSBuYW1lcy5cbiAqIE5lc3RlZCBzdGF0ZSBuYW1lcyBhcmUgc3BsaXQgaW50byBzZWdtZW50cyAoc2VwYXJhdGVkIGJ5IGEgZG90KSB3aGVuIHByb2Nlc3NpbmcuXG4gKiBUaGUgc3RhdGUgbmFtZWQgYGZvby5iYXIuYmF6YCBpcyBzcGxpdCBpbnRvIHRocmVlIHNlZ21lbnRzIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICpcbiAqIEdsb2JzIHdvcmsgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXM6XG4gKlxuICogIyMjIEV4YWN0IG1hdGNoOlxuICpcbiAqIFRoZSBnbG9iIGAnQS5CJ2AgbWF0Y2hlcyB0aGUgc3RhdGUgbmFtZWQgZXhhY3RseSBgJ0EuQidgLlxuICpcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkfFxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IGAnQSdgICAgICAgIHwgYCdBJ2AgICAgICAgICAgICAgICB8IGAnQidgICwgYCdBLkMnYCAgICAgIHxcbiAqIHwgYCdBLkInYCAgICAgfCBgJ0EuQidgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EuQi5DJ2AgICAgfFxuICogfCBgJ2ZvbydgICAgICB8IGAnZm9vJ2AgICAgICAgICAgICAgfCBgJ0ZPTydgICwgYCdmb28uYmFyJ2B8XG4gKlxuICogIyMjIFNpbmdsZSBzdGFyIChgKmApXG4gKlxuICogQSBzaW5nbGUgc3RhciAoYCpgKSBpcyBhIHdpbGRjYXJkIHRoYXQgbWF0Y2hlcyBleGFjdGx5IG9uZSBzZWdtZW50LlxuICpcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkICB8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWQgfFxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IGAnKidgICAgICAgIHwgYCdBJ2AgLCBgJ1onYCAgICAgICAgfCBgJ0EuQidgICwgYCdaLlkuWCdgICAgICAgIHxcbiAqIHwgYCdBLionYCAgICAgfCBgJ0EuQidgICwgYCdBLkMnYCAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgICAgICAgfFxuICogfCBgJ0EuKi4qJ2AgICB8IGAnQS5CLkMnYCAsIGAnQS5YLlknYHwgYCdBJ2AsIGAnQS5CJ2AgLCBgJ1ouWS5YJ2B8XG4gKlxuICogIyMjIERvdWJsZSBzdGFyIChgKipgKVxuICpcbiAqIEEgZG91YmxlIHN0YXIgKGAnKionYCkgaXMgYSB3aWxkY2FyZCB0aGF0IG1hdGNoZXMgKnplcm8gb3IgbW9yZSBzZWdtZW50cypcbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZCAgICAgICAgIHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJyoqJ2AgICAgICB8IGAnQSdgICwgYCdBLkInYCwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgICB8IChtYXRjaGVzIGFsbCBzdGF0ZXMpICAgICAgICAgICAgICB8XG4gKiB8IGAnQS4qKidgICAgIHwgYCdBJ2AgLCBgJ0EuQidgICwgYCdBLkMuWCdgICAgICAgICAgICAgICAgICAgIHwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCcqKi5YJ2AgICAgfCBgJ1gnYCAsIGAnQS5YJ2AgLCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5sb2dpbi5aJ2AgICAgICAgICAgICAgfFxuICogfCBgJ0EuKiouWCdgICB8IGAnQS5YJ2AgLCBgJ0EuQi5YJ2AgLCBgJ0EuQi5DLlgnYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgICAgICAgICAgICAgICB8XG4gKlxuICovXG5leHBvcnQgY2xhc3MgR2xvYiB7XG4gIHRleHQ6IHN0cmluZztcbiAgZ2xvYjogQXJyYXk8c3RyaW5nPjtcbiAgcmVnZXhwOiBSZWdFeHA7XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBnbG9iLWxpa2UgY2hhcmFjdGVycyBpbiBpdCAqL1xuICBzdGF0aWMgaXModGV4dDogc3RyaW5nKSB7XG4gICAgcmV0dXJuICEhL1shLCpdKy8uZXhlYyh0ZXh0KTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgZ2xvYiBmcm9tIHRoZSBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHN0cmluZyBpc24ndCBHbG9iLWxpa2UgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIEdsb2IuaXModGV4dCkgPyBuZXcgR2xvYih0ZXh0KSA6IG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih0ZXh0OiBzdHJpbmcpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZ2xvYiA9IHRleHQuc3BsaXQoJy4nKTtcblxuICAgIGNvbnN0IHJlZ2V4cFN0cmluZyA9IHRoaXMudGV4dFxuICAgICAgLnNwbGl0KCcuJylcbiAgICAgIC5tYXAoc2VnID0+IHtcbiAgICAgICAgaWYgKHNlZyA9PT0gJyoqJykgcmV0dXJuICcoPzp8KD86XFxcXC5bXi5dKikqKSc7XG4gICAgICAgIGlmIChzZWcgPT09ICcqJykgcmV0dXJuICdcXFxcLlteLl0qJztcbiAgICAgICAgcmV0dXJuICdcXFxcLicgKyBzZWc7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpO1xuXG4gICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKCdeJyArIHJlZ2V4cFN0cmluZyArICckJyk7XG4gIH1cblxuICBtYXRjaGVzKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cC50ZXN0KCcuJyArIG5hbWUpO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIGNvbW1vbiAqLyAvKiogKi9cbmltcG9ydCB7IHB1c2hUbyB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGNsYXNzIFF1ZXVlPFQ+IHtcbiAgcHJpdmF0ZSBfZXZpY3RMaXN0ZW5lcnM6ICgoaXRlbTogVCkgPT4gdm9pZClbXSA9IFtdO1xuICBwdWJsaWMgb25FdmljdCA9IHB1c2hUbyh0aGlzLl9ldmljdExpc3RlbmVycyk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaXRlbXM6IFRbXSA9IFtdLCBwcml2YXRlIF9saW1pdDogbnVtYmVyID0gbnVsbCkge31cblxuICBlbnF1ZXVlKGl0ZW06IFQpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgaWYgKHRoaXMuX2xpbWl0ICYmIGl0ZW1zLmxlbmd0aCA+IHRoaXMuX2xpbWl0KSB0aGlzLmV2aWN0KCk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICBldmljdCgpOiBUIHtcbiAgICBjb25zdCBpdGVtOiBUID0gdGhpcy5faXRlbXMuc2hpZnQoKTtcbiAgICB0aGlzLl9ldmljdExpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKGl0ZW0pKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIGRlcXVldWUoKTogVCB7XG4gICAgaWYgKHRoaXMuc2l6ZSgpKSByZXR1cm4gdGhpcy5faXRlbXMuc3BsaWNlKDAsIDEpWzBdO1xuICB9XG5cbiAgY2xlYXIoKTogQXJyYXk8VD4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9pdGVtcztcbiAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH1cblxuICByZW1vdmUoaXRlbTogVCkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgcmV0dXJuIGlkeCA+IC0xICYmIHRoaXMuX2l0ZW1zLnNwbGljZShpZHgsIDEpWzBdO1xuICB9XG5cbiAgcGVla1RhaWwoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgcGVla0hlYWQoKTogVCB7XG4gICAgaWYgKHRoaXMuc2l6ZSgpKSByZXR1cm4gdGhpcy5faXRlbXNbMF07XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdHJhbnNpdGlvbiAqLyAvKiogKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGV4dGVuZCwgc2lsZW50UmVqZWN0aW9uIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9jb21tb24vc3RyaW5ncyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuXG5lbnVtIFJlamVjdFR5cGUge1xuICAvKipcbiAgICogQSBuZXcgdHJhbnNpdGlvbiBzdXBlcnNlZGVkIHRoaXMgb25lLlxuICAgKlxuICAgKiBXaGlsZSB0aGlzIHRyYW5zaXRpb24gd2FzIHJ1bm5pbmcsIGEgbmV3IHRyYW5zaXRpb24gc3RhcnRlZC5cbiAgICogVGhpcyB0cmFuc2l0aW9uIGlzIGNhbmNlbGxlZCBiZWNhdXNlIGl0IHdhcyBzdXBlcnNlZGVkIGJ5IG5ldyB0cmFuc2l0aW9uLlxuICAgKi9cbiAgU1VQRVJTRURFRCA9IDIsXG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2l0aW9uIHdhcyBhYm9ydGVkXG4gICAqXG4gICAqIFRoZSB0cmFuc2l0aW9uIHdhcyBhYm9ydGVkIGJ5IGEgaG9vayB3aGljaCByZXR1cm5lZCBgZmFsc2VgXG4gICAqL1xuICBBQk9SVEVEID0gMyxcblxuICAvKipcbiAgICogVGhlIHRyYW5zaXRpb24gd2FzIGludmFsaWRcbiAgICpcbiAgICogVGhlIHRyYW5zaXRpb24gd2FzIG5ldmVyIHN0YXJ0ZWQgYmVjYXVzZSBpdCB3YXMgaW52YWxpZFxuICAgKi9cbiAgSU5WQUxJRCA9IDQsXG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2l0aW9uIHdhcyBpZ25vcmVkXG4gICAqXG4gICAqIFRoZSB0cmFuc2l0aW9uIHdhcyBpZ25vcmVkIGJlY2F1c2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QuXG4gICAqXG4gICAqIEVpdGhlcjpcbiAgICpcbiAgICogLSBUaGUgdHJhbnNpdGlvbiBpcyB0YXJnZXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHBhcmFtZXRlciB2YWx1ZXNcbiAgICogLSBUaGUgdHJhbnNpdGlvbiBpcyB0YXJnZXRpbmcgdGhlIHNhbWUgc3RhdGUgYW5kIHBhcmFtZXRlciB2YWx1ZXMgYXMgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRyYW5zaXRpb24uXG4gICAqL1xuICBJR05PUkVEID0gNSxcblxuICAvKipcbiAgICogVGhlIHRyYW5zaXRpb24gZXJyb3JlZC5cbiAgICpcbiAgICogVGhpcyBnZW5lcmFsbHkgbWVhbnMgYSBob29rIHRocmV3IGFuIGVycm9yIG9yIHJldHVybmVkIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgKi9cbiAgRVJST1IgPSA2LFxufVxuXG5leHBvcnQgeyBSZWplY3RUeXBlIH07XG5cbi8qKiBAaGlkZGVuICovXG5sZXQgaWQgPSAwO1xuXG5leHBvcnQgY2xhc3MgUmVqZWN0aW9uIHtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgJGlkID0gaWQrKztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSByZWplY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgaXMgYW4gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0cmFuc2l0aW9uIHJlamVjdGlvbi5cbiAgICogSWYgdXNpbmcgVHlwZXNjcmlwdCwgdGhpcyBpcyBhIFR5cGVzY3JpcHQgZW51bS5cbiAgICpcbiAgICogLSBbW1JlamVjdFR5cGUuU1VQRVJTRURFRF1dIChgMmApXG4gICAqIC0gW1tSZWplY3RUeXBlLkFCT1JURURdXSAoYDNgKVxuICAgKiAtIFtbUmVqZWN0VHlwZS5JTlZBTElEXV0gKGA0YClcbiAgICogLSBbW1JlamVjdFR5cGUuSUdOT1JFRF1dIChgNWApXG4gICAqIC0gW1tSZWplY3RUeXBlLkVSUk9SXV0gKGA2YClcbiAgICpcbiAgICovXG4gIHR5cGU6IFJlamVjdFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSByZWplY3Rpb25cbiAgICovXG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogQSBkZXRhaWwgb2JqZWN0XG4gICAqXG4gICAqIFRoaXMgdmFsdWUgdmFyaWVzIGJhc2VkIG9uIHRoZSBtZWNoYW5pc20gZm9yIHJlamVjdGluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGlmIGFuIGVycm9yIHdhcyB0aHJvd24gZnJvbSBhIGhvb2ssIHRoZSBgZGV0YWlsYCB3aWxsIGJlIHRoZSBgRXJyb3JgIG9iamVjdC5cbiAgICogSWYgYSBob29rIHJldHVybmVkIGEgcmVqZWN0ZWQgcHJvbWlzZSwgdGhlIGBkZXRhaWxgIHdpbGwgYmUgdGhlIHJlamVjdGVkIHZhbHVlLlxuICAgKi9cbiAgZGV0YWlsOiBhbnk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgdHJhbnNpdGlvbiB3YXMgcmVkaXJlY3RlZC5cbiAgICpcbiAgICogV2hlbiBhIHRyYW5zaXRpb24gaXMgcmVkaXJlY3RlZCwgdGhlIHJlamVjdGlvbiBbW3R5cGVdXSB3aWxsIGJlIFtbUmVqZWN0VHlwZS5TVVBFUlNFREVEXV0gYW5kIHRoaXMgZmxhZyB3aWxsIGJlIHRydWUuXG4gICAqL1xuICByZWRpcmVjdGVkOiBib29sZWFuO1xuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iaiBpcyBhIHJlamVjdGVkIHByb21pc2UgY3JlYXRlZCBmcm9tIHRoZSBgYXNQcm9taXNlYCBmYWN0b3J5ICovXG4gIHN0YXRpYyBpc1JlamVjdGlvblByb21pc2Uob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpcyhSZWplY3Rpb24pKG9iai5fdHJhbnNpdGlvblJlamVjdGlvbik7XG4gIH1cblxuICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gdHJhbnNpdGlvbiBzdXBlcnNlZGVkICovXG4gIHN0YXRpYyBzdXBlcnNlZGVkKGRldGFpbD86IGFueSwgb3B0aW9ucz86IGFueSk6IFJlamVjdGlvbiB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBzdXBlcnNlZGVkIGJ5IGEgZGlmZmVyZW50IHRyYW5zaXRpb24nO1xuICAgIGNvbnN0IHJlamVjdGlvbiA9IG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5TVVBFUlNFREVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVkaXJlY3RlZCkge1xuICAgICAgcmVqZWN0aW9uLnJlZGlyZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVqZWN0aW9uO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbiAqL1xuICBzdGF0aWMgcmVkaXJlY3RlZChkZXRhaWw/OiBhbnkpOiBSZWplY3Rpb24ge1xuICAgIHJldHVybiBSZWplY3Rpb24uc3VwZXJzZWRlZChkZXRhaWwsIHsgcmVkaXJlY3RlZDogdHJ1ZSB9KTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBpbnZhbGlkIHRyYW5zaXRpb24gKi9cbiAgc3RhdGljIGludmFsaWQoZGV0YWlsPzogYW55KTogUmVqZWN0aW9uIHtcbiAgICBjb25zdCBtZXNzYWdlID0gJ1RoaXMgdHJhbnNpdGlvbiBpcyBpbnZhbGlkJztcbiAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLklOVkFMSUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gIH1cblxuICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gaWdub3JlZCB0cmFuc2l0aW9uICovXG4gIHN0YXRpYyBpZ25vcmVkKGRldGFpbD86IGFueSk6IFJlamVjdGlvbiB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiB3YXMgaWdub3JlZCc7XG4gICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5JR05PUkVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGFib3J0ZWQgdHJhbnNpdGlvbiAqL1xuICBzdGF0aWMgYWJvcnRlZChkZXRhaWw/OiBhbnkpOiBSZWplY3Rpb24ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnVGhlIHRyYW5zaXRpb24gaGFzIGJlZW4gYWJvcnRlZCc7XG4gICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5BQk9SVEVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGFib3J0ZWQgdHJhbnNpdGlvbiAqL1xuICBzdGF0aWMgZXJyb3JlZChkZXRhaWw/OiBhbnkpOiBSZWplY3Rpb24ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnVGhlIHRyYW5zaXRpb24gZXJyb3JlZCc7XG4gICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5FUlJPUiwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgUmVqZWN0aW9uXG4gICAqXG4gICAqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIFJlamVjdGlvbi5cbiAgICogSWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgYSBSZWplY3Rpb24sIHJldHVybnMgaXQuXG4gICAqIE90aGVyd2lzZSwgd3JhcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIGFzIGEgUmVqZWN0aW9uIChSZWplY3Rpb24gdHlwZTogRVJST1IpLlxuICAgKlxuICAgKiBAcmV0dXJucyBgZGV0YWlsYCBpZiBpdCBpcyBhbHJlYWR5IGEgYFJlamVjdGlvbmAsIGVsc2UgcmV0dXJucyBhbiBFUlJPUiBSZWplY3Rpb24uXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplKGRldGFpbD86IFJlamVjdGlvbiB8IEVycm9yIHwgYW55KTogUmVqZWN0aW9uIHtcbiAgICByZXR1cm4gaXMoUmVqZWN0aW9uKShkZXRhaWwpID8gZGV0YWlsIDogUmVqZWN0aW9uLmVycm9yZWQoZGV0YWlsKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IG51bWJlciwgbWVzc2FnZT86IHN0cmluZywgZGV0YWlsPzogYW55KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgZGV0YWlsU3RyaW5nID0gKGQ6IGFueSkgPT4gKGQgJiYgZC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA/IGQudG9TdHJpbmcoKSA6IHN0cmluZ2lmeShkKSk7XG4gICAgY29uc3QgZGV0YWlsID0gZGV0YWlsU3RyaW5nKHRoaXMuZGV0YWlsKTtcbiAgICBjb25zdCB7ICRpZCwgdHlwZSwgbWVzc2FnZSB9ID0gdGhpcztcbiAgICByZXR1cm4gYFRyYW5zaXRpb24gUmVqZWN0aW9uKCRpZDogJHskaWR9IHR5cGU6ICR7dHlwZX0sIG1lc3NhZ2U6ICR7bWVzc2FnZX0sIGRldGFpbDogJHtkZXRhaWx9KWA7XG4gIH1cblxuICB0b1Byb21pc2UoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gZXh0ZW5kKHNpbGVudFJlamVjdGlvbih0aGlzKSwgeyBfdHJhbnNpdGlvblJlamVjdGlvbjogdGhpcyB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBGdW5jdGlvbnMgdGhhdCBtYW5pcHVsYXRlIHN0cmluZ3NcbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCB0aGV5IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9zdHJpbmdzXG4gKi8gLyoqICovXG5cbmltcG9ydCB7IGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzSW5qZWN0YWJsZSwgaXNOdWxsLCBpc09iamVjdCwgaXNQcm9taXNlLCBpc1N0cmluZywgaXNVbmRlZmluZWQgfSBmcm9tICcuL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgUmVqZWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5JztcbmltcG9ydCB7IGlkZW50aXR5LCBJSW5qZWN0YWJsZSwgcHVzaFIsIHRhaWwgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBwYXR0ZXJuLCB2YWwgfSBmcm9tICcuL2hvZic7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBzaG9ydGVuZWQgdG8gYSBtYXhpbXVtIGxlbmd0aFxuICpcbiAqIElmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBsZXNzIHRoYW4gdGhlIGBtYXhgIGxlbmd0aCwgcmV0dXJuIHRoZSBzdHJpbmcuXG4gKiBFbHNlIHJldHVybiB0aGUgc3RyaW5nLCBzaG9ydGVuZWQgdG8gYG1heCAtIDNgIGFuZCBhcHBlbmQgdGhyZWUgZG90cyAoXCIuLi5cIikuXG4gKlxuICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHN0cmluZyB0byByZXR1cm5cbiAqIEBwYXJhbSBzdHIgdGhlIGlucHV0IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4TGVuZ3RoKG1heDogbnVtYmVyLCBzdHI6IHN0cmluZykge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBtYXgpIHJldHVybiBzdHI7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heCAtIDMpICsgJy4uLic7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZywgd2l0aCBzcGFjZXMgYWRkZWQgdG8gdGhlIGVuZCwgdXAgdG8gYSBkZXNpcmVkIHN0ciBsZW5ndGhcbiAqXG4gKiBJZiB0aGUgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gdGhlIGRlc2lyZWQgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cbiAqIEVsc2UgcmV0dXJucyB0aGUgc3RyaW5nLCB3aXRoIGV4dHJhIHNwYWNlcyBvbiB0aGUgZW5kLCBzdWNoIHRoYXQgaXQgcmVhY2hlcyBgbGVuZ3RoYCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBsZW5ndGggdGhlIGRlc2lyZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmV0dXJuXG4gKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0cmluZyhsZW5ndGg6IG51bWJlciwgc3RyOiBzdHJpbmcpIHtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpIHN0ciArPSAnICc7XG4gIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBrZWJvYlN0cmluZyhjYW1lbENhc2U6IHN0cmluZykge1xuICByZXR1cm4gY2FtZWxDYXNlXG4gICAgLnJlcGxhY2UoL14oW0EtWl0pLywgJDEgPT4gJDEudG9Mb3dlckNhc2UoKSkgLy8gcmVwbGFjZSBmaXJzdCBjaGFyXG4gICAgLnJlcGxhY2UoLyhbQS1aXSkvZywgJDEgPT4gJy0nICsgJDEudG9Mb3dlckNhc2UoKSk7IC8vIHJlcGxhY2UgcmVzdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25Ub1N0cmluZyhmbjogRnVuY3Rpb24pIHtcbiAgY29uc3QgZm5TdHIgPSBmblRvU3RyaW5nKGZuKTtcbiAgY29uc3QgbmFtZWRGdW5jdGlvbk1hdGNoID0gZm5TdHIubWF0Y2goL14oZnVuY3Rpb24gW14gXStcXChbXildKlxcKSkvKTtcbiAgY29uc3QgdG9TdHIgPSBuYW1lZEZ1bmN0aW9uTWF0Y2ggPyBuYW1lZEZ1bmN0aW9uTWF0Y2hbMV0gOiBmblN0cjtcblxuICBjb25zdCBmbk5hbWUgPSBmblsnbmFtZSddIHx8ICcnO1xuICBpZiAoZm5OYW1lICYmIHRvU3RyLm1hdGNoKC9mdW5jdGlvbiBcXCgvKSkge1xuICAgIHJldHVybiAnZnVuY3Rpb24gJyArIGZuTmFtZSArIHRvU3RyLnN1YnN0cig5KTtcbiAgfVxuICByZXR1cm4gdG9TdHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmblRvU3RyaW5nKGZuOiBJSW5qZWN0YWJsZSkge1xuICBjb25zdCBfZm4gPSBpc0FycmF5KGZuKSA/IGZuLnNsaWNlKC0xKVswXSA6IGZuO1xuICByZXR1cm4gKF9mbiAmJiBfZm4udG9TdHJpbmcoKSkgfHwgJ3VuZGVmaW5lZCc7XG59XG5cbmNvbnN0IGlzUmVqZWN0aW9uID0gUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZTtcbmNvbnN0IGhhc1RvU3RyaW5nID0gKG9iajogYW55KSA9PlxuICBpc09iamVjdChvYmopICYmICFpc0FycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgJiYgaXNGdW5jdGlvbihvYmoudG9TdHJpbmcpO1xuXG5jb25zdCBzdHJpbmdpZnlQYXR0ZXJuID0gcGF0dGVybihbXG4gIFtpc1VuZGVmaW5lZCwgdmFsKCd1bmRlZmluZWQnKV0sXG4gIFtpc051bGwsIHZhbCgnbnVsbCcpXSxcbiAgW2lzUHJvbWlzZSwgdmFsKCdbUHJvbWlzZV0nKV0sXG4gIFtpc1JlamVjdGlvbiwgKHg6IGFueSkgPT4geC5fdHJhbnNpdGlvblJlamVjdGlvbi50b1N0cmluZygpXSxcbiAgW2hhc1RvU3RyaW5nLCAoeDogb2JqZWN0KSA9PiB4LnRvU3RyaW5nKCldLFxuICBbaXNJbmplY3RhYmxlLCBmdW5jdGlvblRvU3RyaW5nXSxcbiAgW3ZhbCh0cnVlKSwgaWRlbnRpdHldLFxuXSkgYXMgKHZhbDogYW55KSA9PiBzdHJpbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkobzogYW55KSB7XG4gIGNvbnN0IHNlZW46IGFueVtdID0gW107XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHJldHVybiAnW2NpcmN1bGFyIHJlZl0nO1xuICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeVBhdHRlcm4odmFsdWUpO1xuICB9XG5cbiAgaWYgKGlzVW5kZWZpbmVkKG8pKSB7XG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgSUUgJiBFZGdlIFNwZWMgaW5jb21wYXRpYmlsaXR5IHdoZXJlIHJlcGxhY2VyIGZ1bmN0aW9uIHdvdWxkIG5vdCBiZSBjYWxsZWQgd2hlbiBKU09OLnN0cmluZ2lmeVxuICAgIC8vIGlzIGdpdmVuIGB1bmRlZmluZWRgIGFzIHZhbHVlLiBUbyB3b3JrIGFyb3VuZCB0aGF0LCB3ZSBzaW1wbHkgZGV0ZWN0IGB1bmRlZmluZWRgIGFuZCBiYWlsIG91dCBlYXJseSBieVxuICAgIC8vIG1hbnVhbGx5IHN0cmluZ2lmeWluZyBpdC5cbiAgICByZXR1cm4gZm9ybWF0KG8pO1xuICB9XG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG8sIChrZXksIHZhbHVlKSA9PiBmb3JtYXQodmFsdWUpKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG59XG5cbi8qKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBzcGxpdHMgYSBzdHJpbmcgb24gYSBjaGFyYWN0ZXIgb3Igc3Vic3RyaW5nICovXG5leHBvcnQgY29uc3QgYmVmb3JlQWZ0ZXJTdWJzdHIgPSAoY2hhcjogc3RyaW5nKSA9PiAoc3RyOiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XG4gIGlmICghc3RyKSByZXR1cm4gWycnLCAnJ107XG4gIGNvbnN0IGlkeCA9IHN0ci5pbmRleE9mKGNoYXIpO1xuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIFtzdHIsICcnXTtcbiAgcmV0dXJuIFtzdHIuc3Vic3RyKDAsIGlkeCksIHN0ci5zdWJzdHIoaWR4ICsgMSldO1xufTtcblxuZXhwb3J0IGNvbnN0IGhvc3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oPzpbYS16XSs6KT8vL1teL10rLycpO1xuZXhwb3J0IGNvbnN0IHN0cmlwTGFzdFBhdGhFbGVtZW50ID0gKHN0cjogc3RyaW5nKSA9PiBzdHIucmVwbGFjZSgvXFwvW14vXSokLywgJycpO1xuZXhwb3J0IGNvbnN0IHNwbGl0SGFzaCA9IGJlZm9yZUFmdGVyU3Vic3RyKCcjJyk7XG5leHBvcnQgY29uc3Qgc3BsaXRRdWVyeSA9IGJlZm9yZUFmdGVyU3Vic3RyKCc/Jyk7XG5leHBvcnQgY29uc3Qgc3BsaXRFcXVhbCA9IGJlZm9yZUFmdGVyU3Vic3RyKCc9Jyk7XG5leHBvcnQgY29uc3QgdHJpbUhhc2hWYWwgPSAoc3RyOiBzdHJpbmcpID0+IChzdHIgPyBzdHIucmVwbGFjZSgvXiMvLCAnJykgOiAnJyk7XG5cbi8qKlxuICogU3BsaXRzIG9uIGEgZGVsaW1pdGVyLCBidXQgcmV0dXJucyB0aGUgZGVsaW1pdGVycyBpbiB0aGUgYXJyYXlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdmFyIHNwbGl0T25TbGFzaGVzID0gc3BsaXRPbkRlbGltKCcvJyk7XG4gKiBzcGxpdE9uU2xhc2hlcyhcIi9mb29cIik7IC8vIFtcIi9cIiwgXCJmb29cIl1cbiAqIHNwbGl0T25TbGFzaGVzKFwiL2Zvby9cIik7IC8vIFtcIi9cIiwgXCJmb29cIiwgXCIvXCJdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T25EZWxpbShkZWxpbTogc3RyaW5nKSB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cCgnKCcgKyBkZWxpbSArICcpJywgJ2cnKTtcbiAgcmV0dXJuIChzdHI6IHN0cmluZykgPT4gc3RyLnNwbGl0KHJlKS5maWx0ZXIoaWRlbnRpdHkpO1xufVxuXG4vKipcbiAqIFJlZHVjZSBmbiB0aGF0IGpvaW5zIG5laWdoYm9yaW5nIHN0cmluZ3NcbiAqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLCByZXR1cm5zIGEgbmV3IGFycmF5XG4gKiB3aGVyZSBhbGwgbmVpZ2hib3Jpbmcgc3RyaW5ncyBoYXZlIGJlZW4gam9pbmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBsZXQgYXJyID0gW1wiZm9vXCIsIFwiYmFyXCIsIDEsIFwiYmF6XCIsIFwiXCIsIFwicXV4XCIgXTtcbiAqIGFyci5yZWR1Y2Uoam9pbk5laWdoYm9yc1IsIFtdKSAvLyBbXCJmb29iYXJcIiwgMSwgXCJiYXpxdXhcIiBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpvaW5OZWlnaGJvcnNSKGFjYzogYW55W10sIHg6IGFueSkge1xuICBpZiAoaXNTdHJpbmcodGFpbChhY2MpKSAmJiBpc1N0cmluZyh4KSkgcmV0dXJuIGFjYy5zbGljZSgwLCAtMSkuY29uY2F0KHRhaWwoYWNjKSArIHgpO1xuICByZXR1cm4gcHVzaFIoYWNjLCB4KTtcbn1cbiIsIi8qKiB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIGNvbnNvbGUgb2JqZWN0IGluIElFOSB3aGVuIGRldiB0b29scyBoYXZlbid0IGJlZW4gb3BlbmVkIG9fTyAqL1xuLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3Qgbm9vcENvbnNvbGVTdHViID0geyBsb2c6IG5vb3AsIGVycm9yOiBub29wLCB0YWJsZTogbm9vcCB9O1xuXG5mdW5jdGlvbiBpZTlDb25zb2xlKGNvbnNvbGUpIHtcbiAgY29uc3QgYm91bmQgPSAoZm46IEZ1bmN0aW9uKSA9PiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGZuLCBjb25zb2xlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2c6IGJvdW5kKGNvbnNvbGUubG9nKSxcbiAgICBlcnJvcjogYm91bmQoY29uc29sZS5sb2cpLFxuICAgIHRhYmxlOiBib3VuZChjb25zb2xlLmxvZyksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZhbGxiYWNrQ29uc29sZShjb25zb2xlKSB7XG4gIGNvbnN0IGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gIGNvbnN0IGVycm9yID0gY29uc29sZS5lcnJvciA/IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSA6IGxvZztcbiAgY29uc3QgdGFibGUgPSBjb25zb2xlLnRhYmxlID8gY29uc29sZS50YWJsZS5iaW5kKGNvbnNvbGUpIDogbG9nO1xuICByZXR1cm4geyBsb2csIGVycm9yLCB0YWJsZSB9O1xufVxuXG5mdW5jdGlvbiBnZXRTYWZlQ29uc29sZSgpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBpc0lFOSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gOTtcbiAgaWYgKGlzSUU5KSB7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiB3aW5kb3cuY29uc29sZSA/IGllOUNvbnNvbGUod2luZG93LmNvbnNvbGUpIDogbm9vcENvbnNvbGVTdHViO1xuICB9IGVsc2UgaWYgKCFjb25zb2xlLnRhYmxlIHx8ICFjb25zb2xlLmVycm9yKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29uc29sZShjb25zb2xlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uc29sZTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2FmZUNvbnNvbGUgPSBnZXRTYWZlQ29uc29sZSgpO1xuIiwiLyoqXG4gKiAjIFRyYW5zaXRpb24gdHJhY2luZyAoZGVidWcpXG4gKlxuICogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2luZyB0byBwcmludCB0cmFuc2l0aW9uIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLFxuICogaW4gb3JkZXIgdG8gaGVscCBkZWJ1ZyB5b3VyIGFwcGxpY2F0aW9uLlxuICogVHJhY2luZyBsb2dzIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggVHJhbnNpdGlvbiB0byB5b3VyIGNvbnNvbGUuXG4gKlxuICogVG8gZW5hYmxlIHRyYWNpbmcsIGltcG9ydCB0aGUgW1tUcmFjZV1dIHNpbmdsZXRvbiBhbmQgZW5hYmxlIG9uZSBvciBtb3JlIGNhdGVnb3JpZXMuXG4gKlxuICogIyMjIEVTNlxuICogYGBganNcbiAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJAdWlyb3V0ZXIvY29yZVwiO1xuICogdHJhY2UuZW5hYmxlKDEsIDUpOyAvLyBUUkFOU0lUSU9OIGFuZCBWSUVXQ09ORklHXG4gKiBgYGBcbiAqXG4gKiAjIyMgQ0pTXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gcmVxdWlyZShcIkB1aXJvdXRlci9jb3JlXCIpLnRyYWNlO1xuICogdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiLCBcIlZJRVdDT05GSUdcIik7XG4gKiBgYGBcbiAqXG4gKiAjIyMgR2xvYmFsc1xuICogYGBganNcbiAqIGxldCB0cmFjZSA9IHdpbmRvd1tcIkB1aXJvdXRlci9jb3JlXCJdLnRyYWNlO1xuICogdHJhY2UuZW5hYmxlKCk7IC8vIFRyYWNlIGV2ZXJ5dGhpbmcgKHZlcnkgdmVyYm9zZSlcbiAqIGBgYFxuICpcbiAqICMjIyBBbmd1bGFyIDE6XG4gKiBgYGBqc1xuICogYXBwLnJ1bigkdHJhY2UgPT4gJHRyYWNlLmVuYWJsZSgpKTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFjZVxuICovXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNOdW1iZXIgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFZpZXdUdXBsZSB9IGZyb20gJy4uL3ZpZXcnO1xuaW1wb3J0IHsgQWN0aXZlVUlWaWV3LCBWaWV3Q29uZmlnLCBWaWV3Q29udGV4dCB9IGZyb20gJy4uL3ZpZXcvaW50ZXJmYWNlJztcbmltcG9ydCB7IHN0cmluZ2lmeSwgZnVuY3Rpb25Ub1N0cmluZywgbWF4TGVuZ3RoLCBwYWRTdHJpbmcgfSBmcm9tICcuL3N0cmluZ3MnO1xuaW1wb3J0IHsgc2FmZUNvbnNvbGUgfSBmcm9tICcuL3NhZmVDb25zb2xlJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuLi9yZXNvbHZlL3Jlc29sdmFibGUnO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IFBvbGljeVdoZW4gfSBmcm9tICcuLi9yZXNvbHZlL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uSG9vayB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2snO1xuaW1wb3J0IHsgSG9va1Jlc3VsdCB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdWlWaWV3U3RyaW5nKHVpdmlldzogQWN0aXZlVUlWaWV3KSB7XG4gIGlmICghdWl2aWV3KSByZXR1cm4gJ3VpLXZpZXcgKGRlZnVuY3QpJztcbiAgY29uc3Qgc3RhdGUgPSB1aXZpZXcuY3JlYXRpb25Db250ZXh0ID8gdWl2aWV3LmNyZWF0aW9uQ29udGV4dC5uYW1lIHx8ICcocm9vdCknIDogJyhub25lKSc7XG4gIHJldHVybiBgW3VpLXZpZXcjJHt1aXZpZXcuaWR9ICR7dWl2aWV3LiR0eXBlfToke3Vpdmlldy5mcW59ICgke3Vpdmlldy5uYW1lfUAke3N0YXRlfSldYDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHZpZXdDb25maWdTdHJpbmcgPSAodmlld0NvbmZpZzogVmlld0NvbmZpZykgPT4ge1xuICBjb25zdCB2aWV3ID0gdmlld0NvbmZpZy52aWV3RGVjbDtcbiAgY29uc3Qgc3RhdGUgPSB2aWV3LiRjb250ZXh0Lm5hbWUgfHwgJyhyb290KSc7XG4gIHJldHVybiBgW1ZpZXcjJHt2aWV3Q29uZmlnLiRpZH0gZnJvbSAnJHtzdGF0ZX0nIHN0YXRlXTogdGFyZ2V0IHVpLXZpZXc6ICcke3ZpZXcuJHVpVmlld05hbWV9QCR7dmlldy4kdWlWaWV3Q29udGV4dEFuY2hvcn0nYDtcbn07XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBub3JtYWxpemVkQ2F0KGlucHV0OiBDYXRlZ29yeSB8IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBpc051bWJlcihpbnB1dCkgPyBDYXRlZ29yeVtpbnB1dF0gOiBDYXRlZ29yeVtDYXRlZ29yeVtpbnB1dF1dO1xufVxuXG4vKipcbiAqIFRyYWNlIGNhdGVnb3JpZXMgRW51bVxuICpcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGEgY2F0ZWdvcnkgdXNpbmcgW1tUcmFjZS5lbmFibGVdXSBvciBbW1RyYWNlLmRpc2FibGVdXVxuICpcbiAqIGB0cmFjZS5lbmFibGUoQ2F0ZWdvcnkuVFJBTlNJVElPTilgXG4gKlxuICogVGhlc2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgdXNpbmcgYSBtYXRjaGluZyBzdHJpbmcsIG9yIHBvc2l0aW9uIG9yZGluYWxcbiAqXG4gKiBgdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiKWBcbiAqXG4gKiBgdHJhY2UuZW5hYmxlKDEpYFxuICovXG5lbnVtIENhdGVnb3J5IHtcbiAgUkVTT0xWRSxcbiAgVFJBTlNJVElPTixcbiAgSE9PSyxcbiAgVUlWSUVXLFxuICBWSUVXQ09ORklHLFxufVxuXG5leHBvcnQgeyBDYXRlZ29yeSB9O1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgX3RpZCA9IHBhcnNlKCckaWQnKTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IF9yaWQgPSBwYXJzZSgncm91dGVyLiRpZCcpO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgdHJhbnNMYmwgPSB0cmFucyA9PiBgVHJhbnNpdGlvbiAjJHtfdGlkKHRyYW5zKX0tJHtfcmlkKHRyYW5zKX1gO1xuXG4vKipcbiAqIFByaW50cyBVSS1Sb3V0ZXIgVHJhbnNpdGlvbiB0cmFjZSBpbmZvcm1hdGlvbiB0byB0aGUgY29uc29sZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNlIHtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgYXBwcm94aW1hdGVEaWdlc3RzOiBudW1iZXI7XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfZW5hYmxlZDogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFwcHJveGltYXRlRGlnZXN0cyA9IDA7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9zZXQoZW5hYmxlZDogYm9vbGVhbiwgY2F0ZWdvcmllczogQ2F0ZWdvcnlbXSkge1xuICAgIGlmICghY2F0ZWdvcmllcy5sZW5ndGgpIHtcbiAgICAgIGNhdGVnb3JpZXMgPSA8YW55Pk9iamVjdC5rZXlzKENhdGVnb3J5KVxuICAgICAgICAubWFwKGsgPT4gcGFyc2VJbnQoaywgMTApKVxuICAgICAgICAuZmlsdGVyKGsgPT4gIWlzTmFOKGspKVxuICAgICAgICAubWFwKGtleSA9PiBDYXRlZ29yeVtrZXldKTtcbiAgICB9XG4gICAgY2F0ZWdvcmllcy5tYXAobm9ybWFsaXplZENhdCkuZm9yRWFjaChjYXRlZ29yeSA9PiAodGhpcy5fZW5hYmxlZFtjYXRlZ29yeV0gPSBlbmFibGVkKSk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBhIHRyYWNlIFtbQ2F0ZWdvcnldXVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNhdGVnb3JpZXMgY2F0ZWdvcmllcyB0byBlbmFibGUuIElmIGBjYXRlZ29yaWVzYCBpcyBvbWl0dGVkLCBhbGwgY2F0ZWdvcmllcyBhcmUgZW5hYmxlZC5cbiAgICogICAgICAgIEFsc28gdGFrZXMgc3RyaW5ncyAoY2F0ZWdvcnkgbmFtZSkgb3Igb3JkaW5hbCAoY2F0ZWdvcnkgcG9zaXRpb24pXG4gICAqL1xuICBlbmFibGUoLi4uY2F0ZWdvcmllczogKENhdGVnb3J5IHwgc3RyaW5nIHwgbnVtYmVyKVtdKTtcbiAgZW5hYmxlKC4uLmNhdGVnb3JpZXM6IGFueVtdKSB7XG4gICAgdGhpcy5fc2V0KHRydWUsIGNhdGVnb3JpZXMpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBhIHRyYWNlIFtbQ2F0ZWdvcnldXVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB0cmFjZS5kaXNhYmxlKFwiVklFV0NPTkZJR1wiKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjYXRlZ29yaWVzIGNhdGVnb3JpZXMgdG8gZGlzYWJsZS4gSWYgYGNhdGVnb3JpZXNgIGlzIG9taXR0ZWQsIGFsbCBjYXRlZ29yaWVzIGFyZSBkaXNhYmxlZC5cbiAgICogICAgICAgIEFsc28gdGFrZXMgc3RyaW5ncyAoY2F0ZWdvcnkgbmFtZSkgb3Igb3JkaW5hbCAoY2F0ZWdvcnkgcG9zaXRpb24pXG4gICAqL1xuICBkaXNhYmxlKC4uLmNhdGVnb3JpZXM6IChDYXRlZ29yeSB8IHN0cmluZyB8IG51bWJlcilbXSk7XG4gIGRpc2FibGUoLi4uY2F0ZWdvcmllczogYW55W10pIHtcbiAgICB0aGlzLl9zZXQoZmFsc2UsIGNhdGVnb3JpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZW5hYmxlZCBzdGF0ZXVzIG9mIGEgW1tDYXRlZ29yeV1dXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHRyYWNlLmVuYWJsZWQoXCJWSUVXQ09ORklHXCIpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBib29sZWFuIHRydWUgaWYgdGhlIGNhdGVnb3J5IGlzIGVuYWJsZWRcbiAgICovXG4gIGVuYWJsZWQoY2F0ZWdvcnk6IENhdGVnb3J5IHwgc3RyaW5nIHwgbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fZW5hYmxlZFtub3JtYWxpemVkQ2F0KGNhdGVnb3J5KV07XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVRyYW5zaXRpb25TdGFydCh0cmFuczogVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGAke3RyYW5zTGJsKHRyYW5zKX06IFN0YXJ0ZWQgIC0+ICR7c3RyaW5naWZ5KHRyYW5zKX1gKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlVHJhbnNpdGlvbklnbm9yZWQodHJhbnM6IFRyYW5zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSkgcmV0dXJuO1xuICAgIHNhZmVDb25zb2xlLmxvZyhgJHt0cmFuc0xibCh0cmFucyl9OiBJZ25vcmVkICA8PiAke3N0cmluZ2lmeSh0cmFucyl9YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZUhvb2tJbnZvY2F0aW9uKHN0ZXA6IFRyYW5zaXRpb25Ib29rLCB0cmFuczogVHJhbnNpdGlvbiwgb3B0aW9uczogYW55KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuSE9PSykpIHJldHVybjtcbiAgICBjb25zdCBldmVudCA9IHBhcnNlKCd0cmFjZURhdGEuaG9va1R5cGUnKShvcHRpb25zKSB8fCAnaW50ZXJuYWwnLFxuICAgICAgY29udGV4dCA9IHBhcnNlKCd0cmFjZURhdGEuY29udGV4dC5zdGF0ZS5uYW1lJykob3B0aW9ucykgfHwgcGFyc2UoJ3RyYWNlRGF0YS5jb250ZXh0Jykob3B0aW9ucykgfHwgJ3Vua25vd24nLFxuICAgICAgbmFtZSA9IGZ1bmN0aW9uVG9TdHJpbmcoKHN0ZXAgYXMgYW55KS5yZWdpc3RlcmVkSG9vay5jYWxsYmFjayk7XG4gICAgc2FmZUNvbnNvbGUubG9nKGAke3RyYW5zTGJsKHRyYW5zKX06ICAgSG9vayAtPiAke2V2ZW50fSBjb250ZXh0OiAke2NvbnRleHR9LCAke21heExlbmd0aCgyMDAsIG5hbWUpfWApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VIb29rUmVzdWx0KGhvb2tSZXN1bHQ6IEhvb2tSZXN1bHQsIHRyYW5zOiBUcmFuc2l0aW9uLCB0cmFuc2l0aW9uT3B0aW9uczogYW55KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuSE9PSykpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYCR7dHJhbnNMYmwodHJhbnMpfTogICA8LSBIb29rIHJldHVybmVkOiAke21heExlbmd0aCgyMDAsIHN0cmluZ2lmeShob29rUmVzdWx0KSl9YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVJlc29sdmVQYXRoKHBhdGg6IFBhdGhOb2RlW10sIHdoZW46IFBvbGljeVdoZW4sIHRyYW5zPzogVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGAke3RyYW5zTGJsKHRyYW5zKX06ICAgICAgICAgUmVzb2x2aW5nICR7cGF0aH0gKCR7d2hlbn0pYCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVJlc29sdmFibGVSZXNvbHZlZChyZXNvbHZhYmxlOiBSZXNvbHZhYmxlLCB0cmFucz86IFRyYW5zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSkgcmV0dXJuO1xuICAgIHNhZmVDb25zb2xlLmxvZyhcbiAgICAgIGAke3RyYW5zTGJsKHRyYW5zKX06ICAgICAgICAgICAgICAgPC0gUmVzb2x2ZWQgICR7cmVzb2x2YWJsZX0gdG86ICR7bWF4TGVuZ3RoKDIwMCwgc3RyaW5naWZ5KHJlc29sdmFibGUuZGF0YSkpfWBcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VFcnJvcihyZWFzb246IGFueSwgdHJhbnM6IFRyYW5zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSkgcmV0dXJuO1xuICAgIHNhZmVDb25zb2xlLmxvZyhgJHt0cmFuc0xibCh0cmFucyl9OiA8LSBSZWplY3RlZCAke3N0cmluZ2lmeSh0cmFucyl9LCByZWFzb246ICR7cmVhc29ufWApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VTdWNjZXNzKGZpbmFsU3RhdGU6IFN0YXRlT2JqZWN0LCB0cmFuczogVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGAke3RyYW5zTGJsKHRyYW5zKX06IDwtIFN1Y2Nlc3MgICR7c3RyaW5naWZ5KHRyYW5zKX0sIGZpbmFsIHN0YXRlOiAke2ZpbmFsU3RhdGUubmFtZX1gKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gIHRyYWNlVUlWaWV3RXZlbnQoZXZlbnQ6IHN0cmluZywgdmlld0RhdGE6IEFjdGl2ZVVJVmlldywgZXh0cmEgPSAnJykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpIHJldHVybjtcbiAgICBzYWZlQ29uc29sZS5sb2coYHVpLXZpZXc6ICR7cGFkU3RyaW5nKDMwLCBldmVudCl9ICR7dWlWaWV3U3RyaW5nKHZpZXdEYXRhKX0ke2V4dHJhfWApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKHZpZXdEYXRhOiBBY3RpdmVVSVZpZXcsIGNvbnRleHQ6IFZpZXdDb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSkgcmV0dXJuO1xuICAgIHRoaXMudHJhY2VVSVZpZXdFdmVudCgnVXBkYXRpbmcnLCB2aWV3RGF0YSwgYCB3aXRoIFZpZXdDb25maWcgZnJvbSBjb250ZXh0PScke2NvbnRleHR9J2ApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VVSVZpZXdGaWxsKHZpZXdEYXRhOiBBY3RpdmVVSVZpZXcsIGh0bWw6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpIHJldHVybjtcbiAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoJ0ZpbGwnLCB2aWV3RGF0YSwgYCB3aXRoOiAke21heExlbmd0aCgyMDAsIGh0bWwpfWApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgdHJhY2VWaWV3U3luYyhwYWlyczogVmlld1R1cGxlW10pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSkgcmV0dXJuO1xuICAgIGNvbnN0IHVpdmhlYWRlciA9ICd1aXZpZXcgY29tcG9uZW50IGZxbic7XG4gICAgY29uc3QgY2ZnaGVhZGVyID0gJ3ZpZXcgY29uZmlnIHN0YXRlICh2aWV3IG5hbWUpJztcbiAgICBjb25zdCBtYXBwaW5nID0gcGFpcnNcbiAgICAgIC5tYXAoKHsgdWlWaWV3LCB2aWV3Q29uZmlnIH0pID0+IHtcbiAgICAgICAgY29uc3QgdWl2ID0gdWlWaWV3ICYmIHVpVmlldy5mcW47XG4gICAgICAgIGNvbnN0IGNmZyA9IHZpZXdDb25maWcgJiYgYCR7dmlld0NvbmZpZy52aWV3RGVjbC4kY29udGV4dC5uYW1lfTogKCR7dmlld0NvbmZpZy52aWV3RGVjbC4kbmFtZX0pYDtcbiAgICAgICAgcmV0dXJuIHsgW3VpdmhlYWRlcl06IHVpdiwgW2NmZ2hlYWRlcl06IGNmZyB9O1xuICAgICAgfSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiAoYVt1aXZoZWFkZXJdIHx8ICcnKS5sb2NhbGVDb21wYXJlKGJbdWl2aGVhZGVyXSB8fCAnJykpO1xuXG4gICAgc2FmZUNvbnNvbGUudGFibGUobWFwcGluZyk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVZpZXdTZXJ2aWNlRXZlbnQoZXZlbnQ6IHN0cmluZywgdmlld0NvbmZpZzogVmlld0NvbmZpZykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGBWSUVXQ09ORklHOiAke2V2ZW50fSAke3ZpZXdDb25maWdTdHJpbmcodmlld0NvbmZpZyl9YCk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICB0cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoZXZlbnQ6IHN0cmluZywgdmlld0RhdGE6IEFjdGl2ZVVJVmlldykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKSByZXR1cm47XG4gICAgc2FmZUNvbnNvbGUubG9nKGBWSUVXQ09ORklHOiAke2V2ZW50fSAke3VpVmlld1N0cmluZyh2aWV3RGF0YSl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgW1tUcmFjZV1dIHNpbmdsZXRvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge3RyYWNlfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbiAqIHRyYWNlLmVuYWJsZSgxLCA1KTtcbiAqIGBgYFxuICovXG5jb25zdCB0cmFjZSA9IG5ldyBUcmFjZSgpO1xuZXhwb3J0IHsgdHJhY2UgfTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgcGFyYW1zICovIC8qKiAqL1xuaW1wb3J0IHsgZXh0ZW5kLCBmaWx0ZXIsIG1hcCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgaXNBcnJheSwgaXNEZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgUGFyYW1UeXBlRGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlJztcblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxuICpcbiAqIEEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gaXMgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMuXG4gKiBXaGVuIGEgcGFyYW0gdHlwZSBkZWZpbml0aW9uIGlzIHJlZ2lzdGVyZWQsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICpcbiAqIFRoaXMgY2xhc3MgaGFzIG5haXZlIGltcGxlbWVudGF0aW9ucyBmb3IgYWxsIHRoZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBtZXRob2RzLlxuICpcbiAqIFVzZWQgYnkgW1tVcmxNYXRjaGVyXV0gd2hlbiBtYXRjaGluZyBvciBmb3JtYXR0aW5nIFVSTHMsIG9yIGNvbXBhcmluZyBhbmQgdmFsaWRhdGluZyBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyYW1UeXBlRGVmID0ge1xuICogICBkZWNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gKiAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgJiYgdmFsLnRvU3RyaW5nKCk7IH0sXG4gKiAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5pcyhhKSAmJiBhID09PSBiOyB9LFxuICogICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiBhbmd1bGFyLmlzTnVtYmVyKHZhbCkgJiYgaXNGaW5pdGUodmFsKSAmJiB2YWwgJSAxID09PSAwOyB9LFxuICogICBwYXR0ZXJuOiAvXFxkKy9cbiAqIH1cbiAqXG4gKiB2YXIgcGFyYW1UeXBlID0gbmV3IFBhcmFtVHlwZShwYXJhbVR5cGVEZWYpO1xuICogYGBgXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSBpbXBsZW1lbnRzIFBhcmFtVHlwZURlZmluaXRpb24ge1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcGF0dGVybjogUmVnRXhwID0gLy4qLztcbiAgLyoqIFRoZSBuYW1lL2lkIG9mIHRoZSBwYXJhbWV0ZXIgdHlwZSAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByYXc6IGJvb2xlYW47XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBkeW5hbWljOiBib29sZWFuO1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaW5oZXJpdCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBkZWYgIEEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGN1c3RvbSB0eXBlIGRlZmluaXRpb24uICBUaGUgb2JqZWN0J3NcbiAgICogICAgICAgIHByb3BlcnRpZXMgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2RzIGFuZC9vciBwYXR0ZXJuIGluIGBQYXJhbVR5cGVgJ3MgcHVibGljIGludGVyZmFjZS5cbiAgICogQHJldHVybnMgYSBuZXcgUGFyYW1UeXBlIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVmOiBQYXJhbVR5cGVEZWZpbml0aW9uKSB7XG4gICAgZXh0ZW5kKHRoaXMsIGRlZik7XG4gIH1cblxuICAvLyBjb25zaWRlciB0aGVzZSBmb3VyIG1ldGhvZHMgdG8gYmUgXCJhYnN0cmFjdCBtZXRob2RzXCIgdGhhdCBzaG91bGQgYmUgb3ZlcnJpZGRlblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXModmFsOiBhbnksIGtleT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBlbmNvZGUodmFsOiBhbnksIGtleT86IHN0cmluZyk6IHN0cmluZyB8IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBkZWNvZGUodmFsOiBzdHJpbmcsIGtleT86IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZXF1YWxzKGE6IGFueSwgYjogYW55KTogYm9vbGVhbiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcbiAgICByZXR1cm4gYSA9PSBiO1xuICB9XG5cbiAgJHN1YlBhdHRlcm4oKSB7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5wYXR0ZXJuLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHN1Yi5zdWJzdHIoMSwgc3ViLmxlbmd0aCAtIDIpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGB7UGFyYW1UeXBlOiR7dGhpcy5uYW1lfX1gO1xuICB9XG5cbiAgLyoqIEdpdmVuIGFuIGVuY29kZWQgc3RyaW5nLCBvciBhIGRlY29kZWQgb2JqZWN0LCByZXR1cm5zIGEgZGVjb2RlZCBvYmplY3QgKi9cbiAgJG5vcm1hbGl6ZSh2YWw6IGFueSkge1xuICAgIHJldHVybiB0aGlzLmlzKHZhbCkgPyB2YWwgOiB0aGlzLmRlY29kZSh2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGV4aXN0aW5nIGN1c3RvbSBQYXJhbVR5cGUgYXMgYW4gYXJyYXkgb2YgUGFyYW1UeXBlLCBkZXBlbmRpbmcgb24gJ21vZGUnLlxuICAgKiBlLmcuOlxuICAgKiAtIHVybG1hdGNoZXIgcGF0dGVybiBcIi9wYXRoP3txdWVyeVBhcmFtW106aW50fVwiXG4gICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTJcbiAgICogLSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbSB3aWxsIGJlIFsxLCAyXVxuICAgKiBpZiBgbW9kZWAgaXMgXCJhdXRvXCIsIHRoZW5cbiAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xIHdpbGwgY3JlYXRlICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtOiAxXG4gICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTIgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IFsxLCAyXVxuICAgKi9cbiAgJGFzQXJyYXkobW9kZTogYm9vbGVhbiB8ICdhdXRvJywgaXNTZWFyY2g6IGJvb2xlYW4pIHtcbiAgICBpZiAoIW1vZGUpIHJldHVybiB0aGlzO1xuICAgIGlmIChtb2RlID09PSAnYXV0bycgJiYgIWlzU2VhcmNoKSB0aHJvdyBuZXcgRXJyb3IoXCInYXV0bycgYXJyYXkgbW9kZSBpcyBmb3IgcXVlcnkgcGFyYW1ldGVycyBvbmx5XCIpO1xuICAgIHJldHVybiBuZXcgKDxhbnk+QXJyYXlUeXBlKSh0aGlzLCBtb2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBzIHVwIGEgYFBhcmFtVHlwZWAgb2JqZWN0IHRvIGhhbmRsZSBhcnJheSB2YWx1ZXMuXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZnVuY3Rpb24gQXJyYXlUeXBlKHR5cGU6IFBhcmFtVHlwZSwgbW9kZTogYm9vbGVhbiB8ICdhdXRvJykge1xuICAvLyBXcmFwIG5vbi1hcnJheSB2YWx1ZSBhcyBhcnJheVxuICBmdW5jdGlvbiBhcnJheVdyYXAodmFsOiBhbnkpOiBhbnlbXSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsKSA/IHZhbCA6IGlzRGVmaW5lZCh2YWwpID8gW3ZhbF0gOiBbXTtcbiAgfVxuXG4gIC8vIFVud3JhcCBhcnJheSB2YWx1ZSBmb3IgXCJhdXRvXCIgbW9kZS4gUmV0dXJuIHVuZGVmaW5lZCBmb3IgZW1wdHkgYXJyYXkuXG4gIGZ1bmN0aW9uIGFycmF5VW53cmFwKHZhbDogYW55KSB7XG4gICAgc3dpdGNoICh2YWwubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBtb2RlID09PSAnYXV0bycgPyB2YWxbMF0gOiB2YWw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXBzIHR5cGUgKC5pcy8uZW5jb2RlLy5kZWNvZGUpIGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIGVhY2ggdmFsdWUgb2YgYW4gYXJyYXlcbiAgZnVuY3Rpb24gYXJyYXlIYW5kbGVyKGNhbGxiYWNrOiAoeDogYW55KSA9PiBhbnksIGFsbFRydXRoeU1vZGU/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbDogYW55KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApIHJldHVybiB2YWw7XG4gICAgICBjb25zdCBhcnIgPSBhcnJheVdyYXAodmFsKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG1hcChhcnIsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBhbGxUcnV0aHlNb2RlID09PSB0cnVlID8gZmlsdGVyKHJlc3VsdCwgeCA9PiAheCkubGVuZ3RoID09PSAwIDogYXJyYXlVbndyYXAocmVzdWx0KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gV3JhcHMgdHlwZSAoLmVxdWFscykgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICBmdW5jdGlvbiBhcnJheUVxdWFsc0hhbmRsZXIoY2FsbGJhY2s6IChsOiBhbnksIHI6IGFueSkgPT4gYm9vbGVhbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwxOiBhbnksIHZhbDI6IGFueSkge1xuICAgICAgY29uc3QgbGVmdCA9IGFycmF5V3JhcCh2YWwxKSxcbiAgICAgICAgcmlnaHQgPSBhcnJheVdyYXAodmFsMik7XG4gICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sobGVmdFtpXSwgcmlnaHRbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgWydlbmNvZGUnLCAnZGVjb2RlJywgJ2VxdWFscycsICckbm9ybWFsaXplJ10uZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBwYXJhbVR5cGVGbiA9IHR5cGVbbmFtZV0uYmluZCh0eXBlKTtcbiAgICBjb25zdCB3cmFwcGVyRm46IEZ1bmN0aW9uID0gbmFtZSA9PT0gJ2VxdWFscycgPyBhcnJheUVxdWFsc0hhbmRsZXIgOiBhcnJheUhhbmRsZXI7XG4gICAgdGhpc1tuYW1lXSA9IHdyYXBwZXJGbihwYXJhbVR5cGVGbik7XG4gIH0pO1xuXG4gIGV4dGVuZCh0aGlzLCB7XG4gICAgZHluYW1pYzogdHlwZS5keW5hbWljLFxuICAgIG5hbWU6IHR5cGUubmFtZSxcbiAgICBwYXR0ZXJuOiB0eXBlLnBhdHRlcm4sXG4gICAgaW5oZXJpdDogdHlwZS5pbmhlcml0LFxuICAgIHJhdzogdHlwZS5yYXcsXG4gICAgaXM6IGFycmF5SGFuZGxlcih0eXBlLmlzLmJpbmQodHlwZSksIHRydWUpLFxuICAgICRhcnJheU1vZGU6IG1vZGUsXG4gIH0pO1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBwYXJhbXMgKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIGZpbHRlciwgbWFwLCBhbGxUcnVlUiwgZmluZCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgcHJvcCB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgaXNJbmplY3RhYmxlLCBpc0RlZmluZWQsIGlzU3RyaW5nLCBpc0FycmF5LCBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IFJhd1BhcmFtcywgUGFyYW1EZWNsYXJhdGlvbiB9IGZyb20gJy4uL3BhcmFtcy9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gJy4vcGFyYW1UeXBlJztcbmltcG9ydCB7IFBhcmFtVHlwZXMgfSBmcm9tICcuL3BhcmFtVHlwZXMnO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IFVybENvbmZpZyB9IGZyb20gJy4uL3VybCc7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgaXNTaG9ydGhhbmQgPSAoY2ZnOiBQYXJhbURlY2xhcmF0aW9uKSA9PlxuICBbJ3ZhbHVlJywgJ3R5cGUnLCAnc3F1YXNoJywgJ2FycmF5JywgJ2R5bmFtaWMnXS5maWx0ZXIoaGFzT3duLmJpbmQoY2ZnIHx8IHt9KSkubGVuZ3RoID09PSAwO1xuXG4vKiogQGludGVybmFsYXBpICovXG5lbnVtIERlZlR5cGUge1xuICBQQVRILFxuICBTRUFSQ0gsXG4gIENPTkZJRyxcbn1cbmV4cG9ydCB7IERlZlR5cGUgfTtcblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZnVuY3Rpb24gZ2V0UGFyYW1EZWNsYXJhdGlvbihwYXJhbU5hbWU6IHN0cmluZywgbG9jYXRpb246IERlZlR5cGUsIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKTogUGFyYW1EZWNsYXJhdGlvbiB7XG4gIGNvbnN0IG5vUmVsb2FkT25TZWFyY2ggPSAoc3RhdGUucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCkgfHwgdW5kZWZpbmVkO1xuICBjb25zdCBkeW5hbWljID0gZmluZChbc3RhdGUuZHluYW1pYywgbm9SZWxvYWRPblNlYXJjaF0sIGlzRGVmaW5lZCk7XG4gIGNvbnN0IGRlZmF1bHRDb25maWcgPSBpc0RlZmluZWQoZHluYW1pYykgPyB7IGR5bmFtaWMgfSA6IHt9O1xuICBjb25zdCBwYXJhbUNvbmZpZyA9IHVud3JhcFNob3J0aGFuZChzdGF0ZSAmJiBzdGF0ZS5wYXJhbXMgJiYgc3RhdGUucGFyYW1zW3BhcmFtTmFtZV0pO1xuICByZXR1cm4gZXh0ZW5kKGRlZmF1bHRDb25maWcsIHBhcmFtQ29uZmlnKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHVud3JhcFNob3J0aGFuZChjZmc6IFBhcmFtRGVjbGFyYXRpb24pOiBQYXJhbURlY2xhcmF0aW9uIHtcbiAgY2ZnID0gaXNTaG9ydGhhbmQoY2ZnKSA/ICh7IHZhbHVlOiBjZmcgfSBhcyBQYXJhbURlY2xhcmF0aW9uKSA6IGNmZztcblxuICBnZXRTdGF0aWNEZWZhdWx0VmFsdWVbJ19fY2FjaGVhYmxlJ10gPSB0cnVlO1xuICBmdW5jdGlvbiBnZXRTdGF0aWNEZWZhdWx0VmFsdWUoKSB7XG4gICAgcmV0dXJuIGNmZy52YWx1ZTtcbiAgfVxuXG4gIGNvbnN0ICQkZm4gPSBpc0luamVjdGFibGUoY2ZnLnZhbHVlKSA/IGNmZy52YWx1ZSA6IGdldFN0YXRpY0RlZmF1bHRWYWx1ZTtcbiAgcmV0dXJuIGV4dGVuZChjZmcsIHsgJCRmbiB9KTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGdldFR5cGUoY2ZnOiBQYXJhbURlY2xhcmF0aW9uLCB1cmxUeXBlOiBQYXJhbVR5cGUsIGxvY2F0aW9uOiBEZWZUeXBlLCBpZDogc3RyaW5nLCBwYXJhbVR5cGVzOiBQYXJhbVR5cGVzKSB7XG4gIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgUGFyYW0gJyR7aWR9JyBoYXMgdHdvIHR5cGUgY29uZmlndXJhdGlvbnMuYCk7XG4gIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSA9PT0gJ3N0cmluZycgJiYgcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlIGFzIHN0cmluZykpXG4gICAgcmV0dXJuIHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSBhcyBzdHJpbmcpO1xuICBpZiAodXJsVHlwZSkgcmV0dXJuIHVybFR5cGU7XG4gIGlmICghY2ZnLnR5cGUpIHtcbiAgICBjb25zdCB0eXBlID1cbiAgICAgIGxvY2F0aW9uID09PSBEZWZUeXBlLkNPTkZJR1xuICAgICAgICA/ICdhbnknXG4gICAgICAgIDogbG9jYXRpb24gPT09IERlZlR5cGUuUEFUSFxuICAgICAgICA/ICdwYXRoJ1xuICAgICAgICA6IGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSFxuICAgICAgICA/ICdxdWVyeSdcbiAgICAgICAgOiAnc3RyaW5nJztcbiAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKHR5cGUpO1xuICB9XG4gIHJldHVybiBjZmcudHlwZSBpbnN0YW5jZW9mIFBhcmFtVHlwZSA/IGNmZy50eXBlIDogcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlIGFzIHN0cmluZyk7XG59XG5cbi8qKlxuICogQGludGVybmFsYXBpXG4gKiByZXR1cm5zIGZhbHNlLCB0cnVlLCBvciB0aGUgc3F1YXNoIHZhbHVlIHRvIGluZGljYXRlIHRoZSBcImRlZmF1bHQgcGFyYW1ldGVyIHVybCBzcXVhc2ggcG9saWN5XCIuXG4gKi9cbmZ1bmN0aW9uIGdldFNxdWFzaFBvbGljeShjb25maWc6IFBhcmFtRGVjbGFyYXRpb24sIGlzT3B0aW9uYWw6IGJvb2xlYW4sIGRlZmF1bHRQb2xpY3k6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgY29uc3Qgc3F1YXNoID0gY29uZmlnLnNxdWFzaDtcbiAgaWYgKCFpc09wdGlvbmFsIHx8IHNxdWFzaCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc0RlZmluZWQoc3F1YXNoKSB8fCBzcXVhc2ggPT0gbnVsbCkgcmV0dXJuIGRlZmF1bHRQb2xpY3k7XG4gIGlmIChzcXVhc2ggPT09IHRydWUgfHwgaXNTdHJpbmcoc3F1YXNoKSkgcmV0dXJuIHNxdWFzaDtcbiAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNxdWFzaCBwb2xpY3k6ICcke3NxdWFzaH0nLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIG9yIGFyYml0cmFyeSBzdHJpbmdgKTtcbn1cblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZnVuY3Rpb24gZ2V0UmVwbGFjZShjb25maWc6IFBhcmFtRGVjbGFyYXRpb24sIGFycmF5TW9kZTogYm9vbGVhbiwgaXNPcHRpb25hbDogYm9vbGVhbiwgc3F1YXNoOiBzdHJpbmcgfCBib29sZWFuKSB7XG4gIGNvbnN0IGRlZmF1bHRQb2xpY3kgPSBbXG4gICAgeyBmcm9tOiAnJywgdG86IGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogJycgfSxcbiAgICB7IGZyb206IG51bGwsIHRvOiBpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6ICcnIH0sXG4gIF07XG5cbiAgY29uc3QgcmVwbGFjZSA9IGlzQXJyYXkoY29uZmlnLnJlcGxhY2UpID8gY29uZmlnLnJlcGxhY2UgOiBbXTtcbiAgaWYgKGlzU3RyaW5nKHNxdWFzaCkpIHJlcGxhY2UucHVzaCh7IGZyb206IHNxdWFzaCwgdG86IHVuZGVmaW5lZCB9KTtcblxuICBjb25zdCBjb25maWd1cmVkS2V5cyA9IG1hcChyZXBsYWNlLCBwcm9wKCdmcm9tJykpO1xuICByZXR1cm4gZmlsdGVyKGRlZmF1bHRQb2xpY3ksIGl0ZW0gPT4gY29uZmlndXJlZEtleXMuaW5kZXhPZihpdGVtLmZyb20pID09PSAtMSkuY29uY2F0KHJlcGxhY2UpO1xufVxuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgY2xhc3MgUGFyYW0ge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiBQYXJhbVR5cGU7XG4gIGxvY2F0aW9uOiBEZWZUeXBlO1xuICBpc09wdGlvbmFsOiBib29sZWFuO1xuICBkeW5hbWljOiBib29sZWFuO1xuICByYXc6IGJvb2xlYW47XG4gIHNxdWFzaDogYm9vbGVhbiB8IHN0cmluZztcbiAgcmVwbGFjZTogW3sgdG86IGFueTsgZnJvbTogYW55IH1dO1xuICBpbmhlcml0OiBib29sZWFuO1xuICBhcnJheTogYm9vbGVhbjtcbiAgY29uZmlnOiBhbnk7XG4gIC8qKiBDYWNoZSB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBpdCBpcyBhIHN0YXRpYyB2YWx1ZSAqL1xuICBfZGVmYXVsdFZhbHVlQ2FjaGU6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGFueTtcbiAgfTtcblxuICBzdGF0aWMgdmFsdWVzKHBhcmFtczogUGFyYW1bXSwgdmFsdWVzOiBSYXdQYXJhbXMgPSB7fSk6IFJhd1BhcmFtcyB7XG4gICAgY29uc3QgcGFyYW1WYWx1ZXMgPSB7fSBhcyBSYXdQYXJhbXM7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtVmFsdWVzW3BhcmFtLmlkXSA9IHBhcmFtLnZhbHVlKHZhbHVlc1twYXJhbS5pZF0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1WYWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgW1tQYXJhbV1dIG9iamVjdHMgd2hpY2ggaGF2ZSBkaWZmZXJlbnQgcGFyYW0gdmFsdWVzXG4gICAqXG4gICAqIEZpbHRlcnMgYSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIG9ubHkgdGhvc2Ugd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIgaW4gdHdvIHBhcmFtIHZhbHVlIG9iamVjdHNcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtczogVGhlIGxpc3Qgb2YgUGFyYW0gb2JqZWN0cyB0byBmaWx0ZXJcbiAgICogQHBhcmFtIHZhbHVlczE6IFRoZSBmaXJzdCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgKiBAcGFyYW0gdmFsdWVzMjogdGhlIHNlY29uZCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyBhbnkgUGFyYW0gb2JqZWN0cyB3aG9zZSB2YWx1ZXMgd2VyZSBkaWZmZXJlbnQgYmV0d2VlbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyXG4gICAqL1xuICBzdGF0aWMgY2hhbmdlZChwYXJhbXM6IFBhcmFtW10sIHZhbHVlczE6IFJhd1BhcmFtcyA9IHt9LCB2YWx1ZXMyOiBSYXdQYXJhbXMgPSB7fSk6IFBhcmFtW10ge1xuICAgIHJldHVybiBwYXJhbXMuZmlsdGVyKHBhcmFtID0+ICFwYXJhbS50eXBlLmVxdWFscyh2YWx1ZXMxW3BhcmFtLmlkXSwgdmFsdWVzMltwYXJhbS5pZF0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIHBhcmFtIHZhbHVlIG9iamVjdHMgYXJlIGVxdWFsIChmb3IgYSBzZXQgb2YgW1tQYXJhbV1dIG9iamVjdHMpXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgVGhlIGxpc3Qgb2YgW1tQYXJhbV1dIG9iamVjdHMgdG8gY2hlY2tcbiAgICogQHBhcmFtIHZhbHVlczEgVGhlIGZpcnN0IHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlczIgVGhlIHNlY29uZCBzZXQgb2YgcGFyYW0gdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtIHZhbHVlcyBpbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyIGFyZSBlcXVhbFxuICAgKi9cbiAgc3RhdGljIGVxdWFscyhwYXJhbXM6IFBhcmFtW10sIHZhbHVlczEgPSB7fSwgdmFsdWVzMiA9IHt9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFBhcmFtLmNoYW5nZWQocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKS5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIGEgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHZhbGlkLCBhY2NvcmRpbmcgdG8gdGhlIFBhcmFtIGRlZmluaXRpb25zICovXG4gIHN0YXRpYyB2YWxpZGF0ZXMocGFyYW1zOiBQYXJhbVtdLCB2YWx1ZXM6IFJhd1BhcmFtcyA9IHt9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBhcmFtcy5tYXAocGFyYW0gPT4gcGFyYW0udmFsaWRhdGVzKHZhbHVlc1twYXJhbS5pZF0pKS5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoaWQ6IHN0cmluZywgdHlwZTogUGFyYW1UeXBlLCBsb2NhdGlvbjogRGVmVHlwZSwgdXJsQ29uZmlnOiBVcmxDb25maWcsIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKSB7XG4gICAgY29uc3QgY29uZmlnOiBQYXJhbURlY2xhcmF0aW9uID0gZ2V0UGFyYW1EZWNsYXJhdGlvbihpZCwgbG9jYXRpb24sIHN0YXRlKTtcbiAgICB0eXBlID0gZ2V0VHlwZShjb25maWcsIHR5cGUsIGxvY2F0aW9uLCBpZCwgdXJsQ29uZmlnLnBhcmFtVHlwZXMpO1xuICAgIGNvbnN0IGFycmF5TW9kZSA9IGdldEFycmF5TW9kZSgpO1xuICAgIHR5cGUgPSBhcnJheU1vZGUgPyB0eXBlLiRhc0FycmF5KGFycmF5TW9kZSwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIKSA6IHR5cGU7XG4gICAgY29uc3QgaXNPcHRpb25hbCA9IGNvbmZpZy52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSDtcbiAgICBjb25zdCBkeW5hbWljID0gaXNEZWZpbmVkKGNvbmZpZy5keW5hbWljKSA/ICEhY29uZmlnLmR5bmFtaWMgOiAhIXR5cGUuZHluYW1pYztcbiAgICBjb25zdCByYXcgPSBpc0RlZmluZWQoY29uZmlnLnJhdykgPyAhIWNvbmZpZy5yYXcgOiAhIXR5cGUucmF3O1xuICAgIGNvbnN0IHNxdWFzaCA9IGdldFNxdWFzaFBvbGljeShjb25maWcsIGlzT3B0aW9uYWwsIHVybENvbmZpZy5kZWZhdWx0U3F1YXNoUG9saWN5KCkpO1xuICAgIGNvbnN0IHJlcGxhY2UgPSBnZXRSZXBsYWNlKGNvbmZpZywgYXJyYXlNb2RlLCBpc09wdGlvbmFsLCBzcXVhc2gpO1xuICAgIGNvbnN0IGluaGVyaXQgPSBpc0RlZmluZWQoY29uZmlnLmluaGVyaXQpID8gISFjb25maWcuaW5oZXJpdCA6ICEhdHlwZS5pbmhlcml0O1xuXG4gICAgLy8gYXJyYXkgY29uZmlnOiBwYXJhbSBuYW1lIChwYXJhbVtdKSBvdmVycmlkZXMgZGVmYXVsdCBzZXR0aW5ncy4gIGV4cGxpY2l0IGNvbmZpZyBvdmVycmlkZXMgcGFyYW0gbmFtZS5cbiAgICBmdW5jdGlvbiBnZXRBcnJheU1vZGUoKSB7XG4gICAgICBjb25zdCBhcnJheURlZmF1bHRzID0geyBhcnJheTogbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIID8gJ2F1dG8nIDogZmFsc2UgfTtcbiAgICAgIGNvbnN0IGFycmF5UGFyYW1Ob21lbmNsYXR1cmUgPSBpZC5tYXRjaCgvXFxbXFxdJC8pID8geyBhcnJheTogdHJ1ZSB9IDoge307XG4gICAgICByZXR1cm4gZXh0ZW5kKGFycmF5RGVmYXVsdHMsIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUsIGNvbmZpZykuYXJyYXk7XG4gICAgfVxuXG4gICAgZXh0ZW5kKHRoaXMsIHsgaWQsIHR5cGUsIGxvY2F0aW9uLCBpc09wdGlvbmFsLCBkeW5hbWljLCByYXcsIHNxdWFzaCwgcmVwbGFjZSwgaW5oZXJpdCwgYXJyYXk6IGFycmF5TW9kZSwgY29uZmlnIH0pO1xuICB9XG5cbiAgaXNEZWZhdWx0VmFsdWUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgJiYgdGhpcy50eXBlLmVxdWFscyh0aGlzLnZhbHVlKCksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbSW50ZXJuYWxdIEdldHMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxuICAgKiBkZWZhdWx0IHZhbHVlLCB3aGljaCBtYXkgYmUgdGhlIHJlc3VsdCBvZiBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFsdWUodmFsdWU/OiBhbnkpOiBhbnkge1xuICAgIC8qKlxuICAgICAqIFtJbnRlcm5hbF0gR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcGFyYW1ldGVyLCB3aGljaCBtYXkgYmUgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBnZXREZWZhdWx0VmFsdWUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUpIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWVDYWNoZS5kZWZhdWx0VmFsdWU7XG5cbiAgICAgIGlmICghc2VydmljZXMuJGluamVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ0luamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lJyk7XG5cbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UodGhpcy5jb25maWcuJCRmbik7XG5cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMudHlwZS5pcyhkZWZhdWx0VmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYERlZmF1bHQgdmFsdWUgKCR7ZGVmYXVsdFZhbHVlfSkgZm9yIHBhcmFtZXRlciAnJHt0aGlzLmlkfScgaXMgbm90IGFuIGluc3RhbmNlIG9mIFBhcmFtVHlwZSAoJHtcbiAgICAgICAgICAgIHRoaXMudHlwZS5uYW1lXG4gICAgICAgICAgfSlgXG4gICAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy4kJGZuWydfX2NhY2hlYWJsZSddKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlID0geyBkZWZhdWx0VmFsdWUgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVwbGFjZVNwZWNpYWxWYWx1ZXMgPSAodmFsOiBhbnkpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdHVwbGUgb2YgdGhpcy5yZXBsYWNlKSB7XG4gICAgICAgIGlmICh0dXBsZS5mcm9tID09PSB2YWwpIHJldHVybiB0dXBsZS50bztcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHZhbHVlID0gcmVwbGFjZVNwZWNpYWxWYWx1ZXModmFsdWUpO1xuXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSA/IGdldERlZmF1bHRWYWx1ZSgpIDogdGhpcy50eXBlLiRub3JtYWxpemUodmFsdWUpO1xuICB9XG5cbiAgaXNTZWFyY2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICB9XG5cbiAgdmFsaWRhdGVzKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyBUaGVyZSB3YXMgbm8gcGFyYW1ldGVyIHZhbHVlLCBidXQgdGhlIHBhcmFtIGlzIG9wdGlvbmFsXG4gICAgaWYgKChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpICYmIHRoaXMuaXNPcHRpb25hbCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBUaGUgdmFsdWUgd2FzIG5vdCBvZiB0aGUgY29ycmVjdCBQYXJhbVR5cGUsIGFuZCBjb3VsZCBub3QgYmUgZGVjb2RlZCB0byB0aGUgY29ycmVjdCBQYXJhbVR5cGVcbiAgICBjb25zdCBub3JtYWxpemVkID0gdGhpcy50eXBlLiRub3JtYWxpemUodmFsdWUpO1xuICAgIGlmICghdGhpcy50eXBlLmlzKG5vcm1hbGl6ZWQpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBUaGUgdmFsdWUgd2FzIG9mIHRoZSBjb3JyZWN0IHR5cGUsIGJ1dCB3aGVuIGVuY29kZWQsIGRpZCBub3QgbWF0Y2ggdGhlIFBhcmFtVHlwZSdzIHJlZ2V4cFxuICAgIGNvbnN0IGVuY29kZWQgPSB0aGlzLnR5cGUuZW5jb2RlKG5vcm1hbGl6ZWQpO1xuICAgIHJldHVybiAhKGlzU3RyaW5nKGVuY29kZWQpICYmICF0aGlzLnR5cGUucGF0dGVybi5leGVjKDxzdHJpbmc+ZW5jb2RlZCkpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGB7UGFyYW06JHt0aGlzLmlkfSAke3RoaXMudHlwZX0gc3F1YXNoOiAnJHt0aGlzLnNxdWFzaH0nIG9wdGlvbmFsOiAke3RoaXMuaXNPcHRpb25hbH19YDtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBwYXJhbXMgKi8gLyoqICovXG5pbXBvcnQgeyBmcm9tSnNvbiwgdG9Kc29uLCBpZGVudGl0eSwgZXF1YWxzLCBpbmhlcml0LCBtYXAsIGV4dGVuZCwgcGljayB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc051bGxPclVuZGVmaW5lZCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgUGFyYW1UeXBlIH0gZnJvbSAnLi9wYXJhbVR5cGUnO1xuaW1wb3J0IHsgUGFyYW1UeXBlRGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlJztcblxuLyoqXG4gKiBBIHJlZ2lzdHJ5IGZvciBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhpcyByZWdpc3RyeSBtYW5hZ2VzIHRoZSBidWlsdC1pbiAoYW5kIGN1c3RvbSkgcGFyYW1ldGVyIHR5cGVzLlxuICpcbiAqIFRoZSBidWlsdC1pbiBwYXJhbWV0ZXIgdHlwZXMgYXJlOlxuICpcbiAqIC0gW1tzdHJpbmddXVxuICogLSBbW3BhdGhdXVxuICogLSBbW3F1ZXJ5XV1cbiAqIC0gW1toYXNoXV1cbiAqIC0gW1tpbnRdXVxuICogLSBbW2Jvb2xdXVxuICogLSBbW2RhdGVdXVxuICogLSBbW2pzb25dXVxuICogLSBbW2FueV1dXG4gKlxuICogVG8gcmVnaXN0ZXIgY3VzdG9tIHBhcmFtZXRlciB0eXBlcywgdXNlIFtbVXJsQ29uZmlnLnR5cGVdXSwgaS5lLixcbiAqXG4gKiBgYGBqc1xuICogcm91dGVyLnVybFNlcnZpY2UuY29uZmlnLnR5cGUoY3VzdG9tVHlwZSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlcyB7XG4gIC8qKlxuICAgKiBCdWlsdC1pbiBwYXJhbWV0ZXIgdHlwZTogYHN0cmluZ2BcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzLlxuICAgKiBJdCBtYXRjaGVzIGFueXRoaW5nIChgbmV3IFJlZ0V4cChcIi4qXCIpYCkgaW4gdGhlIFVSTFxuICAgKi9cbiAgc3RhdGljIHN0cmluZzogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQnVpbHQtaW4gcGFyYW1ldGVyIHR5cGU6IGBwYXRoYFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGlzIHRoZSBkZWZhdWx0IHR5cGUgZm9yIHBhdGggcGFyYW1ldGVycy5cbiAgICogQSBwYXRoIHBhcmFtZXRlciBpcyBhbnkgcGFyYW1ldGVyIGRlY2xhcmVkIGluIHRoZSBwYXRoIHBvcnRpb24gb2YgYSB1cmxcbiAgICpcbiAgICogLSBgL2Zvby86cGFyYW0xLzpwYXJhbTJgOiB0d28gcGF0aCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIHR5cGUgYmVoYXZlcyBleGFjdGx5IGxpa2UgdGhlIFtbc3RyaW5nXV0gdHlwZSB3aXRoIG9uZSBleGNlcHRpb24uXG4gICAqIFdoZW4gbWF0Y2hpbmcgcGFyYW1ldGVyIHZhbHVlcyBpbiB0aGUgVVJMLCB0aGUgYHBhdGhgIHR5cGUgZG9lcyBub3QgbWF0Y2ggZm9yd2FyZCBzbGFzaGVzIGAvYC5cbiAgICpcbiAgICogIyMjIyBBbmd1bGFyIDEgbm90ZTpcbiAgICogSW4gbmcxLCB0aGlzIHR5cGUgaXMgb3ZlcnJpZGRlbiB3aXRoIG9uZSB0aGF0IHByZS1lbmNvZGVzIHNsYXNoZXMgYXMgYH4yRmAgaW5zdGVhZCBvZiBgJTJGYC5cbiAgICogRm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aGlzIGFuZ3VsYXIgMSBiZWhhdmlvciwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzI1OThcbiAgICovXG4gIHN0YXRpYyBwYXRoOiBQYXJhbVR5cGVEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBCdWlsdC1pbiBwYXJhbWV0ZXIgdHlwZTogYHF1ZXJ5YFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGlzIHRoZSBkZWZhdWx0IHR5cGUgZm9yIHF1ZXJ5L3NlYXJjaCBwYXJhbWV0ZXJzLlxuICAgKiBJdCBiZWhhdmVzIHRoZSBzYW1lIGFzIHRoZSBbW3N0cmluZ11dIHBhcmFtZXRlciB0eXBlLlxuICAgKlxuICAgKiBBIHF1ZXJ5IHBhcmFtZXRlciBpcyBhbnkgcGFyYW1ldGVyIGRlY2xhcmVkIGluIHRoZSBxdWVyeS9zZWFyY2ggcG9ydGlvbiBvZiBhIHVybFxuICAgKlxuICAgKiAtIGAvYmFyP3BhcmFtMmA6IGEgcXVlcnkgcGFyYW1ldGVyXG4gICAqL1xuICBzdGF0aWMgcXVlcnk6IFBhcmFtVHlwZURlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIEJ1aWx0LWluIHBhcmFtZXRlciB0eXBlOiBgaGFzaGBcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBpcyB1c2VkIGZvciB0aGUgYCNgIHBhcmFtZXRlciAodGhlIGhhc2gpXG4gICAqIEl0IGJlaGF2ZXMgdGhlIHNhbWUgYXMgdGhlIFtbc3RyaW5nXV0gcGFyYW1ldGVyIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgaGFzaDogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQnVpbHQtaW4gcGFyYW1ldGVyIHR5cGU6IGBpbnRgXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIHR5cGUgc2VyaWFsaXplcyBqYXZhc2NyaXB0IGludGVnZXJzIChgbnVtYmVyYHMgd2hpY2ggcmVwcmVzZW50IGFuIGludGVnZXIpIHRvIHRoZSBVUkwuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLnN0YXRlKHtcbiAgICogICBuYW1lOiAndXNlcicsXG4gICAqICAgdXJsOiAnL3VzZXIve2lkOmludH0nXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGBganNcbiAgICogJHN0YXRlLmdvKCd1c2VyJywgeyBpZDogMTI5ODU0NyB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBVUkwgd2lsbCBzZXJpYWxpemUgdG86IGAvdXNlci8xMjk4NTQ3YC5cbiAgICpcbiAgICogV2hlbiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIHJlYWQsIGl0IHdpbGwgYmUgdGhlIGBudW1iZXJgIGAxMjk4NTQ3YCwgbm90IHRoZSBzdHJpbmcgYFwiMTI5ODU0N1wiYC5cbiAgICovXG4gIHN0YXRpYyBpbnQ6IFBhcmFtVHlwZURlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIEJ1aWx0LWluIHBhcmFtZXRlciB0eXBlOiBgYm9vbGBcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBzZXJpYWxpemVzIGB0cnVlYC9gZmFsc2VgIGFzIGAxYC9gMGBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAuc3RhdGUoe1xuICAgKiAgIG5hbWU6ICdpbmJveCcsXG4gICAqICAgdXJsOiAnL2luYm94P3t1bnJlYWQ6Ym9vbH0nXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGBganNcbiAgICogJHN0YXRlLmdvKCdpbmJveCcsIHsgdW5yZWFkOiB0cnVlIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIFVSTCB3aWxsIHNlcmlhbGl6ZSB0bzogYC9pbmJveD91bnJlYWQ9MWAuXG4gICAqXG4gICAqIENvbnZlcnNlbHksIGlmIHRoZSB1cmwgaXMgYC9pbmJveD91bnJlYWQ9MGAsIHRoZSB2YWx1ZSBvZiB0aGUgYHVucmVhZGAgcGFyYW1ldGVyIHdpbGwgYmUgYSBgZmFsc2VgLlxuICAgKi9cbiAgc3RhdGljIGJvb2w6IFBhcmFtVHlwZURlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIEJ1aWx0LWluIHBhcmFtZXRlciB0eXBlOiBgZGF0ZWBcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBjYW4gYmUgdXNlZCB0byBzZXJpYWxpemUgSmF2YXNjcmlwdCBkYXRlcyBhcyBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC5zdGF0ZSh7XG4gICAqICAgbmFtZTogJ3NlYXJjaCcsXG4gICAqICAgdXJsOiAnL3NlYXJjaD97c3RhcnQ6ZGF0ZX0nXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGBganNcbiAgICogJHN0YXRlLmdvKCdzZWFyY2gnLCB7IHN0YXJ0OiBuZXcgRGF0ZSgyMDAwLCAwLCAxKSB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBVUkwgd2lsbCBzZXJpYWxpemUgdG86IGAvc2VhcmNoP3N0YXJ0PTIwMDAtMDEtMDFgLlxuICAgKlxuICAgKiBDb252ZXJzZWx5LCBpZiB0aGUgdXJsIGlzIGAvc2VhcmNoP3N0YXJ0PTIwMTYtMTItMjVgLCB0aGUgdmFsdWUgb2YgdGhlIGBzdGFydGAgcGFyYW1ldGVyIHdpbGwgYmUgYSBgRGF0ZWAgb2JqZWN0IHdoZXJlOlxuICAgKlxuICAgKiAtIGBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IDIwMTZgXG4gICAqIC0gYGRhdGUuZ2V0TW9udGgoKSA9PT0gMTFgIChtb250aCBpcyAwLWJhc2VkKVxuICAgKiAtIGBkYXRlLmdldERhdGUoKSA9PT0gMjVgXG4gICAqL1xuICBzdGF0aWMgZGF0ZTogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQnVpbHQtaW4gcGFyYW1ldGVyIHR5cGU6IGBqc29uYFxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciB0eXBlIGNhbiBiZSB1c2VkIHRvIHNlcmlhbGl6ZSBqYXZhc2NyaXB0IG9iamVjdHMgaW50byB0aGUgVVJMIHVzaW5nIEpTT04gc2VyaWFsaXphdGlvbi5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBUaGlzIGV4YW1wbGUgc2VyaWFsaXplcyBhbiBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB0byB0aGUgVVJMXG4gICAqIGBgYGpzXG4gICAqIC5zdGF0ZSh7XG4gICAqICAgbmFtZTogJ21hcCcsXG4gICAqICAgdXJsOiAnL21hcC97Y29vcmRzOmpzb259J1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIGBgYGpzXG4gICAqICRzdGF0ZS5nbygnbWFwJywgeyBjb29yZHM6IHsgeDogMTAzOTkuMiwgeTogNDkwNzEgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgVVJMIHdpbGwgc2VyaWFsaXplIHRvOiBgL21hcC8lN0IlMjJ4JTIyJTNBMTAzOTkuMiUyQyUyMnklMjIlM0E0OTA3MSU3RGBcbiAgICovXG4gIHN0YXRpYyBqc29uOiBQYXJhbVR5cGVEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBCdWlsdC1pbiBwYXJhbWV0ZXIgdHlwZTogYGFueWBcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgdHlwZSBpcyB1c2VkIGJ5IGRlZmF1bHQgZm9yIHVybC1sZXNzIHBhcmFtZXRlcnMgKHBhcmFtZXRlcnMgdGhhdCBkbyBub3QgYXBwZWFyIGluIHRoZSBVUkwpLlxuICAgKiBUaGlzIHR5cGUgZG9lcyBub3QgZW5jb2RlIG9yIGRlY29kZS5cbiAgICogSXQgaXMgY29tcGFyZWQgdXNpbmcgYSBkZWVwIGBlcXVhbHNgIGNvbXBhcmlzb24uXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogVGhpcyBleGFtcGxlIGRlZmluZXMgYSBub24tdXJsIHBhcmFtZXRlciBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dLlxuICAgKiBgYGBqc1xuICAgKiAuc3RhdGUoe1xuICAgKiAgIG5hbWU6ICduZXcnLFxuICAgKiAgIHVybDogJy9uZXcnLFxuICAgKiAgIHBhcmFtczoge1xuICAgKiAgICAgaW5yZXB5dG86IG51bGxcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGBganNcbiAgICogJHN0YXRlLmdvKCduZXcnLCB7IGlucmVwbHl0bzogY3VycmVudE1lc3NhZ2UgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGFueTogUGFyYW1UeXBlRGVmaW5pdGlvbjtcblxuICAvKiogQGhpZGRlbiAqL1xuICB0eXBlczogYW55O1xuICAvKiogQGhpZGRlbiAqL1xuICBlbnF1ZXVlID0gdHJ1ZTtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgdHlwZVF1ZXVlOiBhbnlbXSA9IFtdO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgcHJpdmF0ZSBkZWZhdWx0VHlwZXM6IGFueSA9IHBpY2soUGFyYW1UeXBlcy5wcm90b3R5cGUsIFtcbiAgICAnaGFzaCcsXG4gICAgJ3N0cmluZycsXG4gICAgJ3F1ZXJ5JyxcbiAgICAncGF0aCcsXG4gICAgJ2ludCcsXG4gICAgJ2Jvb2wnLFxuICAgICdkYXRlJyxcbiAgICAnanNvbicsXG4gICAgJ2FueScsXG4gIF0pO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCB0eXBlcy4gU3RvcmUgdGhlbSBpbiB0aGUgcHJvdG90eXBlIG9mIHRoaXMudHlwZXMuXG4gICAgY29uc3QgbWFrZVR5cGUgPSAoZGVmaW5pdGlvbjogUGFyYW1UeXBlRGVmaW5pdGlvbiwgbmFtZTogc3RyaW5nKSA9PiBuZXcgUGFyYW1UeXBlKGV4dGVuZCh7IG5hbWUgfSwgZGVmaW5pdGlvbikpO1xuICAgIHRoaXMudHlwZXMgPSBpbmhlcml0KG1hcCh0aGlzLmRlZmF1bHRUeXBlcywgbWFrZVR5cGUpLCB7fSk7XG4gIH1cblxuICAvKiogQGludGVybmFsYXBpICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy50eXBlcyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHBhcmFtZXRlciB0eXBlXG4gICAqXG4gICAqIEVuZCB1c2VycyBzaG91bGQgY2FsbCBbW1VybE1hdGNoZXJGYWN0b3J5LnR5cGVdXSwgd2hpY2ggZGVsZWdhdGVzIHRvIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgdHlwZShuYW1lOiBzdHJpbmcsIGRlZmluaXRpb24/OiBQYXJhbVR5cGVEZWZpbml0aW9uLCBkZWZpbml0aW9uRm4/OiAoKSA9PiBQYXJhbVR5cGVEZWZpbml0aW9uKSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZGVmaW5pdGlvbikpIHJldHVybiB0aGlzLnR5cGVzW25hbWVdO1xuICAgIGlmICh0aGlzLnR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoYEEgdHlwZSBuYW1lZCAnJHtuYW1lfScgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLmApO1xuXG4gICAgdGhpcy50eXBlc1tuYW1lXSA9IG5ldyBQYXJhbVR5cGUoZXh0ZW5kKHsgbmFtZSB9LCBkZWZpbml0aW9uKSk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbkZuKSB7XG4gICAgICB0aGlzLnR5cGVRdWV1ZS5wdXNoKHsgbmFtZSwgZGVmOiBkZWZpbml0aW9uRm4gfSk7XG4gICAgICBpZiAoIXRoaXMuZW5xdWV1ZSkgdGhpcy5fZmx1c2hUeXBlUXVldWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgX2ZsdXNoVHlwZVF1ZXVlKCkge1xuICAgIHdoaWxlICh0aGlzLnR5cGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGVRdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHR5cGUucGF0dGVybikgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBvdmVycmlkZSBhIHR5cGUncyAucGF0dGVybiBhdCBydW50aW1lLlwiKTtcbiAgICAgIGV4dGVuZCh0aGlzLnR5cGVzW3R5cGUubmFtZV0sIHNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UodHlwZS5kZWYpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGluaXREZWZhdWx0VHlwZXMoKSB7XG4gIGNvbnN0IG1ha2VEZWZhdWx0VHlwZSA9IGRlZiA9PiB7XG4gICAgY29uc3QgdmFsVG9TdHJpbmcgPSAodmFsOiBhbnkpID0+ICh2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpIDogdmFsKTtcblxuICAgIGNvbnN0IGRlZmF1bHRUeXBlQmFzZSA9IHtcbiAgICAgIGVuY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICBkZWNvZGU6IHZhbFRvU3RyaW5nLFxuICAgICAgaXM6IGlzKFN0cmluZyksXG4gICAgICBwYXR0ZXJuOiAvLiovLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcbiAgICAgIGVxdWFsczogKGE6IGFueSwgYjogYW55KSA9PiBhID09IGIsIC8vIGFsbG93IGNvZXJzaW9uIGZvciBudWxsL3VuZGVmaW5lZC9cIlwiXG4gICAgfTtcblxuICAgIHJldHVybiBleHRlbmQoe30sIGRlZmF1bHRUeXBlQmFzZSwgZGVmKSBhcyBQYXJhbVR5cGVEZWZpbml0aW9uO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgUGFyYW1ldGVyIFR5cGUgRGVmaW5pdGlvbnNcbiAgZXh0ZW5kKFBhcmFtVHlwZXMucHJvdG90eXBlLCB7XG4gICAgc3RyaW5nOiBtYWtlRGVmYXVsdFR5cGUoe30pLFxuXG4gICAgcGF0aDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgIHBhdHRlcm46IC9bXi9dKi8sXG4gICAgfSksXG5cbiAgICBxdWVyeTogbWFrZURlZmF1bHRUeXBlKHt9KSxcblxuICAgIGhhc2g6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICB9KSxcblxuICAgIGludDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgIGRlY29kZTogKHZhbDogc3RyaW5nKSA9PiBwYXJzZUludCh2YWwsIDEwKSxcbiAgICAgIGlzOiBmdW5jdGlvbih2YWw6IGFueSkge1xuICAgICAgICByZXR1cm4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbCkgJiYgdGhpcy5kZWNvZGUodmFsLnRvU3RyaW5nKCkpID09PSB2YWw7XG4gICAgICB9LFxuICAgICAgcGF0dGVybjogLy0/XFxkKy8sXG4gICAgfSksXG5cbiAgICBib29sOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgZW5jb2RlOiAodmFsOiBhbnkpID0+ICh2YWwgJiYgMSkgfHwgMCxcbiAgICAgIGRlY29kZTogKHZhbDogc3RyaW5nKSA9PiBwYXJzZUludCh2YWwsIDEwKSAhPT0gMCxcbiAgICAgIGlzOiBpcyhCb29sZWFuKSxcbiAgICAgIHBhdHRlcm46IC8wfDEvLFxuICAgIH0pLFxuXG4gICAgZGF0ZTogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24odmFsOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzKHZhbClcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogW3ZhbC5nZXRGdWxsWWVhcigpLCAoJzAnICsgKHZhbC5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKSwgKCcwJyArIHZhbC5nZXREYXRlKCkpLnNsaWNlKC0yKV0uam9pbignLScpO1xuICAgICAgfSxcbiAgICAgIGRlY29kZTogZnVuY3Rpb24odmFsOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuaXModmFsKSkgcmV0dXJuICg8YW55PnZhbCkgYXMgRGF0ZTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNhcHR1cmUuZXhlYyh2YWwpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBuZXcgRGF0ZShtYXRjaFsxXSwgbWF0Y2hbMl0gLSAxLCBtYXRjaFszXSkgOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgaXM6ICh2YWw6IGFueSkgPT4gdmFsIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsLnZhbHVlT2YoKSksXG4gICAgICBlcXVhbHMobDogYW55LCByOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIFsnZ2V0RnVsbFllYXInLCAnZ2V0TW9udGgnLCAnZ2V0RGF0ZSddLnJlZHVjZSgoYWNjLCBmbikgPT4gYWNjICYmIGxbZm5dKCkgPT09IHJbZm5dKCksIHRydWUpO1xuICAgICAgfSxcbiAgICAgIHBhdHRlcm46IC9bMC05XXs0fS0oPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcbiAgICAgIGNhcHR1cmU6IC8oWzAtOV17NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXG4gICAgfSksXG5cbiAgICBqc29uOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgZW5jb2RlOiB0b0pzb24sXG4gICAgICBkZWNvZGU6IGZyb21Kc29uLFxuICAgICAgaXM6IGlzKE9iamVjdCksXG4gICAgICBlcXVhbHM6IGVxdWFscyxcbiAgICAgIHBhdHRlcm46IC9bXi9dKi8sXG4gICAgfSksXG5cbiAgICAvLyBkb2VzIG5vdCBlbmNvZGUvZGVjb2RlXG4gICAgYW55OiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgZW5jb2RlOiBpZGVudGl0eSxcbiAgICAgIGRlY29kZTogaWRlbnRpdHksXG4gICAgICBpczogKCkgPT4gdHJ1ZSxcbiAgICAgIGVxdWFsczogZXF1YWxzLFxuICAgIH0pLFxuICB9KTtcbn1cblxuaW5pdERlZmF1bHRUeXBlcygpO1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBwYXJhbXMgKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIGFuY2VzdG9ycywgT2JqIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlUGFyYW1zIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogT2JqID0ge30pIHtcbiAgICBleHRlbmQodGhpcywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgYSBzZXQgb2YgcGFyYW1ldGVycyB3aXRoIGFsbCBwYXJhbWV0ZXJzIGluaGVyaXRlZCBiZXR3ZWVuIHRoZSBjb21tb24gcGFyZW50cyBvZiB0aGVcbiAgICogY3VycmVudCBzdGF0ZSBhbmQgYSBnaXZlbiBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9ICRjdXJyZW50IEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9ICR0byBJbnRlcm5hbCBkZWZpbml0aW9uIG9mIG9iamVjdCByZXByZXNlbnRpbmcgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by5cbiAgICovXG4gICRpbmhlcml0KG5ld1BhcmFtczogT2JqLCAkY3VycmVudDogU3RhdGVPYmplY3QsICR0bzogU3RhdGVPYmplY3QpIHtcbiAgICBsZXQgcGFyZW50UGFyYW1zOiBzdHJpbmdbXTtcbiAgICBjb25zdCBwYXJlbnRzID0gYW5jZXN0b3JzKCRjdXJyZW50LCAkdG8pLFxuICAgICAgaW5oZXJpdGVkOiBPYmogPSB7fSxcbiAgICAgIGluaGVyaXRMaXN0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHBhcmVudHMpIHtcbiAgICAgIGlmICghcGFyZW50c1tpXSB8fCAhcGFyZW50c1tpXS5wYXJhbXMpIGNvbnRpbnVlO1xuICAgICAgcGFyZW50UGFyYW1zID0gT2JqZWN0LmtleXMocGFyZW50c1tpXS5wYXJhbXMpO1xuICAgICAgaWYgKCFwYXJlbnRQYXJhbXMubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgZm9yIChjb25zdCBqIGluIHBhcmVudFBhcmFtcykge1xuICAgICAgICBpZiAoaW5oZXJpdExpc3QuaW5kZXhPZihwYXJlbnRQYXJhbXNbal0pID49IDApIGNvbnRpbnVlO1xuICAgICAgICBpbmhlcml0TGlzdC5wdXNoKHBhcmVudFBhcmFtc1tqXSk7XG4gICAgICAgIGluaGVyaXRlZFtwYXJlbnRQYXJhbXNbal1dID0gdGhpc1twYXJlbnRQYXJhbXNbal1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBpbmhlcml0ZWQsIG5ld1BhcmFtcyk7XG4gIH1cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBwYXRoICovIC8qKiAqL1xuaW1wb3J0IHsgZXh0ZW5kLCBhcHBseVBhaXJzLCBmaW5kLCBhbGxUcnVlUiwgcGFpcnMsIGFycmF5VHVwbGVzIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBwcm9wRXEgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgUmF3UGFyYW1zIH0gZnJvbSAnLi4vcGFyYW1zL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBSZXNvbHZhYmxlIH0gZnJvbSAnLi4vcmVzb2x2ZS9yZXNvbHZhYmxlJztcbmltcG9ydCB7IFZpZXdDb25maWcgfSBmcm9tICcuLi92aWV3L2ludGVyZmFjZSc7XG5cbi8qKlxuICogQSBub2RlIGluIGEgW1tUcmVlQ2hhbmdlc11dIHBhdGhcbiAqXG4gKiBGb3IgYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aCwgdGhpcyBjbGFzcyBob2xkcyB0aGUgc3RhdGVmdWwgaW5mb3JtYXRpb24gZm9yIGEgc2luZ2xlIG5vZGUgaW4gdGhlIHBhdGguXG4gKiBFYWNoIFBhdGhOb2RlIGNvcnJlc3BvbmRzIHRvIGEgc3RhdGUgYmVpbmcgZW50ZXJlZCwgZXhpdGVkLCBvciByZXRhaW5lZC5cbiAqIFRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBpbmNsdWRlcyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCByZXNvbHZlIGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoTm9kZSB7XG4gIC8qKiBUaGUgc3RhdGUgYmVpbmcgZW50ZXJlZCwgZXhpdGVkLCBvciByZXRhaW5lZCAqL1xuICBwdWJsaWMgc3RhdGU6IFN0YXRlT2JqZWN0O1xuICAvKiogVGhlIHBhcmFtZXRlcnMgZGVjbGFyZWQgb24gdGhlIHN0YXRlICovXG4gIHB1YmxpYyBwYXJhbVNjaGVtYTogUGFyYW1bXTtcbiAgLyoqIFRoZSBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgYmVsb25nIHRvIHRoZSBzdGF0ZSAqL1xuICBwdWJsaWMgcGFyYW1WYWx1ZXM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKiBUaGUgaW5kaXZpZHVhbCAoc3RhdGVmdWwpIHJlc29sdmFibGUgb2JqZWN0cyB0aGF0IGJlbG9uZyB0byB0aGUgc3RhdGUgKi9cbiAgcHVibGljIHJlc29sdmFibGVzOiBSZXNvbHZhYmxlW107XG4gIC8qKiBUaGUgc3RhdGUncyBkZWNsYXJlZCB2aWV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0cyAqL1xuICBwdWJsaWMgdmlld3M6IFZpZXdDb25maWdbXTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBQYXRoTm9kZVxuICAgKiBAZGVwcmVjYXRlZCB1c2UgaW5zdGFuY2UgbWV0aG9kIGBub2RlLmNsb25lKClgXG4gICAqL1xuICBzdGF0aWMgY2xvbmUgPSAobm9kZTogUGF0aE5vZGUpID0+IG5vZGUuY2xvbmUoKTtcblxuICAvKiogQ3JlYXRlcyBhIGNvcHkgb2YgYSBQYXRoTm9kZSAqL1xuICBjb25zdHJ1Y3Rvcihub2RlOiBQYXRoTm9kZSk7XG4gIC8qKiBDcmVhdGVzIGEgbmV3IChlbXB0eSkgUGF0aE5vZGUgZm9yIGEgU3RhdGUgKi9cbiAgY29uc3RydWN0b3Ioc3RhdGU6IFN0YXRlT2JqZWN0KTtcbiAgY29uc3RydWN0b3Ioc3RhdGVPck5vZGU6IGFueSkge1xuICAgIGlmIChzdGF0ZU9yTm9kZSBpbnN0YW5jZW9mIFBhdGhOb2RlKSB7XG4gICAgICBjb25zdCBub2RlOiBQYXRoTm9kZSA9IHN0YXRlT3JOb2RlO1xuICAgICAgdGhpcy5zdGF0ZSA9IG5vZGUuc3RhdGU7XG4gICAgICB0aGlzLnBhcmFtU2NoZW1hID0gbm9kZS5wYXJhbVNjaGVtYS5zbGljZSgpO1xuICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IGV4dGVuZCh7fSwgbm9kZS5wYXJhbVZhbHVlcyk7XG4gICAgICB0aGlzLnJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5zbGljZSgpO1xuICAgICAgdGhpcy52aWV3cyA9IG5vZGUudmlld3MgJiYgbm9kZS52aWV3cy5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZTogU3RhdGVPYmplY3QgPSBzdGF0ZU9yTm9kZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMucGFyYW1TY2hlbWEgPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSk7XG4gICAgICB0aGlzLnBhcmFtVmFsdWVzID0ge307XG4gICAgICB0aGlzLnJlc29sdmFibGVzID0gc3RhdGUucmVzb2x2YWJsZXMubWFwKHJlcyA9PiByZXMuY2xvbmUoKSk7XG4gICAgfVxuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQYXRoTm9kZSh0aGlzKTtcbiAgfVxuXG4gIC8qKiBTZXRzIFtbcGFyYW1WYWx1ZXNdXSBmb3IgdGhlIG5vZGUsIGZyb20gdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QgaGFzaCAqL1xuICBhcHBseVJhd1BhcmFtcyhwYXJhbXM6IFJhd1BhcmFtcyk6IFBhdGhOb2RlIHtcbiAgICBjb25zdCBnZXRQYXJhbVZhbCA9IChwYXJhbURlZjogUGFyYW0pID0+IFtwYXJhbURlZi5pZCwgcGFyYW1EZWYudmFsdWUocGFyYW1zW3BhcmFtRGVmLmlkXSldO1xuICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB0aGlzLnBhcmFtU2NoZW1hLnJlZHVjZSgobWVtbywgcERlZikgPT4gYXBwbHlQYWlycyhtZW1vLCBnZXRQYXJhbVZhbChwRGVmKSksIHt9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBHZXRzIGEgc3BlY2lmaWMgW1tQYXJhbV1dIG1ldGFkYXRhIHRoYXQgYmVsb25ncyB0byB0aGUgbm9kZSAqL1xuICBwYXJhbWV0ZXIobmFtZTogc3RyaW5nKTogUGFyYW0ge1xuICAgIHJldHVybiBmaW5kKHRoaXMucGFyYW1TY2hlbWEsIHByb3BFcSgnaWQnLCBuYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RhdGUgYW5kIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGFub3RoZXIgUGF0aE5vZGUgYXJlXG4gICAqIGVxdWFsIHRvIHRoZSBzdGF0ZSBhbmQgcGFyYW0gdmFsdWVzIGZvciB0aGlzIFBhdGhOb2RlXG4gICAqL1xuICBlcXVhbHMobm9kZTogUGF0aE5vZGUsIHBhcmFtc0ZuPzogR2V0UGFyYW1zRm4pOiBib29sZWFuIHtcbiAgICBjb25zdCBkaWZmID0gdGhpcy5kaWZmKG5vZGUsIHBhcmFtc0ZuKTtcbiAgICByZXR1cm4gZGlmZiAmJiBkaWZmLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBQYXJhbXMgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVyIHZhbHVlcyBvbiBhbm90aGVyIFBhdGhOb2RlLlxuICAgKlxuICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgKG9mIHRoZSBzYW1lIHN0YXRlKSwgZmluZHMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggZGlmZmVyLlxuICAgKiBSZXR1cm5zIHRoZSBbW1BhcmFtXV0gKHNjaGVtYSBvYmplY3RzKSB3aG9zZSBwYXJhbWV0ZXIgdmFsdWVzIGRpZmZlci5cbiAgICpcbiAgICogR2l2ZW4gYW5vdGhlciBub2RlIGZvciBhIGRpZmZlcmVudCBzdGF0ZSwgcmV0dXJucyBgZmFsc2VgXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNvbXBhcmUgdG9cbiAgICogQHBhcmFtIHBhcmFtc0ZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoaWNoIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGNvbXBhcmVkLlxuICAgKiBAcmV0dXJucyBUaGUgW1tQYXJhbV1dcyB3aGljaCBkaWZmZXIsIG9yIG51bGwgaWYgdGhlIHR3byBub2RlcyBhcmUgZm9yIGRpZmZlcmVudCBzdGF0ZXNcbiAgICovXG4gIGRpZmYobm9kZTogUGF0aE5vZGUsIHBhcmFtc0ZuPzogR2V0UGFyYW1zRm4pOiBQYXJhbVtdIHwgZmFsc2Uge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBub2RlLnN0YXRlKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBwYXJhbXM6IFBhcmFtW10gPSBwYXJhbXNGbiA/IHBhcmFtc0ZuKHRoaXMpIDogdGhpcy5wYXJhbVNjaGVtYTtcbiAgICByZXR1cm4gUGFyYW0uY2hhbmdlZChwYXJhbXMsIHRoaXMucGFyYW1WYWx1ZXMsIG5vZGUucGFyYW1WYWx1ZXMpO1xuICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgdHlwZSBHZXRQYXJhbXNGbiA9IChwYXRoTm9kZTogUGF0aE5vZGUpID0+IFBhcmFtW107XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuXG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uLCBTdGF0ZU9yTmFtZSwgVGFyZ2V0U3RhdGVEZWYgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uT3B0aW9ucyB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmdzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZVJlZ2lzdHJ5IH0gZnJvbSAnLi9zdGF0ZVJlZ2lzdHJ5JztcbmltcG9ydCB7IFJhd1BhcmFtcyB9IGZyb20gJy4uL3BhcmFtcyc7XG5cbi8qKlxuICogRW5jYXBzdWxhdGUgdGhlIHRhcmdldCAoZGVzdGluYXRpb24pIHN0YXRlL3BhcmFtcy9vcHRpb25zIG9mIGEgW1tUcmFuc2l0aW9uXV0uXG4gKlxuICogVGhpcyBjbGFzcyBpcyBmcmVxdWVudGx5IHVzZWQgdG8gcmVkaXJlY3QgYSB0cmFuc2l0aW9uIHRvIGEgbmV3IGRlc3RpbmF0aW9uLlxuICpcbiAqIFNlZTpcbiAqXG4gKiAtIFtbSG9va1Jlc3VsdF1dXG4gKiAtIFtbVHJhbnNpdGlvbkhvb2tGbl1dXG4gKiAtIFtbVHJhbnNpdGlvblNlcnZpY2Uub25TdGFydF1dXG4gKlxuICogVG8gY3JlYXRlIGEgYFRhcmdldFN0YXRlYCwgdXNlIFtbU3RhdGVTZXJ2aWNlLnRhcmdldF1dLlxuICpcbiAqIC0tLVxuICpcbiAqIFRoaXMgY2xhc3Mgd3JhcHM6XG4gKlxuICogMSkgYW4gaWRlbnRpZmllciBmb3IgYSBzdGF0ZVxuICogMikgYSBzZXQgb2YgcGFyYW1ldGVyc1xuICogMykgYW5kIHRyYW5zaXRpb24gb3B0aW9uc1xuICogNCkgdGhlIHJlZ2lzdGVyZWQgc3RhdGUgb2JqZWN0ICh0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0pXG4gKlxuICogTWFueSBVSS1Sb3V0ZXIgQVBJcyBzdWNoIGFzIFtbU3RhdGVTZXJ2aWNlLmdvXV0gdGFrZSBhIFtbU3RhdGVPck5hbWVdXSBhcmd1bWVudCB3aGljaCBjYW5cbiAqIGVpdGhlciBiZSBhICpzdGF0ZSBvYmplY3QqIChhIFtbU3RhdGVEZWNsYXJhdGlvbl1dIG9yIFtbU3RhdGVPYmplY3RdXSkgb3IgYSAqc3RhdGUgbmFtZSogKGEgc3RyaW5nKS5cbiAqIFRoZSBgVGFyZ2V0U3RhdGVgIGNsYXNzIG5vcm1hbGl6ZXMgdGhvc2Ugb3B0aW9ucy5cbiAqXG4gKiBBIGBUYXJnZXRTdGF0ZWAgbWF5IGJlIHZhbGlkICh0aGUgc3RhdGUgYmVpbmcgdGFyZ2V0ZWQgZXhpc3RzIGluIHRoZSByZWdpc3RyeSlcbiAqIG9yIGludmFsaWQgKHRoZSBzdGF0ZSBiZWluZyB0YXJnZXRlZCBpcyBub3QgcmVnaXN0ZXJlZCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXJnZXRTdGF0ZSB7XG4gIHByaXZhdGUgX2RlZmluaXRpb246IFN0YXRlT2JqZWN0O1xuICBwcml2YXRlIF9wYXJhbXM6IFJhd1BhcmFtcztcbiAgcHJpdmF0ZSBfb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnM7XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyBhIHN0YXRlIHByb3BlcnR5IHRoYXQgbWlnaHQgYmUgYSBzdGF0ZSBvciBzdGF0ZSBuYW1lICovXG4gIHN0YXRpYyBpc0RlZiA9IChvYmopOiBvYmogaXMgVGFyZ2V0U3RhdGVEZWYgPT4gb2JqICYmIG9iai5zdGF0ZSAmJiAoaXNTdHJpbmcob2JqLnN0YXRlKSB8fCBpc1N0cmluZyhvYmouc3RhdGUubmFtZSkpO1xuXG4gIC8qKlxuICAgKiBUaGUgVGFyZ2V0U3RhdGUgY29uc3RydWN0b3JcbiAgICpcbiAgICogTm90ZTogRG8gbm90IGNvbnN0cnVjdCBhIGBUYXJnZXRTdGF0ZWAgbWFudWFsbHkuXG4gICAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSB0aGUgW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0gZmFjdG9yeSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSBfc3RhdGVSZWdpc3RyeSBUaGUgU3RhdGVSZWdpc3RyeSB0byB1c2UgdG8gbG9vayB1cCB0aGUgX2RlZmluaXRpb25cbiAgICogQHBhcmFtIF9pZGVudGlmaWVyIEFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGUuXG4gICAqICAgIEVpdGhlciBhIGZ1bGx5LXF1YWxpZmllZCBzdGF0ZSBuYW1lLCBvciB0aGUgb2JqZWN0IHVzZWQgdG8gZGVmaW5lIHRoZSBzdGF0ZS5cbiAgICogQHBhcmFtIF9wYXJhbXMgUGFyYW1ldGVycyBmb3IgdGhlIHRhcmdldCBzdGF0ZVxuICAgKiBAcGFyYW0gX29wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3N0YXRlUmVnaXN0cnk6IFN0YXRlUmVnaXN0cnksXG4gICAgcHJpdmF0ZSBfaWRlbnRpZmllcjogU3RhdGVPck5hbWUsXG4gICAgX3BhcmFtcz86IFJhd1BhcmFtcyxcbiAgICBfb3B0aW9ucz86IFRyYW5zaXRpb25PcHRpb25zXG4gICkge1xuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBfaWRlbnRpZmllcjtcbiAgICB0aGlzLl9wYXJhbXMgPSBleHRlbmQoe30sIF9wYXJhbXMgfHwge30pO1xuICAgIHRoaXMuX29wdGlvbnMgPSBleHRlbmQoe30sIF9vcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLl9kZWZpbml0aW9uID0gX3N0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKF9pZGVudGlmaWVyLCB0aGlzLl9vcHRpb25zLnJlbGF0aXZlKTtcbiAgfVxuXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdGhpcyBvYmplY3QgdGFyZ2V0cyAqL1xuICBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24ubmFtZSkgfHwgPHN0cmluZz50aGlzLl9pZGVudGlmaWVyO1xuICB9XG5cbiAgLyoqIFRoZSBpZGVudGlmaWVyIHVzZWQgd2hlbiBjcmVhdGluZyB0aGlzIFRhcmdldFN0YXRlICovXG4gIGlkZW50aWZpZXIoKTogU3RhdGVPck5hbWUge1xuICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xuICB9XG5cbiAgLyoqIFRoZSB0YXJnZXQgcGFyYW1ldGVyIHZhbHVlcyAqL1xuICBwYXJhbXMoKTogUmF3UGFyYW1zIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICB9XG5cbiAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvYmplY3QgKGlmIGl0IHdhcyBmb3VuZCkgKi9cbiAgJHN0YXRlKCk6IFN0YXRlT2JqZWN0IHtcbiAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcbiAgfVxuXG4gIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgZGVjbGFyYXRpb24gKGlmIGl0IHdhcyBmb3VuZCkgKi9cbiAgc3RhdGUoKTogU3RhdGVEZWNsYXJhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmO1xuICB9XG5cbiAgLyoqIFRoZSB0YXJnZXQgb3B0aW9ucyAqL1xuICBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgLyoqIFRydWUgaWYgdGhlIHRhcmdldCBzdGF0ZSB3YXMgZm91bmQgKi9cbiAgZXhpc3RzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhISh0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24uc2VsZik7XG4gIH1cblxuICAvKiogVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIHZhbGlkICovXG4gIHZhbGlkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgLyoqIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgcmV0dXJucyB0aGUgcmVhc29uIHdoeSAqL1xuICBlcnJvcigpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhc2UgPSA8YW55PnRoaXMub3B0aW9ucygpLnJlbGF0aXZlO1xuICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbiAmJiAhIWJhc2UpIHtcbiAgICAgIGNvbnN0IHN0YXRlTmFtZSA9IGJhc2UubmFtZSA/IGJhc2UubmFtZSA6IGJhc2U7XG4gICAgICByZXR1cm4gYENvdWxkIG5vdCByZXNvbHZlICcke3RoaXMubmFtZSgpfScgZnJvbSBzdGF0ZSAnJHtzdGF0ZU5hbWV9J2A7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbikgcmV0dXJuIGBObyBzdWNoIHN0YXRlICcke3RoaXMubmFtZSgpfSdgO1xuICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbi5zZWxmKSByZXR1cm4gYFN0YXRlICcke3RoaXMubmFtZSgpfScgaGFzIGFuIGludmFsaWQgZGVmaW5pdGlvbmA7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCcke3RoaXMubmFtZSgpfScke3N0cmluZ2lmeSh0aGlzLnBhcmFtcygpKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgVGFyZ2V0U3RhdGUgd2hpY2ggdGFyZ2V0cyBhIGRpZmZlcmVudCBzdGF0ZS5cbiAgICogVGhlIG5ldyBUYXJnZXRTdGF0ZSBoYXMgdGhlIHNhbWUgcGFyYW1ldGVyIHZhbHVlcyBhbmQgdHJhbnNpdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIG5ldyBzdGF0ZSB0aGF0IHNob3VsZCBiZSB0YXJnZXRlZFxuICAgKi9cbiAgd2l0aFN0YXRlKHN0YXRlOiBTdGF0ZU9yTmFtZSk6IFRhcmdldFN0YXRlIHtcbiAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHN0YXRlLCB0aGlzLl9wYXJhbXMsIHRoaXMuX29wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgVGFyZ2V0U3RhdGUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyB0aGUgbmV3IHBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlXG4gICAqIEBwYXJhbSByZXBsYWNlIFdoZW4gZmFsc2UgKGRlZmF1bHQpIHRoZSBuZXcgcGFyYW1ldGVyIHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlcy5cbiAgICogICAgICAgICAgICAgICAgV2hlbiB0cnVlIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHZhbHVlcy5cbiAgICovXG4gIHdpdGhQYXJhbXMocGFyYW1zOiBSYXdQYXJhbXMsIHJlcGxhY2UgPSBmYWxzZSk6IFRhcmdldFN0YXRlIHtcbiAgICBjb25zdCBuZXdQYXJhbXM6IFJhd1BhcmFtcyA9IHJlcGxhY2UgPyBwYXJhbXMgOiBleHRlbmQoe30sIHRoaXMuX3BhcmFtcywgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHRoaXMuX2lkZW50aWZpZXIsIG5ld1BhcmFtcywgdGhpcy5fb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBUcmFuc2l0aW9uIE9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBuZXcgb3B0aW9ucyB0byB1c2VcbiAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiBmYWxzZSAoZGVmYXVsdCkgdGhlIG5ldyBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogICAgICAgICAgICAgICAgV2hlbiB0cnVlIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAqL1xuICB3aXRoT3B0aW9ucyhvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucywgcmVwbGFjZSA9IGZhbHNlKTogVGFyZ2V0U3RhdGUge1xuICAgIGNvbnN0IG5ld09wdHMgPSByZXBsYWNlID8gb3B0aW9ucyA6IGV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBUYXJnZXRTdGF0ZSh0aGlzLl9zdGF0ZVJlZ2lzdHJ5LCB0aGlzLl9pZGVudGlmaWVyLCB0aGlzLl9wYXJhbXMsIG5ld09wdHMpO1xuICB9XG59XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgcGF0aCAqLyAvKiogKi9cblxuaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBmaW5kLFxuICBwaWNrLFxuICBvbWl0LFxuICB0YWlsLFxuICBtZXJnZVIsXG4gIHZhbHVlcyxcbiAgdW5uZXN0UixcbiAgUHJlZGljYXRlLFxuICBpbkFycmF5LFxuICBhcnJheVR1cGxlcyxcbn0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBwcm9wLCBwcm9wRXEsIG5vdCB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuXG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMvaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyZWVDaGFuZ2VzIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVmlld0NvbmZpZyB9IGZyb20gJy4uL3ZpZXcvaW50ZXJmYWNlJztcbmltcG9ydCB7IF9WaWV3RGVjbGFyYXRpb24gfSBmcm9tICcuLi9zdGF0ZS9pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IFRhcmdldFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUvdGFyZ2V0U3RhdGUnO1xuaW1wb3J0IHsgR2V0UGFyYW1zRm4sIFBhdGhOb2RlIH0gZnJvbSAnLi9wYXRoTm9kZSc7XG5pbXBvcnQgeyBWaWV3U2VydmljZSB9IGZyb20gJy4uL3ZpZXcvdmlldyc7XG5pbXBvcnQgeyBQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBTdGF0ZVJlZ2lzdHJ5IH0gZnJvbSAnLi4vc3RhdGUnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgZnVuY3Rpb25zIHdoaWNoIGNvbnZlcnQgVGFyZ2V0U3RhdGVzLCBOb2RlcyBhbmQgcGF0aHMgZnJvbSBvbmUgdHlwZSB0byBhbm90aGVyLlxuICovXG5leHBvcnQgY2xhc3MgUGF0aFV0aWxzIHtcbiAgLyoqIEdpdmVuIGEgUGF0aE5vZGVbXSwgY3JlYXRlIGFuIFRhcmdldFN0YXRlICovXG4gIHN0YXRpYyBtYWtlVGFyZ2V0U3RhdGUocmVnaXN0cnk6IFN0YXRlUmVnaXN0cnksIHBhdGg6IFBhdGhOb2RlW10pOiBUYXJnZXRTdGF0ZSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0YWlsKHBhdGgpLnN0YXRlO1xuICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUocmVnaXN0cnksIHN0YXRlLCBwYXRoLm1hcChwcm9wKCdwYXJhbVZhbHVlcycpKS5yZWR1Y2UobWVyZ2VSLCB7fSksIHt9KTtcbiAgfVxuXG4gIHN0YXRpYyBidWlsZFBhdGgodGFyZ2V0U3RhdGU6IFRhcmdldFN0YXRlKSB7XG4gICAgY29uc3QgdG9QYXJhbXMgPSB0YXJnZXRTdGF0ZS5wYXJhbXMoKTtcbiAgICByZXR1cm4gdGFyZ2V0U3RhdGUuJHN0YXRlKCkucGF0aC5tYXAoc3RhdGUgPT4gbmV3IFBhdGhOb2RlKHN0YXRlKS5hcHBseVJhd1BhcmFtcyh0b1BhcmFtcykpO1xuICB9XG5cbiAgLyoqIEdpdmVuIGEgZnJvbVBhdGg6IFBhdGhOb2RlW10gYW5kIGEgVGFyZ2V0U3RhdGUsIGJ1aWxkcyBhIHRvUGF0aDogUGF0aE5vZGVbXSAqL1xuICBzdGF0aWMgYnVpbGRUb1BhdGgoZnJvbVBhdGg6IFBhdGhOb2RlW10sIHRhcmdldFN0YXRlOiBUYXJnZXRTdGF0ZSk6IFBhdGhOb2RlW10ge1xuICAgIGNvbnN0IHRvUGF0aDogUGF0aE5vZGVbXSA9IFBhdGhVdGlscy5idWlsZFBhdGgodGFyZ2V0U3RhdGUpO1xuICAgIGlmICh0YXJnZXRTdGF0ZS5vcHRpb25zKCkuaW5oZXJpdCkge1xuICAgICAgcmV0dXJuIFBhdGhVdGlscy5pbmhlcml0UGFyYW1zKGZyb21QYXRoLCB0b1BhdGgsIE9iamVjdC5rZXlzKHRhcmdldFN0YXRlLnBhcmFtcygpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b1BhdGg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBWaWV3Q29uZmlnIG9iamVjdHMgYW5kIGFkZHMgdG8gbm9kZXMuXG4gICAqXG4gICAqIE9uIGVhY2ggW1tQYXRoTm9kZV1dLCBjcmVhdGVzIFZpZXdDb25maWcgb2JqZWN0cyBmcm9tIHRoZSB2aWV3czogcHJvcGVydHkgb2YgdGhlIG5vZGUncyBzdGF0ZVxuICAgKi9cbiAgc3RhdGljIGFwcGx5Vmlld0NvbmZpZ3MoJHZpZXc6IFZpZXdTZXJ2aWNlLCBwYXRoOiBQYXRoTm9kZVtdLCBzdGF0ZXM6IFN0YXRlT2JqZWN0W10pIHtcbiAgICAvLyBPbmx5IGFwcGx5IHRoZSB2aWV3Q29uZmlncyB0byB0aGUgbm9kZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZXNcbiAgICBwYXRoXG4gICAgICAuZmlsdGVyKG5vZGUgPT4gaW5BcnJheShzdGF0ZXMsIG5vZGUuc3RhdGUpKVxuICAgICAgLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHZpZXdEZWNsczogX1ZpZXdEZWNsYXJhdGlvbltdID0gdmFsdWVzKG5vZGUuc3RhdGUudmlld3MgfHwge30pO1xuICAgICAgICBjb25zdCBzdWJQYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgbiA9PiBuID09PSBub2RlKTtcbiAgICAgICAgY29uc3Qgdmlld0NvbmZpZ3M6IFZpZXdDb25maWdbXVtdID0gdmlld0RlY2xzLm1hcCh2aWV3ID0+ICR2aWV3LmNyZWF0ZVZpZXdDb25maWcoc3ViUGF0aCwgdmlldykpO1xuICAgICAgICBub2RlLnZpZXdzID0gdmlld0NvbmZpZ3MucmVkdWNlKHVubmVzdFIsIFtdKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgZnJvbVBhdGggYW5kIGEgdG9QYXRoLCByZXR1cm5zIGEgbmV3IHRvIHBhdGggd2hpY2ggaW5oZXJpdHMgcGFyYW1ldGVycyBmcm9tIHRoZSBmcm9tUGF0aFxuICAgKlxuICAgKiBGb3IgYSBwYXJhbWV0ZXIgaW4gYSBub2RlIHRvIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBmcm9tIHBhdGg6XG4gICAqIC0gVGhlIHRvUGF0aCdzIG5vZGUgbXVzdCBoYXZlIGEgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgZnJvbVBhdGggKGJ5IHN0YXRlKS5cbiAgICogLSBUaGUgcGFyYW1ldGVyIG5hbWUgbXVzdCBub3QgYmUgZm91bmQgaW4gdGhlIHRvS2V5cyBwYXJhbWV0ZXIgYXJyYXkuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBrZXlzIHByb3ZpZGVkIGluIHRvS2V5cyBhcmUgaW50ZW5kZWQgdG8gYmUgdGhvc2UgcGFyYW0ga2V5cyBleHBsaWNpdGx5IHNwZWNpZmllZCBieSBzb21lXG4gICAqIGNhbGxlciwgZm9yIGluc3RhbmNlLCAkc3RhdGUudHJhbnNpdGlvblRvKC4uLiwgdG9QYXJhbXMpLiAgSWYgYSBrZXkgd2FzIGZvdW5kIGluIHRvUGFyYW1zLFxuICAgKiBpdCBpcyBub3QgaW5oZXJpdGVkIGZyb20gdGhlIGZyb21QYXRoLlxuICAgKi9cbiAgc3RhdGljIGluaGVyaXRQYXJhbXMoZnJvbVBhdGg6IFBhdGhOb2RlW10sIHRvUGF0aDogUGF0aE5vZGVbXSwgdG9LZXlzOiBzdHJpbmdbXSA9IFtdKTogUGF0aE5vZGVbXSB7XG4gICAgZnVuY3Rpb24gbm9kZVBhcmFtVmFscyhwYXRoOiBQYXRoTm9kZVtdLCBzdGF0ZTogU3RhdGVPYmplY3QpOiBSYXdQYXJhbXMge1xuICAgICAgY29uc3Qgbm9kZTogUGF0aE5vZGUgPSBmaW5kKHBhdGgsIHByb3BFcSgnc3RhdGUnLCBzdGF0ZSkpO1xuICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgbm9kZSAmJiBub2RlLnBhcmFtVmFsdWVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBub0luaGVyaXQgPSBmcm9tUGF0aFxuICAgICAgLm1hcChub2RlID0+IG5vZGUucGFyYW1TY2hlbWEpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgLmZpbHRlcihwYXJhbSA9PiAhcGFyYW0uaW5oZXJpdClcbiAgICAgIC5tYXAocHJvcCgnaWQnKSk7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBbW1BhdGhOb2RlXV0gXCJ0b05vZGVcIiwgcmV0dXJuIGEgbmV3IFtbUGF0aE5vZGVdXSB3aXRoIHBhcmFtIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSB0aGVcbiAgICAgKiBtYXRjaGluZyBub2RlIGluIGZyb21QYXRoLiAgT25seSBpbmhlcml0IGtleXMgdGhhdCBhcmVuJ3QgZm91bmQgaW4gXCJ0b0tleXNcIiBmcm9tIHRoZSBub2RlIGluIFwiZnJvbVBhdGhcIlwiXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUluaGVyaXRlZFBhcmFtc05vZGUodG9Ob2RlOiBQYXRoTm9kZSk6IFBhdGhOb2RlIHtcbiAgICAgIC8vIEFsbCBwYXJhbSB2YWx1ZXMgZm9yIHRoZSBub2RlIChtYXkgaW5jbHVkZSBkZWZhdWx0IGtleS92YWxzLCB3aGVuIGtleSB3YXMgbm90IGZvdW5kIGluIHRvUGFyYW1zKVxuICAgICAgbGV0IHRvUGFyYW1WYWxzID0gZXh0ZW5kKHt9LCB0b05vZGUgJiYgdG9Ob2RlLnBhcmFtVmFsdWVzKTtcbiAgICAgIC8vIGxpbWl0ZWQgdG8gb25seSB0aG9zZSBrZXlzIGZvdW5kIGluIHRvUGFyYW1zXG4gICAgICBjb25zdCBpbmNvbWluZ1BhcmFtVmFscyA9IHBpY2sodG9QYXJhbVZhbHMsIHRvS2V5cyk7XG4gICAgICB0b1BhcmFtVmFscyA9IG9taXQodG9QYXJhbVZhbHMsIHRvS2V5cyk7XG4gICAgICBjb25zdCBmcm9tUGFyYW1WYWxzID0gb21pdChub2RlUGFyYW1WYWxzKGZyb21QYXRoLCB0b05vZGUuc3RhdGUpIHx8IHt9LCBub0luaGVyaXQpO1xuICAgICAgLy8gZXh0ZW5kIHRvUGFyYW1WYWxzIHdpdGggYW55IGZyb21QYXJhbVZhbHMsIHRoZW4gb3ZlcnJpZGUgYW55IG9mIHRob3NlIHRob3NlIHdpdGggaW5jb21pbmdQYXJhbVZhbHNcbiAgICAgIGNvbnN0IG93blBhcmFtVmFsczogUmF3UGFyYW1zID0gZXh0ZW5kKHRvUGFyYW1WYWxzLCBmcm9tUGFyYW1WYWxzLCBpbmNvbWluZ1BhcmFtVmFscyk7XG4gICAgICByZXR1cm4gbmV3IFBhdGhOb2RlKHRvTm9kZS5zdGF0ZSkuYXBwbHlSYXdQYXJhbXMob3duUGFyYW1WYWxzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGFyYW0ga2V5cyBzcGVjaWZpZWQgYnkgdGhlIGluY29taW5nIHRvUGFyYW1zXG4gICAgcmV0dXJuIDxQYXRoTm9kZVtdPnRvUGF0aC5tYXAobWFrZUluaGVyaXRlZFBhcmFtc05vZGUpO1xuICB9XG5cbiAgc3RhdGljIG5vbkR5bmFtaWNQYXJhbXMgPSAobm9kZTogUGF0aE5vZGUpOiBQYXJhbVtdID0+XG4gICAgbm9kZS5zdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSkuZmlsdGVyKHBhcmFtID0+ICFwYXJhbS5keW5hbWljKTtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHRyZWUgY2hhbmdlcyAoZW50ZXJpbmcsIGV4aXRpbmcpIGJldHdlZW4gYSBmcm9tUGF0aCBhbmQgdG9QYXRoLlxuICAgKi9cbiAgc3RhdGljIHRyZWVDaGFuZ2VzKGZyb21QYXRoOiBQYXRoTm9kZVtdLCB0b1BhdGg6IFBhdGhOb2RlW10sIHJlbG9hZFN0YXRlOiBTdGF0ZU9iamVjdCk6IFRyZWVDaGFuZ2VzIHtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1pbihmcm9tUGF0aC5sZW5ndGgsIHRvUGF0aC5sZW5ndGgpO1xuICAgIGxldCBrZWVwID0gMDtcblxuICAgIGNvbnN0IG5vZGVzTWF0Y2ggPSAobm9kZTE6IFBhdGhOb2RlLCBub2RlMjogUGF0aE5vZGUpID0+IG5vZGUxLmVxdWFscyhub2RlMiwgUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpO1xuXG4gICAgd2hpbGUgKGtlZXAgPCBtYXggJiYgZnJvbVBhdGhba2VlcF0uc3RhdGUgIT09IHJlbG9hZFN0YXRlICYmIG5vZGVzTWF0Y2goZnJvbVBhdGhba2VlcF0sIHRvUGF0aFtrZWVwXSkpIHtcbiAgICAgIGtlZXArKztcbiAgICB9XG5cbiAgICAvKiogR2l2ZW4gYSByZXRhaW5lZCBub2RlLCByZXR1cm4gYSBuZXcgbm9kZSB3aGljaCB1c2VzIHRoZSB0byBub2RlJ3MgcGFyYW0gdmFsdWVzICovXG4gICAgZnVuY3Rpb24gYXBwbHlUb1BhcmFtcyhyZXRhaW5lZE5vZGU6IFBhdGhOb2RlLCBpZHg6IG51bWJlcik6IFBhdGhOb2RlIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IHJldGFpbmVkTm9kZS5jbG9uZSgpO1xuICAgICAgY2xvbmVkLnBhcmFtVmFsdWVzID0gdG9QYXRoW2lkeF0ucGFyYW1WYWx1ZXM7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIGxldCBmcm9tOiBQYXRoTm9kZVtdLCByZXRhaW5lZDogUGF0aE5vZGVbXSwgZXhpdGluZzogUGF0aE5vZGVbXSwgZW50ZXJpbmc6IFBhdGhOb2RlW10sIHRvOiBQYXRoTm9kZVtdO1xuXG4gICAgZnJvbSA9IGZyb21QYXRoO1xuICAgIHJldGFpbmVkID0gZnJvbS5zbGljZSgwLCBrZWVwKTtcbiAgICBleGl0aW5nID0gZnJvbS5zbGljZShrZWVwKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyByZXRhaW5lZCBwYXRoICh3aXRoIHNoYWxsb3cgY29waWVzIG9mIG5vZGVzKSB3aGljaCBoYXZlIHRoZSBwYXJhbXMgb2YgdGhlIHRvUGF0aCBtYXBwZWRcbiAgICBjb25zdCByZXRhaW5lZFdpdGhUb1BhcmFtcyA9IHJldGFpbmVkLm1hcChhcHBseVRvUGFyYW1zKTtcbiAgICBlbnRlcmluZyA9IHRvUGF0aC5zbGljZShrZWVwKTtcbiAgICB0byA9IHJldGFpbmVkV2l0aFRvUGFyYW1zLmNvbmNhdChlbnRlcmluZyk7XG5cbiAgICByZXR1cm4geyBmcm9tLCB0bywgcmV0YWluZWQsIHJldGFpbmVkV2l0aFRvUGFyYW1zLCBleGl0aW5nLCBlbnRlcmluZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgcGF0aCB3aGljaCBpczogdGhlIHN1YnBhdGggb2YgdGhlIGZpcnN0IHBhdGggd2hpY2ggbWF0Y2hlcyB0aGUgc2Vjb25kIHBhdGguXG4gICAqXG4gICAqIFRoZSBuZXcgcGF0aCBzdGFydHMgZnJvbSByb290IGFuZCBjb250YWlucyBhbnkgbm9kZXMgdGhhdCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoLlxuICAgKiBJdCBzdG9wcyBiZWZvcmUgdGhlIGZpcnN0IG5vbi1tYXRjaGluZyBub2RlLlxuICAgKlxuICAgKiBOb2RlcyBhcmUgY29tcGFyZWQgdXNpbmcgdGhlaXIgc3RhdGUgcHJvcGVydHkgYW5kIHRoZWlyIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIElmIGEgYHBhcmFtc0ZuYCBpcyBwcm92aWRlZCwgb25seSB0aGUgW1tQYXJhbV1dIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNvbnNpZGVyZWQgd2hlbiBjb21wYXJpbmcgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoQSB0aGUgZmlyc3QgcGF0aFxuICAgKiBAcGFyYW0gcGF0aEIgdGhlIHNlY29uZCBwYXRoXG4gICAqIEBwYXJhbSBwYXJhbXNGbiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHBhcmFtZXRlcnMgdG8gY29uc2lkZXIgd2hlbiBjb21wYXJpbmdcbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgUGF0aE5vZGVzIGZyb20gdGhlIGZpcnN0IHBhdGggd2hpY2ggbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aFxuICAgKi9cbiAgc3RhdGljIG1hdGNoaW5nKHBhdGhBOiBQYXRoTm9kZVtdLCBwYXRoQjogUGF0aE5vZGVbXSwgcGFyYW1zRm4/OiBHZXRQYXJhbXNGbik6IFBhdGhOb2RlW10ge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgdHVwbGVzOiBQYXRoTm9kZVtdW10gPSBhcnJheVR1cGxlcyhwYXRoQSwgcGF0aEIpO1xuICAgIHJldHVybiB0dXBsZXMucmVkdWNlKChtYXRjaGluZywgW25vZGVBLCBub2RlQl0pID0+IHtcbiAgICAgIGRvbmUgPSBkb25lIHx8ICFub2RlQS5lcXVhbHMobm9kZUIsIHBhcmFtc0ZuKTtcbiAgICAgIHJldHVybiBkb25lID8gbWF0Y2hpbmcgOiBtYXRjaGluZy5jb25jYXQobm9kZUEpO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdHdvIHBhdGhzIGFyZSBpZGVudGljYWwuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoQVxuICAgKiBAcGFyYW0gcGF0aEJcbiAgICogQHBhcmFtIHBhcmFtc0ZuIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcGFyYW1ldGVycyB0byBjb25zaWRlciB3aGVuIGNvbXBhcmluZ1xuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0aGUgc3RhdGVzIGFuZCBwYXJhbWV0ZXIgdmFsdWVzIGZvciBib3RoIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICovXG4gIHN0YXRpYyBlcXVhbHMocGF0aEE6IFBhdGhOb2RlW10sIHBhdGhCOiBQYXRoTm9kZVtdLCBwYXJhbXNGbj86IEdldFBhcmFtc0ZuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBhdGhBLmxlbmd0aCA9PT0gcGF0aEIubGVuZ3RoICYmIFBhdGhVdGlscy5tYXRjaGluZyhwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKS5sZW5ndGggPT09IHBhdGhBLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzdWJwYXRoIG9mIGEgcGF0aCwgd2hpY2ggc3RvcHMgYXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGVcbiAgICpcbiAgICogR2l2ZW4gYW4gYXJyYXkgb2Ygbm9kZXMsIHJldHVybnMgYSBzdWJzZXQgb2YgdGhlIGFycmF5IHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IG5vZGUsXG4gICAqIHN0b3BwaW5nIHdoZW4gdGhlIGZpcnN0IG5vZGUgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggb2YgW1tQYXRoTm9kZV1dc1xuICAgKiBAcGFyYW0gcHJlZGljYXRlIGEgW1tQcmVkaWNhdGVdXSBmbiB0aGF0IG1hdGNoZXMgW1tQYXRoTm9kZV1dc1xuICAgKiBAcmV0dXJucyBhIHN1YnBhdGggdXAgdG8gdGhlIG1hdGNoaW5nIG5vZGUsIG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaCBpcyBmb3VuZFxuICAgKi9cbiAgc3RhdGljIHN1YlBhdGgocGF0aDogUGF0aE5vZGVbXSwgcHJlZGljYXRlOiBQcmVkaWNhdGU8UGF0aE5vZGU+KTogUGF0aE5vZGVbXSB7XG4gICAgY29uc3Qgbm9kZSA9IGZpbmQocGF0aCwgcHJlZGljYXRlKTtcbiAgICBjb25zdCBlbGVtZW50SWR4ID0gcGF0aC5pbmRleE9mKG5vZGUpO1xuICAgIHJldHVybiBlbGVtZW50SWR4ID09PSAtMSA/IHVuZGVmaW5lZCA6IHBhdGguc2xpY2UoMCwgZWxlbWVudElkeCArIDEpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJhdyBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gYSBwYXRoICovXG4gIHN0YXRpYyBwYXJhbVZhbHVlcyA9IChwYXRoOiBQYXRoTm9kZVtdKSA9PiBwYXRoLnJlZHVjZSgoYWNjLCBub2RlKSA9PiBleHRlbmQoYWNjLCBub2RlLnBhcmFtVmFsdWVzKSwge30pO1xufVxuIiwiLyoqXG4gKiAjIFRoZSBSZXNvbHZlIHN1YnN5c3RlbVxuICpcbiAqIFRoaXMgc3Vic3lzdGVtIGlzIGFuIGFzeW5jaHJvbm91cywgaGllcmFyY2hpY2FsIERlcGVuZGVuY3kgSW5qZWN0aW9uIHN5c3RlbS5cbiAqXG4gKiBUeXBpY2FsbHksIHJlc29sdmUgaXMgY29uZmlndXJlZCBvbiBhIHN0YXRlIHVzaW5nIGEgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBkZWNsYXJhdGlvbi5cbiAqXG4gKiBAcHVibGljYXBpIEBtb2R1bGUgcmVzb2x2ZVxuICovIC8qKiAqL1xuaW1wb3J0IHsgUmVzb2x2YWJsZSB9IGZyb20gJy4vcmVzb2x2YWJsZSc7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHdoaWNoIGlzIHNpbWlsYXIgdG8gYW4gQW5ndWxhciAyIGBQcm92aWRlcmBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm92aWRlckxpa2Uge1xuICBwcm92aWRlOiBhbnk7XG4gIHVzZUNsYXNzPzogYW55O1xuICB1c2VGYWN0b3J5PzogRnVuY3Rpb247XG4gIHVzZVZhbHVlPzogYW55O1xuICB1c2VFeGlzdGluZz86IGFueTtcbiAgZGVwcz86IGFueVtdO1xufVxuXG4vKipcbiAqIEEgcGxhaW4gb2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgYSBbW1Jlc29sdmFibGVdXVxuICpcbiAqIFRoZXNlIG9iamVjdHMgbWF5IGJlIHVzZWQgaW4gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gYXJyYXkgdG8gZGVjbGFyZVxuICogYXN5bmMgZGF0YSB0aGF0IHRoZSBzdGF0ZSBvciBzdWJzdGF0ZXMgcmVxdWlyZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICpcbiAqIHZhciBzdGF0ZSA9IHtcbiAqICAgbmFtZTogJ21haW4nLFxuICogICByZXNvbHZlOiBbXG4gKiAgICAgeyB0b2tlbjogJ215RGF0YScsIGRlcHM6IFtNeURhdGFBcGldLCByZXNvbHZlRm46IChteURhdGFBcGkpID0+IG15RGF0YUFwaS5nZXREYXRhKCkgfSxcbiAqICAgXSxcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc29sdmFibGVMaXRlcmFsIHtcbiAgLyoqXG4gICAqIEEgRGVwZW5kZW5jeSBJbmplY3Rpb24gdG9rZW5cbiAgICpcbiAgICogVGhpcyBSZXNvbHZhYmxlJ3MgREkgdG9rZW4uXG4gICAqIFRoZSBSZXNvbHZhYmxlIHdpbGwgYmUgaW5qZWN0YWJsZSBlbHNld2hlcmUgdXNpbmcgdGhlIHRva2VuLlxuICAgKi9cbiAgdG9rZW46IGFueTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB3aGljaCBmZXRjaGVzIHRoZSBSZXNvbHZhYmxlJ3MgZGF0YVxuICAgKlxuICAgKiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgb25lIG9mOlxuICAgKlxuICAgKiAtIFRoZSByZXNvbHZlZCB2YWx1ZSAoc3luY2hyb25vdXNseSlcbiAgICogLSBBIHByb21pc2UgZm9yIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgKiAtIEFuIE9ic2VydmFibGUgb2YgdGhlIHJlc29sdmVkIHZhbHVlKHMpXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBwcm92aWRlZCB0aGUgZGVwZW5kZW5jaWVzIGxpc3RlZCBpbiBbW2RlcHNdXSBhcyBpdHMgYXJndW1lbnRzLlxuICAgKiBUaGUgcmVzb2x2ZSBzeXN0ZW0gd2lsbCBhc3luY2hyb25vdXNseSBmZXRjaCB0aGUgZGVwZW5kZW5jaWVzIGJlZm9yZSBpbnZva2luZyB0aGlzIGZ1bmN0aW9uLlxuICAgKi9cbiAgcmVzb2x2ZUZuOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgUmVzb2x2ZSBQb2xpY3lcbiAgICpcbiAgICogQSBwb2xpY3kgdGhhdCBkZWZpbmVzIHdoZW4gdG8gaW52b2tlIHRoZSByZXNvbHZlLFxuICAgKiBhbmQgd2hldGhlciB0byB3YWl0IGZvciBhc3luYyBhbmQgdW53cmFwIHRoZSBkYXRhXG4gICAqL1xuICBwb2xpY3k/OiBSZXNvbHZlUG9saWN5O1xuXG4gIC8qKlxuICAgKiBUaGUgRGVwZW5kZW5jeSBJbmplY3Rpb24gdG9rZW5zXG4gICAqXG4gICAqIFRoaXMgaXMgYW4gYXJyYXkgb2YgRGVwZW5kZW5jeSBJbmplY3Rpb24gdG9rZW5zIGZvciB0aGUgZGVwZW5kZW5jaWVzIG9mIHRoZSBbW3Jlc29sdmVGbl1dLlxuICAgKlxuICAgKiBUaGUgREkgdG9rZW5zIGFyZSByZWZlcmVuY2VzIHRvIG90aGVyIGBSZXNvbHZhYmxlc2AsIG9yIHRvIG90aGVyXG4gICAqIHNlcnZpY2VzIGZyb20gdGhlIG5hdGl2ZSBESSBzeXN0ZW0uXG4gICAqL1xuICBkZXBzPzogYW55W107XG5cbiAgLyoqIFByZS1yZXNvbHZlZCBkYXRhLiAqL1xuICBkYXRhPzogYW55O1xufVxuXG4vKipcbiAqIERlZmluZXMgaG93IGEgcmVzb2x2ZSBpcyBwcm9jZXNzZWQgZHVyaW5nIGEgdHJhbnNpdGlvblxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIHRoZSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZVBvbGljeV1dIHByb3BlcnR5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBGZXRjaGVkIHdoZW4gdGhlIHJlc29sdmUncyBzdGF0ZSBpcyBiZWluZyBlbnRlcmVkLlxuICogLy8gV2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZS5cbiAqIHZhciBwb2xpY3kxID0geyB3aGVuOiBcIkxBWllcIiwgYXN5bmM6IFwiV0FJVFwiIH1cbiAqXG4gKiAvLyBGZXRjaGVkIHdoZW4gdGhlIFRyYW5zaXRpb24gaXMgc3RhcnRpbmcuXG4gKiAvLyBEbyBub3Qgd2FpdCBmb3IgdGhlIHJldHVybmVkIHByb21pc2UgdG8gcmVzb2x2ZS5cbiAqIC8vIEluamVjdCB0aGUgcmF3IHByb21pc2UvdmFsdWVcbiAqIHZhciBwb2xpY3kyID0geyB3aGVuOiBcIkVBR0VSXCIsIGFzeW5jOiBcIk5PV0FJVFwiIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBwb2xpY3kgZm9yIGEgZ2l2ZW4gUmVzb2x2YWJsZSBpcyBtZXJnZWQgZnJvbSB0aHJlZSBzb3VyY2VzIChoaWdoZXN0IHByaW9yaXR5IGZpcnN0KTpcbiAqXG4gKiAtIDEpIEluZGl2aWR1YWwgcmVzb2x2ZSBkZWZpbml0aW9uXG4gKiAtIDIpIFN0YXRlIGRlZmluaXRpb25cbiAqIC0gMykgR2xvYmFsIGRlZmF1bHRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogLy8gV2FpdCBmb3IgYW4gT2JzZXJ2YWJsZSB0byBlbWl0IG9uZSBpdGVtLlxuICogLy8gU2luY2UgYHdhaXRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0IHVzZXMgdGhlIGB3YWl0YFxuICogLy8gcG9saWN5IGRlZmluZWQgb24gdGhlIHN0YXRlLCBvciB0aGUgZ2xvYmFsIGRlZmF1bHRcbiAqIC8vIGlmIG5vIGB3YWl0YCBwb2xpY3kgaXMgZGVmaW5lZCBvbiB0aGUgc3RhdGVcbiAqIGltcG9ydCB7IFJYV0FJVCB9IGZyb20gJ0B1aXJvdXRlci9yeCc7XG4gKlxuICogdmFyIG15UmVzb2x2YWJsZVBvbGljeSA9IHsgYXN5bmM6IFJYV0FJVCB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlUG9saWN5IHtcbiAgLyoqXG4gICAqIERlZmluZXMgd2hlbiBhIFJlc29sdmFibGUgaXMgcmVzb2x2ZWQgKGZldGNoZWQpIGR1cmluZyBhIHRyYW5zaXRpb25cbiAgICpcbiAgICogLSBgTEFaWWAgKGRlZmF1bHQpXG4gICAqICAgLSBSZXNvbHZlZCBhcyB0aGUgcmVzb2x2ZSdzIHN0YXRlIGlzIGJlaW5nIGVudGVyZWRcbiAgICogLSBgRUFHRVJgXG4gICAqICAgLSBSZXNvbHZlZCBhcyB0aGUgdHJhbnNpdGlvbiBpcyBzdGFydGluZ1xuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFJlc29sdmVzIGZvciBgbWFpbmAgYW5kIGBtYWluLmhvbWVgIGFyZSBmZXRjaGVkIHdoZW4gZWFjaCBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiBBbGwgb2YgYG1haW5gIHJlc29sdmVzIGFyZSBwcm9jZXNzZWQgYmVmb3JlIGZldGNoaW5nIGBtYWluLmhvbWVgIHJlc29sdmVzLlxuICAgKiBgYGBqc1xuICAgKiB2YXIgc3RhdGUgPSB7XG4gICAqICAgbmFtZTogJ21haW4nLFxuICAgKiAgIHJlc29sdmU6IG1haW5SZXNvbHZlcywgLy8gZGVmaW5lZCBlbHNld2hlcmVcbiAgICogICByZXNvbHZlUG9saWN5OiB7IHdoZW46ICdMQVpZJyB9LCAvLyBkZWZhdWx0XG4gICAqIH1cbiAgICpcbiAgICogdmFyIHN0YXRlID0ge1xuICAgKiAgIG5hbWU6ICdtYWluLmhvbWUnLFxuICAgKiAgIHJlc29sdmU6IGhvbWVSZXNvbHZlcywgLy8gZGVmaW5lZCBlbHNld2hlcmVcbiAgICogICByZXNvbHZlUG9saWN5OiB7IHdoZW46ICdMQVpZJyB9LCAvLyBkZWZhdWx0XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogUmVzb2x2ZXMgZm9yIGBtYWluYCBhbmQgYG1haW4uaG9tZWAgYXJlIGZldGNoZWQgYXQgdGhlIHNhbWUgdGltZSB3aGVuIHRoZSB0cmFuc2l0aW9uIHN0YXJ0cy5cbiAgICogVGhpcyBoYXBwZW5zIGVhcmxpZXIgaW4gdGhlIGxpZmVjeWNsZSB0aGFuIHdoZW4gc3RhdGVzIGFyZSBlbnRlcmVkLlxuICAgKiBBbGwgb2YgdGhlIGBtYWluYCBhbmQgYG1haW4uaG9tZWAgcmVzb2x2ZXMgYXJlIGZldGNoZWQgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAgICogYGBganNcbiAgICogdmFyIG1haW5TdGF0ZSA9IHtcbiAgICogICBuYW1lOiAnbWFpbicsXG4gICAqICAgcmVzb2x2ZTogbWFpblJlc29sdmVzLCAvLyBkZWZpbmVkIGVsc2V3aGVyZVxuICAgKiAgIHJlc29sdmVQb2xpY3k6IHsgd2hlbjogJ0VBR0VSJyB9LFxuICAgKiB9XG4gICAqXG4gICAqIHZhciBob21lU3RhdGUgPSB7XG4gICAqICAgbmFtZTogJ21haW4uaG9tZScsXG4gICAqICAgcmVzb2x2ZTogaG9tZVJlc29sdmVzLCAvLyBkZWZpbmVkIGVsc2V3aGVyZVxuICAgKiAgIHJlc29sdmVQb2xpY3k6IHsgd2hlbjogJ0VBR0VSJyB9LFxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgd2hlbj86IFBvbGljeVdoZW47XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHVud3JhcHBpbmcgYmVoYXZpb3Igb2YgYXN5bmNocm9ub3VzIHJlc29sdmUgdmFsdWVzLlxuICAgKlxuICAgKiAtIGBXQUlUYCAoZGVmYXVsdClcbiAgICogICAtIElmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCBmcm9tIHRoZSByZXNvbHZlRm4sIHdhaXQgZm9yIHRoZSBwcm9taXNlIGJlZm9yZSBwcm9jZWVkaW5nXG4gICAqICAgLSBUaGUgdW53cmFwcGVkIHZhbHVlIGZyb20gdGhlIHByb21pc2VcbiAgICogLSBgTk9XQUlUYFxuICAgKiAgIC0gSWYgYSBwcm9taXNlIGlzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmUsIGRvIG5vdCB3YWl0IGZvciB0aGUgcHJvbWlzZS5cbiAgICogICAtIEFueSBvdGhlciB2YWx1ZSByZXR1cm5lZCBpcyB3cmFwcGVkIGluIGEgcHJvbWlzZS5cbiAgICogICAtIFRoZSBwcm9taXNlIHdpbGwgbm90IGJlIHVud3JhcHBlZC5cbiAgICogICAtIFRoZSBwcm9taXNlIGl0c2VsZiB3aWxsIGJlIHByb3ZpZGVkIHdoZW4gdGhlIHJlc29sdmUgaXMgaW5qZWN0ZWQgb3IgYm91bmQgZWxzZXdoZXJlLlxuICAgKiAtIHtAbGluayBDdXN0b21Bc3luY1BvbGljeX1cbiAgICogICAtIFlvdSBjYW4gZGVmaW5lIGEgY3VzdG9tIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzb2x2ZUZuIHZhbHVlLlxuICAgKiAgIC0gVGhpcyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHByb21pc2UuXG4gICAqICAgLSBUaGUgdHJhbnNpdGlvbiB3aWxsIHdhaXQgZm9yIHRoaXMgcHJvbWlzZSBiZWZvcmUgcHJvY2VlZGluZ1xuICAgKlxuICAgKiAgIE5PVEU6IFRoZSBwcmV2aW91cyBgUlhXQUlUYCBwb2xpY3kgaGFzIGJlY29tZSBhIEN1c3RvbUFzeW5jUG9saWN5IGZ1bmN0aW9uIGV4cG9ydGVkIGluIGBAdWlyb3V0ZXIvcnhgIHBhY2thZ2UuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogVGhlIGBUcmFuc2l0aW9uYCB3aWxsIG5vdCB3YWl0IGZvciB0aGUgcmVzb2x2ZSBwcm9taXNlKHMpIGZyb20gYG1haW5gIHRvIHNldHRsZSBiZWZvcmUgY29udGludWluZy5cbiAgICogUmVzb2x2ZXMgZm9yIGBtYWluYCB3aWxsIGJlIHByb3ZpZGVkIHRvIGNvbXBvbmVudHMgd3JhcHBlZCBpbiBhIGBQcm9taXNlYC5cbiAgICpcbiAgICogVGhlIGBUcmFuc2l0aW9uYCB3aWxsIHdhaXQgZm9yIHRoZSBgbWFpbi5ob21lYCByZXNvbHZlIHByb21pc2VzLlxuICAgKiBSZXNvbHZlZCB2YWx1ZXMgd2lsbCBiZSB1bndyYXBwZWQgYmVmb3JlIGJlaW5nIHByb3ZpZGVkIHRvIGNvbXBvbmVudHMuXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYWluU3RhdGUgPSB7XG4gICAqICAgbmFtZTogJ21haW4nLFxuICAgKiAgIHJlc29sdmU6IG1haW5SZXNvbHZlcywgLy8gZGVmaW5lZCBlbHNld2hlcmVcbiAgICogICByZXNvbHZlUG9saWN5OiB7IGFzeW5jOiAnTk9XQUlUJyB9LFxuICAgKiB9XG4gICAqIHZhciBob21lU3RhdGUgPSB7XG4gICAqICAgbmFtZTogJ21haW4uaG9tZScsXG4gICAqICAgcmVzb2x2ZTogaG9tZVJlc29sdmVzLCAvLyBkZWZpbmVkIGVsc2V3aGVyZVxuICAgKiAgIHJlc29sdmVQb2xpY3k6IHsgYXN5bmM6ICdXQUlUJyB9LCAvLyBkZWZhdWx0XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYz86IFBvbGljeUFzeW5jO1xufVxuXG5leHBvcnQgdHlwZSBQb2xpY3lXaGVuID0gJ0xBWlknIHwgJ0VBR0VSJztcbmV4cG9ydCB0eXBlIFBvbGljeUFzeW5jID0gJ1dBSVQnIHwgJ05PV0FJVCcgfCBDdXN0b21Bc3luY1BvbGljeTtcbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tQXN5bmNQb2xpY3kge1xuICAoZGF0YTogYW55KTogUHJvbWlzZTxhbnk+O1xufVxuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgbGV0IHJlc29sdmVQb2xpY2llcyA9IHtcbiAgd2hlbjoge1xuICAgIExBWlk6ICdMQVpZJyxcbiAgICBFQUdFUjogJ0VBR0VSJyxcbiAgfSxcbiAgYXN5bmM6IHtcbiAgICBXQUlUOiAnV0FJVCcsXG4gICAgTk9XQUlUOiAnTk9XQUlUJyxcbiAgfSxcbn07XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHJlc29sdmUgKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIGlkZW50aXR5IH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tICcuLi9jb21tb24vdHJhY2UnO1xuaW1wb3J0IHsgUmVzb2x2ZVBvbGljeSwgUmVzb2x2YWJsZUxpdGVyYWwsIFBvbGljeUFzeW5jIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBSZXNvbHZlQ29udGV4dCB9IGZyb20gJy4vcmVzb2x2ZUNvbnRleHQnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZ3MnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNPYmplY3QgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuXG4vLyBUT0RPOiBleHBsaWNpdGx5IG1ha2UgdGhpcyB1c2VyIGNvbmZpZ3VyYWJsZVxuZXhwb3J0IGxldCBkZWZhdWx0UmVzb2x2ZVBvbGljeTogUmVzb2x2ZVBvbGljeSA9IHtcbiAgd2hlbjogJ0xBWlknLFxuICBhc3luYzogJ1dBSVQnLFxufTtcblxuLyoqXG4gKiBUaGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgZm9yIHRoZSByZXNvbHZlIHN5c3RlbS5cbiAqXG4gKiBSZXNvbHZhYmxlcyBlbmNhcHN1bGF0ZSBhIHN0YXRlJ3MgcmVzb2x2ZSdzIHJlc29sdmVGbiwgdGhlIHJlc29sdmVGbidzIGRlY2xhcmVkIGRlcGVuZGVuY2llcywgdGhlIHdyYXBwZWQgKC5wcm9taXNlKSxcbiAqIGFuZCB0aGUgdW53cmFwcGVkLXdoZW4tY29tcGxldGUgKC5kYXRhKSByZXN1bHQgb2YgdGhlIHJlc29sdmVGbi5cbiAqXG4gKiBSZXNvbHZhYmxlLmdldCgpIGVpdGhlciByZXRyaWV2ZXMgdGhlIFJlc29sdmFibGUncyBleGlzdGluZyBwcm9taXNlLCBvciBlbHNlIGludm9rZXMgcmVzb2x2ZSgpICh3aGljaCBpbnZva2VzIHRoZVxuICogcmVzb2x2ZUZuKSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHByb21pc2UuXG4gKlxuICogUmVzb2x2YWJsZS5nZXQoKSBhbmQgUmVzb2x2YWJsZS5yZXNvbHZlKCkgYm90aCBleGVjdXRlIHdpdGhpbiBhIGNvbnRleHQgcGF0aCwgd2hpY2ggaXMgcGFzc2VkIGFzIHRoZSBmaXJzdFxuICogcGFyYW1ldGVyIHRvIHRob3NlIGZucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc29sdmFibGUgaW1wbGVtZW50cyBSZXNvbHZhYmxlTGl0ZXJhbCB7XG4gIHRva2VuOiBhbnk7XG4gIHBvbGljeTogUmVzb2x2ZVBvbGljeTtcbiAgcmVzb2x2ZUZuOiBGdW5jdGlvbjtcbiAgZGVwczogYW55W107XG5cbiAgZGF0YTogYW55O1xuICByZXNvbHZlZCA9IGZhbHNlO1xuICBwcm9taXNlOiBQcm9taXNlPGFueT4gPSB1bmRlZmluZWQ7XG5cbiAgc3RhdGljIGZyb21EYXRhID0gKHRva2VuOiBhbnksIGRhdGE6IGFueSkgPT4gbmV3IFJlc29sdmFibGUodG9rZW4sICgpID0+IGRhdGEsIG51bGwsIG51bGwsIGRhdGEpO1xuXG4gIC8qKiBUaGlzIGNvbnN0cnVjdG9yIGNyZWF0ZXMgYSBSZXNvbHZhYmxlIGNvcHkgKi9cbiAgY29uc3RydWN0b3IocmVzb2x2YWJsZTogUmVzb2x2YWJsZSk7XG5cbiAgLyoqIFRoaXMgY29uc3RydWN0b3IgY3JlYXRlcyBhIG5ldyBSZXNvbHZhYmxlIGZyb20gdGhlIHBsYWluIG9sZCBbW1Jlc29sdmFibGVMaXRlcmFsXV0gamF2YXNjcmlwdCBvYmplY3QgKi9cbiAgY29uc3RydWN0b3IocmVzb2x2YWJsZTogUmVzb2x2YWJsZUxpdGVyYWwpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGNvbnN0cnVjdG9yIGNyZWF0ZXMgYSBuZXcgYFJlc29sdmFibGVgXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHJlc29sdmFibGUxID0gbmV3IFJlc29sdmFibGUoJ215dG9rZW4nLCBodHRwID0+IGh0dHAuZ2V0KCdmb28uanNvbicpLnRvUHJvbWlzZSgpLCBbSHR0cF0pO1xuICAgKlxuICAgKiB2YXIgcmVzb2x2YWJsZTIgPSBuZXcgUmVzb2x2YWJsZShVc2VyU2VydmljZSwgZGVwID0+IG5ldyBVc2VyU2VydmljZShkZXAuZGF0YSksIFtTb21lRGVwZW5kZW5jeV0pO1xuICAgKlxuICAgKiB2YXIgcmVzb2x2YWJsZTFDbG9uZSA9IG5ldyBSZXNvbHZhYmxlKHJlc29sdmFibGUxKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbiBUaGUgbmV3IHJlc29sdmFibGUncyBpbmplY3Rpb24gdG9rZW4sIHN1Y2ggYXMgYFwidXNlckxpc3RcImAgKGEgc3RyaW5nKSBvciBgVXNlclNlcnZpY2VgIChhIGNsYXNzKS5cbiAgICogICAgICAgICAgICAgIFdoZW4gdGhpcyB0b2tlbiBpcyB1c2VkIGR1cmluZyBpbmplY3Rpb24sIHRoZSByZXNvbHZlZCB2YWx1ZSB3aWxsIGJlIGluamVjdGVkLlxuICAgKiBAcGFyYW0gcmVzb2x2ZUZuIFRoZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLCBvciBhIHByb21pc2UgZm9yIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgKiBAcGFyYW0gZGVwcyBBbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMsIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgYHJlc29sdmVGbmBcbiAgICogQHBhcmFtIHBvbGljeSB0aGUgW1tSZXNvbHZlUG9saWN5XV0gZGVmaW5lcyB3aGVuIGFuZCBob3cgdGhlIFJlc29sdmFibGUgaXMgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBkYXRhIFByZS1yZXNvbHZlZCBkYXRhLiBJZiB0aGUgcmVzb2x2ZSB2YWx1ZSBpcyBhbHJlYWR5IGtub3duLCBpdCBtYXkgYmUgcHJvdmlkZWQgaGVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRva2VuOiBhbnksIHJlc29sdmVGbjogRnVuY3Rpb24sIGRlcHM/OiBhbnlbXSwgcG9saWN5PzogUmVzb2x2ZVBvbGljeSwgZGF0YT86IGFueSk7XG4gIGNvbnN0cnVjdG9yKGFyZzE6IGFueSwgcmVzb2x2ZUZuPzogRnVuY3Rpb24sIGRlcHM/OiBhbnlbXSwgcG9saWN5PzogUmVzb2x2ZVBvbGljeSwgZGF0YT86IGFueSkge1xuICAgIGlmIChhcmcxIGluc3RhbmNlb2YgUmVzb2x2YWJsZSkge1xuICAgICAgZXh0ZW5kKHRoaXMsIGFyZzEpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyZXNvbHZlRm4pKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoYXJnMSkpIHRocm93IG5ldyBFcnJvcignbmV3IFJlc29sdmFibGUoKTogdG9rZW4gYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgIGlmICghaXNGdW5jdGlvbihyZXNvbHZlRm4pKSB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSZXNvbHZhYmxlKCk6IHJlc29sdmVGbiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgdGhpcy50b2tlbiA9IGFyZzE7XG4gICAgICB0aGlzLnBvbGljeSA9IHBvbGljeTtcbiAgICAgIHRoaXMucmVzb2x2ZUZuID0gcmVzb2x2ZUZuO1xuICAgICAgdGhpcy5kZXBzID0gZGVwcyB8fCBbXTtcblxuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMucmVzb2x2ZWQgPSBkYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnJlc29sdmVkID8gc2VydmljZXMuJHEud2hlbih0aGlzLmRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoYXJnMSkgJiYgYXJnMS50b2tlbiAmJiAoYXJnMS5oYXNPd25Qcm9wZXJ0eSgncmVzb2x2ZUZuJykgfHwgYXJnMS5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSkge1xuICAgICAgY29uc3QgbGl0ZXJhbCA9IDxSZXNvbHZhYmxlTGl0ZXJhbD5hcmcxO1xuICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKGxpdGVyYWwudG9rZW4sIGxpdGVyYWwucmVzb2x2ZUZuLCBsaXRlcmFsLmRlcHMsIGxpdGVyYWwucG9saWN5LCBsaXRlcmFsLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBvbGljeShzdGF0ZTogU3RhdGVPYmplY3QpOiBSZXNvbHZlUG9saWN5IHtcbiAgICBjb25zdCB0aGlzUG9saWN5ID0gdGhpcy5wb2xpY3kgfHwge307XG4gICAgY29uc3Qgc3RhdGVQb2xpY3kgPSAoc3RhdGUgJiYgc3RhdGUucmVzb2x2ZVBvbGljeSkgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgIHdoZW46IHRoaXNQb2xpY3kud2hlbiB8fCBzdGF0ZVBvbGljeS53aGVuIHx8IGRlZmF1bHRSZXNvbHZlUG9saWN5LndoZW4sXG4gICAgICBhc3luYzogdGhpc1BvbGljeS5hc3luYyB8fCBzdGF0ZVBvbGljeS5hc3luYyB8fCBkZWZhdWx0UmVzb2x2ZVBvbGljeS5hc3luYyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IHJlc29sdmUgdGhpcyBSZXNvbHZhYmxlJ3MgZGF0YVxuICAgKlxuICAgKiBHaXZlbiBhIFJlc29sdmVDb250ZXh0IHRoYXQgdGhpcyBSZXNvbHZhYmxlIGlzIGZvdW5kIGluOlxuICAgKiBXYWl0IGZvciB0aGlzIFJlc29sdmFibGUncyBkZXBlbmRlbmNpZXMsIHRoZW4gaW52b2tlIHRoaXMgUmVzb2x2YWJsZSdzIGZ1bmN0aW9uXG4gICAqIGFuZCB1cGRhdGUgdGhlIFJlc29sdmFibGUncyBzdGF0ZVxuICAgKi9cbiAgcmVzb2x2ZShyZXNvbHZlQ29udGV4dDogUmVzb2x2ZUNvbnRleHQsIHRyYW5zPzogVHJhbnNpdGlvbikge1xuICAgIGNvbnN0ICRxID0gc2VydmljZXMuJHE7XG5cbiAgICAvLyBHZXRzIGFsbCBkZXBlbmRlbmNpZXMgZnJvbSBSZXNvbHZlQ29udGV4dCBhbmQgd2FpdCBmb3IgdGhlbSB0byBiZSByZXNvbHZlZFxuICAgIGNvbnN0IGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMgPSAoKSA9PlxuICAgICAgJHEuYWxsKHJlc29sdmVDb250ZXh0LmdldERlcGVuZGVuY2llcyh0aGlzKS5tYXAocmVzb2x2YWJsZSA9PiByZXNvbHZhYmxlLmdldChyZXNvbHZlQ29udGV4dCwgdHJhbnMpKSkgYXMgUHJvbWlzZTxcbiAgICAgICAgYW55W11cbiAgICAgID47XG5cbiAgICAvLyBJbnZva2VzIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyBhcyBhcmd1bWVudHNcbiAgICBjb25zdCBpbnZva2VSZXNvbHZlRm4gPSAocmVzb2x2ZWREZXBzOiBhbnlbXSkgPT4gdGhpcy5yZXNvbHZlRm4uYXBwbHkobnVsbCwgcmVzb2x2ZWREZXBzKTtcbiAgICBjb25zdCBub2RlOiBQYXRoTm9kZSA9IHJlc29sdmVDb250ZXh0LmZpbmROb2RlKHRoaXMpO1xuICAgIGNvbnN0IHN0YXRlOiBTdGF0ZU9iamVjdCA9IG5vZGUgJiYgbm9kZS5zdGF0ZTtcblxuICAgIGNvbnN0IGFzeW5jUG9saWN5OiBQb2xpY3lBc3luYyA9IHRoaXMuZ2V0UG9saWN5KHN0YXRlKS5hc3luYztcbiAgICBjb25zdCBjdXN0b21Bc3luY1BvbGljeSA9IGlzRnVuY3Rpb24oYXN5bmNQb2xpY3kpID8gYXN5bmNQb2xpY3kgOiBpZGVudGl0eTtcblxuICAgIC8vIEFmdGVyIHRoZSBmaW5hbCB2YWx1ZSBoYXMgYmVlbiByZXNvbHZlZCwgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgUmVzb2x2YWJsZVxuICAgIGNvbnN0IGFwcGx5UmVzb2x2ZWRWYWx1ZSA9IChyZXNvbHZlZFZhbHVlOiBhbnkpID0+IHtcbiAgICAgIHRoaXMuZGF0YSA9IHJlc29sdmVkVmFsdWU7XG4gICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzb2x2ZUZuID0gbnVsbDtcbiAgICAgIHRyYWNlLnRyYWNlUmVzb2x2YWJsZVJlc29sdmVkKHRoaXMsIHRyYW5zKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcblxuICAgIC8vIFNldHMgdGhlIHByb21pc2UgcHJvcGVydHkgZmlyc3QsIHRoZW4gZ2V0c1Jlc29sdmFibGVEZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb21pc2UgY2hhaW4uIEFsd2F5cyB3YWl0cyBvbmUgdGljay5cbiAgICByZXR1cm4gKHRoaXMucHJvbWlzZSA9ICRxXG4gICAgICAud2hlbigpXG4gICAgICAudGhlbihnZXRSZXNvbHZhYmxlRGVwZW5kZW5jaWVzKVxuICAgICAgLnRoZW4oaW52b2tlUmVzb2x2ZUZuKVxuICAgICAgLnRoZW4oY3VzdG9tQXN5bmNQb2xpY3kpXG4gICAgICAudGhlbihhcHBseVJlc29sdmVkVmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcHJvbWlzZSBmb3IgdGhpcyBSZXNvbHZhYmxlJ3MgZGF0YS5cbiAgICpcbiAgICogRmV0Y2hlcyB0aGUgZGF0YSBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAqIFJldHVybnMgdGhlIGV4aXN0aW5nIHByb21pc2UgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBmZXRjaGVkIG9uY2UuXG4gICAqL1xuICBnZXQocmVzb2x2ZUNvbnRleHQ6IFJlc29sdmVDb250ZXh0LCB0cmFucz86IFRyYW5zaXRpb24pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnByb21pc2UgfHwgdGhpcy5yZXNvbHZlKHJlc29sdmVDb250ZXh0LCB0cmFucyk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFJlc29sdmFibGUodG9rZW46ICR7c3RyaW5naWZ5KHRoaXMudG9rZW4pfSwgcmVxdWlyZXM6IFske3RoaXMuZGVwcy5tYXAoc3RyaW5naWZ5KX1dKWA7XG4gIH1cblxuICBjbG9uZSgpOiBSZXNvbHZhYmxlIHtcbiAgICByZXR1cm4gbmV3IFJlc29sdmFibGUodGhpcyk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgcmVzb2x2ZSAqLyAvKiogKi9cbmltcG9ydCB7IGZpbmQsIHRhaWwsIHVuaXFSLCB1bm5lc3RSLCBpbkFycmF5IH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBwcm9wRXEsIG5vdCB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tICcuLi9jb21tb24vdHJhY2UnO1xuaW1wb3J0IHsgc2VydmljZXMsICRJbmplY3Rvckxpa2UgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IHJlc29sdmVQb2xpY2llcywgUG9saWN5V2hlbiwgUmVzb2x2ZVBvbGljeSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5pbXBvcnQgeyBSZXNvbHZhYmxlIH0gZnJvbSAnLi9yZXNvbHZhYmxlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgUGF0aFV0aWxzIH0gZnJvbSAnLi4vcGF0aC9wYXRoVXRpbHMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZ3MnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBVSUluamVjdG9yIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uJztcblxuY29uc3Qgd2hlbnMgPSByZXNvbHZlUG9saWNpZXMud2hlbjtcbmNvbnN0IEFMTF9XSEVOUyA9IFt3aGVucy5FQUdFUiwgd2hlbnMuTEFaWV07XG5jb25zdCBFQUdFUl9XSEVOUyA9IFt3aGVucy5FQUdFUl07XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmZlcnJhYmxlLXR5cGVzXG5leHBvcnQgY29uc3QgTkFUSVZFX0lOSkVDVE9SX1RPS0VOOiBzdHJpbmcgPSAnTmF0aXZlIEluamVjdG9yJztcblxuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgRGVwZW5kZW5jeSBJbmplY3Rpb24gZm9yIGEgcGF0aCBvZiBub2Rlc1xuICpcbiAqIFVJLVJvdXRlciBzdGF0ZXMgYXJlIG9yZ2FuaXplZCBhcyBhIHRyZWUuXG4gKiBBIG5lc3RlZCBzdGF0ZSBoYXMgYSBwYXRoIG9mIGFuY2VzdG9ycyB0byB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAqIFdoZW4gYSBzdGF0ZSBpcyBiZWluZyBhY3RpdmF0ZWQsIGVhY2ggZWxlbWVudCBpbiB0aGUgcGF0aCBpcyB3cmFwcGVkIGFzIGEgW1tQYXRoTm9kZV1dLlxuICogQSBgUGF0aE5vZGVgIGlzIGEgc3RhdGVmdWwgb2JqZWN0IHRoYXQgaG9sZHMgdGhpbmdzIGxpa2UgcGFyYW1ldGVycyBhbmQgcmVzb2x2YWJsZXMgZm9yIHRoZSBzdGF0ZSBiZWluZyBhY3RpdmF0ZWQuXG4gKlxuICogVGhlIFJlc29sdmVDb250ZXh0IGNsb3NlcyBvdmVyIHRoZSBbW1BhdGhOb2RlXV1zLCBhbmQgcHJvdmlkZXMgREkgZm9yIHRoZSBsYXN0IG5vZGUgaW4gdGhlIHBhdGguXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNvbHZlQ29udGV4dCB7XG4gIF9pbmplY3RvcjogVUlJbmplY3RvcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXRoOiBQYXRoTm9kZVtdKSB7fVxuXG4gIC8qKiBHZXRzIGFsbCB0aGUgdG9rZW5zIGZvdW5kIGluIHRoZSByZXNvbHZlIGNvbnRleHQsIGRlLWR1cGxpY2F0ZWQgKi9cbiAgZ2V0VG9rZW5zKCk6IGFueVtdIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aC5yZWR1Y2UoKGFjYywgbm9kZSkgPT4gYWNjLmNvbmNhdChub2RlLnJlc29sdmFibGVzLm1hcChyID0+IHIudG9rZW4pKSwgW10pLnJlZHVjZSh1bmlxUiwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlblxuICAgKlxuICAgKiBHZXRzIHRoZSBsYXN0IFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlbiBpbiB0aGlzIGNvbnRleHQsIG9yIHVuZGVmaW5lZC5cbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIFJlc29sdmVDb250ZXh0XG4gICAqL1xuICBnZXRSZXNvbHZhYmxlKHRva2VuOiBhbnkpOiBSZXNvbHZhYmxlIHtcbiAgICBjb25zdCBtYXRjaGluZyA9IHRoaXMuX3BhdGhcbiAgICAgIC5tYXAobm9kZSA9PiBub2RlLnJlc29sdmFibGVzKVxuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgIC5maWx0ZXIoKHI6IFJlc29sdmFibGUpID0+IHIudG9rZW4gPT09IHRva2VuKTtcbiAgICByZXR1cm4gdGFpbChtYXRjaGluZyk7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgW1tSZXNvbHZlUG9saWN5XV0gZm9yIHRoZSBnaXZlbiBbW1Jlc29sdmFibGVdXSAqL1xuICBnZXRQb2xpY3kocmVzb2x2YWJsZTogUmVzb2x2YWJsZSk6IFJlc29sdmVQb2xpY3kge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmROb2RlKHJlc29sdmFibGUpO1xuICAgIHJldHVybiByZXNvbHZhYmxlLmdldFBvbGljeShub2RlLnN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgUmVzb2x2ZUNvbnRleHQgdGhhdCBpbmNsdWRlcyBhIHBvcnRpb24gb2YgdGhpcyBvbmVcbiAgICpcbiAgICogR2l2ZW4gYSBzdGF0ZSwgdGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBSZXNvbHZlQ29udGV4dCBmcm9tIHRoaXMgb25lLlxuICAgKiBUaGUgbmV3IGNvbnRleHQgc3RhcnRzIGF0IHRoZSBmaXJzdCBub2RlIChyb290KSBhbmQgc3RvcHMgYXQgdGhlIG5vZGUgZm9yIHRoZSBgc3RhdGVgIHBhcmFtZXRlci5cbiAgICpcbiAgICogIyMjIyBXaHlcbiAgICpcbiAgICogV2hlbiBhIHRyYW5zaXRpb24gaXMgY3JlYXRlZCwgdGhlIG5vZGVzIGluIHRoZSBcIlRvIFBhdGhcIiBhcmUgaW5qZWN0ZWQgZnJvbSBhIFJlc29sdmVDb250ZXh0LlxuICAgKiBBIFJlc29sdmVDb250ZXh0IGNsb3NlcyBvdmVyIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGFuZCBwcm9jZXNzZXMgdGhlIHJlc29sdmFibGVzLlxuICAgKiBUaGUgXCJUbyBTdGF0ZVwiIGNhbiBpbmplY3QgdmFsdWVzIGZyb20gaXRzIG93biByZXNvbHZhYmxlcywgYXMgd2VsbCBhcyB0aG9zZSBmcm9tIGFsbCBpdHMgYW5jZXN0b3Igc3RhdGUncyAobm9kZSdzKS5cbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgYSBuYXJyb3dlciBjb250ZXh0IHdoZW4gaW5qZWN0aW5nIGFuY2VzdG9yIG5vZGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgbGV0IEFCQ0QgPSBuZXcgUmVzb2x2ZUNvbnRleHQoW0EsIEIsIEMsIERdKTtgXG4gICAqXG4gICAqIEdpdmVuIGEgcGF0aCBgW0EsIEIsIEMsIERdYCwgd2hlcmUgYEFgLCBgQmAsIGBDYCBhbmQgYERgIGFyZSBub2RlcyBmb3Igc3RhdGVzIGBhYCwgYGJgLCBgY2AsIGBkYDpcbiAgICogV2hlbiBpbmplY3RpbmcgYERgLCBgRGAgc2hvdWxkIGhhdmUgYWNjZXNzIHRvIGFsbCByZXNvbHZhYmxlcyBmcm9tIGBBYCwgYEJgLCBgQ2AsIGBEYC5cbiAgICogSG93ZXZlciwgYEJgIHNob3VsZCBvbmx5IGJlIGFibGUgdG8gYWNjZXNzIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAuXG4gICAqXG4gICAqIFdoZW4gcmVzb2x2aW5nIGZvciB0aGUgYEJgIG5vZGUsIGZpcnN0IHRha2UgdGhlIGZ1bGwgXCJUbyBQYXRoXCIgQ29udGV4dCBgW0EsQixDLERdYCBhbmQgbGltaXQgdG8gdGhlIHN1YnBhdGggYFtBLEJdYC5cbiAgICogYGxldCBBQiA9IEFCQ0Quc3ViY29udGV4dChhKWBcbiAgICovXG4gIHN1YkNvbnRleHQoc3RhdGU6IFN0YXRlT2JqZWN0KTogUmVzb2x2ZUNvbnRleHQge1xuICAgIHJldHVybiBuZXcgUmVzb2x2ZUNvbnRleHQoUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgbm9kZSA9PiBub2RlLnN0YXRlID09PSBzdGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgUmVzb2x2YWJsZXMgdG8gdGhlIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBzdGF0ZVxuICAgKlxuICAgKiBUaGlzIGFkZHMgYSBbW1Jlc29sdmFibGVdXSAoZ2VuZXJhbGx5IG9uZSBjcmVhdGVkIG9uIHRoZSBmbHk7IG5vdCBkZWNsYXJlZCBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gYmxvY2spLlxuICAgKiBUaGUgcmVzb2x2YWJsZSBpcyBhZGRlZCB0byB0aGUgbm9kZSBtYXRjaGluZyB0aGUgYHN0YXRlYCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIFRoZXNlIG5ldyByZXNvbHZhYmxlcyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgZmV0Y2hlZC5cbiAgICogVGhlIGNhbGxpbmcgY29kZSBzaG91bGQgZWl0aGVyIGZldGNoIHRoZW0sIGZldGNoIHNvbWV0aGluZyB0aGF0IGRlcGVuZHMgb24gdGhlbSxcbiAgICogb3IgcmVseSBvbiBbW3Jlc29sdmVQYXRoXV0gYmVpbmcgY2FsbGVkIHdoZW4gc29tZSBzdGF0ZSBpcyBiZWluZyBlbnRlcmVkLlxuICAgKlxuICAgKiBOb3RlOiBlYWNoIHJlc29sdmFibGUncyBbW1Jlc29sdmVQb2xpY3ldXSBpcyBtZXJnZWQgd2l0aCB0aGUgc3RhdGUncyBwb2xpY3ksIGFuZCB0aGUgZ2xvYmFsIGRlZmF1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBuZXdSZXNvbHZhYmxlcyB0aGUgbmV3IFJlc29sdmFibGVzXG4gICAqIEBwYXJhbSBzdGF0ZSBVc2VkIHRvIGZpbmQgdGhlIG5vZGUgdG8gcHV0IHRoZSByZXNvbHZhYmxlIG9uXG4gICAqL1xuICBhZGRSZXNvbHZhYmxlcyhuZXdSZXNvbHZhYmxlczogUmVzb2x2YWJsZVtdLCBzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICBjb25zdCBub2RlID0gPFBhdGhOb2RlPmZpbmQodGhpcy5fcGF0aCwgcHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgY29uc3Qga2V5cyA9IG5ld1Jlc29sdmFibGVzLm1hcChyID0+IHIudG9rZW4pO1xuICAgIG5vZGUucmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLmZpbHRlcihyID0+IGtleXMuaW5kZXhPZihyLnRva2VuKSA9PT0gLTEpLmNvbmNhdChuZXdSZXNvbHZhYmxlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHJlc29sdmVkIHBhdGggRWxlbWVudCBwcm9taXNlc1xuICAgKlxuICAgKiBAcGFyYW0gd2hlblxuICAgKiBAcGFyYW0gdHJhbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pnxhbnl9XG4gICAqL1xuICByZXNvbHZlUGF0aCh3aGVuOiBQb2xpY3lXaGVuID0gJ0xBWlknLCB0cmFucz86IFRyYW5zaXRpb24pOiBQcm9taXNlPHsgdG9rZW46IGFueTsgdmFsdWU6IGFueSB9W10+IHtcbiAgICAvLyBUaGlzIG9wdGlvbiBkZXRlcm1pbmVzIHdoaWNoICd3aGVuJyBwb2xpY3kgUmVzb2x2YWJsZXMgd2UgYXJlIGFib3V0IHRvIGZldGNoLlxuICAgIGNvbnN0IHdoZW5PcHRpb246IHN0cmluZyA9IGluQXJyYXkoQUxMX1dIRU5TLCB3aGVuKSA/IHdoZW4gOiAnTEFaWSc7XG4gICAgLy8gSWYgdGhlIGNhbGxlciBzcGVjaWZpZWQgRUFHRVIsIG9ubHkgdGhlIEVBR0VSIFJlc29sdmFibGVzIGFyZSBmZXRjaGVkLlxuICAgIC8vIGlmIHRoZSBjYWxsZXIgc3BlY2lmaWVkIExBWlksIGJvdGggRUFHRVIgYW5kIExBWlkgUmVzb2x2YWJsZXMgYXJlIGZldGNoZWQuYFxuICAgIGNvbnN0IG1hdGNoZWRXaGVucyA9IHdoZW5PcHRpb24gPT09IHJlc29sdmVQb2xpY2llcy53aGVuLkVBR0VSID8gRUFHRVJfV0hFTlMgOiBBTExfV0hFTlM7XG5cbiAgICAvLyBnZXQgdGhlIHN1YnBhdGggdG8gdGhlIHN0YXRlIGFyZ3VtZW50LCBpZiBwcm92aWRlZFxuICAgIHRyYWNlLnRyYWNlUmVzb2x2ZVBhdGgodGhpcy5fcGF0aCwgd2hlbiwgdHJhbnMpO1xuXG4gICAgY29uc3QgbWF0Y2hlc1BvbGljeSA9IChhY2NlcHRlZFZhbHM6IHN0cmluZ1tdLCB3aGVuT3JBc3luYzogJ3doZW4nIHwgJ2FzeW5jJykgPT4gKHJlc29sdmFibGU6IFJlc29sdmFibGUpID0+XG4gICAgICBpbkFycmF5KGFjY2VwdGVkVmFscywgdGhpcy5nZXRQb2xpY3kocmVzb2x2YWJsZSlbd2hlbk9yQXN5bmNdKTtcblxuICAgIC8vIFRyaWdnZXIgYWxsIHRoZSAobWF0Y2hpbmcpIFJlc29sdmFibGVzIGluIHRoZSBwYXRoXG4gICAgLy8gUmVkdWNlIGFsbCB0aGUgXCJXQUlUXCIgUmVzb2x2YWJsZXMgaW50byBhbiBhcnJheVxuICAgIGNvbnN0IHByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IHRoaXMuX3BhdGgucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVSZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuZmlsdGVyKG1hdGNoZXNQb2xpY3kobWF0Y2hlZFdoZW5zLCAnd2hlbicpKTtcbiAgICAgIGNvbnN0IG5vd2FpdCA9IG5vZGVSZXNvbHZhYmxlcy5maWx0ZXIobWF0Y2hlc1BvbGljeShbJ05PV0FJVCddLCAnYXN5bmMnKSk7XG4gICAgICBjb25zdCB3YWl0ID0gbm9kZVJlc29sdmFibGVzLmZpbHRlcihub3QobWF0Y2hlc1BvbGljeShbJ05PV0FJVCddLCAnYXN5bmMnKSkpO1xuXG4gICAgICAvLyBGb3IgdGhlIG1hdGNoaW5nIFJlc29sdmFibGVzLCBzdGFydCB0aGVpciBhc3luYyBmZXRjaCBwcm9jZXNzLlxuICAgICAgY29uc3Qgc3ViQ29udGV4dCA9IHRoaXMuc3ViQ29udGV4dChub2RlLnN0YXRlKTtcbiAgICAgIGNvbnN0IGdldFJlc3VsdCA9IChyOiBSZXNvbHZhYmxlKSA9PlxuICAgICAgICByXG4gICAgICAgICAgLmdldChzdWJDb250ZXh0LCB0cmFucylcbiAgICAgICAgICAvLyBSZXR1cm4gYSB0dXBsZSB0aGF0IGluY2x1ZGVzIHRoZSBSZXNvbHZhYmxlJ3MgdG9rZW5cbiAgICAgICAgICAudGhlbih2YWx1ZSA9PiAoeyB0b2tlbjogci50b2tlbiwgdmFsdWU6IHZhbHVlIH0pKTtcbiAgICAgIG5vd2FpdC5mb3JFYWNoKGdldFJlc3VsdCk7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdCh3YWl0Lm1hcChnZXRSZXN1bHQpKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBXYWl0IGZvciBhbGwgdGhlIFwiV0FJVFwiIHJlc29sdmFibGVzXG4gICAgcmV0dXJuIHNlcnZpY2VzLiRxLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICBpbmplY3RvcigpOiBVSUluamVjdG9yIHtcbiAgICByZXR1cm4gdGhpcy5faW5qZWN0b3IgfHwgKHRoaXMuX2luamVjdG9yID0gbmV3IFVJSW5qZWN0b3JJbXBsKHRoaXMpKTtcbiAgfVxuXG4gIGZpbmROb2RlKHJlc29sdmFibGU6IFJlc29sdmFibGUpOiBQYXRoTm9kZSB7XG4gICAgcmV0dXJuIGZpbmQodGhpcy5fcGF0aCwgKG5vZGU6IFBhdGhOb2RlKSA9PiBpbkFycmF5KG5vZGUucmVzb2x2YWJsZXMsIHJlc29sdmFibGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhc3luYyBkZXBlbmRlbmNpZXMgb2YgYSBSZXNvbHZhYmxlXG4gICAqXG4gICAqIEdpdmVuIGEgUmVzb2x2YWJsZSwgcmV0dXJucyBpdHMgZGVwZW5kZW5jaWVzIGFzIGEgUmVzb2x2YWJsZVtdXG4gICAqL1xuICBnZXREZXBlbmRlbmNpZXMocmVzb2x2YWJsZTogUmVzb2x2YWJsZSk6IFJlc29sdmFibGVbXSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XG4gICAgLy8gRmluZCB3aGljaCBvdGhlciByZXNvbHZhYmxlcyBhcmUgXCJ2aXNpYmxlXCIgdG8gdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuICAgIC8vIHN1YnBhdGggc3RvcHBpbmcgYXQgcmVzb2x2YWJsZSdzIG5vZGUsIG9yIHRoZSB3aG9sZSBwYXRoIChpZiB0aGUgcmVzb2x2YWJsZSBpc24ndCBpbiB0aGUgcGF0aClcbiAgICBjb25zdCBzdWJQYXRoOiBQYXRoTm9kZVtdID0gUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgeCA9PiB4ID09PSBub2RlKSB8fCB0aGlzLl9wYXRoO1xuICAgIGNvbnN0IGF2YWlsYWJsZVJlc29sdmFibGVzOiBSZXNvbHZhYmxlW10gPSBzdWJQYXRoXG4gICAgICAucmVkdWNlKChhY2MsIF9ub2RlKSA9PiBhY2MuY29uY2F0KF9ub2RlLnJlc29sdmFibGVzKSwgW10pIC8vIGFsbCBvZiBzdWJwYXRoJ3MgcmVzb2x2YWJsZXNcbiAgICAgIC5maWx0ZXIocmVzID0+IHJlcyAhPT0gcmVzb2x2YWJsZSk7IC8vIGZpbHRlciBvdXQgdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuXG4gICAgY29uc3QgZ2V0RGVwZW5kZW5jeSA9ICh0b2tlbjogYW55KSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGluZyA9IGF2YWlsYWJsZVJlc29sdmFibGVzLmZpbHRlcihyID0+IHIudG9rZW4gPT09IHRva2VuKTtcbiAgICAgIGlmIChtYXRjaGluZy5sZW5ndGgpIHJldHVybiB0YWlsKG1hdGNoaW5nKTtcblxuICAgICAgY29uc3QgZnJvbUluamVjdG9yID0gdGhpcy5pbmplY3RvcigpLmdldE5hdGl2ZSh0b2tlbik7XG4gICAgICBpZiAoaXNVbmRlZmluZWQoZnJvbUluamVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIERlcGVuZGVuY3kgSW5qZWN0aW9uIHRva2VuOiAnICsgc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUmVzb2x2YWJsZSh0b2tlbiwgKCkgPT4gZnJvbUluamVjdG9yLCBbXSwgZnJvbUluamVjdG9yKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc29sdmFibGUuZGVwcy5tYXAoZ2V0RGVwZW5kZW5jeSk7XG4gIH1cbn1cblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuY2xhc3MgVUlJbmplY3RvckltcGwgaW1wbGVtZW50cyBVSUluamVjdG9yIHtcbiAgbmF0aXZlOiAkSW5qZWN0b3JMaWtlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCkge1xuICAgIHRoaXMubmF0aXZlID0gdGhpcy5nZXQoTkFUSVZFX0lOSkVDVE9SX1RPS0VOKSB8fCBzZXJ2aWNlcy4kaW5qZWN0b3I7XG4gIH1cblxuICBnZXQodG9rZW46IGFueSkge1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgaWYgKHJlc29sdmFibGUpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQuZ2V0UG9saWN5KHJlc29sdmFibGUpLmFzeW5jID09PSAnTk9XQUlUJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNvbHZhYmxlLnJlc29sdmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x2YWJsZSBhc3luYyAuZ2V0KCkgbm90IGNvbXBsZXRlOicgKyBzdHJpbmdpZnkocmVzb2x2YWJsZS50b2tlbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmFibGUuZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmUodG9rZW4pO1xuICB9XG5cbiAgZ2V0QXN5bmModG9rZW46IGFueSkge1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgaWYgKHJlc29sdmFibGUpIHJldHVybiByZXNvbHZhYmxlLmdldCh0aGlzLmNvbnRleHQpO1xuICAgIHJldHVybiBzZXJ2aWNlcy4kcS53aGVuKHRoaXMubmF0aXZlLmdldCh0b2tlbikpO1xuICB9XG5cbiAgZ2V0TmF0aXZlKHRva2VuOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5uYXRpdmUgJiYgdGhpcy5uYXRpdmUuZ2V0KHRva2VuKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBzdGF0ZSAqLyAvKiogKi9cbmltcG9ydCB7IGFwcGx5UGFpcnMsIGV4dGVuZCwgaWRlbnRpdHksIGluaGVyaXQsIG1hcE9iaiwgbm9vcCwgT2JqLCBvbWl0LCB0YWlsLCB2YWx1ZXMsIGNvcHkgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGlzQXJyYXksIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9jb21tb24vc3RyaW5ncyc7XG5pbXBvcnQgeyBpcywgcGF0dGVybiwgcGlwZSwgcHJvcCwgdmFsIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4vc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgU3RhdGVNYXRjaGVyIH0gZnJvbSAnLi9zdGF0ZU1hdGNoZXInO1xuaW1wb3J0IHsgUGFyYW0gfSBmcm9tICcuLi9wYXJhbXMvcGFyYW0nO1xuaW1wb3J0IHsgVXJsTWF0Y2hlckZhY3RvcnkgfSBmcm9tICcuLi91cmwvdXJsTWF0Y2hlckZhY3RvcnknO1xuaW1wb3J0IHsgVXJsTWF0Y2hlciB9IGZyb20gJy4uL3VybC91cmxNYXRjaGVyJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuLi9yZXNvbHZlL3Jlc29sdmFibGUnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFJlc29sdmVQb2xpY3kgfSBmcm9tICcuLi9yZXNvbHZlL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBQYXJhbURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vcGFyYW1zJztcbmltcG9ydCB7IFBhcmFtRmFjdG9yeSB9IGZyb20gJy4uL3VybCc7XG5cbmNvbnN0IHBhcnNlVXJsID0gKHVybDogc3RyaW5nKTogYW55ID0+IHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHJvb3QgPSB1cmwuY2hhckF0KDApID09PSAnXic7XG4gIHJldHVybiB7IHZhbDogcm9vdCA/IHVybC5zdWJzdHJpbmcoMSkgOiB1cmwsIHJvb3QgfTtcbn07XG5cbmV4cG9ydCB0eXBlIEJ1aWxkZXJGdW5jdGlvbiA9IChzdGF0ZTogU3RhdGVPYmplY3QsIHBhcmVudD86IEJ1aWxkZXJGdW5jdGlvbikgPT4gYW55O1xuXG5pbnRlcmZhY2UgQnVpbGRlcnMge1xuICBba2V5OiBzdHJpbmddOiBCdWlsZGVyRnVuY3Rpb25bXTtcblxuICBuYW1lOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgcGFyZW50OiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgZGF0YTogQnVpbGRlckZ1bmN0aW9uW107XG4gIHVybDogQnVpbGRlckZ1bmN0aW9uW107XG4gIG5hdmlnYWJsZTogQnVpbGRlckZ1bmN0aW9uW107XG4gIHBhcmFtczogQnVpbGRlckZ1bmN0aW9uW107XG4gIHZpZXdzOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgcGF0aDogQnVpbGRlckZ1bmN0aW9uW107XG4gIGluY2x1ZGVzOiBCdWlsZGVyRnVuY3Rpb25bXTtcbiAgcmVzb2x2YWJsZXM6IEJ1aWxkZXJGdW5jdGlvbltdO1xufVxuXG5mdW5jdGlvbiBuYW1lQnVpbGRlcihzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgcmV0dXJuIHN0YXRlLm5hbWU7XG59XG5cbmZ1bmN0aW9uIHNlbGZCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICBzdGF0ZS5zZWxmLiQkc3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgcmV0dXJuIHN0YXRlLnNlbGY7XG59XG5cbmZ1bmN0aW9uIGRhdGFCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICBpZiAoc3RhdGUucGFyZW50ICYmIHN0YXRlLnBhcmVudC5kYXRhKSB7XG4gICAgc3RhdGUuZGF0YSA9IHN0YXRlLnNlbGYuZGF0YSA9IGluaGVyaXQoc3RhdGUucGFyZW50LmRhdGEsIHN0YXRlLmRhdGEpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5kYXRhO1xufVxuXG5jb25zdCBnZXRVcmxCdWlsZGVyID0gKCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyOiBVcmxNYXRjaGVyRmFjdG9yeSwgcm9vdDogKCkgPT4gU3RhdGVPYmplY3QpID0+XG4gIGZ1bmN0aW9uIHVybEJ1aWxkZXIoc3RhdGVPYmplY3Q6IFN0YXRlT2JqZWN0KSB7XG4gICAgbGV0IHN0YXRlRGVjOiBTdGF0ZURlY2xhcmF0aW9uID0gc3RhdGVPYmplY3Quc2VsZjtcblxuICAgIC8vIEZvciBmdXR1cmUgc3RhdGVzLCBpLmUuLCBzdGF0ZXMgd2hvc2UgbmFtZSBlbmRzIHdpdGggYC4qKmAsXG4gICAgLy8gbWF0Y2ggYW55dGhpbmcgdGhhdCBzdGFydHMgd2l0aCB0aGUgdXJsIHByZWZpeFxuICAgIGlmIChzdGF0ZURlYyAmJiBzdGF0ZURlYy51cmwgJiYgc3RhdGVEZWMubmFtZSAmJiBzdGF0ZURlYy5uYW1lLm1hdGNoKC9cXC5cXCpcXCokLykpIHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlRGVjOiBTdGF0ZURlY2xhcmF0aW9uID0ge307XG4gICAgICBjb3B5KHN0YXRlRGVjLCBuZXdTdGF0ZURlYyk7XG4gICAgICBuZXdTdGF0ZURlYy51cmwgKz0gJ3tyZW1haW5kZXI6YW55fSc7IC8vIG1hdGNoIGFueSBwYXRoICguKilcbiAgICAgIHN0YXRlRGVjID0gbmV3U3RhdGVEZWM7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gc3RhdGVPYmplY3QucGFyZW50O1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVXJsKHN0YXRlRGVjLnVybCk7XG4gICAgY29uc3QgdXJsID0gIXBhcnNlZCA/IHN0YXRlRGVjLnVybCA6ICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmNvbXBpbGUocGFyc2VkLnZhbCwgeyBzdGF0ZTogc3RhdGVEZWMgfSk7XG5cbiAgICBpZiAoIXVybCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCEkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5pc01hdGNoZXIodXJsKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHVybCAnJHt1cmx9JyBpbiBzdGF0ZSAnJHtzdGF0ZU9iamVjdH0nYCk7XG4gICAgcmV0dXJuIHBhcnNlZCAmJiBwYXJzZWQucm9vdCA/IHVybCA6ICgocGFyZW50ICYmIHBhcmVudC5uYXZpZ2FibGUpIHx8IHJvb3QoKSkudXJsLmFwcGVuZCg8VXJsTWF0Y2hlcj51cmwpO1xuICB9O1xuXG5jb25zdCBnZXROYXZpZ2FibGVCdWlsZGVyID0gKGlzUm9vdDogKHN0YXRlOiBTdGF0ZU9iamVjdCkgPT4gYm9vbGVhbikgPT5cbiAgZnVuY3Rpb24gbmF2aWdhYmxlQnVpbGRlcihzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUm9vdChzdGF0ZSkgJiYgc3RhdGUudXJsID8gc3RhdGUgOiBzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbDtcbiAgfTtcblxuY29uc3QgZ2V0UGFyYW1zQnVpbGRlciA9IChwYXJhbUZhY3Rvcnk6IFBhcmFtRmFjdG9yeSkgPT5cbiAgZnVuY3Rpb24gcGFyYW1zQnVpbGRlcihzdGF0ZTogU3RhdGVPYmplY3QpOiB7IFtrZXk6IHN0cmluZ106IFBhcmFtIH0ge1xuICAgIGNvbnN0IG1ha2VDb25maWdQYXJhbSA9IChjb25maWc6IFBhcmFtRGVjbGFyYXRpb24sIGlkOiBzdHJpbmcpID0+IHBhcmFtRmFjdG9yeS5mcm9tQ29uZmlnKGlkLCBudWxsLCBzdGF0ZS5zZWxmKTtcbiAgICBjb25zdCB1cmxQYXJhbXM6IFBhcmFtW10gPSAoc3RhdGUudXJsICYmIHN0YXRlLnVybC5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSkpIHx8IFtdO1xuICAgIGNvbnN0IG5vblVybFBhcmFtczogUGFyYW1bXSA9IHZhbHVlcyhtYXBPYmoob21pdChzdGF0ZS5wYXJhbXMgfHwge30sIHVybFBhcmFtcy5tYXAocHJvcCgnaWQnKSkpLCBtYWtlQ29uZmlnUGFyYW0pKTtcbiAgICByZXR1cm4gdXJsUGFyYW1zXG4gICAgICAuY29uY2F0KG5vblVybFBhcmFtcylcbiAgICAgIC5tYXAocCA9PiBbcC5pZCwgcF0pXG4gICAgICAucmVkdWNlKGFwcGx5UGFpcnMsIHt9KTtcbiAgfTtcblxuZnVuY3Rpb24gcGF0aEJ1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gIHJldHVybiBzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQucGF0aC5jb25jYXQoc3RhdGUpIDogLypyb290Ki8gW3N0YXRlXTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICBjb25zdCBpbmNsdWRlcyA9IHN0YXRlLnBhcmVudCA/IGV4dGVuZCh7fSwgc3RhdGUucGFyZW50LmluY2x1ZGVzKSA6IHt9O1xuICBpbmNsdWRlc1tzdGF0ZS5uYW1lXSA9IHRydWU7XG4gIHJldHVybiBpbmNsdWRlcztcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciB0aGUgYHJlc29sdmU6YCBibG9jayBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIHZhbGlkYXRlcyB0aGUgYHJlc29sdmVgIHByb3BlcnR5IGFuZCBjb252ZXJ0cyBpdCB0byBhIFtbUmVzb2x2YWJsZV1dIGFycmF5LlxuICpcbiAqIHJlc29sdmU6IGlucHV0IHZhbHVlIGNhbiBiZTpcbiAqXG4gKiB7XG4gKiAgIC8vIGFuYWx5emVkIGJ1dCBub3QgaW5qZWN0ZWRcbiAqICAgbXlGb29SZXNvbHZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwibXlGb29EYXRhXCI7IH0sXG4gKlxuICogICAvLyBmdW5jdGlvbi50b1N0cmluZygpIHBhcnNlZCwgXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmcgKG5vdCBtaW4tc2FmZSlcbiAqICAgbXlCYXJSZXNvbHZlOiBmdW5jdGlvbihEZXBlbmRlbmN5TmFtZSkgeyByZXR1cm4gRGVwZW5kZW5jeU5hbWUuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gQXJyYXkgc3BsaXQ7IFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXG4gKiAgIG15QmF6UmVzb2x2ZTogWyBcIkRlcGVuZGVuY3lOYW1lXCIsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIEFycmF5IHNwbGl0OyBEZXBlbmRlbmN5VHlwZSBkZXAgYXMgdG9rZW4gKGNvbXBhcmVkIHVzaW5nID09PSlcbiAqICAgbXlRdXhSZXNvbHZlOiBbIERlcGVuZGVuY3lUeXBlLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIHZhbC4kaW5qZWN0IHVzZWQgYXMgZGVwc1xuICogICAvLyB3aGVyZTpcbiAqICAgLy8gICAgIGNvcmdlUmVzb2x2ZS4kaW5qZWN0ID0gW1wiRGVwZW5kZW5jeU5hbWVcIl07XG4gKiAgIC8vICAgICBmdW5jdGlvbiBjb3JnZVJlc29sdmUoZGVwKSB7IGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfVxuICogICAvLyB0aGVuIFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXG4gKiAgIG15Q29yZ2VSZXNvbHZlOiBjb3JnZVJlc29sdmUsXG4gKlxuICogIC8vIGluamVjdCBzZXJ2aWNlIGJ5IG5hbWVcbiAqICAvLyBXaGVuIGEgc3RyaW5nIGlzIGZvdW5kLCBkZXN1Z2FyIGNyZWF0aW5nIGEgcmVzb2x2ZSB0aGF0IGluamVjdHMgdGhlIG5hbWVkIHNlcnZpY2VcbiAqICAgbXlHcmF1bHRSZXNvbHZlOiBcIlNvbWVTZXJ2aWNlXCJcbiAqIH1cbiAqXG4gKiBvcjpcbiAqXG4gKiBbXG4gKiAgIG5ldyBSZXNvbHZhYmxlKFwibXlGb29SZXNvbHZlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIiB9KSxcbiAqICAgbmV3IFJlc29sdmFibGUoXCJteUJhclJlc29sdmVcIiwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LCBbIFwiRGVwZW5kZW5jeU5hbWVcIiBdKSxcbiAqICAgeyBwcm92aWRlOiBcIm15QmF6UmVzb2x2ZVwiLCB1c2VGYWN0b3J5OiBmdW5jdGlvbihkZXApIHsgZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSwgZGVwczogWyBcIkRlcGVuZGVuY3lOYW1lXCIgXSB9XG4gKiBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZhYmxlc0J1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KTogUmVzb2x2YWJsZVtdIHtcbiAgaW50ZXJmYWNlIFR1cGxlIHtcbiAgICB0b2tlbjogYW55O1xuICAgIHZhbDogYW55O1xuICAgIGRlcHM6IGFueVtdO1xuICAgIHBvbGljeTogUmVzb2x2ZVBvbGljeTtcbiAgfVxuXG4gIC8qKiBjb252ZXJ0IHJlc29sdmU6IHt9IGFuZCByZXNvbHZlUG9saWN5OiB7fSBvYmplY3RzIHRvIGFuIGFycmF5IG9mIHR1cGxlcyAqL1xuICBjb25zdCBvYmplY3RzMlR1cGxlcyA9IChyZXNvbHZlT2JqOiBPYmosIHJlc29sdmVQb2xpY2llczogeyBba2V5OiBzdHJpbmddOiBSZXNvbHZlUG9saWN5IH0pID0+XG4gICAgT2JqZWN0LmtleXMocmVzb2x2ZU9iaiB8fCB7fSkubWFwKHRva2VuID0+ICh7XG4gICAgICB0b2tlbixcbiAgICAgIHZhbDogcmVzb2x2ZU9ialt0b2tlbl0sXG4gICAgICBkZXBzOiB1bmRlZmluZWQsXG4gICAgICBwb2xpY3k6IHJlc29sdmVQb2xpY2llc1t0b2tlbl0sXG4gICAgfSkpO1xuXG4gIC8qKiBmZXRjaCBESSBhbm5vdGF0aW9ucyBmcm9tIGEgZnVuY3Rpb24gb3IgbmcxLXN0eWxlIGFycmF5ICovXG4gIGNvbnN0IGFubm90YXRlID0gKGZuOiBGdW5jdGlvbikgPT4ge1xuICAgIGNvbnN0ICRpbmplY3RvciA9IHNlcnZpY2VzLiRpbmplY3RvcjtcbiAgICAvLyBuZzEgZG9lc24ndCBoYXZlIGFuICRpbmplY3RvciB1bnRpbCBydW50aW1lLlxuICAgIC8vIElmIHRoZSAkaW5qZWN0b3IgZG9lc24ndCBleGlzdCwgdXNlIFwiZGVmZXJyZWRcIiBsaXRlcmFsIGFzIGFcbiAgICAvLyBtYXJrZXIgaW5kaWNhdGluZyB0aGV5IHNob3VsZCBiZSBhbm5vdGF0ZWQgd2hlbiBydW50aW1lIHN0YXJ0c1xuICAgIHJldHVybiBmblsnJGluamVjdCddIHx8ICgkaW5qZWN0b3IgJiYgJGluamVjdG9yLmFubm90YXRlKGZuLCAkaW5qZWN0b3Iuc3RyaWN0RGkpKSB8fCA8YW55PidkZWZlcnJlZCc7XG4gIH07XG5cbiAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYm90aCBgdG9rZW5gIGFuZCBgcmVzb2x2ZUZuYCwgYW5kIGlzIHByb2JhYmx5IGEgW1tSZXNvbHZlTGl0ZXJhbF1dICovXG4gIGNvbnN0IGlzUmVzb2x2ZUxpdGVyYWwgPSAob2JqOiBhbnkpID0+ICEhKG9iai50b2tlbiAmJiBvYmoucmVzb2x2ZUZuKTtcblxuICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGxvb2tzIGxpa2UgYSBwcm92aWRlIGxpdGVyYWwsIG9yIGEgbmcyIFByb3ZpZGVyICovXG4gIGNvbnN0IGlzTGlrZU5nMlByb3ZpZGVyID0gKG9iajogYW55KSA9PlxuICAgICEhKChvYmoucHJvdmlkZSB8fCBvYmoudG9rZW4pICYmIChvYmoudXNlVmFsdWUgfHwgb2JqLnVzZUZhY3RvcnkgfHwgb2JqLnVzZUV4aXN0aW5nIHx8IG9iai51c2VDbGFzcykpO1xuXG4gIC8qKiB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhIHR1cGxlIGZyb20gb2JqMlR1cGxlcyAqL1xuICBjb25zdCBpc1R1cGxlRnJvbU9iaiA9IChvYmo6IGFueSkgPT5cbiAgICAhIShvYmogJiYgb2JqLnZhbCAmJiAoaXNTdHJpbmcob2JqLnZhbCkgfHwgaXNBcnJheShvYmoudmFsKSB8fCBpc0Z1bmN0aW9uKG9iai52YWwpKSk7XG5cbiAgLyoqIGV4dHJhY3RzIHRoZSB0b2tlbiBmcm9tIGEgUHJvdmlkZXIgb3IgcHJvdmlkZSBsaXRlcmFsICovXG4gIGNvbnN0IGdldFRva2VuID0gKHA6IGFueSkgPT4gcC5wcm92aWRlIHx8IHAudG9rZW47XG5cbiAgLy8gcHJldHRpZXItaWdub3JlOiBHaXZlbiBhIGxpdGVyYWwgcmVzb2x2ZSBvciBwcm92aWRlciBvYmplY3QsIHJldHVybnMgYSBSZXNvbHZhYmxlXG4gIGNvbnN0IGxpdGVyYWwyUmVzb2x2YWJsZSA9IHBhdHRlcm4oW1xuICAgIFtwcm9wKCdyZXNvbHZlRm4nKSwgcCA9PiBuZXcgUmVzb2x2YWJsZShnZXRUb2tlbihwKSwgcC5yZXNvbHZlRm4sIHAuZGVwcywgcC5wb2xpY3kpXSxcbiAgICBbcHJvcCgndXNlRmFjdG9yeScpLCBwID0+IG5ldyBSZXNvbHZhYmxlKGdldFRva2VuKHApLCBwLnVzZUZhY3RvcnksIHAuZGVwcyB8fCBwLmRlcGVuZGVuY2llcywgcC5wb2xpY3kpXSxcbiAgICBbcHJvcCgndXNlQ2xhc3MnKSwgcCA9PiBuZXcgUmVzb2x2YWJsZShnZXRUb2tlbihwKSwgKCkgPT4gbmV3ICg8YW55PnAudXNlQ2xhc3MpKCksIFtdLCBwLnBvbGljeSldLFxuICAgIFtwcm9wKCd1c2VWYWx1ZScpLCBwID0+IG5ldyBSZXNvbHZhYmxlKGdldFRva2VuKHApLCAoKSA9PiBwLnVzZVZhbHVlLCBbXSwgcC5wb2xpY3ksIHAudXNlVmFsdWUpXSxcbiAgICBbcHJvcCgndXNlRXhpc3RpbmcnKSwgcCA9PiBuZXcgUmVzb2x2YWJsZShnZXRUb2tlbihwKSwgaWRlbnRpdHksIFtwLnVzZUV4aXN0aW5nXSwgcC5wb2xpY3kpXSxcbiAgXSk7XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IHR1cGxlMlJlc29sdmFibGUgPSBwYXR0ZXJuKFtcbiAgICBbcGlwZShwcm9wKCd2YWwnKSwgaXNTdHJpbmcpLCAgICh0dXBsZTogVHVwbGUpID0+IG5ldyBSZXNvbHZhYmxlKHR1cGxlLnRva2VuLCBpZGVudGl0eSwgW3R1cGxlLnZhbF0sIHR1cGxlLnBvbGljeSldLFxuICAgIFtwaXBlKHByb3AoJ3ZhbCcpLCBpc0FycmF5KSwgICAgKHR1cGxlOiBUdXBsZSkgPT4gbmV3IFJlc29sdmFibGUodHVwbGUudG9rZW4sIHRhaWwoPGFueVtdPnR1cGxlLnZhbCksIHR1cGxlLnZhbC5zbGljZSgwLCAtMSksIHR1cGxlLnBvbGljeSldLFxuICAgIFtwaXBlKHByb3AoJ3ZhbCcpLCBpc0Z1bmN0aW9uKSwgKHR1cGxlOiBUdXBsZSkgPT4gbmV3IFJlc29sdmFibGUodHVwbGUudG9rZW4sIHR1cGxlLnZhbCwgYW5ub3RhdGUodHVwbGUudmFsKSwgdHVwbGUucG9saWN5KV0sXG4gIF0pO1xuXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBjb25zdCBpdGVtMlJlc29sdmFibGUgPSA8KG9iajogYW55KSA9PiBSZXNvbHZhYmxlPnBhdHRlcm4oW1xuICAgIFtpcyhSZXNvbHZhYmxlKSwgKHI6IFJlc29sdmFibGUpID0+IHJdLFxuICAgIFtpc1Jlc29sdmVMaXRlcmFsLCBsaXRlcmFsMlJlc29sdmFibGVdLFxuICAgIFtpc0xpa2VOZzJQcm92aWRlciwgbGl0ZXJhbDJSZXNvbHZhYmxlXSxcbiAgICBbaXNUdXBsZUZyb21PYmosIHR1cGxlMlJlc29sdmFibGVdLFxuICAgIFt2YWwodHJ1ZSksIChvYmo6IGFueSkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzb2x2ZSB2YWx1ZTogJyArIHN0cmluZ2lmeShvYmopKTsgfSwgXSxcbiAgXSk7XG5cbiAgLy8gSWYgcmVzb2x2ZUJsb2NrIGlzIGFscmVhZHkgYW4gYXJyYXksIHVzZSBpdCBhcy1pcy5cbiAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXQncyBhbiBvYmplY3QgYW5kIGNvbnZlcnQgdG8gYW4gQXJyYXkgb2YgdHVwbGVzXG4gIGNvbnN0IGRlY2wgPSBzdGF0ZS5yZXNvbHZlO1xuICBjb25zdCBpdGVtczogYW55W10gPSBpc0FycmF5KGRlY2wpID8gZGVjbCA6IG9iamVjdHMyVHVwbGVzKGRlY2wsIHN0YXRlLnJlc29sdmVQb2xpY3kgfHwge30pO1xuICByZXR1cm4gaXRlbXMubWFwKGl0ZW0yUmVzb2x2YWJsZSk7XG59XG5cbi8qKlxuICogQGludGVybmFsYXBpIEEgaW50ZXJuYWwgZ2xvYmFsIHNlcnZpY2VcbiAqXG4gKiBTdGF0ZUJ1aWxkZXIgaXMgYSBmYWN0b3J5IGZvciB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gKlxuICogV2hlbiB5b3UgcmVnaXN0ZXIgYSBzdGF0ZSB3aXRoIHRoZSBbW1N0YXRlUmVnaXN0cnldXSwgeW91IHJlZ2lzdGVyIGEgcGxhaW4gb2xkIGphdmFzY3JpcHQgb2JqZWN0IHdoaWNoXG4gKiBjb25mb3JtcyB0byB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaW50ZXJmYWNlLiAgVGhpcyBmYWN0b3J5IHRha2VzIHRoYXQgb2JqZWN0IGFuZCBidWlsZHMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIFtbU3RhdGVPYmplY3RdXSBvYmplY3QsIHdoaWNoIGhhcyBhbiBBUEkgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBDdXN0b20gcHJvcGVydGllcyBvciBBUEkgbWF5IGJlIGFkZGVkIHRvIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGJ5IHJlZ2lzdGVyaW5nIGEgZGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiB1c2luZyB0aGUgW1tidWlsZGVyXV0gbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVCdWlsZGVyIHtcbiAgLyoqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgQnVpbGRlckZ1bmN0aW9ucyByZWdpc3RlcmVkLCBrZXknZCBieSB0aGUgbmFtZSBvZiB0aGUgU3RhdGUgcHJvcGVydHkgdGhleSBidWlsZCAqL1xuICBwcml2YXRlIGJ1aWxkZXJzOiBCdWlsZGVycztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1hdGNoZXI6IFN0YXRlTWF0Y2hlciwgdXJsTWF0Y2hlckZhY3Rvcnk6IFVybE1hdGNoZXJGYWN0b3J5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBjb25zdCByb290ID0gKCkgPT4gbWF0Y2hlci5maW5kKCcnKTtcbiAgICBjb25zdCBpc1Jvb3QgPSAoc3RhdGU6IFN0YXRlT2JqZWN0KSA9PiBzdGF0ZS5uYW1lID09PSAnJztcblxuICAgIGZ1bmN0aW9uIHBhcmVudEJ1aWxkZXIoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gICAgICBpZiAoaXNSb290KHN0YXRlKSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbWF0Y2hlci5maW5kKHNlbGYucGFyZW50TmFtZShzdGF0ZSkpIHx8IHJvb3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkZXJzID0ge1xuICAgICAgbmFtZTogW25hbWVCdWlsZGVyXSxcbiAgICAgIHNlbGY6IFtzZWxmQnVpbGRlcl0sXG4gICAgICBwYXJlbnQ6IFtwYXJlbnRCdWlsZGVyXSxcbiAgICAgIGRhdGE6IFtkYXRhQnVpbGRlcl0sXG4gICAgICAvLyBCdWlsZCBhIFVSTE1hdGNoZXIgaWYgbmVjZXNzYXJ5LCBlaXRoZXIgdmlhIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMXG4gICAgICB1cmw6IFtnZXRVcmxCdWlsZGVyKHVybE1hdGNoZXJGYWN0b3J5LCByb290KV0sXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChpLmUuIGlzIG5hdmlnYWJsZSlcbiAgICAgIG5hdmlnYWJsZTogW2dldE5hdmlnYWJsZUJ1aWxkZXIoaXNSb290KV0sXG4gICAgICBwYXJhbXM6IFtnZXRQYXJhbXNCdWlsZGVyKHVybE1hdGNoZXJGYWN0b3J5LnBhcmFtRmFjdG9yeSldLFxuICAgICAgLy8gRWFjaCBmcmFtZXdvcmstc3BlY2lmaWMgdWktcm91dGVyIGltcGxlbWVudGF0aW9uIHNob3VsZCBkZWZpbmUgaXRzIG93biBgdmlld3NgIGJ1aWxkZXJcbiAgICAgIC8vIGUuZy4sIHNyYy9uZzEvc3RhdGVidWlsZGVycy92aWV3cy50c1xuICAgICAgdmlld3M6IFtdLFxuICAgICAgLy8gS2VlcCBhIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZSBhcyB0aGlzIGlzIG5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICAgIHBhdGg6IFtwYXRoQnVpbGRlcl0sXG4gICAgICAvLyBTcGVlZCB1cCAkc3RhdGUuaW5jbHVkZXMoKSBhcyBpdCdzIHVzZWQgYSBsb3RcbiAgICAgIGluY2x1ZGVzOiBbaW5jbHVkZXNCdWlsZGVyXSxcbiAgICAgIHJlc29sdmFibGVzOiBbcmVzb2x2YWJsZXNCdWlsZGVyXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbQnVpbGRlckZ1bmN0aW9uXV0gZm9yIGEgc3BlY2lmaWMgW1tTdGF0ZU9iamVjdF1dIHByb3BlcnR5IChlLmcuLCBgcGFyZW50YCwgYHVybGAsIG9yIGBwYXRoYCkuXG4gICAqIE1vcmUgdGhhbiBvbmUgQnVpbGRlckZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGUgQnVpbGRlckZ1bmN0aW9uKHMpIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIHByb3BlcnR5IG9uIGFueSBzdWJzZXF1ZW50bHkgYnVpbHQgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBTdGF0ZSBwcm9wZXJ0eSBiZWluZyByZWdpc3RlcmVkIGZvci5cbiAgICogQHBhcmFtIGZuIFRoZSBCdWlsZGVyRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBTdGF0ZSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBCdWlsZGVyRnVuY3Rpb25cbiAgICovXG4gIGJ1aWxkZXIobmFtZTogc3RyaW5nLCBmbjogQnVpbGRlckZ1bmN0aW9uKTogQnVpbGRlckZ1bmN0aW9uIHwgQnVpbGRlckZ1bmN0aW9uW10gfCBGdW5jdGlvbiB7XG4gICAgY29uc3QgYnVpbGRlcnMgPSB0aGlzLmJ1aWxkZXJzO1xuICAgIGNvbnN0IGFycmF5ID0gYnVpbGRlcnNbbmFtZV0gfHwgW107XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdDogaWYgb25seSBvbmUgYnVpbGRlciBleGlzdHMsIHJldHVybiBpdCwgZWxzZSByZXR1cm4gd2hvbGUgYXJhcnkuXG4gICAgaWYgKGlzU3RyaW5nKG5hbWUpICYmICFpc0RlZmluZWQoZm4pKSByZXR1cm4gYXJyYXkubGVuZ3RoID4gMSA/IGFycmF5IDogYXJyYXlbMF07XG4gICAgaWYgKCFpc1N0cmluZyhuYW1lKSB8fCAhaXNGdW5jdGlvbihmbikpIHJldHVybjtcblxuICAgIGJ1aWxkZXJzW25hbWVdID0gYXJyYXk7XG4gICAgYnVpbGRlcnNbbmFtZV0ucHVzaChmbik7XG4gICAgcmV0dXJuICgpID0+IGJ1aWxkZXJzW25hbWVdLnNwbGljZShidWlsZGVyc1tuYW1lXS5pbmRleE9mKGZuLCAxKSkgJiYgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9uIGFuIGVzc2VudGlhbGx5IGJsYW5rIFN0YXRlIG9iamVjdCwgcmV0dXJuaW5nIGEgU3RhdGUgb2JqZWN0IHdoaWNoIGhhcyBhbGwgaXRzXG4gICAqIHByb3BlcnRpZXMgYW5kIEFQSSBidWlsdC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIGFuIHVuaW5pdGlhbGl6ZWQgU3RhdGUgb2JqZWN0XG4gICAqIEByZXR1cm5zIHRoZSBidWlsdCBTdGF0ZSBvYmplY3RcbiAgICovXG4gIGJ1aWxkKHN0YXRlOiBTdGF0ZU9iamVjdCk6IFN0YXRlT2JqZWN0IHtcbiAgICBjb25zdCB7IG1hdGNoZXIsIGJ1aWxkZXJzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50TmFtZShzdGF0ZSk7XG5cbiAgICBpZiAocGFyZW50ICYmICFtYXRjaGVyLmZpbmQocGFyZW50LCB1bmRlZmluZWQsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYnVpbGRlcnMpIHtcbiAgICAgIGlmICghYnVpbGRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG4gICAgICBjb25zdCBjaGFpbiA9IGJ1aWxkZXJzW2tleV0ucmVkdWNlKFxuICAgICAgICAocGFyZW50Rm46IEJ1aWxkZXJGdW5jdGlvbiwgc3RlcDogQnVpbGRlckZ1bmN0aW9uKSA9PiBfc3RhdGUgPT4gc3RlcChfc3RhdGUsIHBhcmVudEZuKSxcbiAgICAgICAgbm9vcFxuICAgICAgKTtcbiAgICAgIHN0YXRlW2tleV0gPSBjaGFpbihzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIHBhcmVudE5hbWUoc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gICAgLy8gbmFtZSA9ICdmb28uYmFyLmJhei4qKidcbiAgICBjb25zdCBuYW1lID0gc3RhdGUubmFtZSB8fCAnJztcbiAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhcicsICdiYXonLCAnLioqJ11cbiAgICBjb25zdCBzZWdtZW50cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gc2VnbWVudHMucG9wKCk7XG4gICAgLy8gc2VnbWVudHMgPSBbJ2ZvbycsICdiYXInXSAoaWdub3JlIC4qKiBzZWdtZW50IGZvciBmdXR1cmUgc3RhdGVzKVxuICAgIGlmIChsYXN0U2VnbWVudCA9PT0gJyoqJykgc2VnbWVudHMucG9wKCk7XG5cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoc3RhdGUucGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGVzIHRoYXQgc3BlY2lmeSB0aGUgJ3BhcmVudDonIHByb3BlcnR5IHNob3VsZCBub3QgaGF2ZSBhICcuJyBpbiB0aGVpciBuYW1lICgke25hbWV9KWApO1xuICAgICAgfVxuXG4gICAgICAvLyAnZm9vLmJhcidcbiAgICAgIHJldHVybiBzZWdtZW50cy5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5wYXJlbnQpIHJldHVybiAnJztcbiAgICByZXR1cm4gaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xuICB9XG5cbiAgbmFtZShzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICBjb25zdCBuYW1lID0gc3RhdGUubmFtZTtcbiAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgIT09IC0xIHx8ICFzdGF0ZS5wYXJlbnQpIHJldHVybiBuYW1lO1xuXG4gICAgY29uc3QgcGFyZW50TmFtZSA9IGlzU3RyaW5nKHN0YXRlLnBhcmVudCkgPyBzdGF0ZS5wYXJlbnQgOiBzdGF0ZS5wYXJlbnQubmFtZTtcbiAgICByZXR1cm4gcGFyZW50TmFtZSA/IHBhcmVudE5hbWUgKyAnLicgKyBuYW1lIDogbmFtZTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBzdGF0ZSAqLyAvKiogKi9cbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24sIF9WaWV3RGVjbGFyYXRpb24sIF9TdGF0ZURlY2xhcmF0aW9uLCBMYXp5TG9hZFJlc3VsdCB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGRlZmF1bHRzLCB2YWx1ZXMsIGZpbmQsIGluaGVyaXQgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHByb3BFcSB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgUGFyYW0gfSBmcm9tICcuLi9wYXJhbXMvcGFyYW0nO1xuaW1wb3J0IHsgVXJsTWF0Y2hlciB9IGZyb20gJy4uL3VybC91cmxNYXRjaGVyJztcbmltcG9ydCB7IFJlc29sdmFibGUgfSBmcm9tICcuLi9yZXNvbHZlL3Jlc29sdmFibGUnO1xuaW1wb3J0IHsgVHJhbnNpdGlvblN0YXRlSG9va0ZuIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUgfSBmcm9tICcuL3RhcmdldFN0YXRlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgR2xvYiB9IGZyb20gJy4uL2NvbW1vbi9nbG9iJztcbmltcG9ydCB7IGlzT2JqZWN0LCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgVUktUm91dGVyIHN0YXRlLlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjcmVhdGVkIHdoZW4gYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBpcyByZWdpc3RlcmVkIHdpdGggdGhlIFtbU3RhdGVSZWdpc3RyeV1dLlxuICpcbiAqIEEgcmVnaXN0ZXJlZCBbW1N0YXRlRGVjbGFyYXRpb25dXSBpcyBhdWdtZW50ZWQgd2l0aCBhIGdldHRlciAoW1tTdGF0ZURlY2xhcmF0aW9uLiQkc3RhdGVdXSkgd2hpY2ggcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgW1tTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKiBFYWNoIG9mIGl0cyBvd24gcHJvcGVydGllcyAoaS5lLiwgYGhhc093blByb3BlcnR5YCkgYXJlIGJ1aWx0IHVzaW5nIGJ1aWxkZXJzIGZyb20gdGhlIFtbU3RhdGVCdWlsZGVyXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0ZU9iamVjdCB7XG4gIC8qKiBUaGUgcGFyZW50IFtbU3RhdGVPYmplY3RdXSAqL1xuICBwdWJsaWMgcGFyZW50OiBTdGF0ZU9iamVjdDtcblxuICAvKiogVGhlIG5hbWUgdXNlZCB0byByZWdpc3RlciB0aGUgc3RhdGUgKi9cbiAgcHVibGljIG5hbWU6IHN0cmluZztcblxuICAvKiogUHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gW1tTdGF0ZURlY2xhcmF0aW9uLmFic3RyYWN0XV0gKi9cbiAgcHVibGljIGFic3RyYWN0OiBib29sZWFuO1xuXG4gIC8qKiBQcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dICovXG4gIHB1YmxpYyByZXNvbHZlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IGFueVtdIHwgRnVuY3Rpb24gfSB8IGFueVtdO1xuXG4gIC8qKiBBIGxpc3Qgb2YgW1tSZXNvbHZhYmxlXV0gb2JqZWN0cy4gIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBbW3Jlc29sdmVdXS4gKi9cbiAgcHVibGljIHJlc29sdmFibGVzOiBSZXNvbHZhYmxlW107XG5cbiAgLyoqIFByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlUG9saWN5XV0gKi9cbiAgcHVibGljIHJlc29sdmVQb2xpY3k6IGFueTtcblxuICAvKiogQSBjb21waWxlZCBVUkxNYXRjaGVyIHdoaWNoIGRldGVjdHMgd2hlbiB0aGUgc3RhdGUncyBVUkwgaXMgbWF0Y2hlZCAqL1xuICBwdWJsaWMgdXJsOiBVcmxNYXRjaGVyO1xuXG4gIC8qKiBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHN0YXRlLCBidWlsdCBmcm9tIHRoZSBVUkwgYW5kIFtbU3RhdGVEZWNsYXJhdGlvbi5wYXJhbXNdXSAqL1xuICBwdWJsaWMgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IFBhcmFtIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2aWV3cyBmb3IgdGhlIHN0YXRlLlxuICAgKiBOb3RlOiBgQHVpcm91dGVyL2NvcmVgIGRvZXMgbm90IHJlZ2lzdGVyIGEgYnVpbGRlciBmb3Igdmlld3MuXG4gICAqIFRoZSBmcmFtZXdvcmsgc3BlY2lmaWMgY29kZSBzaG91bGQgcmVnaXN0ZXIgYSBgdmlld3NgIGJ1aWxkZXIuXG4gICAqL1xuICBwdWJsaWMgdmlld3M6IHsgW2tleTogc3RyaW5nXTogX1ZpZXdEZWNsYXJhdGlvbiB9O1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgW1tTdGF0ZURlY2xhcmF0aW9uXV0gdXNlZCB0byBidWlsZCB0aGlzIFtbU3RhdGVPYmplY3RdXS5cbiAgICogTm90ZTogYHRoaXNgIG9iamVjdCBhbHNvIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIHRoZSBgc2VsZmAgZGVjbGFyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIHNlbGY6IFN0YXRlRGVjbGFyYXRpb247XG5cbiAgLyoqIFRoZSBuZWFyZXN0IHBhcmVudCBbW1N0YXRlT2JqZWN0XV0gd2hpY2ggaGFzIGEgVVJMICovXG4gIHB1YmxpYyBuYXZpZ2FibGU6IFN0YXRlT2JqZWN0O1xuXG4gIC8qKiBUaGUgcGFyZW50IFtbU3RhdGVPYmplY3RdXSBvYmplY3RzIGZyb20gdGhpcyBzdGF0ZSB1cCB0byB0aGUgcm9vdCAqL1xuICBwdWJsaWMgcGF0aDogU3RhdGVPYmplY3RbXTtcblxuICAvKipcbiAgICogUHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gW1tTdGF0ZURlY2xhcmF0aW9uLmRhdGFdXVxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBvbmx5IGZpZWxkIG9uIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSB3aGljaCBpcyBtdXRhdGVkLlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvYmplY3QncyBgZGF0YWAgZmllbGQgaXMgcmVwbGFjZWQgd2l0aCBhIG5ldyBvYmplY3RcbiAgICogd2hpY2ggcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gdGhlIHBhcmVudCBzdGF0ZSBkZWZpbml0aW9uJ3MgYGRhdGFgIGZpZWxkLlxuICAgKi9cbiAgcHVibGljIGRhdGE6IGFueTtcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmVudCBTdGF0ZXMnIG5hbWVzIGFzIGtleXMgYW5kXG4gICAqIHRydWUgYXMgdGhlaXIgdmFsdWVzLlxuICAgKi9cbiAgcHVibGljIGluY2x1ZGVzOiB7IFtuYW1lOiBzdHJpbmddOiBib29sZWFuIH07XG5cbiAgLyoqIFByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFtbU3RhdGVEZWNsYXJhdGlvbi5vbkV4aXRdXSAqL1xuICBwdWJsaWMgb25FeGl0OiBUcmFuc2l0aW9uU3RhdGVIb29rRm47XG4gIC8qKiBQcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBbW1N0YXRlRGVjbGFyYXRpb24ub25SZXRhaW5dXSAqL1xuICBwdWJsaWMgb25SZXRhaW46IFRyYW5zaXRpb25TdGF0ZUhvb2tGbjtcbiAgLyoqIFByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFtbU3RhdGVEZWNsYXJhdGlvbi5vbkVudGVyXV0gKi9cbiAgcHVibGljIG9uRW50ZXI6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbjtcblxuICAvKiogUHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gW1tTdGF0ZURlY2xhcmF0aW9uLmxhenlMb2FkXV0gKi9cbiAgcHVibGljIGxhenlMb2FkOiAodHJhbnNpdGlvbjogVHJhbnNpdGlvbiwgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pID0+IFByb21pc2U8TGF6eUxvYWRSZXN1bHQ+O1xuXG4gIC8qKiBQcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBbW1N0YXRlRGVjbGFyYXRpb24ucmVkaXJlY3RUb11dICovXG4gIHJlZGlyZWN0VG86XG4gICAgfCBzdHJpbmdcbiAgICB8ICgoJHRyYW5zaXRpb24kOiBUcmFuc2l0aW9uKSA9PiBUYXJnZXRTdGF0ZSlcbiAgICB8IHsgc3RhdGU6IHN0cmluZyB8IFN0YXRlRGVjbGFyYXRpb247IHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB9O1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIF9fc3RhdGVPYmplY3RDYWNoZToge1xuICAgIC8qKiBNaWdodCBiZSBudWxsICovXG4gICAgbmFtZUdsb2I/OiBHbG9iO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdGF0ZSBvYmplY3QgdG8gcHV0IHRoZSBwcml2YXRlL2ludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb250by5cbiAgICogVGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiBsb29rcyBsaWtlOlxuICAgKiAoSW50ZXJuYWwgU3RhdGUgT2JqZWN0KSAtPiAoQ29weSBvZiBTdGF0ZS5wcm90b3R5cGUpIC0+IChTdGF0ZSBEZWNsYXJhdGlvbiBvYmplY3QpIC0+IChTdGF0ZSBEZWNsYXJhdGlvbidzIHByb3RvdHlwZS4uLilcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlRGVjbCB0aGUgdXNlci1zdXBwbGllZCBTdGF0ZSBEZWNsYXJhdGlvblxuICAgKiBAcmV0dXJucyB7U3RhdGVPYmplY3R9IGFuIGludGVybmFsIFN0YXRlIG9iamVjdFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShzdGF0ZURlY2w6IF9TdGF0ZURlY2xhcmF0aW9uKTogU3RhdGVPYmplY3Qge1xuICAgIHN0YXRlRGVjbCA9IFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyhzdGF0ZURlY2wpID8gbmV3IHN0YXRlRGVjbCgpIDogc3RhdGVEZWNsO1xuXG4gICAgY29uc3Qgc3RhdGUgPSBpbmhlcml0KGluaGVyaXQoc3RhdGVEZWNsLCBTdGF0ZU9iamVjdC5wcm90b3R5cGUpKSBhcyBTdGF0ZU9iamVjdDtcbiAgICBzdGF0ZURlY2wuJCRzdGF0ZSA9ICgpID0+IHN0YXRlO1xuICAgIHN0YXRlLnNlbGYgPSBzdGF0ZURlY2w7XG4gICAgc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlID0ge1xuICAgICAgbmFtZUdsb2I6IEdsb2IuZnJvbVN0cmluZyhzdGF0ZS5uYW1lKSwgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gY2xhc3Mgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3IgKi9cbiAgc3RhdGljIGlzU3RhdGVDbGFzcyA9IChzdGF0ZURlY2w6IF9TdGF0ZURlY2xhcmF0aW9uKTogc3RhdGVEZWNsIGlzIHsgbmV3ICgpOiBTdGF0ZURlY2xhcmF0aW9uIH0gPT5cbiAgICBpc0Z1bmN0aW9uKHN0YXRlRGVjbCkgJiYgc3RhdGVEZWNsWydfX3VpUm91dGVyU3RhdGUnXSA9PT0gdHJ1ZTtcblxuICAvKiogUHJlZGljYXRlIHdoaWNoIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSBvYmplY3QgKi9cbiAgc3RhdGljIGlzU3RhdGUgPSAob2JqOiBhbnkpOiBvYmogaXMgU3RhdGVPYmplY3QgPT4gaXNPYmplY3Qob2JqWydfX3N0YXRlT2JqZWN0Q2FjaGUnXSk7XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBTdGF0ZS5jcmVhdGUoKSAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBTdGF0ZURlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIFN0YXRlT2JqZWN0LmNyZWF0ZShjb25maWcgfHwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIHRoZSBzYW1lIHN0YXRlLlxuICAgKlxuICAgKiBDb21wYXJlcyB0aGUgaWRlbnRpdHkgb2YgdGhlIHN0YXRlIGFnYWluc3QgdGhlIHBhc3NlZCB2YWx1ZSwgd2hpY2ggaXMgZWl0aGVyIGFuIG9iamVjdFxuICAgKiByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBgU3RhdGVgIGluc3RhbmNlLCB0aGUgb3JpZ2luYWwgZGVmaW5pdGlvbiBvYmplY3QgcGFzc2VkIHRvXG4gICAqIGAkc3RhdGVQcm92aWRlci5zdGF0ZSgpYCwgb3IgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gcmVmIENhbiBiZSBvbmUgb2YgKGEpIGEgYFN0YXRlYCBpbnN0YW5jZSwgKGIpIGFuIG9iamVjdCB0aGF0IHdhcyBwYXNzZWRcbiAgICogICAgICAgIGludG8gYCRzdGF0ZVByb3ZpZGVyLnN0YXRlKClgLCAoYykgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lIG9mIGEgc3RhdGUgYXMgYSBzdHJpbmcuXG4gICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGByZWZgIG1hdGNoZXMgdGhlIGN1cnJlbnQgYFN0YXRlYCBpbnN0YW5jZS5cbiAgICovXG4gIGlzKHJlZjogU3RhdGVPYmplY3QgfCBTdGF0ZURlY2xhcmF0aW9uIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMgPT09IHJlZiB8fCB0aGlzLnNlbGYgPT09IHJlZiB8fCB0aGlzLmZxbigpID09PSByZWY7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdGhpcyBkb2VzIG5vdCBwcm9wZXJseSBoYW5kbGUgZG90IG5vdGF0aW9uXG4gICAqIEByZXR1cm5zIFJldHVybnMgYSBkb3Qtc2VwYXJhdGVkIG5hbWUgb2YgdGhlIHN0YXRlLlxuICAgKi9cbiAgZnFuKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCB8fCAhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpIHJldHVybiB0aGlzLm5hbWU7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyZW50LmZxbigpO1xuICAgIHJldHVybiBuYW1lID8gbmFtZSArICcuJyArIHRoaXMubmFtZSA6IHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSByb290IG9mIHRoaXMgc3RhdGUncyB0cmVlLlxuICAgKi9cbiAgcm9vdCgpOiBTdGF0ZU9iamVjdCB7XG4gICAgcmV0dXJuICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5yb290KCkpIHx8IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGUncyBgUGFyYW1gIG9iamVjdHNcbiAgICpcbiAgICogR2V0cyB0aGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyBvd25lZCBieSB0aGUgc3RhdGUuXG4gICAqIElmIGBvcHRzLmluaGVyaXRgIGlzIHRydWUsIGl0IGFsc28gaW5jbHVkZXMgdGhlIGFuY2VzdG9yIHN0YXRlcycgW1tQYXJhbV1dIG9iamVjdHMuXG4gICAqIElmIGBvcHRzLm1hdGNoaW5nS2V5c2AgZXhpc3RzLCByZXR1cm5zIG9ubHkgYFBhcmFtYHMgd2hvc2UgYGlkYCBpcyBhIGtleSBvbiB0aGUgYG1hdGNoaW5nS2V5c2Agb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcbiAgICovXG4gIHBhcmFtZXRlcnMob3B0cz86IHsgaW5oZXJpdD86IGJvb2xlYW47IG1hdGNoaW5nS2V5cz86IGFueSB9KTogUGFyYW1bXSB7XG4gICAgb3B0cyA9IGRlZmF1bHRzKG9wdHMsIHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBudWxsIH0pO1xuICAgIGNvbnN0IGluaGVyaXRlZCA9IChvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVycygpKSB8fCBbXTtcbiAgICByZXR1cm4gaW5oZXJpdGVkXG4gICAgICAuY29uY2F0KHZhbHVlcyh0aGlzLnBhcmFtcykpXG4gICAgICAuZmlsdGVyKHBhcmFtID0+ICFvcHRzLm1hdGNoaW5nS2V5cyB8fCBvcHRzLm1hdGNoaW5nS2V5cy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5pZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaW5nbGUgW1tQYXJhbV1dIHRoYXQgaXMgb3duZWQgYnkgdGhlIHN0YXRlXG4gICAqXG4gICAqIElmIGBvcHRzLmluaGVyaXRgIGlzIHRydWUsIGl0IGFsc28gc2VhcmNoZXMgdGhlIGFuY2VzdG9yIHN0YXRlc2AgW1tQYXJhbV1dcy5cbiAgICogQHBhcmFtIGlkIHRoZSBuYW1lIG9mIHRoZSBbW1BhcmFtXV0gdG8gcmV0dXJuXG4gICAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcbiAgICovXG4gIHBhcmFtZXRlcihpZDogc3RyaW5nLCBvcHRzOiB7IGluaGVyaXQ/OiBib29sZWFuIH0gPSB7fSk6IFBhcmFtIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHRoaXMudXJsICYmIHRoaXMudXJsLnBhcmFtZXRlcihpZCwgb3B0cykpIHx8XG4gICAgICBmaW5kKHZhbHVlcyh0aGlzLnBhcmFtcyksIHByb3BFcSgnaWQnLCBpZCkpIHx8XG4gICAgICAob3B0cy5pbmhlcml0ICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBhcmFtZXRlcihpZCkpXG4gICAgKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZxbigpO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBTdGF0ZU9yTmFtZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyB2YWx1ZXMgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IHNhZmVDb25zb2xlIH0gZnJvbSAnLi4vY29tbW9uL3NhZmVDb25zb2xlJztcblxuZXhwb3J0IGNsYXNzIFN0YXRlTWF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3N0YXRlczogeyBba2V5OiBzdHJpbmddOiBTdGF0ZU9iamVjdCB9KSB7fVxuXG4gIGlzUmVsYXRpdmUoc3RhdGVOYW1lOiBzdHJpbmcpIHtcbiAgICBzdGF0ZU5hbWUgPSBzdGF0ZU5hbWUgfHwgJyc7XG4gICAgcmV0dXJuIHN0YXRlTmFtZS5pbmRleE9mKCcuJykgPT09IDAgfHwgc3RhdGVOYW1lLmluZGV4T2YoJ14nKSA9PT0gMDtcbiAgfVxuXG4gIGZpbmQoc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lLCBiYXNlPzogU3RhdGVPck5hbWUsIG1hdGNoR2xvYiA9IHRydWUpOiBTdGF0ZU9iamVjdCB7XG4gICAgaWYgKCFzdGF0ZU9yTmFtZSAmJiBzdGF0ZU9yTmFtZSAhPT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNTdHIgPSBpc1N0cmluZyhzdGF0ZU9yTmFtZSk7XG4gICAgbGV0IG5hbWU6IHN0cmluZyA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiAoPGFueT5zdGF0ZU9yTmFtZSkubmFtZTtcblxuICAgIGlmICh0aGlzLmlzUmVsYXRpdmUobmFtZSkpIG5hbWUgPSB0aGlzLnJlc29sdmVQYXRoKG5hbWUsIGJhc2UpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuXG4gICAgaWYgKHN0YXRlICYmIChpc1N0ciB8fCAoIWlzU3RyICYmIChzdGF0ZSA9PT0gc3RhdGVPck5hbWUgfHwgc3RhdGUuc2VsZiA9PT0gc3RhdGVPck5hbWUpKSkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyICYmIG1hdGNoR2xvYikge1xuICAgICAgY29uc3QgX3N0YXRlcyA9IHZhbHVlcyh0aGlzLl9zdGF0ZXMpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IF9zdGF0ZXMuZmlsdGVyKFxuICAgICAgICBfc3RhdGUgPT4gX3N0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYiAmJiBfc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlLm5hbWVHbG9iLm1hdGNoZXMobmFtZSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2FmZUNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYHN0YXRlTWF0Y2hlci5maW5kOiBGb3VuZCBtdWx0aXBsZSBtYXRjaGVzIGZvciAke25hbWV9IHVzaW5nIGdsb2I6IGAsXG4gICAgICAgICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gubmFtZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmVzb2x2ZVBhdGgobmFtZTogc3RyaW5nLCBiYXNlOiBTdGF0ZU9yTmFtZSkge1xuICAgIGlmICghYmFzZSkgdGhyb3cgbmV3IEVycm9yKGBObyByZWZlcmVuY2UgcG9pbnQgZ2l2ZW4gZm9yIHBhdGggJyR7bmFtZX0nYCk7XG5cbiAgICBjb25zdCBiYXNlU3RhdGU6IFN0YXRlT2JqZWN0ID0gdGhpcy5maW5kKGJhc2UpO1xuXG4gICAgY29uc3Qgc3BsaXROYW1lID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHBhdGhMZW5ndGggPSBzcGxpdE5hbWUubGVuZ3RoO1xuICAgIGxldCBpID0gMCxcbiAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XG5cbiAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNwbGl0TmFtZVtpXSA9PT0gJycgJiYgaSA9PT0gMCkge1xuICAgICAgICBjdXJyZW50ID0gYmFzZVN0YXRlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxpdE5hbWVbaV0gPT09ICdeJykge1xuICAgICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJyR7bmFtZX0nIG5vdCB2YWxpZCBmb3Igc3RhdGUgJyR7YmFzZVN0YXRlLm5hbWV9J2ApO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHJlbE5hbWUgPSBzcGxpdE5hbWUuc2xpY2UoaSkuam9pbignLicpO1xuICAgIHJldHVybiBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbE5hbWUgPyAnLicgOiAnJykgKyByZWxOYW1lO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuaW1wb3J0IHsgaW5BcnJheSwgaXNTdHJpbmcsIHByb3AgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgX1N0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4vc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgU3RhdGVCdWlsZGVyIH0gZnJvbSAnLi9zdGF0ZUJ1aWxkZXInO1xuaW1wb3J0IHsgU3RhdGVSZWdpc3RyeUxpc3RlbmVyIH0gZnJvbSAnLi9zdGF0ZVJlZ2lzdHJ5JztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgY2xhc3MgU3RhdGVRdWV1ZU1hbmFnZXIgaW1wbGVtZW50cyBEaXNwb3NhYmxlIHtcbiAgcXVldWU6IFN0YXRlT2JqZWN0W10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIsXG4gICAgcHVibGljIHN0YXRlczogeyBba2V5OiBzdHJpbmddOiBTdGF0ZU9iamVjdCB9LFxuICAgIHB1YmxpYyBidWlsZGVyOiBTdGF0ZUJ1aWxkZXIsXG4gICAgcHVibGljIGxpc3RlbmVyczogU3RhdGVSZWdpc3RyeUxpc3RlbmVyW11cbiAgKSB7fVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gIH1cblxuICByZWdpc3RlcihzdGF0ZURlY2w6IF9TdGF0ZURlY2xhcmF0aW9uKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgIGNvbnN0IHN0YXRlID0gU3RhdGVPYmplY3QuY3JlYXRlKHN0YXRlRGVjbCk7XG4gICAgY29uc3QgbmFtZSA9IHN0YXRlLm5hbWU7XG5cbiAgICBpZiAoIWlzU3RyaW5nKG5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG11c3QgaGF2ZSBhIHZhbGlkIG5hbWUnKTtcbiAgICBpZiAodGhpcy5zdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgaW5BcnJheShxdWV1ZS5tYXAocHJvcCgnbmFtZScpKSwgbmFtZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlICcke25hbWV9JyBpcyBhbHJlYWR5IGRlZmluZWRgKTtcblxuICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgIHRoaXMuZmx1c2goKTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHsgcXVldWUsIHN0YXRlcywgYnVpbGRlciB9ID0gdGhpcztcbiAgICBjb25zdCByZWdpc3RlcmVkOiBTdGF0ZU9iamVjdFtdID0gW10sIC8vIHN0YXRlcyB0aGF0IGdvdCByZWdpc3RlcmVkXG4gICAgICBvcnBoYW5zOiBTdGF0ZU9iamVjdFtdID0gW10sIC8vIHN0YXRlcyB0aGF0IGRvbid0IHlldCBoYXZlIGEgcGFyZW50IHJlZ2lzdGVyZWRcbiAgICAgIHByZXZpb3VzUXVldWVMZW5ndGggPSB7fTsgLy8ga2VlcCB0cmFjayBvZiBob3cgbG9uZyB0aGUgcXVldWUgd2hlbiBhbiBvcnBoYW4gd2FzIGZpcnN0IGVuY291bnRlcmVkXG4gICAgY29uc3QgZ2V0U3RhdGUgPSBuYW1lID0+IHRoaXMuc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMuc3RhdGVzW25hbWVdO1xuICAgIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIGlmIChyZWdpc3RlcmVkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCdyZWdpc3RlcmVkJywgcmVnaXN0ZXJlZC5tYXAocyA9PiBzLnNlbGYpKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzdGF0ZTogU3RhdGVPYmplY3QgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgY29uc3QgbmFtZSA9IHN0YXRlLm5hbWU7XG4gICAgICBjb25zdCByZXN1bHQ6IFN0YXRlT2JqZWN0ID0gYnVpbGRlci5idWlsZChzdGF0ZSk7XG4gICAgICBjb25zdCBvcnBoYW5JZHg6IG51bWJlciA9IG9ycGhhbnMuaW5kZXhPZihzdGF0ZSk7XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTdGF0ZSA9IGdldFN0YXRlKG5hbWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZSAmJiBleGlzdGluZ1N0YXRlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlICcke25hbWV9JyBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRnV0dXJlU3RhdGUgPSBnZXRTdGF0ZShuYW1lICsgJy4qKicpO1xuICAgICAgICBpZiAoZXhpc3RpbmdGdXR1cmVTdGF0ZSkge1xuICAgICAgICAgIC8vIFJlbW92ZSBmdXR1cmUgc3RhdGUgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAgICAgIHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkuZGVyZWdpc3RlcihleGlzdGluZ0Z1dHVyZVN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlc1tuYW1lXSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmF0dGFjaFJvdXRlKHN0YXRlKTtcbiAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwKSBvcnBoYW5zLnNwbGljZShvcnBoYW5JZHgsIDEpO1xuICAgICAgICByZWdpc3RlcmVkLnB1c2goc3RhdGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJldiA9IHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV07XG4gICAgICBwcmV2aW91c1F1ZXVlTGVuZ3RoW25hbWVdID0gcXVldWUubGVuZ3RoO1xuICAgICAgaWYgKG9ycGhhbklkeCA+PSAwICYmIHByZXYgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAvLyBXYWl0IHVudGlsIHR3byBjb25zZWN1dGl2ZSBpdGVyYXRpb25zIHdoZXJlIG5vIGFkZGl0aW9uYWwgc3RhdGVzIHdlcmUgZGVxdWV1ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBvcnBoYW5lZCBzdGF0ZSAnJHtuYW1lfSdgKTtcbiAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgICAgfSBlbHNlIGlmIChvcnBoYW5JZHggPCAwKSB7XG4gICAgICAgIG9ycGhhbnMucHVzaChzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgIH1cblxuICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cblxuICBhdHRhY2hSb3V0ZShzdGF0ZTogU3RhdGVPYmplY3QpIHtcbiAgICBpZiAoc3RhdGUuYWJzdHJhY3QgfHwgIXN0YXRlLnVybCkgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGVzQXBpID0gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcztcbiAgICBydWxlc0FwaS5ydWxlKHJ1bGVzQXBpLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShzdGF0ZSkpO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuXG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4vc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgU3RhdGVNYXRjaGVyIH0gZnJvbSAnLi9zdGF0ZU1hdGNoZXInO1xuaW1wb3J0IHsgU3RhdGVCdWlsZGVyIH0gZnJvbSAnLi9zdGF0ZUJ1aWxkZXInO1xuaW1wb3J0IHsgU3RhdGVRdWV1ZU1hbmFnZXIgfSBmcm9tICcuL3N0YXRlUXVldWVNYW5hZ2VyJztcbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24sIF9TdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQnVpbGRlckZ1bmN0aW9uIH0gZnJvbSAnLi9zdGF0ZUJ1aWxkZXInO1xuaW1wb3J0IHsgU3RhdGVPck5hbWUgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyByZW1vdmVGcm9tIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBwcm9wRXEgfSBmcm9tICcuLi9jb21tb24vaG9mJztcblxuLyoqXG4gKiBUaGUgc2lnbmF0dXJlIGZvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcHJvdmlkZWQgdG8gW1tTdGF0ZVJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZF1dLlxuICpcbiAqIFRoaXMgY2FsbGJhY2sgcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnM6XG4gKlxuICogQHBhcmFtIGV2ZW50IGEgc3RyaW5nOyBlaXRoZXIgXCJyZWdpc3RlcmVkXCIgb3IgXCJkZXJlZ2lzdGVyZWRcIlxuICogQHBhcmFtIHN0YXRlcyB0aGUgbGlzdCBvZiBbW1N0YXRlRGVjbGFyYXRpb25dXXMgdGhhdCB3ZXJlIHJlZ2lzdGVyZWQgKG9yIGRlcmVnaXN0ZXJlZCkuXG4gKi9cbmV4cG9ydCB0eXBlIFN0YXRlUmVnaXN0cnlMaXN0ZW5lciA9IChldmVudDogJ3JlZ2lzdGVyZWQnIHwgJ2RlcmVnaXN0ZXJlZCcsIHN0YXRlczogU3RhdGVEZWNsYXJhdGlvbltdKSA9PiB2b2lkO1xuXG5leHBvcnQgY2xhc3MgU3RhdGVSZWdpc3RyeSB7XG4gIHByaXZhdGUgX3Jvb3Q6IFN0YXRlT2JqZWN0O1xuICBwcml2YXRlIHN0YXRlczogeyBba2V5OiBzdHJpbmddOiBTdGF0ZU9iamVjdCB9ID0ge307XG5cbiAgbWF0Y2hlcjogU3RhdGVNYXRjaGVyO1xuICBwcml2YXRlIGJ1aWxkZXI6IFN0YXRlQnVpbGRlcjtcbiAgc3RhdGVRdWV1ZTogU3RhdGVRdWV1ZU1hbmFnZXI7XG5cbiAgbGlzdGVuZXJzOiBTdGF0ZVJlZ2lzdHJ5TGlzdGVuZXJbXSA9IFtdO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgdGhpcy5tYXRjaGVyID0gbmV3IFN0YXRlTWF0Y2hlcih0aGlzLnN0YXRlcyk7XG4gICAgdGhpcy5idWlsZGVyID0gbmV3IFN0YXRlQnVpbGRlcih0aGlzLm1hdGNoZXIsIHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeSk7XG4gICAgdGhpcy5zdGF0ZVF1ZXVlID0gbmV3IFN0YXRlUXVldWVNYW5hZ2VyKHJvdXRlciwgdGhpcy5zdGF0ZXMsIHRoaXMuYnVpbGRlciwgdGhpcy5saXN0ZW5lcnMpO1xuICAgIHRoaXMuX3JlZ2lzdGVyUm9vdCgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBwcml2YXRlIF9yZWdpc3RlclJvb3QoKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlRGVmOiBTdGF0ZURlY2xhcmF0aW9uID0ge1xuICAgICAgbmFtZTogJycsXG4gICAgICB1cmw6ICdeJyxcbiAgICAgIHZpZXdzOiBudWxsLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICcjJzogeyB2YWx1ZTogbnVsbCwgdHlwZTogJ2hhc2gnLCBkeW5hbWljOiB0cnVlIH0sXG4gICAgICB9LFxuICAgICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgfTtcblxuICAgIGNvbnN0IF9yb290ID0gKHRoaXMuX3Jvb3QgPSB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIocm9vdFN0YXRlRGVmKSk7XG4gICAgX3Jvb3QubmF2aWdhYmxlID0gbnVsbDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUuZGlzcG9zZSgpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5nZXQoKS5mb3JFYWNoKHN0YXRlID0+IHRoaXMuZ2V0KHN0YXRlKSAmJiB0aGlzLmRlcmVnaXN0ZXIoc3RhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIGEgU3RhdGUgUmVnaXN0cnkgZXZlbnRzXG4gICAqXG4gICAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiBzdGF0ZXMgYXJlIHJlZ2lzdGVyZWQgb3IgZGVyZWdpc3RlcmVkIHdpdGggdGhlIFN0YXRlUmVnaXN0cnkuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbGV0IGFsbFN0YXRlcyA9IHJlZ2lzdHJ5LmdldCgpO1xuICAgKlxuICAgKiAvLyBMYXRlciwgaW52b2tlIGRlcmVnaXN0ZXJGbigpIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICogbGV0IGRlcmVnaXN0ZXJGbiA9IHJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZCgoZXZlbnQsIHN0YXRlcykgPT4ge1xuICAgKiAgIHN3aXRjaChldmVudCkge1xuICAgKiAgICAgY2FzZTogJ3JlZ2lzdGVyZWQnOlxuICAgKiAgICAgICBzdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiBhbGxTdGF0ZXMucHVzaChzdGF0ZSkpO1xuICAgKiAgICAgICBicmVhaztcbiAgICogICAgIGNhc2U6ICdkZXJlZ2lzdGVyZWQnOlxuICAgKiAgICAgICBzdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAqICAgICAgICAgbGV0IGlkeCA9IGFsbFN0YXRlcy5pbmRleE9mKHN0YXRlKTtcbiAgICogICAgICAgICBpZiAoaWR4ICE9PSAtMSkgYWxsU3RhdGVzLnNwbGljZShpZHgsIDEpO1xuICAgKiAgICAgICB9KTtcbiAgICogICAgICAgYnJlYWs7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgd2hlbiB0aGUgcmVnaXN0ZXJlZCBzdGF0ZXMgY2hhbmdlcy5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0d28gcGFyYW1ldGVycywgYGV2ZW50YCBhbmQgYHN0YXRlYC5cbiAgICogICAgICAgIFNlZSBbW1N0YXRlUmVnaXN0cnlMaXN0ZW5lcl1dXG4gICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBsaXN0ZW5lclxuICAgKi9cbiAgb25TdGF0ZXNDaGFuZ2VkKGxpc3RlbmVyOiBTdGF0ZVJlZ2lzdHJ5TGlzdGVuZXIpOiAoKSA9PiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgcmVtb3ZlRnJvbSh0aGlzLmxpc3RlbmVycykobGlzdGVuZXIpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbXBsaWNpdCByb290IHN0YXRlXG4gICAqXG4gICAqIEdldHMgdGhlIHJvb3Qgb2YgdGhlIHN0YXRlIHRyZWUuXG4gICAqIFRoZSByb290IHN0YXRlIGlzIGltcGxpY2l0bHkgY3JlYXRlZCBieSBVSS1Sb3V0ZXIuXG4gICAqIE5vdGU6IHRoaXMgcmV0dXJucyB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIHJlcHJlc2VudGF0aW9uLCBub3QgYSBbW1N0YXRlRGVjbGFyYXRpb25dXVxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByb290IFtbU3RhdGVPYmplY3RdXVxuICAgKi9cbiAgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3RhdGUgdG8gdGhlIHJlZ2lzdHJ5XG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dIG9yIHF1ZXVlcyBpdCBmb3IgcmVnaXN0cmF0aW9uLlxuICAgKlxuICAgKiBOb3RlOiBhIHN0YXRlIHdpbGwgYmUgcXVldWVkIGlmIHRoZSBzdGF0ZSdzIHBhcmVudCBpc24ndCB5ZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlRGVmaW5pdGlvbiB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgc3RhdGUgdG8gcmVnaXN0ZXIuXG4gICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxuICAgKiAgICAgICAgICBJZiB0aGUgc3RhdGUgd2FzIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkLCB0aGVuIHRoZSBvYmplY3QgaXMgZnVsbHkgYnVpbHQgKFNlZTogW1tTdGF0ZUJ1aWxkZXJdXSkuXG4gICAqICAgICAgICAgIElmIHRoZSBzdGF0ZSB3YXMgb25seSBxdWV1ZWQsIHRoZW4gdGhlIG9iamVjdCBpcyBub3QgZnVsbHkgYnVpbHQuXG4gICAqL1xuICByZWdpc3RlcihzdGF0ZURlZmluaXRpb246IF9TdGF0ZURlY2xhcmF0aW9uKTogU3RhdGVPYmplY3Qge1xuICAgIHJldHVybiB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIoc3RhdGVEZWZpbml0aW9uKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2RlcmVnaXN0ZXJUcmVlKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICAgIGNvbnN0IGFsbCA9IHRoaXMuZ2V0KCkubWFwKHMgPT4gcy4kJHN0YXRlKCkpO1xuICAgIGNvbnN0IGdldENoaWxkcmVuID0gKHN0YXRlczogU3RhdGVPYmplY3RbXSkgPT4ge1xuICAgICAgY29uc3QgX2NoaWxkcmVuID0gYWxsLmZpbHRlcihzID0+IHN0YXRlcy5pbmRleE9mKHMucGFyZW50KSAhPT0gLTEpO1xuICAgICAgcmV0dXJuIF9jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBfY2hpbGRyZW4gOiBfY2hpbGRyZW4uY29uY2F0KGdldENoaWxkcmVuKF9jaGlsZHJlbikpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKFtzdGF0ZV0pO1xuICAgIGNvbnN0IGRlcmVnaXN0ZXJlZDogU3RhdGVPYmplY3RbXSA9IFtzdGF0ZV0uY29uY2F0KGNoaWxkcmVuKS5yZXZlcnNlKCk7XG5cbiAgICBkZXJlZ2lzdGVyZWQuZm9yRWFjaChfc3RhdGUgPT4ge1xuICAgICAgY29uc3QgcnVsZXNBcGkgPSB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLnJ1bGVzO1xuXG4gICAgICAvLyBSZW1vdmUgVVJMIHJ1bGVcbiAgICAgIHJ1bGVzQXBpXG4gICAgICAgIC5ydWxlcygpXG4gICAgICAgIC5maWx0ZXIocHJvcEVxKCdzdGF0ZScsIF9zdGF0ZSkpXG4gICAgICAgIC5mb3JFYWNoKHJ1bGUgPT4gcnVsZXNBcGkucmVtb3ZlUnVsZShydWxlKSk7XG5cbiAgICAgIC8vIFJlbW92ZSBzdGF0ZSBmcm9tIHJlZ2lzdHJ5XG4gICAgICBkZWxldGUgdGhpcy5zdGF0ZXNbX3N0YXRlLm5hbWVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRlcmVnaXN0ZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3RhdGUgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICpcbiAgICogVGhpcyByZW1vdmVzIGEgc3RhdGUgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqIElmIHRoZSBzdGF0ZSBoYXMgY2hpbGRyZW4sIHRoZXkgYXJlIGFyZSBhbHNvIHJlbW92ZWQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUncyBuYW1lIG9yIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAcmV0dXJucyB7U3RhdGVPYmplY3RbXX0gYSBsaXN0IG9mIHJlbW92ZWQgc3RhdGVzXG4gICAqL1xuICBkZXJlZ2lzdGVyKHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSkge1xuICAgIGNvbnN0IF9zdGF0ZSA9IHRoaXMuZ2V0KHN0YXRlT3JOYW1lKTtcbiAgICBpZiAoIV9zdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZGVyZWdpc3RlciBzdGF0ZTsgbm90IGZvdW5kOiBcIiArIHN0YXRlT3JOYW1lKTtcbiAgICBjb25zdCBkZXJlZ2lzdGVyZWRTdGF0ZXMgPSB0aGlzLl9kZXJlZ2lzdGVyVHJlZShfc3RhdGUuJCRzdGF0ZSgpKTtcblxuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoJ2RlcmVnaXN0ZXJlZCcsIGRlcmVnaXN0ZXJlZFN0YXRlcy5tYXAocyA9PiBzLnNlbGYpKSk7XG4gICAgcmV0dXJuIGRlcmVnaXN0ZXJlZFN0YXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCByZWdpc3RlcmVkIHN0YXRlc1xuICAgKlxuICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggbm8gYXJndW1lbnRzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBhbGwgdGhlIHN0YXRlcyB0aGF0IGFyZSBjdXJyZW50bHkgcmVnaXN0ZXJlZC5cbiAgICogTm90ZTogdGhpcyBkb2VzIG5vdCByZXR1cm4gc3RhdGVzIHRoYXQgYXJlICpxdWV1ZWQqIGJ1dCBub3QgeWV0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEByZXR1cm4gYSBsaXN0IG9mIFtbU3RhdGVEZWNsYXJhdGlvbl1dc1xuICAgKi9cbiAgZ2V0KCk6IFN0YXRlRGVjbGFyYXRpb25bXTtcblxuICAvKipcbiAgICogR2V0cyBhIHJlZ2lzdGVyZWQgc3RhdGVcbiAgICpcbiAgICogR2l2ZW4gYSBzdGF0ZSBvciBhIG5hbWUsIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICogTm90ZTogdGhpcyBkb2VzIG5vdCByZXR1cm4gc3RhdGVzIHRoYXQgYXJlICpxdWV1ZWQqIGJ1dCBub3QgeWV0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBlaXRoZXIgdGhlIG5hbWUgb2YgYSBzdGF0ZSwgb3IgYSBzdGF0ZSBvYmplY3QuXG4gICAqIEBwYXJhbSBiYXNlIHRoZSBiYXNlIHN0YXRlIHRvIHVzZSB3aGVuIHN0YXRlT3JOYW1lIGlzIHJlbGF0aXZlLlxuICAgKiBAcmV0dXJuIGEgcmVnaXN0ZXJlZCBbW1N0YXRlRGVjbGFyYXRpb25dXSB0aGF0IG1hdGNoZWQgdGhlIGBzdGF0ZU9yTmFtZWAsIG9yIG51bGwgaWYgdGhlIHN0YXRlIGlzbid0IHJlZ2lzdGVyZWQuXG4gICAqL1xuICBnZXQoc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lLCBiYXNlPzogU3RhdGVPck5hbWUpOiBTdGF0ZURlY2xhcmF0aW9uO1xuICBnZXQoc3RhdGVPck5hbWU/OiBTdGF0ZU9yTmFtZSwgYmFzZT86IFN0YXRlT3JOYW1lKTogYW55IHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDxTdGF0ZURlY2xhcmF0aW9uW10+T2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLm1hcChuYW1lID0+IHRoaXMuc3RhdGVzW25hbWVdLnNlbGYpO1xuICAgIGNvbnN0IGZvdW5kID0gdGhpcy5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIGJhc2UpO1xuICAgIHJldHVybiAoZm91bmQgJiYgZm91bmQuc2VsZikgfHwgbnVsbDtcbiAgfVxuXG4gIGRlY29yYXRvcihuYW1lOiBzdHJpbmcsIGZ1bmM6IEJ1aWxkZXJGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkZXIuYnVpbGRlcihuYW1lLCBmdW5jKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiAqL1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBQcmVkaWNhdGVCaW5hcnkgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcblxuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL3RhcmdldFN0YXRlJztcbmltcG9ydCB7IFJlZ2lzdGVyZWRIb29rIH0gZnJvbSAnLi9ob29rUmVnaXN0cnknO1xuXG4vKipcbiAqIFRoZSBUcmFuc2l0aW9uT3B0aW9ucyBvYmplY3QgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBiZWhhdmlvciBvZiBhIHRyYW5zaXRpb24uXG4gKlxuICogSXQgaXMgcGFzc2VkIGFzIHRoZSB0aGlyZCBhcmd1bWVudCB0byBbW1N0YXRlU2VydmljZS5nb11dLCBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXS5cbiAqIEl0IGNhbiBhbHNvIGJlIHVzZWQgd2l0aCBhIGB1aVNyZWZgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zaXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoaXMgb3B0aW9uIGNoYW5nZXMgaG93IHRoZSBUcmFuc2l0aW9uIGludGVyYWN0cyB3aXRoIHRoZSBicm93c2VyJ3MgbG9jYXRpb24gYmFyIChVUkwpLlxuICAgKlxuICAgKiAtIElmIGB0cnVlYCwgaXQgd2lsbCB1cGRhdGUgdGhlIHVybCBpbiB0aGUgbG9jYXRpb24gYmFyLlxuICAgKiAtIElmIGBmYWxzZWAsIGl0IHdpbGwgbm90IHVwZGF0ZSB0aGUgdXJsIGluIHRoZSBsb2NhdGlvbiBiYXIuXG4gICAqIC0gSWYgaXQgaXMgdGhlIHN0cmluZyBgXCJyZXBsYWNlXCJgLCBpdCB3aWxsIHVwZGF0ZSB0aGUgdXJsIGFuZCBhbHNvIHJlcGxhY2UgdGhlIGxhc3QgaGlzdG9yeSByZWNvcmQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgKi9cbiAgbG9jYXRpb24/OiBib29sZWFuIHwgc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGVuIHRyYW5zaXRpb25pbmcgdG8gcmVsYXRpdmUgcGF0aCAoZS5nICdgXmAnKSwgdGhpcyBvcHRpb24gZGVmaW5lcyB3aGljaCBzdGF0ZSB0byBiZSByZWxhdGl2ZSBmcm9tLlxuICAgKiBAZGVmYXVsdCBgJHN0YXRlLmN1cnJlbnRgXG4gICAqL1xuICByZWxhdGl2ZT86IHN0cmluZyB8IFN0YXRlRGVjbGFyYXRpb24gfCBTdGF0ZU9iamVjdDtcblxuICAvKipcbiAgICogVGhpcyBvcHRpb24gc2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgdHJhbnNpdGlvbidzIHBhcmFtZXRlciB2YWx1ZXMgc2hvdWxkIGJlIGluaGVyaXRlZCBmcm9tXG4gICAqIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqXG4gICAqIC0gSWYgYHRydWVgLCBpdCB3aWxsIGluaGVyaXQgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIC0gSWYgYGZhbHNlYCwgb25seSB0aGUgcGFyYW1ldGVycyB3aGljaCBhcmUgcHJvdmlkZWQgdG8gYHRyYW5zaXRpb25Ub2Agd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBpbmhlcml0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG5vdGlmeT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoaXMgb3B0aW9uIG1heSBiZSB1c2VkIHRvIGZvcmNlIHN0YXRlcyB3aGljaCBhcmUgY3VycmVudGx5IGFjdGl2ZSB0byByZWxvYWQuXG4gICAqXG4gICAqIER1cmluZyBhIG5vcm1hbCB0cmFuc2l0aW9uLCBhIHN0YXRlIGlzIFwicmV0YWluZWRcIiBpZjpcbiAgICogLSBJdCB3YXMgcHJldmlvdXNseSBhY3RpdmVcbiAgICogLSBUaGUgc3RhdGUncyBwYXJhbWV0ZXIgdmFsdWVzIGhhdmUgbm90IGNoYW5nZWRcbiAgICogLSBBbGwgdGhlIHBhcmVudCBzdGF0ZXMnIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBub3QgY2hhbmdlZFxuICAgKlxuICAgKiBGb3JjaW5nIGEgcmVsb2FkIG9mIGEgc3RhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBleGl0ZWQgYW5kIGVudGVyZWQsIHdoaWNoIHdpbGw6XG4gICAqIC0gUmVmZXRjaCB0aGF0IHN0YXRlJ3MgcmVzb2x2ZSBkYXRhXG4gICAqIC0gRXhpdCB0aGUgc3RhdGUgKG9uRXhpdCBob29rKVxuICAgKiAtIFJlLWVudGVyIHRoZSBzdGF0ZSAob25FbnRlciBob29rKVxuICAgKiAtIFJlLXJlbmRlciB0aGUgdmlld3MgKGNvbnRyb2xsZXJzIGFuZCB0ZW1wbGF0ZXMpXG4gICAqXG4gICAqIC0gV2hlbiBgdHJ1ZWAsIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSAoYW5kIGFsbCBwYXJlbnQgc3RhdGVzKSB3aWxsIGJlIHJlbG9hZGVkLlxuICAgKiAtIFdoZW4gaXQgaXMgYSBzdHJpbmcgYW5kIGlzIHRoZSBuYW1lIG9mIGEgc3RhdGUsIG9yIHdoZW4gaXQgaXMgYSBTdGF0ZSBvYmplY3QsXG4gICAqICAgdGhhdCBzdGF0ZSBhbmQgYW55IGNoaWxkcmVuIHN0YXRlcyB3aWxsIGJlIHJlbG9hZGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICByZWxvYWQ/OiBib29sZWFuIHwgc3RyaW5nIHwgU3RhdGVEZWNsYXJhdGlvbiB8IFN0YXRlT2JqZWN0O1xuICAvKipcbiAgICogWW91IGNhbiBkZWZpbmUgeW91ciBvd24gVHJhbnNpdGlvbiBPcHRpb25zIGluc2lkZSB0aGlzIHByb3BlcnR5IGFuZCB1c2UgdGhlbSwgZS5nLiwgZnJvbSBhIFRyYW5zaXRpb24gSG9va1xuICAgKi9cbiAgY3VzdG9tPzogYW55O1xuICAvKipcbiAgICogVGhpcyBvcHRpb24gbWF5IGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBhY3RpdmUgdHJhbnNpdGlvbiAoaWYgb25lIGlzIGFjdGl2ZSkgaW4gZmF2b3VyIG9mIHRoZSB0aGlzIG9uZS5cbiAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb3IgdWktcm91dGVyLlxuICAgKlxuICAgKlxuICAgKiAtIFdoZW4gYHRydWVgLCB0aGUgYWN0aXZlIHRyYW5zaXRpb24gd2lsbCBiZSBjYW5jZWxlZCBhbmQgbmV3IHRyYW5zaXRpb24gd2lsbCBiZWdpbi5cbiAgICogLSB3aGVuIGBmYWxzZWAsIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgY2FuY2VsZWQgaWYgYSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgcnVubmluZy4gVGhpcyBjYW4gYmUgdXNlZnVsIGluIGNhc2VzIHdoZXJlXG4gICAqIHlvdSBvbmx5IHdhbnQgdG8gbmF2aWdhdGUgdG8gYSBkaWZmZXJlbnQgc3RhdGUgaWYgeW91IGFyZSBub3QgYWxyZWFkeSBuYXZpZ2F0aW5nIHNvbWV3aGVyZS5cbiAgICpcbiAgICogQGRlZmF1bHQgYHRydWVgXG4gICAqL1xuICBzdXBlcmNlZGU/OiBib29sZWFuO1xuICAvKiogQGludGVybmFsYXBpICovXG4gIHJlbG9hZFN0YXRlPzogU3RhdGVPYmplY3Q7XG4gIC8qKiBAaW50ZXJuYWxhcGlcbiAgICogSWYgdGhpcyB0cmFuc2l0aW9uIGlzIGEgcmVkaXJlY3QsIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIHRoZSBvcmlnaW5hbCBUcmFuc2l0aW9uICh3aGljaCB3YXMgcmVkaXJlY3RlZCB0byB0aGlzIG9uZSlcbiAgICovXG4gIHJlZGlyZWN0ZWRGcm9tPzogVHJhbnNpdGlvbjtcbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBjdXJyZW50PzogKCkgPT4gVHJhbnNpdGlvbjtcbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBzb3VyY2U/OiAnc3JlZicgfCAndXJsJyB8ICdyZWRpcmVjdCcgfCAnb3RoZXJ3aXNlJyB8ICd1bmtub3duJztcbn1cblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2l0aW9uSG9va09wdGlvbnMge1xuICBjdXJyZW50PzogKCkgPT4gVHJhbnNpdGlvbjsgLy8gcGF0aD9cbiAgdHJhbnNpdGlvbj86IFRyYW5zaXRpb247XG4gIGhvb2tUeXBlPzogc3RyaW5nO1xuICB0YXJnZXQ/OiBhbnk7XG4gIHRyYWNlRGF0YT86IGFueTtcbiAgYmluZD86IGFueTtcbiAgc3RhdGVIb29rPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUcmVlQ2hhbmdlcyBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgUGF0aHMgdGhhdCBhcmUgaW52b2x2ZWQgaW4gYSBUcmFuc2l0aW9uLlxuICpcbiAqIEdldCBhIFRyZWVDaGFuZ2VzIG9iamVjdCB1c2luZyBbW1RyYW5zaXRpb24udHJlZUNoYW5nZXNdXVxuICpcbiAqIEEgVUktUm91dGVyIFRyYW5zaXRpb24gaXMgZnJvbSBvbmUgUGF0aCBpbiBhIFN0YXRlIFRyZWUgdG8gYW5vdGhlciBQYXRoLiAgRm9yIGEgZ2l2ZW4gVHJhbnNpdGlvbixcbiAqIHRoaXMgb2JqZWN0IHN0b3JlcyB0aGUgXCJ0b1wiIGFuZCBcImZyb21cIiBwYXRocywgYXMgd2VsbCBhcyBzdWJzZXRzIG9mIHRob3NlOiB0aGUgXCJyZXRhaW5lZFwiLFxuICogXCJleGl0aW5nXCIgYW5kIFwiZW50ZXJpbmdcIiBwYXRocy5cbiAqXG4gKiBFYWNoIHBhdGggaW4gVHJlZUNoYW5nZXMgaXMgYW4gYXJyYXkgb2YgW1tQYXRoTm9kZV1dIG9iamVjdHMuIEVhY2ggUGF0aE5vZGUgaW4gdGhlIGFycmF5IGNvcnJlc3BvbmRzIHRvIGEgcG9ydGlvblxuICogb2YgYSBuZXN0ZWQgc3RhdGUuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYWQgYSBuZXN0ZWQgc3RhdGUgbmFtZWQgYGZvby5iYXIuYmF6YCwgaXQgd291bGQgaGF2ZSB0aHJlZVxuICogcG9ydGlvbnMsIGBmb28sIGJhciwgYmF6YC4gIElmIHlvdSB0cmFuc2l0aW9uZWQgKip0byoqIGBmb28uYmFyLmJhemAgYW5kIGluc3BlY3RlZCB0aGUgW1tUcmVlQ2hhbmdlcy50b11dXG4gKiBQYXRoLCB5b3Ugd291bGQgZmluZCBhIG5vZGUgaW4gdGhlIGFycmF5IGZvciBlYWNoIHBvcnRpb246IGBmb29gLCBgYmFyYCwgYW5kIGBiYXpgLlxuICpcbiAqIC0tLVxuICpcbiAqIEB0b2RvIHNob3cgdmlzdWFsIHN0YXRlIHRyZWVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmVlQ2hhbmdlcyB7XG4gIC8qKiBAbm9kb2MgKi9cbiAgW2tleTogc3RyaW5nXTogUGF0aE5vZGVbXSB8IHVuZGVmaW5lZDtcblxuICAvKiogVGhlIHBhdGggb2Ygbm9kZXMgaW4gdGhlIHN0YXRlIHRyZWUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBjb21pbmcgKmZyb20qICovXG4gIGZyb206IFBhdGhOb2RlW107XG5cbiAgLyoqIFRoZSBwYXRoIG9mIG5vZGVzIGluIHRoZSBzdGF0ZSB0cmVlIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgZ29pbmcgKnRvKiAqL1xuICB0bzogUGF0aE5vZGVbXTtcblxuICAvKipcbiAgICogVGhlIHBhdGggb2YgYWN0aXZlIG5vZGVzIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgcmV0YWluaW5nLlxuICAgKlxuICAgKiBUaGVzZSBub2RlcyBhcmUgbmVpdGhlciBleGl0ZWQsIG5vciBlbnRlcmVkLlxuICAgKiBCZWZvcmUgYW5kIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZXNlIG5vZGVzIGFyZSBhY3RpdmUuXG4gICAqL1xuICByZXRhaW5lZDogUGF0aE5vZGVbXTtcblxuICAvKipcbiAgICogVGhlIHBhdGggb2YgYWN0aXZlIG5vZGVzIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgcmV0YWluaW5nIHdpdGggdXBkYXRlZCBcInRvIHBhcmFtc1wiIGFwcGxpZWQuXG4gICAqXG4gICAqIFRoZXNlIG5vZGVzIGFyZSBuZWl0aGVyIGV4aXRlZCwgbm9yIGVudGVyZWQuXG4gICAqIEJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlc2Ugbm9kZXMgYXJlIGFjdGl2ZS5cbiAgICpcbiAgICogVGhpcyBpcyBhIHNoYWxsb3cgY29weSBvZiBbW3JldGFpbmVkXV0sIGJ1dCB3aXRoIG5ldyAoZHluYW1pYykgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIFtbdG9dXSBhcHBsaWVkLlxuICAgKi9cbiAgcmV0YWluZWRXaXRoVG9QYXJhbXM6IFBhdGhOb2RlW107XG5cbiAgLyoqXG4gICAqIFRoZSBwYXRoIG9mIHByZXZpb3VzbHkgYWN0aXZlIG5vZGVzIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgZXhpdGluZy5cbiAgICpcbiAgICogQWZ0ZXIgdGhlIFRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlc2Ugbm9kZXMgYXJlIG5vIGxvbmdlciBhY3RpdmUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBhIHN0YXRlIHRoYXQgaXMgYmVpbmcgcmVsb2FkZWQgKGR1ZSB0byBwYXJhbWV0ZXIgdmFsdWVzIGNoYW5naW5nLCBvciBgcmVsb2FkOiB0cnVlYCkgbWF5IGJlIGluIGJvdGggdGhlXG4gICAqIGBleGl0aW5nYCBhbmQgYGVudGVyaW5nYCBwYXRocy5cbiAgICovXG4gIGV4aXRpbmc6IFBhdGhOb2RlW107XG5cbiAgLyoqXG4gICAqIFRoZSBwYXRoIG9mIG5vZGVzIHRoYXQgdGhlIHRyYW5zaXRpb24gaXMgZW50ZXJpbmcuXG4gICAqXG4gICAqIEFmdGVyIHRoZSBUcmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZXNlIG5vZGVzIHdpbGwgYmUgYWN0aXZlLlxuICAgKiBCZWNhdXNlIHRoZXkgYXJlIGVudGVyaW5nLCB0aGV5IGhhdmUgdGhlaXIgcmVzb2x2ZXMgZmV0Y2hlZCwgYG9uRW50ZXJgIGhvb2tzIHJ1biwgYW5kIHRoZWlyIHZpZXdzXG4gICAqIChjb21wb25lbnQocykgb3IgY29udHJvbGxlcihzKSt0ZW1wbGF0ZShzKSkgcmVmcmVzaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYSBzdGF0ZSB0aGF0IGlzIHJlbG9hZGVkIChkdWUgdG8gcGFyYW1ldGVyIHZhbHVlcyBjaGFuZ2luZywgb3IgYHJlbG9hZDogdHJ1ZWApIG1heSBiZSBpbiBib3RoIHRoZVxuICAgKiBgZXhpdGluZ2AgYW5kIGBlbnRlcmluZ2AgcGF0aHMuXG4gICAqL1xuICBlbnRlcmluZzogUGF0aE5vZGVbXTtcbn1cblxuZXhwb3J0IHR5cGUgSUhvb2tSZWdpc3RyYXRpb24gPSAoXG4gIG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLFxuICBjYWxsYmFjazogSG9va0ZuLFxuICBvcHRpb25zPzogSG9va1JlZ09wdGlvbnNcbikgPT4gRnVuY3Rpb247XG5cbi8qKlxuICogVGhlIHNpZ25hdHVyZSBmb3IgVHJhbnNpdGlvbiBIb29rcy5cbiAqXG4gKiBUcmFuc2l0aW9uIGhvb2tzIGFyZSBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBob29rIGludG8gdGhlIGxpZmVjeWNsZSBvZiB0cmFuc2l0aW9ucy5cbiAqIEFzIGEgdHJhbnNpdGlvbiBydW5zLCBpdCByZWFjaGVzIGNlcnRhaW4gbGlmZWN5Y2xlIGV2ZW50cy5cbiAqIEFzIGVhY2ggZXZlbnQgb2NjdXJzLCB0aGUgaG9va3Mgd2hpY2ggYXJlIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCBhcmUgY2FsbGVkIChpbiBwcmlvcml0eSBvcmRlcikuXG4gKlxuICogQSB0cmFuc2l0aW9uIGhvb2sgbWF5IGFsdGVyIGEgVHJhbnNpdGlvbiBieSByZXR1cm5pbmcgYSBbW0hvb2tSZXN1bHRdXS5cbiAqXG4gKiAjIyMjIFNlZTpcbiAqXG4gKiAtIFtbSUhvb2tSZWdpc3RyeS5vbkJlZm9yZV1dXG4gKiAtIFtbSUhvb2tSZWdpc3RyeS5vblN0YXJ0XV1cbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uRmluaXNoXV1cbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uU3VjY2Vzc11dXG4gKiAtIFtbSUhvb2tSZWdpc3RyeS5vbkVycm9yXV1cbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgY3VycmVudCBbW1RyYW5zaXRpb25dXVxuICogQHBhcmFtIGluamVjdG9yIChmb3IgbmcxIG9yIG5nMiBvbmx5KSB0aGUgaW5qZWN0b3Igc2VydmljZVxuICpcbiAqIEByZXR1cm5zIGEgW1tIb29rUmVzdWx0XV0gd2hpY2ggbWF5IGFsdGVyIHRoZSB0cmFuc2l0aW9uXG4gKlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zaXRpb25Ib29rRm4ge1xuICAodHJhbnNpdGlvbjogVHJhbnNpdGlvbik6IEhvb2tSZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIHNpZ25hdHVyZSBmb3IgVHJhbnNpdGlvbiBTdGF0ZSBIb29rcy5cbiAqXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIGhvb2tzIGludG8gYSBsaWZlY3ljbGUgZXZlbnQgZm9yIGEgc3BlY2lmaWMgc3RhdGUuXG4gKlxuICogVHJhbnNpdGlvbiBTdGF0ZSBIb29rcyBhcmUgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgaG9vayBpbnRvIHRoZSBsaWZlY3ljbGUgZXZlbnRzIG9mIHNwZWNpZmljIHN0YXRlcyBkdXJpbmcgYSB0cmFuc2l0aW9uLlxuICogQXMgYSB0cmFuc2l0aW9uIHJ1bnMsIGl0IG1heSBleGl0IHNvbWUgc3RhdGVzLCByZXRhaW4gKGtlZXApIHN0YXRlcywgYW5kIGVudGVyIHN0YXRlcy5cbiAqIEFzIGVhY2ggbGlmZWN5Y2xlIGV2ZW50IG9jY3VycywgdGhlIGhvb2tzIHdoaWNoIGFyZSByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnQgYW5kIHRoYXQgc3RhdGUgYXJlIGNhbGxlZCAoaW4gcHJpb3JpdHkgb3JkZXIpLlxuICpcbiAqICMjIyMgU2VlOlxuICpcbiAqIC0gW1tJSG9va1JlZ2lzdHJ5Lm9uRXhpdF1dXG4gKiAtIFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXG4gKiAtIFtbSUhvb2tSZWdpc3RyeS5vbkVudGVyXV1cbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgY3VycmVudCBbW1RyYW5zaXRpb25dXVxuICogQHBhcmFtIHN0YXRlIHRoZSBbW1N0YXRlT2JqZWN0XV0gdGhhdCB0aGUgaG9vayBpcyBib3VuZCB0b1xuICogQHBhcmFtIGluamVjdG9yIChmb3IgbmcxIG9yIG5nMiBvbmx5KSB0aGUgaW5qZWN0b3Igc2VydmljZVxuICpcbiAqIEByZXR1cm5zIGEgW1tIb29rUmVzdWx0XV0gd2hpY2ggbWF5IGFsdGVyIHRoZSB0cmFuc2l0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNpdGlvblN0YXRlSG9va0ZuIHtcbiAgKHRyYW5zaXRpb246IFRyYW5zaXRpb24sIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKTogSG9va1Jlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgc2lnbmF0dXJlIGZvciBUcmFuc2l0aW9uIG9uQ3JlYXRlIEhvb2tzLlxuICpcbiAqIFRyYW5zaXRpb24gb25DcmVhdGUgSG9va3MgYXJlIGNhbGxiYWNrcyB0aGF0IGFsbG93IGN1c3RvbWl6YXRpb24gb3IgcHJlcHJvY2Vzc2luZyBvZlxuICogYSBUcmFuc2l0aW9uIGJlZm9yZSBpdCBpcyByZXR1cm5lZCBmcm9tIFtbVHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlXV1cbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgW1tUcmFuc2l0aW9uXV0gdGhhdCB3YXMganVzdCBjcmVhdGVkXG4gKiBAcmV0dXJuIGEgW1tUcmFuc2l0aW9uXV0gd2hpY2ggd2lsbCB0aGVuIGJlIHJldHVybmVkIGZyb20gW1tUcmFuc2l0aW9uU2VydmljZS5jcmVhdGVdXVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zaXRpb25DcmVhdGVIb29rRm4ge1xuICAodHJhbnNpdGlvbjogVHJhbnNpdGlvbik6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIEhvb2tGbiA9IFRyYW5zaXRpb25Ib29rRm4gfCBUcmFuc2l0aW9uU3RhdGVIb29rRm4gfCBUcmFuc2l0aW9uQ3JlYXRlSG9va0ZuO1xuXG4vKipcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSBvciBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dXG4gKlxuICogV2hlbiByZXR1cm5lZCBmcm9tIGEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gb3IgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgdGhlc2UgdmFsdWVzIGFsdGVyIHRoZSBydW5uaW5nIFtbVHJhbnNpdGlvbl1dOlxuICpcbiAqIC0gYGZhbHNlYDogdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBjYW5jZWxsZWQuXG4gKiAtIFtbVGFyZ2V0U3RhdGVdXTogdGhlIHRyYW5zaXRpb24gd2lsbCBiZSByZWRpcmVjdGVkIHRvIHRoZSBuZXcgdGFyZ2V0IHN0YXRlIChzZWU6IFtbU3RhdGVTZXJ2aWNlLnRhcmdldF1dKVxuICogLSBgUHJvbWlzZWA6IHRoZSB0cmFuc2l0aW9uIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBvciByZWplY3RcbiAqICAgIC0gSWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgKG9yIHJlc29sdmVzIHRvIGBmYWxzZWApLCB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGNhbmNlbGxlZFxuICogICAgLSBJZiB0aGUgcHJvbWlzZSByZXNvbHZlcyB0byBhIFtbVGFyZ2V0U3RhdGVdXSwgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSByZWRpcmVjdGVkXG4gKiAgICAtIElmIHRoZSBwcm9taXNlIHJlc29sdmVzIHRvIGFueXRoaW5nIGVsc2UsIHRoZSB0cmFuc2l0aW9uIHdpbGwgcmVzdW1lXG4gKiAtIEFueXRoaW5nIGVsc2U6IHRoZSB0cmFuc2l0aW9uIHdpbGwgcmVzdW1lXG4gKi9cbmV4cG9ydCB0eXBlIEhvb2tSZXN1bHQgPSBib29sZWFuIHwgVGFyZ2V0U3RhdGUgfCB2b2lkIHwgUHJvbWlzZTxib29sZWFuIHwgVGFyZ2V0U3RhdGUgfCB2b2lkPjtcblxuLyoqXG4gKiBUaGVzZSBvcHRpb25zIG1heSBiZSBwcm92aWRlZCB3aGVuIHJlZ2lzdGVyaW5nIGEgVHJhbnNpdGlvbiBIb29rIChzdWNoIGFzIGBvblN0YXJ0YClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIb29rUmVnT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmlvcml0eSBvZiB0aGUgcmVnaXN0ZXJlZCBob29rXG4gICAqXG4gICAqIEhvb2tzIG9mIHRoZSBzYW1lIHR5cGUgKG9uQmVmb3JlLCBvblN0YXJ0LCBldGMpIGFyZSBpbnZva2VkIGluIHByaW9yaXR5IG9yZGVyLiAgQSBob29rIHdpdGggYSBoaWdoZXIgcHJpb3JpdHlcbiAgICogaXMgaW52b2tlZCBiZWZvcmUgYSBob29rIHdpdGggYSBsb3dlciBwcmlvcml0eS5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgaG9vayBwcmlvcml0eSBpcyAwXG4gICAqL1xuICBwcmlvcml0eT86IG51bWJlcjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQgYHRoaXNgIGlzIGJvdW5kIHRvIGR1cmluZyBob29rIGludm9jYXRpb24uXG4gICAqL1xuICBiaW5kPzogYW55O1xuXG4gIC8qKlxuICAgKiBMaW1pdHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSBob29rIHdpbGwgYmUgaW52b2tlZC5cbiAgICogT25jZSB0aGUgaG9vayBoYXMgYmVlbiBpbnZva2VkIHRoaXMgbWFueSB0aW1lcywgaXQgaXMgYXV0b21hdGljYWxseSBkZXJlZ2lzdGVyZWQuXG4gICAqL1xuICBpbnZva2VMaW1pdD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBzcGVjaWZpZXMgdGhlIGFwaSBmb3IgcmVnaXN0ZXJpbmcgVHJhbnNpdGlvbiBIb29rcy4gIEJvdGggdGhlXG4gKiBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gYW5kIGFsc28gdGhlIFtbVHJhbnNpdGlvbl1dIG9iamVjdCBpdHNlbGYgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxuICogTm90ZTogdGhlIFRyYW5zaXRpb24gb2JqZWN0IG9ubHkgYWxsb3dzIGhvb2tzIHRvIGJlIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBUcmFuc2l0aW9uIGlzIHN0YXJ0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUhvb2tSZWdpc3RyeSB7XG4gIC8qKiBAaGlkZGVuIHBsYWNlIHRvIHN0b3JlIHRoZSBob29rcyAqL1xuICBfcmVnaXN0ZXJlZEhvb2tzOiB7IFtrZXk6IHN0cmluZ106IFJlZ2lzdGVyZWRIb29rW10gfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uSG9va0ZuXV0sIGNhbGxlZCAqYmVmb3JlIGEgdHJhbnNpdGlvbiBzdGFydHMqLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGJlZm9yZSBhIHRyYW5zaXRpb24gZXZlbiBiZWdpbnMuXG4gICAqIFRoaXMgaG9vayBjYW4gYmUgdXNlZnVsIHRvIGltcGxlbWVudCBsb2dpYyB3aGljaCBwcmV2ZW50cyBhIHRyYW5zaXRpb24gZnJvbSBldmVuIHN0YXJ0aW5nLCBzdWNoXG4gICAqIGFzIGF1dGhlbnRpY2F0aW9uLCByZWRpcmVjdGlvblxuICAgKlxuICAgKiBTZWUgW1tUcmFuc2l0aW9uSG9va0ZuXV0gZm9yIHRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogVG8gbWF0Y2ggYWxsIFRyYW5zaXRpb25zLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogYG9uQmVmb3JlYCBob29rcyBhcmUgaW52b2tlZCAqYmVmb3JlIGEgVHJhbnNpdGlvbiBzdGFydHMqLlxuICAgKiBObyByZXNvbHZlcyBoYXZlIGJlZW4gZmV0Y2hlZCB5ZXQuXG4gICAqIEVhY2ggYG9uQmVmb3JlYCBob29rIGlzIGludm9rZWQgc3luY2hyb25vdXNseSwgaW4gdGhlIHNhbWUgY2FsbCBzdGFjayBhcyBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXS5cbiAgICogVGhlIHJlZ2lzdGVyZWQgYG9uQmVmb3JlYCBob29rcyBhcmUgaW52b2tlZCBpbiBwcmlvcml0eSBvcmRlci5cbiAgICpcbiAgICogTm90ZTogZHVyaW5nIHRoZSBgb25CZWZvcmVgIHBoYXNlLCBhZGRpdGlvbmFsIGhvb2tzIGNhbiBiZSBhZGRlZCB0byB0aGUgc3BlY2lmaWMgW1tUcmFuc2l0aW9uXV0gaW5zdGFuY2UuXG4gICAqIFRoZXNlIFwib24tdGhlLWZseVwiIGhvb2tzIG9ubHkgYWZmZWN0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0cmFuc2l0aW9uLi5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byBwYXVzZSwgY2FuY2VsLCBvciByZWRpcmVjdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uLlxuICAgKiBTZWUgW1tIb29rUmVzdWx0XV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIElmIGFueSBob29rIG1vZGlmaWVzIHRoZSB0cmFuc2l0aW9uICpzeW5jaHJvbm91c2x5KiAoYnkgdGhyb3dpbmcsIHJldHVybmluZyBgZmFsc2VgLCBvciByZXR1cm5pbmdcbiAgICogYSBbW1RhcmdldFN0YXRlXV0pLCB0aGUgcmVtYWluZGVyIG9mIHRoZSBob29rcyBhcmUgc2tpcHBlZC5cbiAgICogSWYgYSBob29rIHJldHVybnMgYSBwcm9taXNlLCB0aGUgcmVtYWluZGVyIG9mIHRoZSBgb25CZWZvcmVgIGhvb2tzIGFyZSBzdGlsbCBpbnZva2VkIHN5bmNocm9ub3VzbHkuXG4gICAqIEFsbCBwcm9taXNlcyBhcmUgcmVzb2x2ZWQsIGFuZCBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkgYmVmb3JlIHRoZSBgb25TdGFydGAgcGhhc2Ugb2YgdGhlIFRyYW5zaXRpb24uXG4gICAqXG4gICAqICMjIyBFeGFtcGxlc1xuICAgKlxuICAgKiAjIyMjIERlZmF1bHQgU3Vic3RhdGVcbiAgICpcbiAgICogVGhpcyBleGFtcGxlIHJlZGlyZWN0cyBhbnkgdHJhbnNpdGlvbiBmcm9tICdob21lJyB0byAnaG9tZS5kYXNoYm9hcmQnLiAgVGhpcyBpcyBjb21tb25seSByZWZlcnJlZCB0byBhcyBhXG4gICAqIFwiZGVmYXVsdCBzdWJzdGF0ZVwiLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAvLyBuZzJcbiAgICogdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoeyB0bzogJ2hvbWUnIH0sICh0cmFuczogVHJhbnNpdGlvbikgPT5cbiAgICogICAgIHRyYW5zLnJvdXRlci5zdGF0ZVNlcnZpY2UudGFyZ2V0KFwiaG9tZS5kYXNoYm9hcmRcIikpO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBEYXRhIERyaXZlbiBEZWZhdWx0IFN1YnN0YXRlXG4gICAqXG4gICAqIFRoaXMgZXhhbXBsZSBwcm92aWRlcyBkYXRhLWRyaXZlbiBkZWZhdWx0IHN1YnN0YXRlIGZ1bmN0aW9uYWxpdHkuIEl0IG1hdGNoZXMgb24gYSB0cmFuc2l0aW9uIHRvIGFueSBzdGF0ZVxuICAgKiB3aGljaCBoYXMgYGRlZmF1bHRTdWJzdGF0ZTogXCJzb21lLnN1Yi5zdGF0ZVwiYCBkZWZpbmVkLiAgU2VlOiBbW1RyYW5zaXRpb24udG9dXSB3aGljaCByZXR1cm5zIHRoZSBcInRvIHN0YXRlXCJcbiAgICogZGVmaW5pdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogLy8gbmcxXG4gICAqIC8vIHN0YXRlIGRlY2xhcmF0aW9uXG4gICAqIHtcbiAgICogICBuYW1lOiAnaG9tZScsXG4gICAqICAgdGVtcGxhdGU6ICc8ZGl2IHVpLXZpZXcvPicsXG4gICAqICAgZGVmYXVsdFN1YnN0YXRlOiAnaG9tZS5kYXNoYm9hcmQnXG4gICAqIH1cbiAgICpcbiAgICogdmFyIGNyaXRlcmlhID0ge1xuICAgKiAgIHRvOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgKiAgICAgcmV0dXJuIHN0YXRlLmRlZmF1bHRTdWJzdGF0ZSAhPSBudWxsO1xuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiAkdHJhbnNpdGlvbnMub25CZWZvcmUoY3JpdGVyaWEsIGZ1bmN0aW9uKHRyYW5zOiBUcmFuc2l0aW9uKSB7XG4gICAqICAgdmFyIHN1YnN0YXRlID0gdHJhbnMudG8oKS5kZWZhdWx0U3Vic3RhdGU7XG4gICAqICAgcmV0dXJuIHRyYW5zLnJvdXRlci5zdGF0ZVNlcnZpY2UudGFyZ2V0KHN1YnN0YXRlKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKlxuICAgKiAjIyMjIFJlcXVpcmUgYXV0aGVudGljYXRpb25cbiAgICpcbiAgICogVGhpcyBleGFtcGxlIGNhbmNlbHMgYSB0cmFuc2l0aW9uIHRvIGEgc3RhdGUgd2hpY2ggcmVxdWlyZXMgYXV0aGVudGljYXRpb24sIGlmIHRoZSB1c2VyIGlzIG5vdCBjdXJyZW50bHkgYXV0aGVudGljYXRlZC5cbiAgICpcbiAgICogVGhpcyBleGFtcGxlIGFzc3VtZXMgYSBzdGF0ZSB0cmVlIHdoZXJlIGFsbCBzdGF0ZXMgd2hpY2ggcmVxdWlyZSBhdXRoZW50aWNhdGlvbiBhcmUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgYCdyZXF1aXJlYXV0aCdgIHN0YXRlLlxuICAgKiBUaGlzIGV4YW1wbGUgYXNzdW1lcyBgTXlBdXRoU2VydmljZWAgc3luY2hyb25vdXNseSByZXR1cm5zIGEgYm9vbGVhbiBmcm9tIGBpc0F1dGhlbnRpY2F0ZWQoKWAuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy8gbmcxXG4gICAqICR0cmFuc2l0aW9ucy5vbkJlZm9yZSggeyB0bzogJ3JlcXVpcmVhdXRoLioqJyB9LCBmdW5jdGlvbih0cmFucykge1xuICAgKiAgIHZhciBteUF1dGhTZXJ2aWNlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ015QXV0aFNlcnZpY2UnKTtcbiAgICogICAvLyBJZiBpc0F1dGhlbnRpY2F0ZWQgcmV0dXJucyBmYWxzZSwgdGhlIHRyYW5zaXRpb24gaXMgY2FuY2VsbGVkLlxuICAgKiAgIHJldHVybiBteUF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaENyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbnZva2VkLlxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgKi9cbiAgb25CZWZvcmUobWF0Y2hDcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uSG9va0ZuXV0sIGNhbGxlZCB3aGVuIGEgdHJhbnNpdGlvbiBzdGFydHMuXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgYXMgYSB0cmFuc2l0aW9uIHN0YXJ0cyBydW5uaW5nLlxuICAgKiBUaGlzIGhvb2sgY2FuIGJlIHVzZWZ1bCB0byBwZXJmb3JtIHNvbWUgYXN5bmNocm9ub3VzIGFjdGlvbiBiZWZvcmUgY29tcGxldGluZyBhIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIFNlZSBbW1RyYW5zaXRpb25Ib29rRm5dXSBmb3IgdGhlIHNpZ25hdHVyZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoZSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIGhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBUbyBtYXRjaCBhbGwgVHJhbnNpdGlvbnMsIHVzZSBhbiBlbXB0eSBjcml0ZXJpYSBvYmplY3QgYHt9YC5cbiAgICpcbiAgICogIyMjIExpZmVjeWNsZVxuICAgKlxuICAgKiBgb25TdGFydGAgaG9va3MgYXJlIGludm9rZWQgYXN5bmNocm9ub3VzbHkgd2hlbiB0aGUgVHJhbnNpdGlvbiBzdGFydHMgcnVubmluZy5cbiAgICogVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBgb25CZWZvcmVgIHBoYXNlIGlzIGNvbXBsZXRlLlxuICAgKiBBdCB0aGlzIHBvaW50LCB0aGUgVHJhbnNpdGlvbiBoYXMgbm90IHlldCBleGl0ZWQgbm9yIGVudGVyZWQgYW55IHN0YXRlcy5cbiAgICogVGhlIHJlZ2lzdGVyZWQgYG9uU3RhcnRgIGhvb2tzIGFyZSBpbnZva2VkIGluIHByaW9yaXR5IG9yZGVyLlxuICAgKlxuICAgKiBOb3RlOiBBIGJ1aWx0LWluIGBvblN0YXJ0YCBob29rIHdpdGggaGlnaCBwcmlvcml0eSBpcyB1c2VkIHRvIGZldGNoIGFueSBlYWdlciByZXNvbHZlIGRhdGEuXG4gICAqXG4gICAqICMjIyBSZXR1cm4gdmFsdWVcbiAgICpcbiAgICogVGhlIGhvb2sncyByZXR1cm4gdmFsdWUgY2FuIGJlIHVzZWQgdG8gcGF1c2UsIGNhbmNlbCwgb3IgcmVkaXJlY3QgdGhlIGN1cnJlbnQgVHJhbnNpdGlvbi5cbiAgICogU2VlIFtbSG9va1Jlc3VsdF1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiAjIyMjIExvZ2luIGR1cmluZyB0cmFuc2l0aW9uXG4gICAqXG4gICAqIFRoaXMgZXhhbXBsZSBpbnRlcmNlcHRzIGFueSB0cmFuc2l0aW9uIHRvIGEgc3RhdGUgd2hpY2ggcmVxdWlyZXMgYXV0aGVudGljYXRpb24sIHdoZW4gdGhlIHVzZXIgaXNcbiAgICogbm90IGN1cnJlbnRseSBhdXRoZW50aWNhdGVkLiAgSXQgYWxsb3dzIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhc3luY2hyb25vdXNseSwgdGhlbiByZXN1bWVzIHRoZVxuICAgKiB0cmFuc2l0aW9uLiAgSWYgdGhlIHVzZXIgZGlkIG5vdCBhdXRoZW50aWNhdGUgc3VjY2Vzc2Z1bGx5LCBpdCByZWRpcmVjdHMgdG8gdGhlIFwiZ3Vlc3RcIiBzdGF0ZSwgd2hpY2hcbiAgICogZG9lcyBub3QgcmVxdWlyZSBhdXRoZW50aWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBleGFtcGxlIGFzc3VtZXM6XG4gICAqIC0gYSBzdGF0ZSB0cmVlIHdoZXJlIGFsbCBzdGF0ZXMgd2hpY2ggcmVxdWlyZSBhdXRoZW50aWNhdGlvbiBhcmUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgYCdhdXRoJ2Agc3RhdGUuXG4gICAqIC0gYE15QXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKClgIHN5bmNocm9ub3VzbHkgcmV0dXJucyBhIGJvb2xlYW4uXG4gICAqIC0gYE15QXV0aFNlcnZpY2UuYXV0aGVudGljYXRlKClgIHByZXNlbnRzIGEgbG9naW4gZGlhbG9nLCBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWRcbiAgICogICBvciByZWplY3RlZCwgd2hldGhlciBvciBub3QgdGhlIGxvZ2luIGF0dGVtcHQgd2FzIHN1Y2Nlc3NmdWwuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy8gbmcxXG4gICAqICR0cmFuc2l0aW9ucy5vblN0YXJ0KCB7IHRvOiAnYXV0aC4qKicgfSwgZnVuY3Rpb24odHJhbnMpIHtcbiAgICogICB2YXIgJHN0YXRlID0gdHJhbnMucm91dGVyLnN0YXRlU2VydmljZTtcbiAgICogICB2YXIgTXlBdXRoU2VydmljZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdNeUF1dGhTZXJ2aWNlJyk7XG4gICAqXG4gICAqICAgLy8gSWYgdGhlIHVzZXIgaXMgbm90IGF1dGhlbnRpY2F0ZWRcbiAgICogICBpZiAoIU15QXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICpcbiAgICogICAgIC8vIFRoZW4gcmV0dXJuIGEgcHJvbWlzZSBmb3IgYSBzdWNjZXNzZnVsIGxvZ2luLlxuICAgKiAgICAgLy8gVGhlIHRyYW5zaXRpb24gd2lsbCB3YWl0IGZvciB0aGlzIHByb21pc2UgdG8gc2V0dGxlXG4gICAqXG4gICAqICAgICByZXR1cm4gTXlBdXRoU2VydmljZS5hdXRoZW50aWNhdGUoKS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICpcbiAgICogICAgICAgLy8gSWYgdGhlIGF1dGhlbnRpY2F0ZSgpIG1ldGhvZCBmYWlsZWQgZm9yIHdoYXRldmVyIHJlYXNvbixcbiAgICogICAgICAgLy8gcmVkaXJlY3QgdG8gYSAnZ3Vlc3QnIHN0YXRlIHdoaWNoIGRvZXNuJ3QgcmVxdWlyZSBhdXRoLlxuICAgKiAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldChcImd1ZXN0XCIpO1xuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaENyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZC5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICovXG4gIG9uU3RhcnQobWF0Y2hDcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbjtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgY2FsbGVkIHdoZW4gYSBzcGVjaWZpYyBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCAoZHVyaW5nIGEgdHJhbnNpdGlvbikgd2hlbiBhIHNwZWNpZmljIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gICAqXG4gICAqIFNpbmNlIHRoaXMgaG9vayBpcyBydW4gb25seSB3aGVuIHRoZSBzcGVjaWZpYyBzdGF0ZSBpcyBiZWluZyAqZW50ZXJlZCosIGl0IGNhbiBiZSB1c2VmdWwgZm9yXG4gICAqIHBlcmZvcm1pbmcgdGFza3Mgd2hlbiBlbnRlcmluZyBhIHN1Ym1vZHVsZS9mZWF0dXJlIGFyZWEgc3VjaCBhcyBpbml0aWFsaXppbmcgYSBzdGF0ZWZ1bCBzZXJ2aWNlLFxuICAgKiBvciBmb3IgZ3VhcmRpbmcgYWNjZXNzIHRvIGEgc3VibW9kdWxlL2ZlYXR1cmUgYXJlYS5cbiAgICpcbiAgICogU2VlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIHRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogYG9uRW50ZXJgIGhvb2tzIGdlbmVyYWxseSBzcGVjaWZ5IGB7IGVudGVyaW5nOiAnc29tZXN0YXRlJyB9YC5cbiAgICogVG8gbWF0Y2ggYWxsIFRyYW5zaXRpb25zLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gICAqXG4gICAqICMjIyBMaWZlY3ljbGVcbiAgICpcbiAgICogYG9uRW50ZXJgIGhvb2tzIGFyZSBpbnZva2VkIHdoZW4gdGhlIFRyYW5zaXRpb24gaXMgZW50ZXJpbmcgYSBzdGF0ZS5cbiAgICogU3RhdGVzIGFyZSBlbnRlcmVkIGFmdGVyIHRoZSBgb25SZXRhaW5gIHBoYXNlIGlzIGNvbXBsZXRlLlxuICAgKiBJZiBtb3JlIHRoYW4gb25lIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBwYXJlbnQgc3RhdGUgaXMgZW50ZXJlZCBmaXJzdC5cbiAgICogVGhlIHJlZ2lzdGVyZWQgYG9uRW50ZXJgIGhvb2tzIGZvciBhIHN0YXRlIGFyZSBpbnZva2VkIGluIHByaW9yaXR5IG9yZGVyLlxuICAgKlxuICAgKiBOb3RlOiBBIGJ1aWx0LWluIGBvbkVudGVyYCBob29rIHdpdGggaGlnaCBwcmlvcml0eSBpcyB1c2VkIHRvIGZldGNoIGxhenkgcmVzb2x2ZSBkYXRhIGZvciBzdGF0ZXMgYmVpbmcgZW50ZXJlZC5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byBwYXVzZSwgY2FuY2VsLCBvciByZWRpcmVjdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uLlxuICAgKiBTZWUgW1tIb29rUmVzdWx0XV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqICMjIyBJbnNpZGUgYSBzdGF0ZSBkZWNsYXJhdGlvblxuICAgKlxuICAgKiBJbnN0ZWFkIG9mIHJlZ2lzdGVyaW5nIGBvbkVudGVyYCBob29rcyB1c2luZyB0aGUgW1tUcmFuc2l0aW9uU2VydmljZV1dLCB5b3UgbWF5IGRlZmluZSBhbiBgb25FbnRlcmAgaG9va1xuICAgKiBkaXJlY3RseSBvbiBhIHN0YXRlIGRlY2xhcmF0aW9uIChzZWU6IFtbU3RhdGVEZWNsYXJhdGlvbi5vbkVudGVyXV0pLlxuICAgKlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZXNcbiAgICpcbiAgICogIyMjIyBBdWRpdCBMb2dcbiAgICpcbiAgICogVGhpcyBleGFtcGxlIHVzZXMgYSBzZXJ2aWNlIHRvIGxvZyB0aGF0IGEgdXNlciBoYXMgZW50ZXJlZCB0aGUgYWRtaW4gc2VjdGlvbiBvZiBhbiBhcHAuXG4gICAqIFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGFyZSBzdWJzdGF0ZXMgb2YgdGhlIFwiYWRtaW5cIiBzdGF0ZSwgc3VjaCBhcyBcImFkbWluLnVzZXJzXCIsIFwiYWRtaW4ucGFnZXNcIiwgZXRjLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICpcbiAgICogJHRyYW5zaXRpb25zLm9uRW50ZXIoeyBlbnRlcmluZzogJ2FkbWluJyB9LCBmdW5jdGlvbih0cmFuc2l0aW9uLCBzdGF0ZSkge1xuICAgKiAgIHZhciBBdWRpdFNlcnZpY2UgPSB0cmFucy5pbmplY3RvcigpLmdldCgnQXVkaXRTZXJ2aWNlJyk7XG4gICAqICAgQXVkaXRTZXJ2aWNlLmxvZyhcIkVudGVyZWQgXCIgKyBzdGF0ZS5uYW1lICsgXCIgbW9kdWxlIHdoaWxlIHRyYW5zaXRpb25pbmcgdG8gXCIgKyB0cmFuc2l0aW9uLnRvKCkubmFtZSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgQXVkaXQgTG9nIChpbnNpZGUgYSBzdGF0ZSBkZWNsYXJhdGlvbilcbiAgICpcbiAgICogVGhlIGBvbkVudGVyYCBpbnNpZGUgdGhpcyBzdGF0ZSBkZWNsYXJhdGlvbiBpcyBzeW50YWN0aWMgc3VnYXIgZm9yIHRoZSBwcmV2aW91cyBBdWRpdCBMb2cgZXhhbXBsZS5cbiAgICogYGBgXG4gICAqIHtcbiAgICogICBuYW1lOiAnYWRtaW4nLFxuICAgKiAgIGNvbXBvbmVudDogJ2FkbWluJyxcbiAgICogICBvbkVudGVyOiBmdW5jdGlvbigkdHJhbnNpdGlvbiQsICRzdGF0ZSQpIHtcbiAgICogICAgIHZhciBBdWRpdFNlcnZpY2UgPSAkdHJhbnNpdGlvbiQuaW5qZWN0b3IoKS5nZXQoJ0F1ZGl0U2VydmljZScpO1xuICAgKiAgICAgQXVkaXRTZXJ2aWNlLmxvZyhcIkVudGVyZWQgXCIgKyBzdGF0ZS5uYW1lICsgXCIgbW9kdWxlIHdoaWxlIHRyYW5zaXRpb25pbmcgdG8gXCIgKyB0cmFuc2l0aW9uLnRvKCkubmFtZSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlOiBBIHN0YXRlIGRlY2xhcmF0aW9uJ3MgYG9uRW50ZXJgIGZ1bmN0aW9uIGlzIGluamVjdGVkIGZvciBBbmd1bGFyIDEgb25seS5cbiAgICpcbiAgICogQHBhcmFtIG1hdGNoQ3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGluamVjdGVkIGFuZCBpbnZva2VkLlxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgKi9cbiAgb25FbnRlcihtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0sIGNhbGxlZCB3aGVuIGEgc3BlY2lmaWMgc3RhdGUgaXMgcmV0YWluZWQva2VwdC5cbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgKGR1cmluZyBhIHRyYW5zaXRpb24pIGZvclxuICAgKiBhIHNwZWNpZmljIHN0YXRlIHRoYXQgd2FzIHByZXZpb3VzbHkgYWN0aXZlIHdpbGwgcmVtYWluIGFjdGl2ZSAoaXMgbm90IGJlaW5nIGVudGVyZWQgbm9yIGV4aXRlZCkuXG4gICAqXG4gICAqIFRoaXMgaG9vayBpcyBpbnZva2VkIHdoZW4gYSBzdGF0ZSBpcyBcInJldGFpbmVkXCIgb3IgXCJrZXB0XCIuXG4gICAqIEl0IG1lYW5zIHRoZSB0cmFuc2l0aW9uIGlzIGNvbWluZyAqZnJvbSogYSBzdWJzdGF0ZSBvZiB0aGUgcmV0YWluZWQgc3RhdGUgKnRvKiBhIHN1YnN0YXRlIG9mIHRoZSByZXRhaW5lZCBzdGF0ZS5cbiAgICogVGhpcyBob29rIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gYWN0aW9ucyB3aGVuIHRoZSB1c2VyIG1vdmVzIGZyb20gb25lIHN1YnN0YXRlIHRvIGFub3RoZXIsIHN1Y2ggYXMgYmV0d2VlbiBzdGVwcyBpbiBhIHdpemFyZC5cbiAgICpcbiAgICogVGhlIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBUcmFuc2l0aW9ucyB0aGUgaG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIGBvblJldGFpbmAgaG9va3MgZ2VuZXJhbGx5IHNwZWNpZnkgYHsgcmV0YWluZWQ6ICdzb21lc3RhdGUnIH1gLlxuICAgKiBUbyBtYXRjaCBhbGwgVHJhbnNpdGlvbnMsIHVzZSBhbiBlbXB0eSBjcml0ZXJpYSBvYmplY3QgYHt9YC5cbiAgICpcbiAgICogIyMjIExpZmVjeWNsZVxuICAgKlxuICAgKiBgb25SZXRhaW5gIGhvb2tzIGFyZSBpbnZva2VkIGFmdGVyIGFueSBgb25FeGl0YCBob29rcyBoYXZlIGJlZW4gZmlyZWQuXG4gICAqIElmIG1vcmUgdGhhbiBvbmUgc3RhdGUgaXMgcmV0YWluZWQsIHRoZSBjaGlsZCBzdGF0ZXMnIGBvblJldGFpbmAgaG9va3MgYXJlIGludm9rZWQgZmlyc3QuXG4gICAqIFRoZSByZWdpc3RlcmVkIGBvblJldGFpbmAgaG9va3MgZm9yIGEgc3RhdGUgYXJlIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuXG4gICAqXG4gICAqICMjIyBSZXR1cm4gdmFsdWVcbiAgICpcbiAgICogVGhlIGhvb2sncyByZXR1cm4gdmFsdWUgY2FuIGJlIHVzZWQgdG8gcGF1c2UsIGNhbmNlbCwgb3IgcmVkaXJlY3QgdGhlIGN1cnJlbnQgVHJhbnNpdGlvbi5cbiAgICogU2VlIFtbSG9va1Jlc3VsdF1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiAjIyMgSW5zaWRlIGEgc3RhdGUgZGVjbGFyYXRpb25cbiAgICpcbiAgICogSW5zdGVhZCBvZiByZWdpc3RlcmluZyBgb25SZXRhaW5gIGhvb2tzIHVzaW5nIHRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0sIHlvdSBtYXkgZGVmaW5lIGFuIGBvblJldGFpbmAgaG9va1xuICAgKiBkaXJlY3RseSBvbiBhIHN0YXRlIGRlY2xhcmF0aW9uIChzZWU6IFtbU3RhdGVEZWNsYXJhdGlvbi5vblJldGFpbl1dKS5cbiAgICpcbiAgICogTm90ZTogQSBzdGF0ZSBkZWNsYXJhdGlvbidzIGBvblJldGFpbmAgZnVuY3Rpb24gaXMgaW5qZWN0ZWQgZm9yIEFuZ3VsYXIgMSBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hDcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvblJldGFpbihtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0sIGNhbGxlZCB3aGVuIGEgc3BlY2lmaWMgc3RhdGUgaXMgZXhpdGVkLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCAoZHVyaW5nIGEgdHJhbnNpdGlvbikgd2hlbiBhIHNwZWNpZmljIHN0YXRlIGlzIGJlaW5nIGV4aXRlZC5cbiAgICpcbiAgICogU2luY2UgdGhpcyBob29rIGlzIHJ1biBvbmx5IHdoZW4gdGhlIHNwZWNpZmljIHN0YXRlIGlzIGJlaW5nICpleGl0ZWQqLCBpdCBjYW4gYmUgdXNlZnVsIGZvclxuICAgKiBwZXJmb3JtaW5nIHRhc2tzIHdoZW4gbGVhdmluZyBhIHN1Ym1vZHVsZS9mZWF0dXJlIGFyZWEgc3VjaCBhcyBjbGVhbmluZyB1cCBhIHN0YXRlZnVsIHNlcnZpY2UsXG4gICAqIG9yIGZvciBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gbGVhdmluZyBhIHN0YXRlIG9yIHN1Ym1vZHVsZSB1bnRpbCBzb21lIGNyaXRlcmlhIGlzIHNhdGlzZmllZC5cbiAgICpcbiAgICogU2VlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIHRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBob29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogYG9uRXhpdGAgaG9va3MgZ2VuZXJhbGx5IHNwZWNpZnkgYHsgZXhpdGluZzogJ3NvbWVzdGF0ZScgfWAuXG4gICAqIFRvIG1hdGNoIGFsbCBUcmFuc2l0aW9ucywgdXNlIGFuIGVtcHR5IGNyaXRlcmlhIG9iamVjdCBge31gLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIGBvbkV4aXRgIGhvb2tzIGFyZSBpbnZva2VkIHdoZW4gdGhlIFRyYW5zaXRpb24gaXMgZXhpdGluZyBhIHN0YXRlLlxuICAgKiBTdGF0ZXMgYXJlIGV4aXRlZCBhZnRlciBhbnkgYG9uU3RhcnRgIHBoYXNlIGlzIGNvbXBsZXRlLlxuICAgKiBJZiBtb3JlIHRoYW4gb25lIHN0YXRlIGlzIGJlaW5nIGV4aXRlZCwgdGhlIGNoaWxkIHN0YXRlcyBhcmUgZXhpdGVkIGZpcnN0LlxuICAgKiBUaGUgcmVnaXN0ZXJlZCBgb25FeGl0YCBob29rcyBmb3IgYSBzdGF0ZSBhcmUgaW52b2tlZCBpbiBwcmlvcml0eSBvcmRlci5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byBwYXVzZSwgY2FuY2VsLCBvciByZWRpcmVjdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uLlxuICAgKiBTZWUgW1tIb29rUmVzdWx0XV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqICMjIyBJbnNpZGUgYSBzdGF0ZSBkZWNsYXJhdGlvblxuICAgKlxuICAgKiBJbnN0ZWFkIG9mIHJlZ2lzdGVyaW5nIGBvbkV4aXRgIGhvb2tzIHVzaW5nIHRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0sIHlvdSBtYXkgZGVmaW5lIGFuIGBvbkV4aXRgIGhvb2tcbiAgICogZGlyZWN0bHkgb24gYSBzdGF0ZSBkZWNsYXJhdGlvbiAoc2VlOiBbW1N0YXRlRGVjbGFyYXRpb24ub25FeGl0XV0pLlxuICAgKlxuICAgKiBOb3RlOiBBIHN0YXRlIGRlY2xhcmF0aW9uJ3MgYG9uRXhpdGAgZnVuY3Rpb24gaXMgaW5qZWN0ZWQgZm9yIEFuZ3VsYXIgMSBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hDcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvbkV4aXQobWF0Y2hDcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSwgY2FsbGVkICpqdXN0IGJlZm9yZSBhIHRyYW5zaXRpb24gZmluaXNoZXMqLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGp1c3QgYmVmb3JlIGEgdHJhbnNpdGlvbiBmaW5pc2hlcy5cbiAgICogVGhpcyBob29rIGlzIGEgbGFzdCBjaGFuY2UgdG8gY2FuY2VsIG9yIHJlZGlyZWN0IGEgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogU2VlIFtbVHJhbnNpdGlvbkhvb2tGbl1dIGZvciB0aGUgc2lnbmF0dXJlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhlIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBUcmFuc2l0aW9ucyB0aGUgaG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIFRvIG1hdGNoIGFsbCBUcmFuc2l0aW9ucywgdXNlIGFuIGVtcHR5IGNyaXRlcmlhIG9iamVjdCBge31gLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIGBvbkZpbmlzaGAgaG9va3MgYXJlIGludm9rZWQgYWZ0ZXIgdGhlIGBvbkVudGVyYCBwaGFzZSBpcyBjb21wbGV0ZS5cbiAgICogVGhlc2UgaG9va3MgYXJlIGludm9rZWQganVzdCBiZWZvcmUgdGhlIHRyYW5zaXRpb24gaXMgXCJjb21taXR0ZWRcIi5cbiAgICogRWFjaCBob29rIGlzIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuXG4gICAqXG4gICAqICMjIyBSZXR1cm4gdmFsdWVcbiAgICpcbiAgICogVGhlIGhvb2sncyByZXR1cm4gdmFsdWUgY2FuIGJlIHVzZWQgdG8gcGF1c2UsIGNhbmNlbCwgb3IgcmVkaXJlY3QgdGhlIGN1cnJlbnQgVHJhbnNpdGlvbi5cbiAgICogU2VlIFtbSG9va1Jlc3VsdF1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hDcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvbkZpbmlzaChtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSwgY2FsbGVkIGFmdGVyIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uIGNvbXBsZXRlZC5cbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCBhZnRlciBhIHRyYW5zaXRpb24gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy5cbiAgICpcbiAgICogU2VlIFtbVHJhbnNpdGlvbkhvb2tGbl1dIGZvciB0aGUgc2lnbmF0dXJlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhlIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBUcmFuc2l0aW9ucyB0aGUgaG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIFRvIG1hdGNoIGFsbCBUcmFuc2l0aW9ucywgdXNlIGFuIGVtcHR5IGNyaXRlcmlhIG9iamVjdCBge31gLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIGBvblN1Y2Nlc3NgIGhvb2tzIGFyZSBjaGFpbmVkIG9mZiB0aGUgVHJhbnNpdGlvbidzIHByb21pc2UgKHNlZSBbW1RyYW5zaXRpb24ucHJvbWlzZV1dKS5cbiAgICogSWYgdGhlIFRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCBhbmQgaXRzIHByb21pc2UgaXMgcmVzb2x2ZWQsIHRoZW4gdGhlIGBvblN1Y2Nlc3NgIGhvb2tzIGFyZSBpbnZva2VkLlxuICAgKiBTaW5jZSB0aGVzZSBob29rcyBhcmUgcnVuIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGlzIG92ZXIsIHRoZWlyIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBUaGUgYG9uU3VjY2Vzc2AgaG9va3MgYXJlIGludm9rZWQgaW4gcHJpb3JpdHkgb3JkZXIuXG4gICAqXG4gICAqICMjIyBSZXR1cm4gdmFsdWVcbiAgICpcbiAgICogU2luY2UgdGhlIFRyYW5zaXRpb24gaXMgYWxyZWFkeSBjb21wbGV0ZWQsIHRoZSBob29rJ3MgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICpcbiAgICogQHBhcmFtIG1hdGNoQ3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGluamVjdGVkIGFuZCBpbnZva2VkLlxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgKi9cbiAgb25TdWNjZXNzKG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGhhcyBlcnJvcmVkLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGFmdGVyIGEgdHJhbnNpdGlvbiBoYXMgYmVlbiByZWplY3RlZCBmb3IgYW55IHJlYXNvbi5cbiAgICpcbiAgICogU2VlIFtbVHJhbnNpdGlvbkhvb2tGbl1dIGZvciB0aGUgc2lnbmF0dXJlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhlIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBUcmFuc2l0aW9ucyB0aGUgaG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAqIFRvIG1hdGNoIGFsbCBUcmFuc2l0aW9ucywgdXNlIGFuIGVtcHR5IGNyaXRlcmlhIG9iamVjdCBge31gLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIFRoZSBgb25FcnJvcmAgaG9va3MgYXJlIGNoYWluZWQgb2ZmIHRoZSBUcmFuc2l0aW9uJ3MgcHJvbWlzZSAoc2VlIFtbVHJhbnNpdGlvbi5wcm9taXNlXV0pLlxuICAgKiBJZiBhIFRyYW5zaXRpb24gZmFpbHMsIGl0cyBwcm9taXNlIGlzIHJlamVjdGVkIGFuZCB0aGUgYG9uRXJyb3JgIGhvb2tzIGFyZSBpbnZva2VkLlxuICAgKiBUaGUgYG9uRXJyb3JgIGhvb2tzIGFyZSBpbnZva2VkIGluIHByaW9yaXR5IG9yZGVyLlxuICAgKlxuICAgKiBTaW5jZSB0aGVzZSBob29rcyBhcmUgcnVuIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGlzIG92ZXIsIHRoZWlyIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKlxuICAgKiBBIHRyYW5zaXRpb24gXCJlcnJvcnNcIiBpZiBpdCB3YXMgc3RhcnRlZCwgYnV0IGZhaWxlZCB0byBjb21wbGV0ZSAoZm9yIGFueSByZWFzb24pLlxuICAgKiBBICpub24tZXhoYXVzdGl2ZSBsaXN0KiBvZiByZWFzb25zIGEgdHJhbnNpdGlvbiBjYW4gZXJyb3I6XG4gICAqXG4gICAqIC0gQSB0cmFuc2l0aW9uIHdhcyBjYW5jZWxsZWQgYmVjYXVzZSBhIG5ldyB0cmFuc2l0aW9uIHN0YXJ0ZWQgd2hpbGUgaXQgd2FzIHN0aWxsIHJ1bm5pbmcgKGBUcmFuc2l0aW9uIHN1cGVyc2VkZWRgKVxuICAgKiAtIEEgdHJhbnNpdGlvbiB3YXMgY2FuY2VsbGVkIGJ5IGEgVHJhbnNpdGlvbiBIb29rIHJldHVybmluZyBmYWxzZVxuICAgKiAtIEEgdHJhbnNpdGlvbiB3YXMgcmVkaXJlY3RlZCBieSBhIFRyYW5zaXRpb24gSG9vayByZXR1cm5pbmcgYSBbW1RhcmdldFN0YXRlXV1cbiAgICogLSBBIFRyYW5zaXRpb24gSG9vayBvciByZXNvbHZlIGZ1bmN0aW9uIHRocmV3IGFuIGVycm9yXG4gICAqIC0gQSBUcmFuc2l0aW9uIEhvb2sgcmV0dXJuZWQgYSByZWplY3RlZCBwcm9taXNlXG4gICAqIC0gQSByZXNvbHZlIGZ1bmN0aW9uIHJldHVybmVkIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgKlxuICAgKiBUbyBjaGVjayB0aGUgZmFpbHVyZSByZWFzb24sIGluc3BlY3QgdGhlIHJldHVybiB2YWx1ZSBvZiBbW1RyYW5zaXRpb24uZXJyb3JdXS5cbiAgICpcbiAgICogTm90ZTogYG9uRXJyb3JgIHNob3VsZCBiZSB1c2VkIGZvciB0YXJnZXRlZCBlcnJvciBoYW5kbGluZywgb3IgZXJyb3IgcmVjb3ZlcnkuXG4gICAqIEZvciBzaW1wbGUgY2F0Y2gtYWxsIGVycm9yIHJlcG9ydGluZywgdXNlIFtbU3RhdGVTZXJ2aWNlLmRlZmF1bHRFcnJvckhhbmRsZXJdXS5cbiAgICpcbiAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBTaW5jZSB0aGUgVHJhbnNpdGlvbiBpcyBhbHJlYWR5IGNvbXBsZXRlZCwgdGhlIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2hDcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAqL1xuICBvbkVycm9yKG1hdGNoQ3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIGhvb2tzIG9mIGEgZ2l2ZW4gYGhvb2tOYW1lYCB0eXBlXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBgXG4gICAqICR0cmFuc2l0aW9ucy5nZXRIb29rcyhcIm9uRW50ZXJcIilcbiAgICogYGBgXG4gICAqL1xuICBnZXRIb29rcyhob29rTmFtZTogc3RyaW5nKTogUmVnaXN0ZXJlZEhvb2tbXTtcbn1cblxuLyoqIEEgcHJlZGljYXRlIHR5cGUgd2hpY2ggdGVzdHMgaWYgYSBbW1N0YXRlT2JqZWN0XV0gYW5kIFtbVHJhbnNpdGlvbl1dIHBhc3NlcyBzb21lIHRlc3QuIFJldHVybnMgYSBib29sZWFuLiAqL1xuZXhwb3J0IHR5cGUgSVN0YXRlTWF0Y2ggPSBQcmVkaWNhdGVCaW5hcnk8U3RhdGVPYmplY3QsIFRyYW5zaXRpb24+O1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGlzIHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgb3Igbm90IGEgVHJhbnNpdGlvbiBIb29rIGlzIGludm9rZWQgZm9yIGEgcGFydGljdWxhciB0cmFuc2l0aW9uLFxuICogYmFzZWQgb24gdGhlIFRyYW5zaXRpb24ncyBcInRvIHN0YXRlXCIgYW5kIFwiZnJvbSBzdGF0ZVwiLlxuICpcbiAqIEVhY2ggcHJvcGVydHkgKGB0b2AsIGBmcm9tYCwgYGV4aXRpbmdgLCBgcmV0YWluZWRgLCBhbmQgYGVudGVyaW5nYCkgY2FuIGJlIGEgc3RhdGUgW1tHbG9iXV0gc3RyaW5nLFxuICogYSBib29sZWFuLCBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdGF0ZSBhbmQgcmV0dXJucyBhIGJvb2xlYW4gKHNlZSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dKVxuICpcbiAqIEFsbCBwcm9wZXJ0aWVzIGFyZSBvcHRpb25hbC4gIElmIGFueSBwcm9wZXJ0eSBpcyBvbWl0dGVkLCBpdCBpcyByZXBsYWNlZCB3aXRoIHRoZSB2YWx1ZSBgdHJ1ZWAsIGFuZCBhbHdheXMgbWF0Y2hlcy5cbiAqIFRvIG1hdGNoIGFueSB0cmFuc2l0aW9uLCB1c2UgYW4gZW1wdHkgY3JpdGVyaWEgb2JqZWN0IGB7fWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIFRoaXMgbWF0Y2hlcyBhIHRyYW5zaXRpb24gY29taW5nIGZyb20gdGhlIGBwYXJlbnRgIHN0YXRlIGFuZCBnb2luZyB0byB0aGUgYHBhcmVudC5jaGlsZGAgc3RhdGUuXG4gKiB2YXIgbWF0Y2ggPSB7XG4gKiAgIHRvOiAncGFyZW50JyxcbiAqICAgZnJvbTogJ3BhcmVudC5jaGlsZCdcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBUaGlzIG1hdGNoZXMgYSB0cmFuc2l0aW9uIGNvbWluZyBmcm9tIGFueSBzdWJzdGF0ZSBvZiBgcGFyZW50YCBhbmQgZ29pbmcgZGlyZWN0bHkgdG8gdGhlIGBwYXJlbnRgIHN0YXRlLlxuICogdmFyIG1hdGNoID0ge1xuICogICB0bzogJ3BhcmVudCcsXG4gKiAgIGZyb206ICdwYXJlbnQuKionXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogLy8gVGhpcyBtYXRjaGVzIGEgdHJhbnNpdGlvbiBjb21pbmcgZnJvbSBhbnkgc3RhdGUgYW5kIGdvaW5nIHRvIGFueSBzdWJzdGF0ZSBvZiBgbXltb2R1bGVgXG4gKiB2YXIgbWF0Y2ggPSB7XG4gKiAgIHRvOiAnbXltb2R1bGUuKionXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogLy8gVGhpcyBtYXRjaGVzIGEgdHJhbnNpdGlvbiBjb21pbmcgZnJvbSBhbnkgc3RhdGUgYW5kIGdvaW5nIHRvIGFueSBzdGF0ZSB0aGF0IGhhcyBgZGF0YS5hdXRoUmVxdWlyZWRgXG4gKiAvLyBzZXQgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKiB2YXIgbWF0Y2ggPSB7XG4gKiAgIHRvOiBmdW5jdGlvbihzdGF0ZSkge1xuICogICAgIHJldHVybiBzdGF0ZS5kYXRhICE9IG51bGwgJiYgc3RhdGUuZGF0YS5hdXRoUmVxdWlyZWQgPT09IHRydWU7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIFRoaXMgd2lsbCBtYXRjaCB3aGVuIHJvdXRlIGlzIGp1c3QgZW50ZXJlZCAoaW5pdGlhbCBsb2FkKSBvciB3aGVuIHRoZSBzdGF0ZSBpcyBoYXJkLXJlZnJlc2hlZFxuICogLy8gYnkgc3BlY2lmeWluZyBge3JlZnJlc2g6IHRydWV9YCBhcyB0cmFuc2l0aW9uIG9wdGlvbnMuXG4gKiB2YXIgbWF0Y2ggPSB7XG4gKiAgIGZyb206IChzdGF0ZSwgdHJhbnNpdGlvbikgPT4gc3RhdGUuc2VsZi5uYW1lID09PSAnJyB8fCB0cmFuc2l0aW9uLm9wdGlvbnMoKS5yZWxvYWRcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBUaGlzIG1hdGNoZXMgYSB0cmFuc2l0aW9uIHRoYXQgaXMgZXhpdGluZyBgcGFyZW50LmNoaWxkYFxuICogdmFyIG1hdGNoID0ge1xuICogICBleGl0aW5nOiAncGFyZW50LmNoaWxkJ1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG9va01hdGNoQ3JpdGVyaWEge1xuICBba2V5OiBzdHJpbmddOiBIb29rTWF0Y2hDcml0ZXJpb24gfCB1bmRlZmluZWQ7XG5cbiAgLyoqIEEgW1tIb29rTWF0Y2hDcml0ZXJpb25dXSB0byBtYXRjaCB0aGUgZGVzdGluYXRpb24gc3RhdGUgKi9cbiAgdG8/OiBIb29rTWF0Y2hDcml0ZXJpb247XG4gIC8qKiBBIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0gdG8gbWF0Y2ggdGhlIG9yaWdpbmFsIChmcm9tKSBzdGF0ZSAqL1xuICBmcm9tPzogSG9va01hdGNoQ3JpdGVyaW9uO1xuICAvKiogQSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dIHRvIG1hdGNoIGFueSBzdGF0ZSB0aGF0IHdvdWxkIGJlIGV4aXRpbmcgKi9cbiAgZXhpdGluZz86IEhvb2tNYXRjaENyaXRlcmlvbjtcbiAgLyoqIEEgW1tIb29rTWF0Y2hDcml0ZXJpb25dXSB0byBtYXRjaCBhbnkgc3RhdGUgdGhhdCB3b3VsZCBiZSByZXRhaW5lZCAqL1xuICByZXRhaW5lZD86IEhvb2tNYXRjaENyaXRlcmlvbjtcbiAgLyoqIEEgW1tIb29rTWF0Y2hDcml0ZXJpb25dXSB0byBtYXRjaCBhbnkgc3RhdGUgdGhhdCB3b3VsZCBiZSBlbnRlcmluZyAqL1xuICBlbnRlcmluZz86IEhvb2tNYXRjaENyaXRlcmlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWF0Y2hpbmdOb2RlcyB7XG4gIFtrZXk6IHN0cmluZ106IFBhdGhOb2RlW107XG5cbiAgdG86IFBhdGhOb2RlW107XG4gIGZyb206IFBhdGhOb2RlW107XG4gIGV4aXRpbmc6IFBhdGhOb2RlW107XG4gIHJldGFpbmVkOiBQYXRoTm9kZVtdO1xuICBlbnRlcmluZzogUGF0aE5vZGVbXTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0ZXJlZEhvb2tzIHtcbiAgW2tleTogc3RyaW5nXTogUmVnaXN0ZXJlZEhvb2tbXTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFR5cGVzIHtcbiAgW2tleTogc3RyaW5nXTogUGF0aFR5cGU7XG5cbiAgdG86IFBhdGhUeXBlO1xuICBmcm9tOiBQYXRoVHlwZTtcbiAgZXhpdGluZzogUGF0aFR5cGU7XG4gIHJldGFpbmVkOiBQYXRoVHlwZTtcbiAgZW50ZXJpbmc6IFBhdGhUeXBlO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoVHlwZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgc2NvcGU6IFRyYW5zaXRpb25Ib29rU2NvcGU7XG59XG5cbi8qKlxuICogSG9vayBDcml0ZXJpb24gdXNlZCB0byBtYXRjaCBhIHRyYW5zaXRpb24uXG4gKlxuICogQSBbW0dsb2JdXSBzdHJpbmcgdGhhdCBtYXRjaGVzIHRoZSBuYW1lIG9mIGEgc3RhdGUuXG4gKlxuICogT3IsIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2lnbmF0dXJlIGBmdW5jdGlvbihzdGF0ZSwgdHJhbnNpdGlvbikgeyByZXR1cm4gbWF0Y2hlczsgfWBcbiAqIHdoaWNoIHNob3VsZCByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIGlmIGEgc3RhdGUgbWF0Y2hlcy5cbiAqXG4gKiBPciwgYHRydWVgIHRvIGFsd2F5cyBtYXRjaFxuICovXG5leHBvcnQgdHlwZSBIb29rTWF0Y2hDcml0ZXJpb24gPSBzdHJpbmcgfCBJU3RhdGVNYXRjaCB8IGJvb2xlYW47XG5cbmVudW0gVHJhbnNpdGlvbkhvb2tQaGFzZSB7XG4gIENSRUFURSxcbiAgQkVGT1JFLFxuICBSVU4sXG4gIFNVQ0NFU1MsXG4gIEVSUk9SLFxufVxuZW51bSBUcmFuc2l0aW9uSG9va1Njb3BlIHtcbiAgVFJBTlNJVElPTixcbiAgU1RBVEUsXG59XG5cbmV4cG9ydCB7IFRyYW5zaXRpb25Ib29rUGhhc2UsIFRyYW5zaXRpb25Ib29rU2NvcGUgfTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdHJhbnNpdGlvbiAqLyAvKiogKi9cbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rT3B0aW9ucywgSG9va1Jlc3VsdCwgVHJhbnNpdGlvbkhvb2tQaGFzZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGRlZmF1bHRzLCBub29wLCBzaWxlbnRSZWplY3Rpb24gfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGZuVG9TdHJpbmcsIG1heExlbmd0aCB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmdzJztcbmltcG9ydCB7IGlzUHJvbWlzZSB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IGlzLCBwYXJzZSB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tICcuLi9jb21tb24vdHJhY2UnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFJlamVjdGlvbiB9IGZyb20gJy4vcmVqZWN0RmFjdG9yeSc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL3RhcmdldFN0YXRlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkV2ZW50VHlwZSB9IGZyb20gJy4vdHJhbnNpdGlvbkV2ZW50VHlwZSc7XG5pbXBvcnQgeyBSZWdpc3RlcmVkSG9vayB9IGZyb20gJy4vaG9va1JlZ2lzdHJ5JztcbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuLi9zdGF0ZS9pbnRlcmZhY2UnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogVHJhbnNpdGlvbkhvb2tPcHRpb25zID0ge1xuICBjdXJyZW50OiBub29wLFxuICB0cmFuc2l0aW9uOiBudWxsLFxuICB0cmFjZURhdGE6IHt9LFxuICBiaW5kOiBudWxsLFxufTtcblxuZXhwb3J0IHR5cGUgR2V0UmVzdWx0SGFuZGxlciA9IChob29rOiBUcmFuc2l0aW9uSG9vaykgPT4gUmVzdWx0SGFuZGxlcjtcbmV4cG9ydCB0eXBlIEdldEVycm9ySGFuZGxlciA9IChob29rOiBUcmFuc2l0aW9uSG9vaykgPT4gRXJyb3JIYW5kbGVyO1xuXG5leHBvcnQgdHlwZSBSZXN1bHRIYW5kbGVyID0gKHJlc3VsdDogSG9va1Jlc3VsdCkgPT4gUHJvbWlzZTxIb29rUmVzdWx0PjtcbmV4cG9ydCB0eXBlIEVycm9ySGFuZGxlciA9IChlcnJvcjogYW55KSA9PiBQcm9taXNlPGFueT47XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgY2xhc3MgVHJhbnNpdGlvbkhvb2sge1xuICB0eXBlOiBUcmFuc2l0aW9uRXZlbnRUeXBlO1xuXG4gIC8qKlxuICAgKiBUaGVzZSBHZXRSZXN1bHRIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XG4gICAqIEVhY2ggSG9va1R5cGUgY2hvb3NlcyBhIEdldFJlc3VsdEhhbmRsZXIgKFNlZTogW1tUcmFuc2l0aW9uU2VydmljZS5fZGVmaW5lQ29yZUV2ZW50c11dKVxuICAgKi9cbiAgc3RhdGljIEhBTkRMRV9SRVNVTFQ6IEdldFJlc3VsdEhhbmRsZXIgPSAoaG9vazogVHJhbnNpdGlvbkhvb2spID0+IChyZXN1bHQ6IEhvb2tSZXN1bHQpID0+XG4gICAgaG9vay5oYW5kbGVIb29rUmVzdWx0KHJlc3VsdCk7XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZXN1bHQgaXMgYSBwcm9taXNlIHJlamVjdGlvbiwgbG9nIGl0LlxuICAgKiBPdGhlcndpc2UsIGlnbm9yZSB0aGUgcmVzdWx0LlxuICAgKi9cbiAgc3RhdGljIExPR19SRUpFQ1RFRF9SRVNVTFQ6IEdldFJlc3VsdEhhbmRsZXIgPSAoaG9vazogVHJhbnNpdGlvbkhvb2spID0+IChyZXN1bHQ6IEhvb2tSZXN1bHQpID0+IHtcbiAgICBpc1Byb21pc2UocmVzdWx0KSAmJiByZXN1bHQuY2F0Y2goZXJyID0+IGhvb2subG9nRXJyb3IoUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlc2UgR2V0RXJyb3JIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XG4gICAqIEVhY2ggSG9va1R5cGUgY2hvb3NlcyBhIEdldEVycm9ySGFuZGxlciAoU2VlOiBbW1RyYW5zaXRpb25TZXJ2aWNlLl9kZWZpbmVDb3JlRXZlbnRzXV0pXG4gICAqL1xuICBzdGF0aWMgTE9HX0VSUk9SOiBHZXRFcnJvckhhbmRsZXIgPSAoaG9vazogVHJhbnNpdGlvbkhvb2spID0+IChlcnJvcjogYW55KSA9PiBob29rLmxvZ0Vycm9yKGVycm9yKTtcblxuICBzdGF0aWMgUkVKRUNUX0VSUk9SOiBHZXRFcnJvckhhbmRsZXIgPSAoaG9vazogVHJhbnNpdGlvbkhvb2spID0+IChlcnJvcjogYW55KSA9PiBzaWxlbnRSZWplY3Rpb24oZXJyb3IpO1xuXG4gIHN0YXRpYyBUSFJPV19FUlJPUjogR2V0RXJyb3JIYW5kbGVyID0gKGhvb2s6IFRyYW5zaXRpb25Ib29rKSA9PiAoZXJyb3I6IGFueSkgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFpbnMgdG9nZXRoZXIgYW4gYXJyYXkgb2YgVHJhbnNpdGlvbkhvb2tzLlxuICAgKlxuICAgKiBHaXZlbiBhIGxpc3Qgb2YgW1tUcmFuc2l0aW9uSG9va11dIG9iamVjdHMsIGNoYWlucyB0aGVtIHRvZ2V0aGVyLlxuICAgKiBFYWNoIGhvb2sgaXMgaW52b2tlZCBhZnRlciB0aGUgcHJldmlvdXMgb25lIGNvbXBsZXRlcy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgaG9va3M6IFRyYW5zaXRpb25Ib29rW10gPSBnZXRIb29rcygpO1xuICAgKiBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+ID0gVHJhbnNpdGlvbkhvb2suY2hhaW4oaG9va3MpO1xuICAgKlxuICAgKiBwcm9taXNlLnRoZW4oaGFuZGxlU3VjY2VzcywgaGFuZGxlRXJyb3IpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIGhvb2tzIHRvIGNoYWluIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB3YWl0Rm9yIGlmIHByb3ZpZGVkLCB0aGUgY2hhaW4gaXMgYC50aGVuKClgJ2VkIG9mZiB0aGlzIHByb21pc2VcbiAgICogQHJldHVybnMgYSBgUHJvbWlzZWAgZm9yIHNlcXVlbnRpYWxseSBpbnZva2luZyB0aGUgaG9va3MgKGluIG9yZGVyKVxuICAgKi9cbiAgc3RhdGljIGNoYWluKGhvb2tzOiBUcmFuc2l0aW9uSG9va1tdLCB3YWl0Rm9yPzogUHJvbWlzZTxhbnk+KTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBDaGFpbiB0aGUgbmV4dCBob29rIG9mZiB0aGUgcHJldmlvdXNcbiAgICBjb25zdCBjcmVhdGVIb29rQ2hhaW5SID0gKHByZXY6IFByb21pc2U8YW55PiwgbmV4dEhvb2s6IFRyYW5zaXRpb25Ib29rKSA9PiBwcmV2LnRoZW4oKCkgPT4gbmV4dEhvb2suaW52b2tlSG9vaygpKTtcbiAgICByZXR1cm4gaG9va3MucmVkdWNlKGNyZWF0ZUhvb2tDaGFpblIsIHdhaXRGb3IgfHwgc2VydmljZXMuJHEud2hlbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCB0aGUgcHJvdmlkZWQgVHJhbnNpdGlvbkhvb2tzLCBpbiBvcmRlci5cbiAgICogRWFjaCBob29rJ3MgcmV0dXJuIHZhbHVlIGlzIGNoZWNrZWQuXG4gICAqIElmIGFueSBob29rIHJldHVybnMgYSBwcm9taXNlLCB0aGVuIHRoZSByZXN0IG9mIHRoZSBob29rcyBhcmUgY2hhaW5lZCBvZmYgdGhhdCBwcm9taXNlLCBhbmQgdGhlIHByb21pc2UgaXMgcmV0dXJuZWQuXG4gICAqIElmIG5vIGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gYWxsIGhvb2tzIGFyZSBwcm9jZXNzZWQgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIFRyYW5zaXRpb25Ib29rcyB0byBpbnZva2VcbiAgICogQHBhcmFtIGRvbmVDYWxsYmFjayBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCBhZnRlciBhbGwgdGhlIGhvb2tzIGhhdmUgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxuICAgKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBhc3luYyByZXN1bHQsIG9yIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBzdGF0aWMgaW52b2tlSG9va3M8VD4oaG9va3M6IFRyYW5zaXRpb25Ib29rW10sIGRvbmVDYWxsYmFjazogKHJlc3VsdD86IEhvb2tSZXN1bHQpID0+IFQpOiBQcm9taXNlPGFueT4gfCBUIHtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBob29rcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBob29rUmVzdWx0ID0gaG9va3NbaWR4XS5pbnZva2VIb29rKCk7XG5cbiAgICAgIGlmIChpc1Byb21pc2UoaG9va1Jlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nSG9va3MgPSBob29rcy5zbGljZShpZHggKyAxKTtcblxuICAgICAgICByZXR1cm4gVHJhbnNpdGlvbkhvb2suY2hhaW4ocmVtYWluaW5nSG9va3MsIGhvb2tSZXN1bHQpLnRoZW4oZG9uZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZUNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGFsbCBUcmFuc2l0aW9uSG9va3MsIGlnbm9yaW5nIHRoZWlyIHJldHVybiB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBydW5BbGxIb29rcyhob29rczogVHJhbnNpdGlvbkhvb2tbXSk6IHZvaWQge1xuICAgIGhvb2tzLmZvckVhY2goaG9vayA9PiBob29rLmludm9rZUhvb2soKSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gICAgcHJpdmF0ZSBzdGF0ZUNvbnRleHQ6IFN0YXRlRGVjbGFyYXRpb24sXG4gICAgcHJpdmF0ZSByZWdpc3RlcmVkSG9vazogUmVnaXN0ZXJlZEhvb2ssXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBUcmFuc2l0aW9uSG9va09wdGlvbnNcbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMudHlwZSA9IHJlZ2lzdGVyZWRIb29rLmV2ZW50VHlwZTtcbiAgfVxuXG4gIHByaXZhdGUgaXNTdXBlcnNlZGVkID0gKCkgPT4gdGhpcy50eXBlLmhvb2tQaGFzZSA9PT0gVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4gJiYgIXRoaXMub3B0aW9ucy50cmFuc2l0aW9uLmlzQWN0aXZlKCk7XG5cbiAgbG9nRXJyb3IoZXJyKTogYW55IHtcbiAgICB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnN0YXRlU2VydmljZS5kZWZhdWx0RXJyb3JIYW5kbGVyKCkoZXJyKTtcbiAgfVxuXG4gIGludm9rZUhvb2soKTogUHJvbWlzZTxIb29rUmVzdWx0PiB8IHZvaWQge1xuICAgIGNvbnN0IGhvb2sgPSB0aGlzLnJlZ2lzdGVyZWRIb29rO1xuICAgIGlmIChob29rLl9kZXJlZ2lzdGVyZWQpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdEN1cnJlbnQgPSB0aGlzLmdldE5vdEN1cnJlbnRSZWplY3Rpb24oKTtcbiAgICBpZiAobm90Q3VycmVudCkgcmV0dXJuIG5vdEN1cnJlbnQ7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHRyYWNlLnRyYWNlSG9va0ludm9jYXRpb24odGhpcywgdGhpcy50cmFuc2l0aW9uLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGludm9rZUNhbGxiYWNrID0gKCkgPT4gaG9vay5jYWxsYmFjay5jYWxsKG9wdGlvbnMuYmluZCwgdGhpcy50cmFuc2l0aW9uLCB0aGlzLnN0YXRlQ29udGV4dCk7XG5cbiAgICBjb25zdCBub3JtYWxpemVFcnIgPSBlcnIgPT4gUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpLnRvUHJvbWlzZSgpO1xuXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSBlcnIgPT4gaG9vay5ldmVudFR5cGUuZ2V0RXJyb3JIYW5kbGVyKHRoaXMpKGVycik7XG5cbiAgICBjb25zdCBoYW5kbGVSZXN1bHQgPSByZXN1bHQgPT4gaG9vay5ldmVudFR5cGUuZ2V0UmVzdWx0SGFuZGxlcih0aGlzKShyZXN1bHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGludm9rZUNhbGxiYWNrKCk7XG5cbiAgICAgIGlmICghdGhpcy50eXBlLnN5bmNocm9ub3VzICYmIGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2F0Y2gobm9ybWFsaXplRXJyKS50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgY2FsbGJhY2sgdGhyb3dzIChzeW5jaHJvbm91c2x5KVxuICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKFJlamVjdGlvbi5ub3JtYWxpemUoZXJyKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChob29rLmludm9rZUxpbWl0ICYmICsraG9vay5pbnZva2VDb3VudCA+PSBob29rLmludm9rZUxpbWl0KSB7XG4gICAgICAgIGhvb2suZGVyZWdpc3RlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBUcmFuc2l0aW9uIEhvb2suXG4gICAqXG4gICAqIEEgaG9vayBjYW4gcmV0dXJuIGZhbHNlIChjYW5jZWwpLCBhIFRhcmdldFN0YXRlIChyZWRpcmVjdCksXG4gICAqIG9yIGEgcHJvbWlzZSAod2hpY2ggbWF5IGxhdGVyIHJlc29sdmUgdG8gZmFsc2Ugb3IgYSByZWRpcmVjdClcbiAgICpcbiAgICogVGhpcyBhbHNvIGhhbmRsZXMgXCJ0cmFuc2l0aW9uIHN1cGVyc2VkZWRcIiAtLSB3aGVuIGEgbmV3IHRyYW5zaXRpb25cbiAgICogd2FzIHN0YXJ0ZWQgd2hpbGUgdGhlIGhvb2sgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICovXG4gIGhhbmRsZUhvb2tSZXN1bHQocmVzdWx0OiBIb29rUmVzdWx0KTogUHJvbWlzZTxIb29rUmVzdWx0PiB7XG4gICAgY29uc3Qgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xuICAgIGlmIChub3RDdXJyZW50KSByZXR1cm4gbm90Q3VycmVudDtcblxuICAgIC8vIEhvb2sgcmV0dXJuZWQgYSBwcm9taXNlXG4gICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgcHJvbWlzZSwgdGhlbiByZXByb2Nlc3Mgd2l0aCB0aGUgcmVzdWx0aW5nIHZhbHVlXG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4odmFsID0+IHRoaXMuaGFuZGxlSG9va1Jlc3VsdCh2YWwpKTtcbiAgICB9XG5cbiAgICB0cmFjZS50cmFjZUhvb2tSZXN1bHQocmVzdWx0LCB0aGlzLnRyYW5zaXRpb24sIHRoaXMub3B0aW9ucyk7XG5cbiAgICAvLyBIb29rIHJldHVybmVkIGZhbHNlXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIEFib3J0IHRoaXMgVHJhbnNpdGlvblxuICAgICAgcmV0dXJuIFJlamVjdGlvbi5hYm9ydGVkKCdIb29rIGFib3J0ZWQgdHJhbnNpdGlvbicpLnRvUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVGFyZ2V0U3RhdGUgPSBpcyhUYXJnZXRTdGF0ZSk7XG4gICAgLy8gaG9vayByZXR1cm5lZCBhIFRhcmdldFN0YXRlXG4gICAgaWYgKGlzVGFyZ2V0U3RhdGUocmVzdWx0KSkge1xuICAgICAgLy8gSGFsdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uIGFuZCByZWRpcmVjdCAoYSBuZXcgVHJhbnNpdGlvbikgdG8gdGhlIFRhcmdldFN0YXRlLlxuICAgICAgcmV0dXJuIFJlamVjdGlvbi5yZWRpcmVjdGVkKHJlc3VsdCkudG9Qcm9taXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFJlamVjdGlvbiBwcm9taXNlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIG5vIGxvbmdlciBjdXJyZW50IGR1ZVxuICAgKiB0byBhIHN0b3BwZWQgcm91dGVyIChkaXNwb3NlZCksIG9yIGEgbmV3IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHN1cGVyc2VkZWQgdGhpcyBvbmUuXG4gICAqL1xuICBwcml2YXRlIGdldE5vdEN1cnJlbnRSZWplY3Rpb24oKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcy50cmFuc2l0aW9uLnJvdXRlcjtcblxuICAgIC8vIFRoZSByb3V0ZXIgaXMgc3RvcHBlZFxuICAgIGlmIChyb3V0ZXIuX2Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm4gUmVqZWN0aW9uLmFib3J0ZWQoYFVJUm91dGVyIGluc3RhbmNlICMke3JvdXRlci4kaWR9IGhhcyBiZWVuIHN0b3BwZWQgKGRpc3Bvc2VkKWApLnRvUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRyYW5zaXRpb24uX2Fib3J0ZWQpIHtcbiAgICAgIHJldHVybiBSZWplY3Rpb24uYWJvcnRlZCgpLnRvUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdHJhbnNpdGlvbiBpcyBubyBsb25nZXIgY3VycmVudC5cbiAgICAvLyBBbm90aGVyIHRyYW5zaXRpb24gc3RhcnRlZCB3aGlsZSB0aGlzIGhvb2sgd2FzIHN0aWxsIHJ1bm5pbmcuXG4gICAgaWYgKHRoaXMuaXNTdXBlcnNlZGVkKCkpIHtcbiAgICAgIC8vIEFib3J0IHRoaXMgdHJhbnNpdGlvblxuICAgICAgcmV0dXJuIFJlamVjdGlvbi5zdXBlcnNlZGVkKHRoaXMub3B0aW9ucy5jdXJyZW50KCkpLnRvUHJvbWlzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHsgb3B0aW9ucywgcmVnaXN0ZXJlZEhvb2sgfSA9IHRoaXM7XG4gICAgY29uc3QgZXZlbnQgPSBwYXJzZSgndHJhY2VEYXRhLmhvb2tUeXBlJykob3B0aW9ucykgfHwgJ2ludGVybmFsJyxcbiAgICAgIGNvbnRleHQgPSBwYXJzZSgndHJhY2VEYXRhLmNvbnRleHQuc3RhdGUubmFtZScpKG9wdGlvbnMpIHx8IHBhcnNlKCd0cmFjZURhdGEuY29udGV4dCcpKG9wdGlvbnMpIHx8ICd1bmtub3duJyxcbiAgICAgIG5hbWUgPSBmblRvU3RyaW5nKHJlZ2lzdGVyZWRIb29rLmNhbGxiYWNrKTtcbiAgICByZXR1cm4gYCR7ZXZlbnR9IGNvbnRleHQ6ICR7Y29udGV4dH0sICR7bWF4TGVuZ3RoKDIwMCwgbmFtZSl9YDtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiAqL1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIEdsb2IsIGV4dGVuZCwgcmVtb3ZlRnJvbSwgdGFpbCwgdmFsdWVzLCBpZGVudGl0eSwgbWFwT2JqIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5pbXBvcnQge1xuICBUcmFuc2l0aW9uU3RhdGVIb29rRm4sXG4gIFRyYW5zaXRpb25Ib29rRm4sXG4gIFRyYW5zaXRpb25Ib29rUGhhc2UsIC8vIGhhcyBvciBpcyB1c2luZ1xuICBUcmFuc2l0aW9uSG9va1Njb3BlLFxuICBJSG9va1JlZ2lzdHJ5LFxuICBQYXRoVHlwZSxcbn0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG5pbXBvcnQge1xuICBIb29rUmVnT3B0aW9ucyxcbiAgSG9va01hdGNoQ3JpdGVyaWEsXG4gIFRyZWVDaGFuZ2VzLFxuICBIb29rTWF0Y2hDcml0ZXJpb24sXG4gIElNYXRjaGluZ05vZGVzLFxuICBIb29rRm4sXG59IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uRXZlbnRUeXBlIH0gZnJvbSAnLi90cmFuc2l0aW9uRXZlbnRUeXBlJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmFuc2l0aW9uU2VydmljZSc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gc3RhdGUgbWF0Y2hlcyB0aGUgbWF0Y2hDcml0ZXJpYVxuICpcbiAqIEBoaWRkZW5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgYSBTdGF0ZSBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0gY3JpdGVyaW9uXG4gKiAtIElmIGEgc3RyaW5nLCBtYXRjaFN0YXRlIHVzZXMgdGhlIHN0cmluZyBhcyBhIGdsb2ItbWF0Y2hlciBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAtIElmIGFuIGFycmF5IChvZiBzdHJpbmdzKSwgbWF0Y2hTdGF0ZSB1c2VzIGVhY2ggc3RyaW5nIGluIHRoZSBhcnJheSBhcyBhIGdsb2ItbWF0Y2hlcnMgYWdhaW5zdCB0aGUgc3RhdGUgbmFtZVxuICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXG4gKiAtIElmIGEgZnVuY3Rpb24sIG1hdGNoU3RhdGUgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN0YXRlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IGlzIHRydXRoeS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hTdGF0ZShzdGF0ZTogU3RhdGVPYmplY3QsIGNyaXRlcmlvbjogSG9va01hdGNoQ3JpdGVyaW9uLCB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XG4gIGNvbnN0IHRvTWF0Y2ggPSBpc1N0cmluZyhjcml0ZXJpb24pID8gW2NyaXRlcmlvbl0gOiBjcml0ZXJpb247XG5cbiAgZnVuY3Rpb24gbWF0Y2hHbG9icyhfc3RhdGU6IFN0YXRlT2JqZWN0KSB7XG4gICAgY29uc3QgZ2xvYlN0cmluZ3MgPSA8c3RyaW5nW10+dG9NYXRjaDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2JTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBnbG9iID0gbmV3IEdsb2IoZ2xvYlN0cmluZ3NbaV0pO1xuXG4gICAgICBpZiAoKGdsb2IgJiYgZ2xvYi5tYXRjaGVzKF9zdGF0ZS5uYW1lKSkgfHwgKCFnbG9iICYmIGdsb2JTdHJpbmdzW2ldID09PSBfc3RhdGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoRm4gPSA8YW55Pihpc0Z1bmN0aW9uKHRvTWF0Y2gpID8gdG9NYXRjaCA6IG1hdGNoR2xvYnMpO1xuICByZXR1cm4gISFtYXRjaEZuKHN0YXRlLCB0cmFuc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIFRoZSByZWdpc3RyYXRpb24gZGF0YSBmb3IgYSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0ZXJlZEhvb2sge1xuICBwcmlvcml0eTogbnVtYmVyO1xuICBiaW5kOiBhbnk7XG4gIGludm9rZUNvdW50ID0gMDtcbiAgaW52b2tlTGltaXQ6IG51bWJlcjtcbiAgX2RlcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyB0cmFuU3ZjOiBUcmFuc2l0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgZXZlbnRUeXBlOiBUcmFuc2l0aW9uRXZlbnRUeXBlLFxuICAgIHB1YmxpYyBjYWxsYmFjazogSG9va0ZuLFxuICAgIHB1YmxpYyBtYXRjaENyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSxcbiAgICBwdWJsaWMgcmVtb3ZlSG9va0Zyb21SZWdpc3RyeTogKGhvb2s6IFJlZ2lzdGVyZWRIb29rKSA9PiB2b2lkLFxuICAgIG9wdGlvbnM6IEhvb2tSZWdPcHRpb25zID0ge30gYXMgYW55XG4gICkge1xuICAgIHRoaXMucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5IHx8IDA7XG4gICAgdGhpcy5iaW5kID0gb3B0aW9ucy5iaW5kIHx8IG51bGw7XG4gICAgdGhpcy5pbnZva2VMaW1pdCA9IG9wdGlvbnMuaW52b2tlTGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbWF0Y2hpbmcgW1tQYXRoTm9kZV1dc1xuICAgKlxuICAgKiBHaXZlbiBhbiBhcnJheSBvZiBbW1BhdGhOb2RlXV1zLCBhbmQgYSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dLCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmdcbiAgICogdGhlIFtbUGF0aE5vZGVdXXMgdGhhdCB0aGUgY3JpdGVyaWEgbWF0Y2hlcywgb3IgYG51bGxgIGlmIHRoZXJlIHdlcmUgbm8gbWF0Y2hpbmcgbm9kZXMuXG4gICAqXG4gICAqIFJldHVybmluZyBgbnVsbGAgaXMgc2lnbmlmaWNhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVmYXVsdFxuICAgKiBcIm1hdGNoLWFsbCBjcml0ZXJpb24gdmFsdWVcIiBvZiBgdHJ1ZWAgY29tcGFyZWQgdG8gYSBgKCkgPT4gdHJ1ZWAgZnVuY3Rpb24sXG4gICAqIHdoZW4gdGhlIG5vZGVzIGlzIGFuIGVtcHR5IGFycmF5LlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBhbGxvdyBhIHRyYW5zaXRpb24gbWF0Y2ggY3JpdGVyaWEgb2YgYGVudGVyaW5nOiB0cnVlYFxuICAgKiB0byBzdGlsbCBtYXRjaCBhIHRyYW5zaXRpb24sIGV2ZW4gd2hlbiBgZW50ZXJpbmcgPT09IFtdYC4gIENvbnRyYXN0IHRoYXRcbiAgICogd2l0aCBgZW50ZXJpbmc6IChzdGF0ZSkgPT4gdHJ1ZWAgd2hpY2ggb25seSBtYXRjaGVzIHdoZW4gYSBzdGF0ZSBpcyBhY3R1YWxseVxuICAgKiBiZWluZyBlbnRlcmVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfbWF0Y2hpbmdOb2Rlcyhub2RlczogUGF0aE5vZGVbXSwgY3JpdGVyaW9uOiBIb29rTWF0Y2hDcml0ZXJpb24sIHRyYW5zaXRpb246IFRyYW5zaXRpb24pOiBQYXRoTm9kZVtdIHtcbiAgICBpZiAoY3JpdGVyaW9uID09PSB0cnVlKSByZXR1cm4gbm9kZXM7XG4gICAgY29uc3QgbWF0Y2hpbmcgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiBtYXRjaFN0YXRlKG5vZGUuc3RhdGUsIGNyaXRlcmlvbiwgdHJhbnNpdGlvbikpO1xuICAgIHJldHVybiBtYXRjaGluZy5sZW5ndGggPyBtYXRjaGluZyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZGVmYXVsdCBtYXRjaCBjcml0ZXJpYSAoYWxsIGB0cnVlYClcbiAgICpcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggaGFzIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2ggcGF0aHMgYXMga2V5cyBhbmQgYHRydWVgIGFzIHZhbHVlcywgaS5lLjpcbiAgICpcbiAgICogYGBganNcbiAgICoge1xuICAgKiAgIHRvOiB0cnVlLFxuICAgKiAgIGZyb206IHRydWUsXG4gICAqICAgZW50ZXJpbmc6IHRydWUsXG4gICAqICAgZXhpdGluZzogdHJ1ZSxcbiAgICogICByZXRhaW5lZDogdHJ1ZSxcbiAgICogfVxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEoKTogSG9va01hdGNoQ3JpdGVyaWEge1xuICAgIHJldHVybiBtYXBPYmoodGhpcy50cmFuU3ZjLl9wbHVnaW5hcGkuX2dldFBhdGhUeXBlcygpLCAoKSA9PiB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIG1hdGNoaW5nIG5vZGVzIGFzIFtbSU1hdGNoaW5nTm9kZXNdXVxuICAgKlxuICAgKiBDcmVhdGUgYSBJTWF0Y2hpbmdOb2RlcyBvYmplY3QgZnJvbSB0aGUgVHJhbnNpdGlvbkhvb2tUeXBlcyB0aGF0IGlzIHJvdWdobHkgZXF1aXZhbGVudCB0bzpcbiAgICpcbiAgICogYGBganNcbiAgICogbGV0IG1hdGNoZXM6IElNYXRjaGluZ05vZGVzID0ge1xuICAgKiAgIHRvOiAgICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy50byldLCAgIG1jLnRvKSxcbiAgICogICBmcm9tOiAgICAgX21hdGNoaW5nTm9kZXMoW3RhaWwodHJlZUNoYW5nZXMuZnJvbSldLCBtYy5mcm9tKSxcbiAgICogICBleGl0aW5nOiAgX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZXhpdGluZywgICAgICBtYy5leGl0aW5nKSxcbiAgICogICByZXRhaW5lZDogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMucmV0YWluZWQsICAgICBtYy5yZXRhaW5lZCksXG4gICAqICAgZW50ZXJpbmc6IF9tYXRjaGluZ05vZGVzKHRyZWVDaGFuZ2VzLmVudGVyaW5nLCAgICAgbWMuZW50ZXJpbmcpLFxuICAgKiB9O1xuICAgKiBgYGBcbiAgICovXG4gIHByaXZhdGUgX2dldE1hdGNoaW5nTm9kZXModHJlZUNoYW5nZXM6IFRyZWVDaGFuZ2VzLCB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKTogSU1hdGNoaW5nTm9kZXMge1xuICAgIGNvbnN0IGNyaXRlcmlhID0gZXh0ZW5kKHRoaXMuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhKCksIHRoaXMubWF0Y2hDcml0ZXJpYSk7XG4gICAgY29uc3QgcGF0aHM6IFBhdGhUeXBlW10gPSB2YWx1ZXModGhpcy50cmFuU3ZjLl9wbHVnaW5hcGkuX2dldFBhdGhUeXBlcygpKTtcblxuICAgIHJldHVybiBwYXRocy5yZWR1Y2UoXG4gICAgICAobW46IElNYXRjaGluZ05vZGVzLCBwYXRodHlwZTogUGF0aFR5cGUpID0+IHtcbiAgICAgICAgLy8gU1RBVEUgc2NvcGUgY3JpdGVyaWEgbWF0Y2hlcyBhZ2FpbnN0IGV2ZXJ5IG5vZGUgaW4gdGhlIHBhdGguXG4gICAgICAgIC8vIFRSQU5TSVRJT04gc2NvcGUgY3JpdGVyaWEgbWF0Y2hlcyBhZ2FpbnN0IG9ubHkgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgcGF0aFxuICAgICAgICBjb25zdCBpc1N0YXRlSG9vayA9IHBhdGh0eXBlLnNjb3BlID09PSBUcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFO1xuICAgICAgICBjb25zdCBwYXRoID0gdHJlZUNoYW5nZXNbcGF0aHR5cGUubmFtZV0gfHwgW107XG4gICAgICAgIGNvbnN0IG5vZGVzOiBQYXRoTm9kZVtdID0gaXNTdGF0ZUhvb2sgPyBwYXRoIDogW3RhaWwocGF0aCldO1xuXG4gICAgICAgIG1uW3BhdGh0eXBlLm5hbWVdID0gdGhpcy5fbWF0Y2hpbmdOb2Rlcyhub2RlcywgY3JpdGVyaWFbcGF0aHR5cGUubmFtZV0sIHRyYW5zaXRpb24pO1xuICAgICAgICByZXR1cm4gbW47XG4gICAgICB9LFxuICAgICAge30gYXMgSU1hdGNoaW5nTm9kZXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhpcyBob29rJ3MgW1ttYXRjaENyaXRlcmlhXV0gbWF0Y2ggdGhlIGdpdmVuIFtbVHJlZUNoYW5nZXNdXVxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QsIG9yIG51bGwuIElmIGFuIElNYXRjaGluZ05vZGVzIG9iamVjdCBpcyByZXR1cm5lZCwgaXRzIHZhbHVlc1xuICAgKiBhcmUgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXMgZm9yIGVhY2ggW1tIb29rTWF0Y2hDcml0ZXJpb25dXSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcbiAgICovXG4gIG1hdGNoZXModHJlZUNoYW5nZXM6IFRyZWVDaGFuZ2VzLCB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKTogSU1hdGNoaW5nTm9kZXMge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLl9nZXRNYXRjaGluZ05vZGVzKHRyZWVDaGFuZ2VzLCB0cmFuc2l0aW9uKTtcblxuICAgIC8vIENoZWNrIGlmIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2hlZCB0aGUgVHJlZUNoYW5nZXMgb2JqZWN0XG4gICAgY29uc3QgYWxsTWF0Y2hlZCA9IHZhbHVlcyhtYXRjaGVzKS5ldmVyeShpZGVudGl0eSk7XG4gICAgcmV0dXJuIGFsbE1hdGNoZWQgPyBtYXRjaGVzIDogbnVsbDtcbiAgfVxuXG4gIGRlcmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5yZW1vdmVIb29rRnJvbVJlZ2lzdHJ5KHRoaXMpO1xuICAgIHRoaXMuX2RlcmVnaXN0ZXJlZCA9IHRydWU7XG4gIH1cbn1cblxuLyoqIEBoaWRkZW4gUmV0dXJuIGEgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIG9mIHRoZSByZXF1ZXN0ZWQgdHlwZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXZlbnQoXG4gIHJlZ2lzdHJ5OiBJSG9va1JlZ2lzdHJ5LFxuICB0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UsXG4gIGV2ZW50VHlwZTogVHJhbnNpdGlvbkV2ZW50VHlwZVxuKSB7XG4gIC8vIENyZWF0ZSB0aGUgb2JqZWN0IHdoaWNoIGhvbGRzIHRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MuXG4gIGNvbnN0IF9yZWdpc3RlcmVkSG9va3MgPSAocmVnaXN0cnkuX3JlZ2lzdGVyZWRIb29rcyA9IHJlZ2lzdHJ5Ll9yZWdpc3RlcmVkSG9va3MgfHwge30pO1xuICBjb25zdCBob29rcyA9IChfcmVnaXN0ZXJlZEhvb2tzW2V2ZW50VHlwZS5uYW1lXSA9IFtdKTtcbiAgY29uc3QgcmVtb3ZlSG9va0ZuOiAoaG9vazogUmVnaXN0ZXJlZEhvb2spID0+IHZvaWQgPSByZW1vdmVGcm9tKGhvb2tzKTtcblxuICAvLyBDcmVhdGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb24gb24gdGhlIElIb29rUmVnaXN0cnkgZm9yIHRoZSBldmVudFxuICByZWdpc3RyeVtldmVudFR5cGUubmFtZV0gPSBob29rUmVnaXN0cmF0aW9uRm47XG5cbiAgZnVuY3Rpb24gaG9va1JlZ2lzdHJhdGlvbkZuKG1hdGNoT2JqZWN0LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZEhvb2sgPSBuZXcgUmVnaXN0ZXJlZEhvb2soXG4gICAgICB0cmFuc2l0aW9uU2VydmljZSxcbiAgICAgIGV2ZW50VHlwZSxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWF0Y2hPYmplY3QsXG4gICAgICByZW1vdmVIb29rRm4sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBob29rcy5wdXNoKHJlZ2lzdGVyZWRIb29rKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZEhvb2suZGVyZWdpc3Rlci5iaW5kKHJlZ2lzdGVyZWRIb29rKTtcbiAgfVxuXG4gIHJldHVybiBob29rUmVnaXN0cmF0aW9uRm47XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHRyYW5zaXRpb24gKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIHRhaWwsIGFzc2VydFByZWRpY2F0ZSwgdW5uZXN0UiwgaWRlbnRpdHkgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5cbmltcG9ydCB7XG4gIFRyYW5zaXRpb25PcHRpb25zLFxuICBUcmFuc2l0aW9uSG9va09wdGlvbnMsXG4gIElIb29rUmVnaXN0cnksXG4gIFRyZWVDaGFuZ2VzLFxuICBJTWF0Y2hpbmdOb2RlcyxcbiAgVHJhbnNpdGlvbkhvb2tQaGFzZSxcbiAgVHJhbnNpdGlvbkhvb2tTY29wZSxcbn0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rIH0gZnJvbSAnLi90cmFuc2l0aW9uSG9vayc7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uL3N0YXRlL3N0YXRlT2JqZWN0JztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU2VydmljZSB9IGZyb20gJy4vdHJhbnNpdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkV2ZW50VHlwZSB9IGZyb20gJy4vdHJhbnNpdGlvbkV2ZW50VHlwZSc7XG5pbXBvcnQgeyBSZWdpc3RlcmVkSG9vayB9IGZyb20gJy4vaG9va1JlZ2lzdHJ5JztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJldHVybnMgYXBwbGljYWJsZSBUcmFuc2l0aW9uSG9va3MgZm9yIGEgc3BlY2lmaWMgVHJhbnNpdGlvbiBpbnN0YW5jZS5cbiAqXG4gKiBIb29rcyAoW1tSZWdpc3RlcmVkSG9va11dKSBtYXkgYmUgcmVnaXN0ZXJlZCBnbG9iYWxseSwgZS5nLiwgJHRyYW5zaXRpb25zLm9uRW50ZXIoLi4uKSwgb3IgbG9jYWxseSwgZS5nLlxuICogbXlUcmFuc2l0aW9uLm9uRW50ZXIoLi4uKS4gIFRoZSBIb29rQnVpbGRlciBmaW5kcyBtYXRjaGluZyBSZWdpc3RlcmVkSG9va3MgKHdoZXJlIHRoZSBtYXRjaCBjcml0ZXJpYSBpc1xuICogZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBvZiBob29rKVxuICpcbiAqIFRoZSBIb29rQnVpbGRlciBhbHNvIGNvbnZlcnRzIFJlZ2lzdGVyZWRIb29rcyBvYmplY3RzIHRvIFRyYW5zaXRpb25Ib29rIG9iamVjdHMsIHdoaWNoIGFyZSB1c2VkIHRvIHJ1biBhIFRyYW5zaXRpb24uXG4gKlxuICogVGhlIEhvb2tCdWlsZGVyIGNvbnN0cnVjdG9yIGlzIGdpdmVuIHRoZSAkdHJhbnNpdGlvbnMgc2VydmljZSBhbmQgYSBUcmFuc2l0aW9uIGluc3RhbmNlLiAgVGh1cywgYSBIb29rQnVpbGRlclxuICogaW5zdGFuY2UgbWF5IG9ubHkgYmUgdXNlZCBmb3Igb25lIHNwZWNpZmljIFRyYW5zaXRpb24gb2JqZWN0LiAoc2lkZSBub3RlOiB0aGUgX3RyZWVDaGFuZ2VzIGFjY2Vzc29yIGlzIHByaXZhdGVcbiAqIGluIHRoZSBUcmFuc2l0aW9uIGNsYXNzLCBzbyB3ZSBtdXN0IGFsc28gcHJvdmlkZSB0aGUgVHJhbnNpdGlvbidzIF90cmVlQ2hhbmdlcylcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBIb29rQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJhbnNpdGlvbjogVHJhbnNpdGlvbikge31cblxuICBidWlsZEhvb2tzRm9yUGhhc2UocGhhc2U6IFRyYW5zaXRpb25Ib29rUGhhc2UpOiBUcmFuc2l0aW9uSG9va1tdIHtcbiAgICBjb25zdCAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgIHJldHVybiAkdHJhbnNpdGlvbnMuX3BsdWdpbmFwaVxuICAgICAgLl9nZXRFdmVudHMocGhhc2UpXG4gICAgICAubWFwKHR5cGUgPT4gdGhpcy5idWlsZEhvb2tzKHR5cGUpKVxuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgIC5maWx0ZXIoaWRlbnRpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbmV3bHkgYnVpbHQgVHJhbnNpdGlvbkhvb2sgb2JqZWN0cy5cbiAgICpcbiAgICogLSBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiBgaG9va1R5cGVgIHdoaWNoIG1hdGNoZWQgdGhlIHRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzXV0uXG4gICAqIC0gRmluZHMgW1tQYXRoTm9kZV1dIChvciBgUGF0aE5vZGVbXWApIHRvIHVzZSBhcyB0aGUgVHJhbnNpdGlvbkhvb2sgY29udGV4dChzKVxuICAgKiAtIEZvciBlYWNoIG9mIHRoZSBbW1BhdGhOb2RlXV1zLCBjcmVhdGVzIGEgVHJhbnNpdGlvbkhvb2tcbiAgICpcbiAgICogQHBhcmFtIGhvb2tUeXBlIHRoZSB0eXBlIG9mIHRoZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiwgZS5nLiwgJ29uRW50ZXInLCAnb25GaW5pc2gnLlxuICAgKi9cbiAgYnVpbGRIb29rcyhob29rVHlwZTogVHJhbnNpdGlvbkV2ZW50VHlwZSk6IFRyYW5zaXRpb25Ib29rW10ge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb247XG4gICAgY29uc3QgdHJlZUNoYW5nZXMgPSB0cmFuc2l0aW9uLnRyZWVDaGFuZ2VzKCk7XG5cbiAgICAvLyBGaW5kIGFsbCB0aGUgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBob29rcyBmb3IgYSBnaXZlbiBob29rIHR5cGVcbiAgICBjb25zdCBtYXRjaGluZ0hvb2tzID0gdGhpcy5nZXRNYXRjaGluZ0hvb2tzKGhvb2tUeXBlLCB0cmVlQ2hhbmdlcywgdHJhbnNpdGlvbik7XG4gICAgaWYgKCFtYXRjaGluZ0hvb2tzKSByZXR1cm4gW107XG5cbiAgICBjb25zdCBiYXNlSG9va09wdGlvbnMgPSA8VHJhbnNpdGlvbkhvb2tPcHRpb25zPntcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICBjdXJyZW50OiB0cmFuc2l0aW9uLm9wdGlvbnMoKS5jdXJyZW50LFxuICAgIH07XG5cbiAgICBjb25zdCBtYWtlVHJhbnNpdGlvbkhvb2tzID0gKGhvb2s6IFJlZ2lzdGVyZWRIb29rKSA9PiB7XG4gICAgICAvLyBGZXRjaCB0aGUgTm9kZXMgdGhhdCBjYXVzZWQgdGhpcyBob29rIHRvIG1hdGNoLlxuICAgICAgY29uc3QgbWF0Y2hlczogSU1hdGNoaW5nTm9kZXMgPSBob29rLm1hdGNoZXModHJlZUNoYW5nZXMsIHRyYW5zaXRpb24pO1xuICAgICAgLy8gU2VsZWN0IHRoZSBQYXRoTm9kZVtdIHRoYXQgd2lsbCBiZSB1c2VkIGFzIFRyYW5zaXRpb25Ib29rIGNvbnRleHQgb2JqZWN0c1xuICAgICAgY29uc3QgbWF0Y2hpbmdOb2RlczogUGF0aE5vZGVbXSA9IG1hdGNoZXNbaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGgubmFtZV07XG5cbiAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBIb29rVHVwbGVzXG4gICAgICByZXR1cm4gbWF0Y2hpbmdOb2Rlcy5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IF9vcHRpb25zID0gZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJpbmQ6IGhvb2suYmluZCxcbiAgICAgICAgICAgIHRyYWNlRGF0YTogeyBob29rVHlwZTogaG9va1R5cGUubmFtZSwgY29udGV4dDogbm9kZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmFzZUhvb2tPcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBob29rVHlwZS5jcml0ZXJpYU1hdGNoUGF0aC5zY29wZSA9PT0gVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSA/IG5vZGUuc3RhdGUuc2VsZiA6IG51bGw7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25Ib29rID0gbmV3IFRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlLCBob29rLCBfb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiA8SG9va1R1cGxlPnsgaG9vaywgbm9kZSwgdHJhbnNpdGlvbkhvb2sgfTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbWF0Y2hpbmdIb29rc1xuICAgICAgLm1hcChtYWtlVHJhbnNpdGlvbkhvb2tzKVxuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgIC5zb3J0KHR1cGxlU29ydChob29rVHlwZS5yZXZlcnNlU29ydCkpXG4gICAgICAubWFwKHR1cGxlID0+IHR1cGxlLnRyYW5zaXRpb25Ib29rKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIGZyb206XG4gICAqIC0gVGhlIFRyYW5zaXRpb24gb2JqZWN0IGluc3RhbmNlIGhvb2sgcmVnaXN0cnlcbiAgICogLSBUaGUgVHJhbnNpdGlvblNlcnZpY2UgKCR0cmFuc2l0aW9ucykgZ2xvYmFsIGhvb2sgcmVnaXN0cnlcbiAgICpcbiAgICogd2hpY2ggbWF0Y2hlZDpcbiAgICogLSB0aGUgZXZlbnRUeXBlXG4gICAqIC0gdGhlIG1hdGNoQ3JpdGVyaWEgKHRvLCBmcm9tLCBleGl0aW5nLCByZXRhaW5lZCwgZW50ZXJpbmcpXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZWQgW1tSZWdpc3RlcmVkSG9va11dc1xuICAgKi9cbiAgcHVibGljIGdldE1hdGNoaW5nSG9va3MoXG4gICAgaG9va1R5cGU6IFRyYW5zaXRpb25FdmVudFR5cGUsXG4gICAgdHJlZUNoYW5nZXM6IFRyZWVDaGFuZ2VzLFxuICAgIHRyYW5zaXRpb246IFRyYW5zaXRpb25cbiAgKTogUmVnaXN0ZXJlZEhvb2tbXSB7XG4gICAgY29uc3QgaXNDcmVhdGUgPSBob29rVHlwZS5ob29rUGhhc2UgPT09IFRyYW5zaXRpb25Ib29rUGhhc2UuQ1JFQVRFO1xuXG4gICAgLy8gSW5zdGFuY2UgYW5kIEdsb2JhbCBob29rIHJlZ2lzdHJpZXNcbiAgICBjb25zdCAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgIGNvbnN0IHJlZ2lzdHJpZXMgPSBpc0NyZWF0ZSA/IFskdHJhbnNpdGlvbnNdIDogW3RoaXMudHJhbnNpdGlvbiwgJHRyYW5zaXRpb25zXTtcblxuICAgIHJldHVybiByZWdpc3RyaWVzXG4gICAgICAubWFwKChyZWc6IElIb29rUmVnaXN0cnkpID0+IHJlZy5nZXRIb29rcyhob29rVHlwZS5uYW1lKSkgLy8gR2V0IG5hbWVkIGhvb2tzIGZyb20gcmVnaXN0cmllc1xuICAgICAgLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNBcnJheSwgYGJyb2tlbiBldmVudCBuYW1lZDogJHtob29rVHlwZS5uYW1lfWApKSAvLyBTYW5pdHkgY2hlY2tcbiAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pIC8vIFVuLW5lc3QgUmVnaXN0ZXJlZEhvb2tbXVtdIHRvIFJlZ2lzdGVyZWRIb29rW10gYXJyYXlcbiAgICAgIC5maWx0ZXIoaG9vayA9PiBob29rLm1hdGNoZXModHJlZUNoYW5nZXMsIHRyYW5zaXRpb24pKTsgLy8gT25seSB0aG9zZSBzYXRpc2Z5aW5nIG1hdGNoQ3JpdGVyaWFcbiAgfVxufVxuXG5pbnRlcmZhY2UgSG9va1R1cGxlIHtcbiAgaG9vazogUmVnaXN0ZXJlZEhvb2s7XG4gIG5vZGU6IFBhdGhOb2RlO1xuICB0cmFuc2l0aW9uSG9vazogVHJhbnNpdGlvbkhvb2s7XG59XG5cbi8qKlxuICogQSBmYWN0b3J5IGZvciBhIHNvcnQgZnVuY3Rpb24gZm9yIEhvb2tUdXBsZXMuXG4gKlxuICogVGhlIHNvcnQgZnVuY3Rpb24gZmlyc3QgY29tcGFyZXMgdGhlIFBhdGhOb2RlIGRlcHRoIChob3cgZGVlcCBpbiB0aGUgc3RhdGUgdHJlZSBhIG5vZGUgaXMpLCB0aGVuIGNvbXBhcmVzXG4gKiB0aGUgRXZlbnRIb29rIHByaW9yaXR5LlxuICpcbiAqIEBwYXJhbSByZXZlcnNlRGVwdGhTb3J0IGEgYm9vbGVhbiwgd2hlbiB0cnVlLCByZXZlcnNlcyB0aGUgc29ydCBvcmRlciBmb3IgdGhlIG5vZGUgZGVwdGhcbiAqIEByZXR1cm5zIGEgdHVwbGUgc29ydCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB0dXBsZVNvcnQocmV2ZXJzZURlcHRoU29ydCA9IGZhbHNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlRGVwdGhUaGVuUHJpb3JpdHkobDogSG9va1R1cGxlLCByOiBIb29rVHVwbGUpOiBudW1iZXIge1xuICAgIGNvbnN0IGZhY3RvciA9IHJldmVyc2VEZXB0aFNvcnQgPyAtMSA6IDE7XG4gICAgY29uc3QgZGVwdGhEZWx0YSA9IChsLm5vZGUuc3RhdGUucGF0aC5sZW5ndGggLSByLm5vZGUuc3RhdGUucGF0aC5sZW5ndGgpICogZmFjdG9yO1xuICAgIHJldHVybiBkZXB0aERlbHRhICE9PSAwID8gZGVwdGhEZWx0YSA6IHIuaG9vay5wcmlvcml0eSAtIGwuaG9vay5wcmlvcml0eTtcbiAgfTtcbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdHJhbnNpdGlvbiAqLyAvKiogKi9cbmltcG9ydCB7IHRyYWNlIH0gZnJvbSAnLi4vY29tbW9uL3RyYWNlJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9jb21tb24vc3RyaW5ncyc7XG5pbXBvcnQgeyBtYXAsIGZpbmQsIGV4dGVuZCwgbWVyZ2VSLCB0YWlsLCBvbWl0LCBhcnJheVR1cGxlcywgdW5uZXN0UiwgaWRlbnRpdHksIGFueVRydWVSIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBpc09iamVjdCwgaXNVbmRlZmluZWQgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBwcm9wLCBwcm9wRXEsIHZhbCwgbm90LCBpcyB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiwgU3RhdGVPck5hbWUgfSBmcm9tICcuLi9zdGF0ZS9pbnRlcmZhY2UnO1xuaW1wb3J0IHtcbiAgVHJhbnNpdGlvbk9wdGlvbnMsXG4gIFRyZWVDaGFuZ2VzLFxuICBJSG9va1JlZ2lzdHJ5LFxuICBUcmFuc2l0aW9uSG9va1BoYXNlLFxuICBSZWdpc3RlcmVkSG9va3MsXG4gIEhvb2tSZWdPcHRpb25zLFxuICBIb29rTWF0Y2hDcml0ZXJpYSxcbiAgVHJhbnNpdGlvblN0YXRlSG9va0ZuLFxuICBUcmFuc2l0aW9uSG9va0ZuLFxufSBmcm9tICcuL2ludGVyZmFjZSc7IC8vIGhhcyBvciBpcyB1c2luZ1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2sgfSBmcm9tICcuL3RyYW5zaXRpb25Ib29rJztcbmltcG9ydCB7IG1hdGNoU3RhdGUsIG1ha2VFdmVudCwgUmVnaXN0ZXJlZEhvb2sgfSBmcm9tICcuL2hvb2tSZWdpc3RyeSc7XG5pbXBvcnQgeyBIb29rQnVpbGRlciB9IGZyb20gJy4vaG9va0J1aWxkZXInO1xuaW1wb3J0IHsgUGF0aE5vZGUgfSBmcm9tICcuLi9wYXRoL3BhdGhOb2RlJztcbmltcG9ydCB7IFBhdGhVdGlscyB9IGZyb20gJy4uL3BhdGgvcGF0aFV0aWxzJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUgfSBmcm9tICcuLi9zdGF0ZS90YXJnZXRTdGF0ZSc7XG5pbXBvcnQgeyBQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBSZXNvbHZhYmxlIH0gZnJvbSAnLi4vcmVzb2x2ZS9yZXNvbHZhYmxlJztcbmltcG9ydCB7IFZpZXdDb25maWcgfSBmcm9tICcuLi92aWV3L2ludGVyZmFjZSc7XG5pbXBvcnQgeyBSZXNvbHZlQ29udGV4dCB9IGZyb20gJy4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgVUlJbmplY3RvciB9IGZyb20gJy4uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMvaW50ZXJmYWNlJztcbmltcG9ydCB7IFJlc29sdmFibGVMaXRlcmFsIH0gZnJvbSAnLi4vcmVzb2x2ZS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUmVqZWN0aW9uIH0gZnJvbSAnLi9yZWplY3RGYWN0b3J5JztcbmltcG9ydCB7IGFwcGx5UGFpcnMsIGZsYXR0ZW5SLCB1bmlxUiB9IGZyb20gJy4uL2NvbW1vbic7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBzdGF0ZVNlbGY6IChfc3RhdGU6IFN0YXRlT2JqZWN0KSA9PiBTdGF0ZURlY2xhcmF0aW9uID0gcHJvcCgnc2VsZicpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2l0aW9uIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBXaGVuIG5hdmlnYXRpbmcgdG8gYSBzdGF0ZSwgd2UgYXJlIHRyYW5zaXRpb25pbmcgKipmcm9tKiogdGhlIGN1cnJlbnQgc3RhdGUgKip0byoqIHRoZSBuZXcgc3RhdGUuXG4gKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRvL2Zyb20gc3RhdGVzLCBwYXJhbWV0ZXJzLCByZXNvbHZlcy5cbiAqIEl0IGhhcyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgc3RhdGVzIGJlaW5nIGVudGVyZWQgYW5kIGV4aXRlZCBhcyBhIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zaXRpb24gaW1wbGVtZW50cyBJSG9va1JlZ2lzdHJ5IHtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgc3RhdGljIGRpVG9rZW4gPSBUcmFuc2l0aW9uO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyBhbiBhdXRvIGluY3JlbWVudGluZyBpbnRlZ2VyLCBzdGFydGluZyBmcm9tIGAwYC5cbiAgICovXG4gICRpZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAqXG4gICAqIFRoaXMgcmVmZXJlbmNlIGNhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGUgcm91dGVyIHNlcnZpY2VzLCBzdWNoIGFzIHRoZSBbW1N0YXRlU2VydmljZV1dXG4gICAqL1xuICByb3V0ZXI6IFVJUm91dGVyO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2RlZmVycmVkID0gc2VydmljZXMuJHEuZGVmZXIoKTtcbiAgLyoqXG4gICAqIFRoaXMgcHJvbWlzZSBpcyByZXNvbHZlZCBvciByZWplY3RlZCBiYXNlZCBvbiB0aGUgb3V0Y29tZSBvZiB0aGUgVHJhbnNpdGlvbi5cbiAgICpcbiAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxuICAgKiBXaGVuIHRoZSB0cmFuc2l0aW9uIGlzIHVuc3VjY2Vzc2Z1bCwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCB0aGUgW1tSZWplY3Rpb25dXSBvciBqYXZhc2NyaXB0IGVycm9yXG4gICAqL1xuICBwcm9taXNlOiBQcm9taXNlPGFueT4gPSB0aGlzLl9kZWZlcnJlZC5wcm9taXNlO1xuICAvKipcbiAgICogQSBib29sZWFuIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgdHJhbnNpdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgKlxuICAgKiBBZnRlciBhIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbiwgdGhpcyB2YWx1ZSBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQWZ0ZXIgYW4gdW5zdWNjZXNzZnVsIHRyYW5zaXRpb24sIHRoaXMgdmFsdWUgaXMgc2V0IHRvIGZhbHNlLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIHRyYW5zaXRpb24gaXMgbm90IGNvbXBsZXRlXG4gICAqL1xuICBzdWNjZXNzOiBib29sZWFuO1xuICAvKiogQGhpZGRlbiAqL1xuICBfYWJvcnRlZDogYm9vbGVhbjtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfZXJyb3I6IFJlamVjdGlvbjtcblxuICAvKiogQGhpZGRlbiBIb2xkcyB0aGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zIHN1Y2ggYXMgdGhvc2UgcGFzc2VkIHRvIFRyYW5zaXRpb24ub25TdGFydCgpICovXG4gIF9yZWdpc3RlcmVkSG9va3M6IFJlZ2lzdGVyZWRIb29rcyA9IHt9O1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX29wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF90cmVlQ2hhbmdlczogVHJlZUNoYW5nZXM7XG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX3RhcmdldFN0YXRlOiBUYXJnZXRTdGF0ZTtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfaG9va0J1aWxkZXIgPSBuZXcgSG9va0J1aWxkZXIodGhpcyk7XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgb25CZWZvcmUoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25TdGFydChjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvbkV4aXQoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvblJldGFpbihjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uRW50ZXIoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvbkZpbmlzaChjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvblN1Y2Nlc3MoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25FcnJvcihjcml0ZXJpYTogSG9va01hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrOiBUcmFuc2l0aW9uSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqIEBoaWRkZW5cbiAgICogQ3JlYXRlcyB0aGUgdHJhbnNpdGlvbi1sZXZlbCBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnNcbiAgICogKHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgaG9va3MpXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVRyYW5zaXRpb25Ib29rUmVnRm5zKCkge1xuICAgIHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl9wbHVnaW5hcGlcbiAgICAgIC5fZ2V0RXZlbnRzKClcbiAgICAgIC5maWx0ZXIodHlwZSA9PiB0eXBlLmhvb2tQaGFzZSAhPT0gVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEUpXG4gICAgICAuZm9yRWFjaCh0eXBlID0+IG1ha2VFdmVudCh0aGlzLCB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZSwgdHlwZSkpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBnZXRIb29rcyhob29rTmFtZTogc3RyaW5nKTogUmVnaXN0ZXJlZEhvb2tbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRIb29rc1tob29rTmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUcmFuc2l0aW9uIG9iamVjdC5cbiAgICpcbiAgICogSWYgdGhlIHRhcmdldCBzdGF0ZSBpcyBub3QgdmFsaWQsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICpcbiAgICogQGludGVybmFsYXBpXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGZyb20gd2hpY2ggdGhlIHRyYW5zaXRpb24gaXMgbGVhdmluZy4gIFRoZSBsYXN0IG5vZGUgaW4gdGhlIGBmcm9tUGF0aGBcbiAgICogICAgICAgIGVuY2Fwc3VsYXRlcyB0aGUgXCJmcm9tIHN0YXRlXCIuXG4gICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSBUaGUgdGFyZ2V0IHN0YXRlIGFuZCBwYXJhbWV0ZXJzIGJlaW5nIHRyYW5zaXRpb25lZCB0byAoYWxzbywgdGhlIHRyYW5zaXRpb24gb3B0aW9ucylcbiAgICogQHBhcmFtIHJvdXRlciBUaGUgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihmcm9tUGF0aDogUGF0aE5vZGVbXSwgdGFyZ2V0U3RhdGU6IFRhcmdldFN0YXRlLCByb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgdGhpcy5fdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZTtcblxuICAgIGlmICghdGFyZ2V0U3RhdGUudmFsaWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRhcmdldFN0YXRlLmVycm9yKCkpO1xuICAgIH1cblxuICAgIC8vIGN1cnJlbnQoKSBpcyBhc3N1bWVkIHRvIGNvbWUgZnJvbSB0YXJnZXRTdGF0ZS5vcHRpb25zLCBidXQgcHJvdmlkZSBhIG5haXZlIGltcGxlbWVudGF0aW9uIG90aGVyd2lzZS5cbiAgICB0aGlzLl9vcHRpb25zID0gZXh0ZW5kKHsgY3VycmVudDogdmFsKHRoaXMpIH0sIHRhcmdldFN0YXRlLm9wdGlvbnMoKSk7XG4gICAgdGhpcy4kaWQgPSByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuX3RyYW5zaXRpb25Db3VudCsrO1xuICAgIGNvbnN0IHRvUGF0aCA9IFBhdGhVdGlscy5idWlsZFRvUGF0aChmcm9tUGF0aCwgdGFyZ2V0U3RhdGUpO1xuICAgIHRoaXMuX3RyZWVDaGFuZ2VzID0gUGF0aFV0aWxzLnRyZWVDaGFuZ2VzKGZyb21QYXRoLCB0b1BhdGgsIHRoaXMuX29wdGlvbnMucmVsb2FkU3RhdGUpO1xuICAgIHRoaXMuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMoKTtcblxuICAgIGNvbnN0IG9uQ3JlYXRlSG9va3MgPSB0aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UoVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEUpO1xuICAgIFRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKG9uQ3JlYXRlSG9va3MsICgpID0+IG51bGwpO1xuXG4gICAgdGhpcy5hcHBseVZpZXdDb25maWdzKHJvdXRlcik7XG4gIH1cblxuICBwcml2YXRlIGFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyOiBVSVJvdXRlcikge1xuICAgIGNvbnN0IGVudGVyaW5nU3RhdGVzID0gdGhpcy5fdHJlZUNoYW5nZXMuZW50ZXJpbmcubWFwKG5vZGUgPT4gbm9kZS5zdGF0ZSk7XG4gICAgUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLiR2aWV3LCB0aGlzLl90cmVlQ2hhbmdlcy50bywgZW50ZXJpbmdTdGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgZnJvbSBbU3RhdGVdIG9iamVjdFxuICAgKi9cbiAgJGZyb20oKSB7XG4gICAgcmV0dXJuIHRhaWwodGhpcy5fdHJlZUNoYW5nZXMuZnJvbSkuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsYXBpXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCB0byBbU3RhdGVdIG9iamVjdFxuICAgKi9cbiAgJHRvKCkge1xuICAgIHJldHVybiB0YWlsKHRoaXMuX3RyZWVDaGFuZ2VzLnRvKS5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcImZyb20gc3RhdGVcIlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0aGF0IHRoZSB0cmFuc2l0aW9uIGlzIGNvbWluZyAqZnJvbSouXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgKFwiZnJvbSBzdGF0ZVwiKS5cbiAgICovXG4gIGZyb20oKTogU3RhdGVEZWNsYXJhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuJGZyb20oKS5zZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwidG8gc3RhdGVcIlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0aGF0IHRoZSB0cmFuc2l0aW9uIGlzIGdvaW5nICp0byouXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgdGFyZ2V0IHN0YXRlIChcInRvIHN0YXRlXCIpLlxuICAgKi9cbiAgdG8oKTogU3RhdGVEZWNsYXJhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuJHRvKCkuc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBUYXJnZXQgU3RhdGVcbiAgICpcbiAgICogQSB0cmFuc2l0aW9uJ3MgW1tUYXJnZXRTdGF0ZV1dIGVuY2Fwc3VsYXRlcyB0aGUgW1t0b11dIHN0YXRlLCB0aGUgW1twYXJhbXNdXSwgYW5kIHRoZSBbW29wdGlvbnNdXSBhcyBhIHNpbmdsZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBbW1RhcmdldFN0YXRlXV0gb2YgdGhpcyBUcmFuc2l0aW9uXG4gICAqL1xuICB0YXJnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB0cmFuc2l0aW9ucyBhcmUgZXF1aXZhbGVudC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGlzKGNvbXBhcmU6IFRyYW5zaXRpb24gfCB7IHRvPzogYW55OyBmcm9tPzogYW55IH0pOiBib29sZWFuIHtcbiAgICBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICAgIC8vIFRPRE86IEFsc28gY29tcGFyZSBwYXJhbWV0ZXJzXG4gICAgICByZXR1cm4gdGhpcy5pcyh7IHRvOiBjb21wYXJlLiR0bygpLm5hbWUsIGZyb206IGNvbXBhcmUuJGZyb20oKS5uYW1lIH0pO1xuICAgIH1cbiAgICByZXR1cm4gIShcbiAgICAgIChjb21wYXJlLnRvICYmICFtYXRjaFN0YXRlKHRoaXMuJHRvKCksIGNvbXBhcmUudG8sIHRoaXMpKSB8fFxuICAgICAgKGNvbXBhcmUuZnJvbSAmJiAhbWF0Y2hTdGF0ZSh0aGlzLiRmcm9tKCksIGNvbXBhcmUuZnJvbSwgdGhpcykpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRyYW5zaXRpb24gcGFyYW1ldGVyIHZhbHVlc1xuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZvciBhIHRyYW5zaXRpb24gYXMga2V5L3ZhbHVlIHBhaXJzLlxuICAgKiBUaGlzIG9iamVjdCBpcyBpbW11dGFibGUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHJldHVybnMgdGhlIG5ldyBwYXJhbWV0ZXIgdmFsdWVzIChmb3IgdGhlIFwidG8gc3RhdGVcIikuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHRvUGFyYW1zID0gdHJhbnNpdGlvbi5wYXJhbXMoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRvIHJldHVybiB0aGUgcHJldmlvdXMgcGFyYW1ldGVyIHZhbHVlcywgIHN1cHBseSBgJ2Zyb20nYCBhcyB0aGUgYHBhdGhuYW1lYCBhcmd1bWVudC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgZnJvbVBhcmFtcyA9IHRyYW5zaXRpb24ucGFyYW1zKCdmcm9tJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcGF0aG5hbWUgdGhlIG5hbWUgb2YgdGhlIHRyZWVDaGFuZ2VzIHBhdGggdG8gZ2V0IHBhcmFtZXRlciB2YWx1ZXMgZm9yOlxuICAgKiAgIChgJ3RvJ2AsIGAnZnJvbSdgLCBgJ2VudGVyaW5nJ2AsIGAnZXhpdGluZydgLCBgJ3JldGFpbmVkJ2ApXG4gICAqXG4gICAqIEByZXR1cm5zIHRyYW5zaXRpb24gcGFyYW1ldGVyIHZhbHVlcyBmb3IgdGhlIGRlc2lyZWQgcGF0aC5cbiAgICovXG4gIHBhcmFtcyhwYXRobmFtZT86IHN0cmluZyk6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogYW55IH07XG4gIHBhcmFtczxUPihwYXRobmFtZT86IHN0cmluZyk6IFQ7XG4gIHBhcmFtcyhwYXRobmFtZSA9ICd0bycpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0ubWFwKHByb3AoJ3BhcmFtVmFsdWVzJykpLnJlZHVjZShtZXJnZVIsIHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV3IHZhbHVlcyBvZiBhbnkgcGFyYW1ldGVycyB0aGF0IGNoYW5nZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhbnkgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGhhdmUgY2hhbmdlZCBkdXJpbmcgYSB0cmFuc2l0aW9uLCBhcyBrZXkvdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIC0gQW55IHBhcmFtZXRlciB2YWx1ZXMgdGhhdCBoYXZlIGNoYW5nZWQgd2lsbCBiZSBwcmVzZW50IG9uIHRoZSByZXR1cm5lZCBvYmplY3QgcmVmbGVjdGluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiAtIEFueSBwYXJhbWV0ZXJzIHRoYXQgKm5vdCogaGF2ZSBjaGFuZ2VkIHdpbGwgbm90IGJlIHByZXNlbnQgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICogLSBBbnkgbmV3IHBhcmFtZXRlcnMgdGhhdCB3ZXJlbid0IHByZXNlbnQgaW4gdGhlIFwiZnJvbVwiIHN0YXRlLCBidXQgYXJlIG5vdyBwcmVzZW50IGluIHRoZSBcInRvXCIgc3RhdGUgd2lsbCBiZSBwcmVzZW50IG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAqIC0gQW55IHByZXZpb3VzIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQgKGJlY2F1c2UgdGhlIFwidG9cIiBzdGF0ZSBkb2Vzbid0IGhhdmUgdGhlbSkgd2lsbCBiZSBpbmNsdWRlZCB3aXRoIGEgdmFsdWUgb2YgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBvYmplY3QgaXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGVzOlxuICAgKlxuICAgKiBHaXZlbjpcbiAgICogYGBganNcbiAgICogdmFyIHN0YXRlQSA9IHsgbmFtZTogJ3N0YXRlQScsIHVybDogJy9zdGF0ZUEvOnBhcmFtMS9wYXJhbTInIH1cbiAgICogdmFyIHN0YXRlQiA9IHsgbmFtZTogJ3N0YXRlQicsIHVybDogJy9zdGF0ZUIvOnBhcmFtMycgfVxuICAgKiB2YXIgc3RhdGVDID0geyBuYW1lOiAnc3RhdGVCLm5lc3QnLCB1cmw6ICcvbmVzdC86cGFyYW00JyB9XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGUgMVxuICAgKlxuICAgKiBGcm9tIGAvc3RhdGVBL2FiYy9kZWZgIHRvIGAvc3RhdGVBL2FiYy94eXpgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBjaGFuZ2VkID0gdHJhbnNpdGlvbi5wYXJhbXNDaGFuZ2VkKClcbiAgICogLy8gY2hhbmdlZCBpcyB7IHBhcmFtMjogJ3h5eicgfVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHZhbHVlIG9mIGBwYXJhbTJgIGNoYW5nZWQgdG8gYHh5emAuXG4gICAqIFRoZSB2YWx1ZSBvZiBgcGFyYW0xYCBzdGF5ZWQgdGhlIHNhbWUgc28gaXRzIHZhbHVlIGlzIG5vdCBwcmVzZW50LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGUgMlxuICAgKlxuICAgKiBGcm9tIGAvc3RhdGVBL2FiYy9kZWZgIHRvIGAvc3RhdGVCLzEyM2BcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNoYW5nZWQgPSB0cmFuc2l0aW9uLnBhcmFtc0NoYW5nZWQoKVxuICAgKiAvLyBjaGFuZ2VkIGlzIHsgcGFyYW0xOiB1bmRlZmluZWQsIHBhcmFtMjogdW5kZWZpbmVkLCBwYXJhbTM6ICcxMjMnIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSB2YWx1ZSBgcGFyYW0zYCBpcyBwcmVzZW50IGJlY2F1c2UgaXQgaXMgYSBuZXcgcGFyYW0uXG4gICAqIEJvdGggYHBhcmFtMWAgYW5kIGBwYXJhbTJgIGFyZSBubyBsb25nZXIgcHJlc2VudCBzbyB0aGVpciB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZSAzXG4gICAqXG4gICAqIEZyb20gYC9zdGF0ZUIvMTIzYCB0byBgL3N0YXRlQi8xMjMvbmVzdC80NTZgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBjaGFuZ2VkID0gdHJhbnNpdGlvbi5wYXJhbXNDaGFuZ2VkKClcbiAgICogLy8gY2hhbmdlZCBpcyB7IHBhcmFtNDogJzQ1NicgfVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHZhbHVlIGBwYXJhbTRgIGlzIHByZXNlbnQgYmVjYXVzZSBpdCBpcyBhIG5ldyBwYXJhbS5cbiAgICogVGhlIHZhbHVlIG9mIGBwYXJhbTNgIGRpZCBub3QgY2hhbmdlLCBzbyBpdHMgdmFsdWUgaXMgbm90IHByZXNlbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBjaGFuZ2VkIHBhcmFtZXRlciBrZXlzL3ZhbHVlcy5cbiAgICovXG4gIHBhcmFtc0NoYW5nZWQoKTogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBhbnkgfTtcbiAgcGFyYW1zQ2hhbmdlZDxUPigpOiBUO1xuICBwYXJhbXNDaGFuZ2VkKCkge1xuICAgIGNvbnN0IGZyb21QYXJhbXMgPSB0aGlzLnBhcmFtcygnZnJvbScpO1xuICAgIGNvbnN0IHRvUGFyYW1zID0gdGhpcy5wYXJhbXMoJ3RvJyk7XG5cbiAgICAvLyBBbGwgdGhlIHBhcmFtZXRlcnMgZGVjbGFyZWQgb24gYm90aCB0aGUgXCJ0b1wiIGFuZCBcImZyb21cIiBwYXRoc1xuICAgIGNvbnN0IGFsbFBhcmFtRGVzY3JpcHRvcnM6IFBhcmFtW10gPSBbXVxuICAgICAgLmNvbmNhdCh0aGlzLl90cmVlQ2hhbmdlcy50bylcbiAgICAgIC5jb25jYXQodGhpcy5fdHJlZUNoYW5nZXMuZnJvbSlcbiAgICAgIC5tYXAocGF0aE5vZGUgPT4gcGF0aE5vZGUucGFyYW1TY2hlbWEpXG4gICAgICAucmVkdWNlKGZsYXR0ZW5SLCBbXSlcbiAgICAgIC5yZWR1Y2UodW5pcVIsIFtdKTtcblxuICAgIGNvbnN0IGNoYW5nZWRQYXJhbURlc2NyaXB0b3JzID0gUGFyYW0uY2hhbmdlZChhbGxQYXJhbURlc2NyaXB0b3JzLCBmcm9tUGFyYW1zLCB0b1BhcmFtcyk7XG5cbiAgICByZXR1cm4gY2hhbmdlZFBhcmFtRGVzY3JpcHRvcnMucmVkdWNlKChjaGFuZ2VkVmFsdWVzLCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgICBjaGFuZ2VkVmFsdWVzW2Rlc2NyaXB0b3IuaWRdID0gdG9QYXJhbXNbZGVzY3JpcHRvci5pZF07XG4gICAgICByZXR1cm4gY2hhbmdlZFZhbHVlcztcbiAgICB9LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFtbVUlJbmplY3Rvcl1dIERlcGVuZGVuY3kgSW5qZWN0b3JcbiAgICpcbiAgICogUmV0dXJucyBhIERlcGVuZGVuY3kgSW5qZWN0b3IgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgdGFyZ2V0IHN0YXRlICh0byBzdGF0ZSkuXG4gICAqIFRoZSBpbmplY3RvciBwcm92aWRlcyByZXNvbHZlIHZhbHVlcyB3aGljaCB0aGUgdGFyZ2V0IHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAqXG4gICAqIFRoZSBgVUlJbmplY3RvcmAgY2FuIGFsc28gcHJvdmlkZSB2YWx1ZXMgZnJvbSB0aGUgbmF0aXZlIHJvb3QvZ2xvYmFsIGluamVjdG9yIChuZzEvbmcyKS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAub25FbnRlcih7IGVudGVyaW5nOiAnbXlTdGF0ZScgfSwgdHJhbnMgPT4ge1xuICAgKiAgIHZhciBteVJlc29sdmVWYWx1ZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdteVJlc29sdmUnKTtcbiAgICogICAvLyBJbmplY3QgYSBnbG9iYWwgc2VydmljZSBmcm9tIHRoZSBnbG9iYWwvbmF0aXZlIGluamVjdG9yIChpZiBpdCBleGlzdHMpXG4gICAqICAgdmFyIE15U2VydmljZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdNeVNlcnZpY2UnKTtcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEluIHNvbWUgY2FzZXMgKHN1Y2ggYXMgYG9uQmVmb3JlYCksIHlvdSBtYXkgbmVlZCBhY2Nlc3MgdG8gc29tZSByZXNvbHZlIGRhdGEgYnV0IGl0IGhhcyBub3QgeWV0IGJlZW4gZmV0Y2hlZC5cbiAgICogWW91IGNhbiB1c2UgW1tVSUluamVjdG9yLmdldEFzeW5jXV0gdG8gZ2V0IGEgcHJvbWlzZSBmb3IgdGhlIGRhdGEuXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLm9uQmVmb3JlKHt9LCB0cmFucyA9PiB7XG4gICAqICAgcmV0dXJuIHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmMoJ215UmVzb2x2ZScpLnRoZW4obXlSZXNvbHZlVmFsdWUgPT5cbiAgICogICAgIHJldHVybiBteVJlc29sdmVWYWx1ZSAhPT0gJ0FCT1JUJztcbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiBhIGBzdGF0ZWAgaXMgcHJvdmlkZWQsIHRoZSBpbmplY3RvciB0aGF0IGlzIHJldHVybmVkIHdpbGwgYmUgbGltaXRlZCB0byByZXNvbHZlIHZhbHVlcyB0aGF0IHRoZSBwcm92aWRlZCBzdGF0ZSBoYXMgYWNjZXNzIHRvLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgYm90aCBhIHBhcmVudCBzdGF0ZSBgZm9vYCBhbmQgYSBjaGlsZCBzdGF0ZSBgZm9vLmJhcmAgaGF2ZSBib3RoIGRlZmluZWQgYSByZXNvbHZlIHN1Y2ggYXMgYGRhdGFgLlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC5vbkVudGVyKHsgdG86ICdmb28uYmFyJyB9LCB0cmFucyA9PiB7XG4gICAqICAgLy8gcmV0dXJucyByZXN1bHQgb2YgYGZvb2Agc3RhdGUncyBgbXlSZXNvbHZlYCByZXNvbHZlXG4gICAqICAgLy8gZXZlbiB0aG91Z2ggYGZvby5iYXJgIGFsc28gaGFzIGEgYG15UmVzb2x2ZWAgcmVzb2x2ZVxuICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IoJ2ZvbycpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IG5lZWQgcmVzb2x2ZSBkYXRhIGZyb20gdGhlIGV4aXRpbmcgc3RhdGVzLCBwYXNzIGAnZnJvbSdgIGFzIGBwYXRoTmFtZWAuXG4gICAqIFRoZSByZXNvbHZlIGRhdGEgZnJvbSB0aGUgYGZyb21gIHBhdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAub25FeGl0KHsgZXhpdGluZzogJ2Zvby5iYXInIH0sIHRyYW5zID0+IHtcbiAgICogICAvLyBHZXRzIHRoZSByZXNvbHZlIHZhbHVlIG9mIGBteVJlc29sdmVgIGZyb20gdGhlIHN0YXRlIGJlaW5nIGV4aXRlZFxuICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IobnVsbCwgJ2Zyb20nKS5nZXQoJ215UmVzb2x2ZScpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBMaW1pdHMgdGhlIHJlc29sdmVzIHByb3ZpZGVkIHRvIG9ubHkgdGhlIHJlc29sdmVzIHRoZSBwcm92aWRlZCBzdGF0ZSBoYXMgYWNjZXNzIHRvLlxuICAgKiBAcGFyYW0gcGF0aE5hbWUgRGVmYXVsdDogYCd0bydgOiBDaG9vc2VzIHRoZSBwYXRoIGZvciB3aGljaCB0byBjcmVhdGUgdGhlIGluamVjdG9yLiBVc2UgdGhpcyB0byBhY2Nlc3MgcmVzb2x2ZXMgZm9yIGBleGl0aW5nYCBzdGF0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgW1tVSUluamVjdG9yXV1cbiAgICovXG4gIGluamVjdG9yKHN0YXRlPzogU3RhdGVPck5hbWUsIHBhdGhOYW1lID0gJ3RvJyk6IFVJSW5qZWN0b3Ige1xuICAgIGxldCBwYXRoOiBQYXRoTm9kZVtdID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aE5hbWVdO1xuICAgIGlmIChzdGF0ZSkgcGF0aCA9IFBhdGhVdGlscy5zdWJQYXRoKHBhdGgsIG5vZGUgPT4gbm9kZS5zdGF0ZSA9PT0gc3RhdGUgfHwgbm9kZS5zdGF0ZS5uYW1lID09PSBzdGF0ZSk7XG4gICAgcmV0dXJuIG5ldyBSZXNvbHZlQ29udGV4dChwYXRoKS5pbmplY3RvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIGF2YWlsYWJsZSByZXNvbHZlIHRva2VucyAoa2V5cylcbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW2luamVjdG9yXV0gdG8gaW5zcGVjdCB0aGUgcmVzb2x2ZSB2YWx1ZXNcbiAgICogYXZhaWxhYmxlIHRvIHRoZSBUcmFuc2l0aW9uLlxuICAgKlxuICAgKiBUaGlzIHJldHVybnMgYWxsIHRoZSB0b2tlbnMgZGVmaW5lZCBvbiBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dIGJsb2NrcywgZm9yIHRoZSBzdGF0ZXNcbiAgICogaW4gdGhlIFRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzLnRvXV0gcGF0aC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBUaGlzIGV4YW1wbGUgbG9ncyBhbGwgcmVzb2x2ZSB2YWx1ZXNcbiAgICogYGBganNcbiAgICogbGV0IHRva2VucyA9IHRyYW5zLmdldFJlc29sdmVUb2tlbnMoKTtcbiAgICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4gY29uc29sZS5sb2codG9rZW4gKyBcIiA9IFwiICsgdHJhbnMuaW5qZWN0b3IoKS5nZXQodG9rZW4pKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIHByb21pc2VzIGZvciBlYWNoIHJlc29sdmUgdmFsdWUuXG4gICAqIFRoaXMgdHJpZ2dlcnMgZmV0Y2hlcyBvZiByZXNvbHZlcyAoaWYgYW55IGhhdmUgbm90IHlldCBiZWVuIGZldGNoZWQpLlxuICAgKiBXaGVuIGFsbCBwcm9taXNlcyBoYXZlIGFsbCBzZXR0bGVkLCBpdCBsb2dzIHRoZSByZXNvbHZlIHZhbHVlcy5cbiAgICogYGBganNcbiAgICogbGV0IHRva2VucyA9IHRyYW5zLmdldFJlc29sdmVUb2tlbnMoKTtcbiAgICogbGV0IHByb21pc2UgPSB0b2tlbnMubWFwKHRva2VuID0+IHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmModG9rZW4pKTtcbiAgICogUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4odmFsdWVzID0+IGNvbnNvbGUubG9nKFwiUmVzb2x2ZWQgdmFsdWVzOiBcIiArIHZhbHVlcykpO1xuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZTogQW5ndWxhciAxIHVzZXJzIHdob3VsZCB1c2UgYCRxLmFsbCgpYFxuICAgKlxuICAgKiBAcGFyYW0gcGF0aG5hbWUgcmVzb2x2ZSBjb250ZXh0J3MgcGF0aCBuYW1lIChlLmcuLCBgdG9gIG9yIGBmcm9tYClcbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgcmVzb2x2ZSB0b2tlbnMgKGtleXMpXG4gICAqL1xuICBnZXRSZXNvbHZlVG9rZW5zKHBhdGhuYW1lID0gJ3RvJyk6IGFueVtdIHtcbiAgICByZXR1cm4gbmV3IFJlc29sdmVDb250ZXh0KHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXSkuZ2V0VG9rZW5zKCk7XG4gIH1cblxuICAvKipcbiAgICogRHluYW1pY2FsbHkgYWRkcyBhIG5ldyBbW1Jlc29sdmFibGVdXSAoaS5lLiwgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSkgdG8gdGhpcyB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBBbGxvd3MgYSB0cmFuc2l0aW9uIGhvb2sgdG8gZHluYW1pY2FsbHkgYWRkIGEgUmVzb2x2YWJsZSB0byB0aGlzIFRyYW5zaXRpb24uXG4gICAqXG4gICAqIFVzZSB0aGUgW1tUcmFuc2l0aW9uLmluamVjdG9yXV0gdG8gcmV0cmlldmUgdGhlIHJlc29sdmVkIGRhdGEgaW4gc3Vic2VxdWVudCBob29rcyAoW1tVSUluamVjdG9yLmdldF1dKS5cbiAgICpcbiAgICogSWYgYSBgc3RhdGVgIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGUgUmVzb2x2YWJsZSBpcyBwcm9jZXNzZWQgd2hlbiB0aGF0IHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gICAqIElmIG5vIGBzdGF0ZWAgaXMgcHJvdmlkZWQgdGhlbiB0aGUgcm9vdCBzdGF0ZSBpcyB1c2VkLlxuICAgKiBJZiB0aGUgZ2l2ZW4gYHN0YXRlYCBoYXMgYWxyZWFkeSBiZWVuIGVudGVyZWQsIHRoZSBSZXNvbHZhYmxlIGlzIHByb2Nlc3NlZCB3aGVuIGFueSBjaGlsZCBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiBJZiBubyBjaGlsZCBzdGF0ZXMgd2lsbCBiZSBlbnRlcmVkLCB0aGUgUmVzb2x2YWJsZSBpcyBwcm9jZXNzZWQgZHVyaW5nIHRoZSBgb25GaW5pc2hgIHBoYXNlIG9mIHRoZSBUcmFuc2l0aW9uLlxuICAgKlxuICAgKiBUaGUgYHN0YXRlYCBhcmd1bWVudCBhbHNvIHNjb3BlcyB0aGUgcmVzb2x2ZWQgZGF0YS5cbiAgICogVGhlIHJlc29sdmVkIGRhdGEgaXMgYXZhaWxhYmxlIGZyb20gdGhlIGluamVjdG9yIGZvciB0aGF0IGBzdGF0ZWAgYW5kIGFueSBjaGlsZHJlbiBzdGF0ZXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIHRyYW5zaXRpb24gPT4ge1xuICAgKiAgIHRyYW5zaXRpb24uYWRkUmVzb2x2YWJsZSh7XG4gICAqICAgICB0b2tlbjogJ215UmVzb2x2ZScsXG4gICAqICAgICBkZXBzOiBbJ015U2VydmljZSddLFxuICAgKiAgICAgcmVzb2x2ZUZuOiBteVNlcnZpY2UgPT4gbXlTZXJ2aWNlLmdldERhdGEoKVxuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByZXNvbHZhYmxlIGEgW1tSZXNvbHZhYmxlTGl0ZXJhbF1dIG9iamVjdCAob3IgYSBbW1Jlc29sdmFibGVdXSlcbiAgICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSBpbiB0aGUgXCJ0byBwYXRoXCIgd2hpY2ggc2hvdWxkIHJlY2VpdmUgdGhlIG5ldyByZXNvbHZlIChvdGhlcndpc2UsIHRoZSByb290IHN0YXRlKVxuICAgKi9cbiAgYWRkUmVzb2x2YWJsZShyZXNvbHZhYmxlOiBSZXNvbHZhYmxlIHwgUmVzb2x2YWJsZUxpdGVyYWwsIHN0YXRlOiBTdGF0ZU9yTmFtZSA9ICcnKTogdm9pZCB7XG4gICAgcmVzb2x2YWJsZSA9IGlzKFJlc29sdmFibGUpKHJlc29sdmFibGUpID8gcmVzb2x2YWJsZSA6IG5ldyBSZXNvbHZhYmxlKHJlc29sdmFibGUpO1xuXG4gICAgY29uc3Qgc3RhdGVOYW1lOiBzdHJpbmcgPSB0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnID8gc3RhdGUgOiBzdGF0ZS5uYW1lO1xuICAgIGNvbnN0IHRvcGF0aCA9IHRoaXMuX3RyZWVDaGFuZ2VzLnRvO1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSBmaW5kKHRvcGF0aCwgbm9kZSA9PiBub2RlLnN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZSk7XG4gICAgY29uc3QgcmVzb2x2ZUNvbnRleHQ6IFJlc29sdmVDb250ZXh0ID0gbmV3IFJlc29sdmVDb250ZXh0KHRvcGF0aCk7XG4gICAgcmVzb2x2ZUNvbnRleHQuYWRkUmVzb2x2YWJsZXMoW3Jlc29sdmFibGUgYXMgUmVzb2x2YWJsZV0sIHRhcmdldE5vZGUuc3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zaXRpb24gZnJvbSB3aGljaCB0aGlzIHRyYW5zaXRpb24gd2FzIHJlZGlyZWN0ZWQuXG4gICAqXG4gICAqIElmIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gaXMgYSByZWRpcmVjdCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdHJhbnNpdGlvbiB0aGF0IHdhcyByZWRpcmVjdGVkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGxldCB0cmFuc2l0aW9uQSA9ICRzdGF0ZS5nbygnQScpLnRyYW5zaXRpb25cbiAgICogdHJhbnNpdGlvbkEub25TdGFydCh7fSwgKCkgPT4gJHN0YXRlLnRhcmdldCgnQicpKTtcbiAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnQicgfSwgKHRyYW5zKSA9PiB7XG4gICAqICAgdHJhbnMudG8oKS5uYW1lID09PSAnQic7IC8vIHRydWVcbiAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBUcmFuc2l0aW9uLCBvciBudWxsIGlmIHRoaXMgVHJhbnNpdGlvbiBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0aW9uXG4gICAqL1xuICByZWRpcmVjdGVkRnJvbSgpOiBUcmFuc2l0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5yZWRpcmVjdGVkRnJvbSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gaW4gYSByZWRpcmVjdCBjaGFpblxuICAgKlxuICAgKiBBIHRyYW5zaXRpb24gbWlnaHQgYmVsb25nIHRvIGEgbG9uZyBjaGFpbiBvZiBtdWx0aXBsZSByZWRpcmVjdHMuXG4gICAqIFRoaXMgbWV0aG9kIHdhbGtzIHRoZSBbW3JlZGlyZWN0ZWRGcm9tXV0gY2hhaW4gYmFjayB0byB0aGUgb3JpZ2luYWwgKGZpcnN0KSB0cmFuc2l0aW9uIGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAvLyBzdGF0ZXNcbiAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQScsIHJlZGlyZWN0VG86ICdCJyB9KTtcbiAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQicsIHJlZGlyZWN0VG86ICdDJyB9KTtcbiAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQycsIHJlZGlyZWN0VG86ICdEJyB9KTtcbiAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnRCcgfSk7XG4gICAqXG4gICAqIGxldCB0cmFuc2l0aW9uQSA9ICRzdGF0ZS5nbygnQScpLnRyYW5zaXRpb25cbiAgICpcbiAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnRCcgfSwgKHRyYW5zKSA9PiB7XG4gICAqICAgdHJhbnMudG8oKS5uYW1lID09PSAnRCc7IC8vIHRydWVcbiAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpLnRvKCkubmFtZSA9PT0gJ0MnOyAvLyB0cnVlXG4gICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXG4gICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkudG8oKS5uYW1lID09PSAnQSc7IC8vIHRydWVcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVHJhbnNpdGlvbiB0aGF0IHN0YXJ0ZWQgYSByZWRpcmVjdCBjaGFpblxuICAgKi9cbiAgb3JpZ2luYWxUcmFuc2l0aW9uKCk6IFRyYW5zaXRpb24ge1xuICAgIGNvbnN0IHJmID0gdGhpcy5yZWRpcmVjdGVkRnJvbSgpO1xuICAgIHJldHVybiAocmYgJiYgcmYub3JpZ2luYWxUcmFuc2l0aW9uKCkpIHx8IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2l0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoaXMgVHJhbnNpdGlvbi5cbiAgICovXG4gIG9wdGlvbnMoKTogVHJhbnNpdGlvbk9wdGlvbnMge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXRlcyBiZWluZyBlbnRlcmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICovXG4gIGVudGVyaW5nKCk6IFN0YXRlRGVjbGFyYXRpb25bXSB7XG4gICAgcmV0dXJuIG1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgcHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGV4aXRlZC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgd2lsbCBiZSBleGl0ZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICovXG4gIGV4aXRpbmcoKTogU3RhdGVEZWNsYXJhdGlvbltdIHtcbiAgICByZXR1cm4gbWFwKHRoaXMuX3RyZWVDaGFuZ2VzLmV4aXRpbmcsIHByb3AoJ3N0YXRlJykpXG4gICAgICAubWFwKHN0YXRlU2VsZilcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIHJldGFpbmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCBhcmUgYWxyZWFkeSBlbnRlcmVkIGZyb20gYSBwcmV2aW91cyBUcmFuc2l0aW9uLCB0aGF0IHdpbGwgbm90IGJlXG4gICAqICAgIGV4aXRlZCBkdXJpbmcgdGhpcyBUcmFuc2l0aW9uXG4gICAqL1xuICByZXRhaW5lZCgpOiBTdGF0ZURlY2xhcmF0aW9uW10ge1xuICAgIHJldHVybiBtYXAodGhpcy5fdHJlZUNoYW5nZXMucmV0YWluZWQsIHByb3AoJ3N0YXRlJykpLm1hcChzdGF0ZVNlbGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgW1tWaWV3Q29uZmlnXV1zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFRyYW5zaXRpb25cbiAgICpcbiAgICogRWFjaCBzdGF0ZSBjYW4gZGVmaW5lIG9uZSBvciBtb3JlIHZpZXdzICh0ZW1wbGF0ZS9jb250cm9sbGVyKSwgd2hpY2ggYXJlIGVuY2Fwc3VsYXRlZCBhcyBgVmlld0NvbmZpZ2Agb2JqZWN0cy5cbiAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyB0aGUgYFZpZXdDb25maWdzYCBmb3IgYSBnaXZlbiBwYXRoIGluIHRoZSBUcmFuc2l0aW9uIChlLmcuLCBcInRvXCIgb3IgXCJlbnRlcmluZ1wiKS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGhuYW1lIHRoZSBuYW1lIG9mIHRoZSBwYXRoIHRvIGZldGNoIHZpZXdzIGZvcjpcbiAgICogICAoYCd0bydgLCBgJ2Zyb20nYCwgYCdlbnRlcmluZydgLCBgJ2V4aXRpbmcnYCwgYCdyZXRhaW5lZCdgKVxuICAgKiBAcGFyYW0gc3RhdGUgSWYgcHJvdmlkZWQsIG9ubHkgcmV0dXJucyB0aGUgYFZpZXdDb25maWdgcyBmb3IgYSBzaW5nbGUgc3RhdGUgaW4gdGhlIHBhdGhcbiAgICpcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIFZpZXdDb25maWcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gICAqL1xuICB2aWV3cyhwYXRobmFtZSA9ICdlbnRlcmluZycsIHN0YXRlPzogU3RhdGVPYmplY3QpOiBWaWV3Q29uZmlnW10ge1xuICAgIGxldCBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdO1xuICAgIHBhdGggPSAhc3RhdGUgPyBwYXRoIDogcGF0aC5maWx0ZXIocHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgcmV0dXJuIHBhdGhcbiAgICAgIC5tYXAocHJvcCgndmlld3MnKSlcbiAgICAgIC5maWx0ZXIoaWRlbnRpdHkpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRyYW5zaXRpb24ncyB0cmVlIGNoYW5nZXNcbiAgICpcbiAgICogQSB0cmFuc2l0aW9uIGdvZXMgZnJvbSBvbmUgc3RhdGUvcGFyYW1ldGVycyB0byBhbm90aGVyIHN0YXRlL3BhcmFtZXRlcnMuXG4gICAqIER1cmluZyBhIHRyYW5zaXRpb24sIHN0YXRlcyBhcmUgZW50ZXJlZCBhbmQvb3IgZXhpdGVkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdmFyaW91cyBicmFuY2hlcyAocGF0aHMpIHdoaWNoIHJlcHJlc2VudCB0aGUgY2hhbmdlcyB0byB0aGVcbiAgICogYWN0aXZlIHN0YXRlIHRyZWUgdGhhdCBhcmUgY2F1c2VkIGJ5IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRyZWUgY2hhbmdlcyBwYXRoIHRvIGdldDpcbiAgICogICAoYCd0bydgLCBgJ2Zyb20nYCwgYCdlbnRlcmluZydgLCBgJ2V4aXRpbmcnYCwgYCdyZXRhaW5lZCdgKVxuICAgKi9cbiAgdHJlZUNoYW5nZXMocGF0aG5hbWU6IHN0cmluZyk6IFBhdGhOb2RlW107XG4gIHRyZWVDaGFuZ2VzKCk6IFRyZWVDaGFuZ2VzO1xuICB0cmVlQ2hhbmdlcyhwYXRobmFtZT86IHN0cmluZykge1xuICAgIHJldHVybiBwYXRobmFtZSA/IHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXSA6IHRoaXMuX3RyZWVDaGFuZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNpdGlvbiB0aGF0IGlzIGEgcmVkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgKlxuICAgKiBUaGlzIHRyYW5zaXRpb24gY2FuIGJlIHJldHVybmVkIGZyb20gYSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gaG9vayB0b1xuICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICpcbiAgICogQHJldHVybnMgUmV0dXJucyBhIG5ldyBbW1RyYW5zaXRpb25dXSBpbnN0YW5jZS5cbiAgICovXG4gIHJlZGlyZWN0KHRhcmdldFN0YXRlOiBUYXJnZXRTdGF0ZSk6IFRyYW5zaXRpb24ge1xuICAgIGxldCByZWRpcmVjdHMgPSAxLFxuICAgICAgdHJhbnM6IFRyYW5zaXRpb24gPSB0aGlzO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgd2hpbGUgKCh0cmFucyA9IHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkpICE9IG51bGwpIHtcbiAgICAgIGlmICgrK3JlZGlyZWN0cyA+IDIwKSB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtYW55IGNvbnNlY3V0aXZlIFRyYW5zaXRpb24gcmVkaXJlY3RzICgyMCspYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVkaXJlY3RPcHRzOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHsgcmVkaXJlY3RlZEZyb206IHRoaXMsIHNvdXJjZTogJ3JlZGlyZWN0JyB9O1xuICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBjYXVzZWQgYnkgVVJMIHN5bmMsIHRoZW4gdXNlIHsgbG9jYXRpb246ICdyZXBsYWNlJyB9XG4gICAgLy8gb24gdGhlIG5ldyB0cmFuc2l0aW9uICh1bmxlc3MgdGhlIHRhcmdldCBzdGF0ZSBleHBsaWNpdGx5IHNwZWNpZmllcyBsb2NhdGlvbjogZmFsc2UpLlxuICAgIC8vIFRoaXMgY2F1c2VzIHRoZSBvcmlnaW5hbCB1cmwgdG8gYmUgcmVwbGFjZWQgd2l0aCB0aGUgdXJsIGZvciB0aGUgcmVkaXJlY3QgdGFyZ2V0XG4gICAgLy8gc28gdGhlIG9yaWdpbmFsIHVybCBkaXNhcHBlYXJzIGZyb20gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICBpZiAodGhpcy5vcHRpb25zKCkuc291cmNlID09PSAndXJsJyAmJiB0YXJnZXRTdGF0ZS5vcHRpb25zKCkubG9jYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICByZWRpcmVjdE9wdHMubG9jYXRpb24gPSAncmVwbGFjZSc7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IGV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKCksIHRhcmdldFN0YXRlLm9wdGlvbnMoKSwgcmVkaXJlY3RPcHRzKTtcbiAgICB0YXJnZXRTdGF0ZSA9IHRhcmdldFN0YXRlLndpdGhPcHRpb25zKG5ld09wdGlvbnMsIHRydWUpO1xuXG4gICAgY29uc3QgbmV3VHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZSh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLCB0YXJnZXRTdGF0ZSk7XG4gICAgY29uc3Qgb3JpZ2luYWxFbnRlcmluZ05vZGVzID0gdGhpcy5fdHJlZUNoYW5nZXMuZW50ZXJpbmc7XG4gICAgY29uc3QgcmVkaXJlY3RFbnRlcmluZ05vZGVzID0gbmV3VHJhbnNpdGlvbi5fdHJlZUNoYW5nZXMuZW50ZXJpbmc7XG5cbiAgICAvLyAtLS0gUmUtdXNlIHJlc29sdmUgZGF0YSBmcm9tIG9yaWdpbmFsIHRyYW5zaXRpb24gLS0tXG4gICAgLy8gV2hlbiByZWRpcmVjdGluZyBmcm9tIGEgcGFyZW50IHN0YXRlIHRvIGEgY2hpbGQgc3RhdGUgd2hlcmUgdGhlIHBhcmVudCBwYXJhbWV0ZXIgdmFsdWVzIGhhdmVuJ3QgY2hhbmdlZFxuICAgIC8vIChiZWNhdXNlIG9mIHRoZSByZWRpcmVjdCksIHRoZSByZXNvbHZlcyBmZXRjaGVkIGJ5IHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIGFyZSBzdGlsbCB2YWxpZCBpbiB0aGVcbiAgICAvLyByZWRpcmVjdGVkIHRyYW5zaXRpb24uXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsbG93cyB5b3UgdG8gZGVmaW5lIGEgcmVkaXJlY3Qgb24gYSBwYXJlbnQgc3RhdGUgd2hpY2ggZGVwZW5kcyBvbiBhbiBhc3luYyByZXNvbHZlIHZhbHVlLlxuICAgIC8vIFlvdSBjYW4gd2FpdCBmb3IgdGhlIHJlc29sdmUsIHRoZW4gcmVkaXJlY3QgdG8gYSBjaGlsZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0LlxuICAgIC8vIFRoZSByZWRpcmVjdGVkIHRyYW5zaXRpb24gZG9lcyBub3QgaGF2ZSB0byByZS1mZXRjaCB0aGUgcmVzb2x2ZS5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbnN0IG5vZGVJc1JlbG9hZGluZyA9IChyZWxvYWRTdGF0ZTogU3RhdGVPYmplY3QpID0+IChub2RlOiBQYXRoTm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlbG9hZFN0YXRlICYmIG5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV07XG4gICAgfTtcblxuICAgIC8vIEZpbmQgYW55IFwiZW50ZXJpbmdcIiBub2RlcyBpbiB0aGUgcmVkaXJlY3QgcGF0aCB0aGF0IG1hdGNoIHRoZSBvcmlnaW5hbCBwYXRoIGFuZCBhcmVuJ3QgYmVpbmcgcmVsb2FkZWRcbiAgICBjb25zdCBtYXRjaGluZ0VudGVyaW5nTm9kZXM6IFBhdGhOb2RlW10gPSBQYXRoVXRpbHMubWF0Y2hpbmcoXG4gICAgICByZWRpcmVjdEVudGVyaW5nTm9kZXMsXG4gICAgICBvcmlnaW5hbEVudGVyaW5nTm9kZXMsXG4gICAgICBQYXRoVXRpbHMubm9uRHluYW1pY1BhcmFtc1xuICAgICkuZmlsdGVyKG5vdChub2RlSXNSZWxvYWRpbmcodGFyZ2V0U3RhdGUub3B0aW9ucygpLnJlbG9hZFN0YXRlKSkpO1xuXG4gICAgLy8gVXNlIHRoZSBleGlzdGluZyAocG9zc2libHkgcHJlLXJlc29sdmVkKSByZXNvbHZhYmxlcyBmb3IgdGhlIG1hdGNoaW5nIGVudGVyaW5nIG5vZGVzLlxuICAgIG1hdGNoaW5nRW50ZXJpbmdOb2Rlcy5mb3JFYWNoKChub2RlLCBpZHgpID0+IHtcbiAgICAgIG5vZGUucmVzb2x2YWJsZXMgPSBvcmlnaW5hbEVudGVyaW5nTm9kZXNbaWR4XS5yZXNvbHZhYmxlcztcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXdUcmFuc2l0aW9uO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gSWYgYSB0cmFuc2l0aW9uIGRvZXNuJ3QgZXhpdC9lbnRlciBhbnkgc3RhdGVzLCByZXR1cm5zIGFueSBbW1BhcmFtXV0gd2hvc2UgdmFsdWUgY2hhbmdlZCAqL1xuICBwcml2YXRlIF9jaGFuZ2VkUGFyYW1zKCk6IFBhcmFtW10ge1xuICAgIGNvbnN0IHRjID0gdGhpcy5fdHJlZUNoYW5nZXM7XG5cbiAgICAvKiogUmV0dXJuIHVuZGVmaW5lZCBpZiBpdCdzIG5vdCBhIFwiZHluYW1pY1wiIHRyYW5zaXRpb24sIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbnMgKi9cbiAgICAvLyBJZiB1c2VyIGV4cGxpY2l0bHkgd2FudHMgYSByZWxvYWRcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5yZWxvYWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gSWYgYW55IHN0YXRlcyBhcmUgZXhpdGluZyBvciBlbnRlcmluZ1xuICAgIGlmICh0Yy5leGl0aW5nLmxlbmd0aCB8fCB0Yy5lbnRlcmluZy5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gSWYgdG8vZnJvbSBwYXRoIGxlbmd0aHMgZGlmZmVyXG4gICAgaWYgKHRjLnRvLmxlbmd0aCAhPT0gdGMuZnJvbS5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gSWYgdGhlIHRvL2Zyb20gcGF0aHMgYXJlIGRpZmZlcmVudFxuICAgIGNvbnN0IHBhdGhzRGlmZmVyOiBib29sZWFuID0gYXJyYXlUdXBsZXModGMudG8sIHRjLmZyb20pXG4gICAgICAubWFwKHR1cGxlID0+IHR1cGxlWzBdLnN0YXRlICE9PSB0dXBsZVsxXS5zdGF0ZSlcbiAgICAgIC5yZWR1Y2UoYW55VHJ1ZVIsIGZhbHNlKTtcbiAgICBpZiAocGF0aHNEaWZmZXIpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBGaW5kIGFueSBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgZGlmZmVyXG4gICAgY29uc3Qgbm9kZVNjaGVtYXM6IFBhcmFtW11bXSA9IHRjLnRvLm1hcCgobm9kZTogUGF0aE5vZGUpID0+IG5vZGUucGFyYW1TY2hlbWEpO1xuICAgIGNvbnN0IFt0b1ZhbHVlcywgZnJvbVZhbHVlc10gPSBbdGMudG8sIHRjLmZyb21dLm1hcChwYXRoID0+IHBhdGgubWFwKHggPT4geC5wYXJhbVZhbHVlcykpO1xuICAgIGNvbnN0IHR1cGxlcyA9IGFycmF5VHVwbGVzKG5vZGVTY2hlbWFzLCB0b1ZhbHVlcywgZnJvbVZhbHVlcyk7XG5cbiAgICByZXR1cm4gdHVwbGVzLm1hcCgoW3NjaGVtYSwgdG9WYWxzLCBmcm9tVmFsc10pID0+IFBhcmFtLmNoYW5nZWQoc2NoZW1hLCB0b1ZhbHMsIGZyb21WYWxzKSkucmVkdWNlKHVubmVzdFIsIFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zaXRpb24gaXMgZHluYW1pYy5cbiAgICpcbiAgICogQSB0cmFuc2l0aW9uIGlzIGR5bmFtaWMgaWYgbm8gc3RhdGVzIGFyZSBlbnRlcmVkIG5vciBleGl0ZWQsIGJ1dCBhdCBsZWFzdCBvbmUgZHluYW1pYyBwYXJhbWV0ZXIgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgZHluYW1pY1xuICAgKi9cbiAgZHluYW1pYygpOiBib29sZWFuIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlZFBhcmFtcygpO1xuICAgIHJldHVybiAhY2hhbmdlcyA/IGZhbHNlIDogY2hhbmdlcy5tYXAoeCA9PiB4LmR5bmFtaWMpLnJlZHVjZShhbnlUcnVlUiwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBpZ25vcmVkLlxuICAgKlxuICAgKiBBIHRyYW5zaXRpb24gaXMgaWdub3JlZCBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYW5kIG5vIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIGlnbm9yZWQuXG4gICAqL1xuICBpZ25vcmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX2lnbm9yZWRSZWFzb24oKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIF9pZ25vcmVkUmVhc29uKCk6ICdTYW1lQXNDdXJyZW50JyB8ICdTYW1lQXNQZW5kaW5nJyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjtcbiAgICBjb25zdCByZWxvYWRTdGF0ZSA9IHRoaXMuX29wdGlvbnMucmVsb2FkU3RhdGU7XG5cbiAgICBjb25zdCBzYW1lID0gKHBhdGhBLCBwYXRoQikgPT4ge1xuICAgICAgaWYgKHBhdGhBLmxlbmd0aCAhPT0gcGF0aEIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBtYXRjaGluZyA9IFBhdGhVdGlscy5tYXRjaGluZyhwYXRoQSwgcGF0aEIpO1xuICAgICAgcmV0dXJuIHBhdGhBLmxlbmd0aCA9PT0gbWF0Y2hpbmcuZmlsdGVyKG5vZGUgPT4gIXJlbG9hZFN0YXRlIHx8ICFub2RlLnN0YXRlLmluY2x1ZGVzW3JlbG9hZFN0YXRlLm5hbWVdKS5sZW5ndGg7XG4gICAgfTtcblxuICAgIGNvbnN0IG5ld1RDID0gdGhpcy50cmVlQ2hhbmdlcygpO1xuICAgIGNvbnN0IHBlbmRUQyA9IHBlbmRpbmcgJiYgcGVuZGluZy50cmVlQ2hhbmdlcygpO1xuXG4gICAgaWYgKHBlbmRUQyAmJiBzYW1lKHBlbmRUQy50bywgbmV3VEMudG8pICYmIHNhbWUocGVuZFRDLmV4aXRpbmcsIG5ld1RDLmV4aXRpbmcpKSByZXR1cm4gJ1NhbWVBc1BlbmRpbmcnO1xuICAgIGlmIChuZXdUQy5leGl0aW5nLmxlbmd0aCA9PT0gMCAmJiBuZXdUQy5lbnRlcmluZy5sZW5ndGggPT09IDAgJiYgc2FtZShuZXdUQy5mcm9tLCBuZXdUQy50bykpIHJldHVybiAnU2FtZUFzQ3VycmVudCc7XG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgdHJhbnNpdGlvblxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZW5lcmFsbHkgY2FsbGVkIGZyb20gdGhlIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXG4gICAqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uLlxuICAgKi9cbiAgcnVuKCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcnVuQWxsSG9va3MgPSBUcmFuc2l0aW9uSG9vay5ydW5BbGxIb29rcztcblxuICAgIC8vIEdldHMgdHJhbnNpdGlvbiBob29rcyBhcnJheSBmb3IgdGhlIGdpdmVuIHBoYXNlXG4gICAgY29uc3QgZ2V0SG9va3NGb3IgPSAocGhhc2U6IFRyYW5zaXRpb25Ib29rUGhhc2UpID0+IHRoaXMuX2hvb2tCdWlsZGVyLmJ1aWxkSG9va3NGb3JQaGFzZShwaGFzZSk7XG5cbiAgICAvLyBXaGVuIHRoZSBjaGFpbiBpcyBjb21wbGV0ZSwgdGhlbiByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAgICBjb25zdCB0cmFuc2l0aW9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgIHRyYWNlLnRyYWNlU3VjY2Vzcyh0aGlzLiR0bygpLCB0aGlzKTtcbiAgICAgIHRoaXMuc3VjY2VzcyA9IHRydWU7XG4gICAgICB0aGlzLl9kZWZlcnJlZC5yZXNvbHZlKHRoaXMudG8oKSk7XG4gICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihUcmFuc2l0aW9uSG9va1BoYXNlLlNVQ0NFU1MpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdHJhbnNpdGlvbkVycm9yID0gKHJlYXNvbjogUmVqZWN0aW9uKSA9PiB7XG4gICAgICB0cmFjZS50cmFjZUVycm9yKHJlYXNvbiwgdGhpcyk7XG4gICAgICB0aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2RlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgdGhpcy5fZXJyb3IgPSByZWFzb247XG4gICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihUcmFuc2l0aW9uSG9va1BoYXNlLkVSUk9SKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJ1blRyYW5zaXRpb24gPSAoKSA9PiB7XG4gICAgICAvLyBXYWl0IHRvIGJ1aWxkIHRoZSBSVU4gaG9vayBjaGFpbiB1bnRpbCB0aGUgQkVGT1JFIGhvb2tzIGFyZSBkb25lXG4gICAgICAvLyBUaGlzIGFsbG93cyBhIEJFRk9SRSBob29rIHRvIGR5bmFtaWNhbGx5IGFkZCBhZGRpdGlvbmFsIFJVTiBob29rcyB2aWEgdGhlIFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAgY29uc3QgYWxsUnVuSG9va3MgPSBnZXRIb29rc0ZvcihUcmFuc2l0aW9uSG9va1BoYXNlLlJVTik7XG4gICAgICBjb25zdCBkb25lID0gKCkgPT4gc2VydmljZXMuJHEud2hlbih1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIFRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbFJ1bkhvb2tzLCBkb25lKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgZ2xvYmFscyA9IHRoaXMucm91dGVyLmdsb2JhbHM7XG5cbiAgICAgIGdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPSB0aGlzLiRpZDtcbiAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IHRoaXM7XG4gICAgICBnbG9iYWxzLnRyYW5zaXRpb25IaXN0b3J5LmVucXVldWUodGhpcyk7XG5cbiAgICAgIHRyYWNlLnRyYWNlVHJhbnNpdGlvblN0YXJ0KHRoaXMpO1xuXG4gICAgICByZXR1cm4gc2VydmljZXMuJHEud2hlbih1bmRlZmluZWQpO1xuICAgIH07XG5cbiAgICBjb25zdCBhbGxCZWZvcmVIb29rcyA9IGdldEhvb2tzRm9yKFRyYW5zaXRpb25Ib29rUGhhc2UuQkVGT1JFKTtcbiAgICBUcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhhbGxCZWZvcmVIb29rcywgc3RhcnRUcmFuc2l0aW9uKVxuICAgICAgLnRoZW4ocnVuVHJhbnNpdGlvbilcbiAgICAgIC50aGVuKHRyYW5zaXRpb25TdWNjZXNzLCB0cmFuc2l0aW9uRXJyb3IpO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgfVxuXG4gIC8qKiBDaGVja3MgaWYgdGhpcyB0cmFuc2l0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUvcnVubmluZy4gKi9cbiAgaXNBY3RpdmUgPSAoKSA9PiB0aGlzLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24gPT09IHRoaXM7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgVHJhbnNpdGlvbiBpcyB2YWxpZFxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIHZhbGlkXG4gICAqL1xuICB2YWxpZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZXJyb3IoKSB8fCB0aGlzLnN1Y2Nlc3MgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydHMgdGhpcyB0cmFuc2l0aW9uXG4gICAqXG4gICAqIEltcGVyYXRpdmUgQVBJIHRvIGFib3J0IGEgVHJhbnNpdGlvbi5cbiAgICogVGhpcyBvbmx5IGFwcGxpZXMgdG8gVHJhbnNpdGlvbnMgdGhhdCBhcmUgbm90IHlldCBjb21wbGV0ZS5cbiAgICovXG4gIGFib3J0KCkge1xuICAgIC8vIERvIG5vdCBzZXQgZmxhZyBpZiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGNvbXBsZXRlXG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuc3VjY2VzcykpIHtcbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVHJhbnNpdGlvbiBlcnJvciByZWFzb24uXG4gICAqXG4gICAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGFuZCBjb3VsZCBub3QgYmUgcnVuKSwgcmV0dXJucyB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQuXG4gICAqIElmIHRoZSB0cmFuc2l0aW9uIHdhcyB2YWxpZCBhbmQgcmFuLCBidXQgd2FzIG5vdCBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gZmFpbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRyYW5zaXRpb24gcmVqZWN0aW9uIGV4cGxhaW5pbmcgd2h5IHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQsIG9yIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gZmFpbGVkLlxuICAgKi9cbiAgZXJyb3IoKTogUmVqZWN0aW9uIHtcbiAgICBjb25zdCBzdGF0ZTogU3RhdGVPYmplY3QgPSB0aGlzLiR0bygpO1xuXG4gICAgaWYgKHN0YXRlLnNlbGYuYWJzdHJhY3QpIHtcbiAgICAgIHJldHVybiBSZWplY3Rpb24uaW52YWxpZChgQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJyR7c3RhdGUubmFtZX0nYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1EZWZzID0gc3RhdGUucGFyYW1ldGVycygpO1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyYW1zKCk7XG4gICAgY29uc3QgaW52YWxpZFBhcmFtcyA9IHBhcmFtRGVmcy5maWx0ZXIocGFyYW0gPT4gIXBhcmFtLnZhbGlkYXRlcyh2YWx1ZXNbcGFyYW0uaWRdKSk7XG5cbiAgICBpZiAoaW52YWxpZFBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGludmFsaWRWYWx1ZXMgPSBpbnZhbGlkUGFyYW1zLm1hcChwYXJhbSA9PiBgWyR7cGFyYW0uaWR9OiR7c3RyaW5naWZ5KHZhbHVlc1twYXJhbS5pZF0pfV1gKS5qb2luKCcsICcpO1xuICAgICAgY29uc3QgZGV0YWlsID0gYFRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyIHZhbHVlcyBhcmUgbm90IHZhbGlkIGZvciBzdGF0ZSAnJHtzdGF0ZS5uYW1lfSc6ICR7aW52YWxpZFZhbHVlc31gO1xuICAgICAgcmV0dXJuIFJlamVjdGlvbi5pbnZhbGlkKGRldGFpbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3VjY2VzcyA9PT0gZmFsc2UpIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgZnJvbVN0YXRlT3JOYW1lID0gdGhpcy5mcm9tKCk7XG4gICAgY29uc3QgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcblxuICAgIGNvbnN0IGF2b2lkRW1wdHlIYXNoID0gKHBhcmFtczogUmF3UGFyYW1zKSA9PlxuICAgICAgcGFyYW1zWycjJ10gIT09IG51bGwgJiYgcGFyYW1zWycjJ10gIT09IHVuZGVmaW5lZCA/IHBhcmFtcyA6IG9taXQocGFyYW1zLCBbJyMnXSk7XG5cbiAgICAvLyAoWCkgbWVhbnMgdGhlIHRvIHN0YXRlIGlzIGludmFsaWQuXG4gICAgY29uc3QgaWQgPSB0aGlzLiRpZCxcbiAgICAgIGZyb20gPSBpc09iamVjdChmcm9tU3RhdGVPck5hbWUpID8gZnJvbVN0YXRlT3JOYW1lLm5hbWUgOiBmcm9tU3RhdGVPck5hbWUsXG4gICAgICBmcm9tUGFyYW1zID0gc3RyaW5naWZ5KGF2b2lkRW1wdHlIYXNoKHRoaXMuX3RyZWVDaGFuZ2VzLmZyb20ubWFwKHByb3AoJ3BhcmFtVmFsdWVzJykpLnJlZHVjZShtZXJnZVIsIHt9KSkpLFxuICAgICAgdG9WYWxpZCA9IHRoaXMudmFsaWQoKSA/ICcnIDogJyhYKSAnLFxuICAgICAgdG8gPSBpc09iamVjdCh0b1N0YXRlT3JOYW1lKSA/IHRvU3RhdGVPck5hbWUubmFtZSA6IHRvU3RhdGVPck5hbWUsXG4gICAgICB0b1BhcmFtcyA9IHN0cmluZ2lmeShhdm9pZEVtcHR5SGFzaCh0aGlzLnBhcmFtcygpKSk7XG5cbiAgICByZXR1cm4gYFRyYW5zaXRpb24jJHtpZH0oICcke2Zyb219JyR7ZnJvbVBhcmFtc30gLT4gJHt0b1ZhbGlkfScke3RvfScke3RvUGFyYW1zfSApYDtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQgeyBtYXAsIGluaGVyaXQsIGlkZW50aXR5LCB1bm5lc3QsIHRhaWwsIGZpbmQsIE9iaiwgYWxsVHJ1ZVIsIHVubmVzdFIsIGFycmF5VHVwbGVzIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBwcm9wLCBwcm9wRXEgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nLCBpc0RlZmluZWQgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBQYXJhbSwgRGVmVHlwZSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBQYXJhbVR5cGVzIH0gZnJvbSAnLi4vcGFyYW1zL3BhcmFtVHlwZXMnO1xuaW1wb3J0IHsgUmF3UGFyYW1zIH0gZnJvbSAnLi4vcGFyYW1zL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBVcmxNYXRjaGVyQ29tcGlsZUNvbmZpZyB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGpvaW5OZWlnaGJvcnNSLCBzcGxpdE9uRGVsaW0gfSBmcm9tICcuLi9jb21tb24vc3RyaW5ncyc7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tICcuLi9wYXJhbXMnO1xuaW1wb3J0IHsgZGVmYXVsdHMgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgUGFyYW1GYWN0b3J5IH0gZnJvbSAnLi91cmxNYXRjaGVyRmFjdG9yeSc7XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cChzdHI6IGFueSwgcGFyYW0/OiBhbnkpIHtcbiAgbGV0IHN1cnJvdW5kUGF0dGVybiA9IFsnJywgJyddLFxuICAgIHJlc3VsdCA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dL2csICdcXFxcJCYnKTtcbiAgaWYgKCFwYXJhbSkgcmV0dXJuIHJlc3VsdDtcblxuICBzd2l0Y2ggKHBhcmFtLnNxdWFzaCkge1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJygnLCAnKScgKyAocGFyYW0uaXNPcHRpb25hbCA/ICc/JyA6ICcnKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRydWU6XG4gICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsnKD86LygnLCAnKXwvKT8nXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbYCgke3BhcmFtLnNxdWFzaH18YCwgJyk/J107XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzdWx0ICsgc3Vycm91bmRQYXR0ZXJuWzBdICsgcGFyYW0udHlwZS5wYXR0ZXJuLnNvdXJjZSArIHN1cnJvdW5kUGF0dGVyblsxXTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IG1lbW9pemVUbyA9IChvYmo6IE9iaiwgX3Byb3A6IHN0cmluZywgZm46IEZ1bmN0aW9uKSA9PiAob2JqW19wcm9wXSA9IG9ialtfcHJvcF0gfHwgZm4oKSk7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBzcGxpdE9uU2xhc2ggPSBzcGxpdE9uRGVsaW0oJy8nKTtcblxuLyoqIEBoaWRkZW4gKi9cbmludGVyZmFjZSBVcmxNYXRjaGVyQ2FjaGUge1xuICBzZWdtZW50cz86IGFueVtdO1xuICB3ZWlnaHRzPzogbnVtYmVyW107XG4gIHBhdGg/OiBVcmxNYXRjaGVyW107XG4gIHBhcmVudD86IFVybE1hdGNoZXI7XG4gIHBhdHRlcm4/OiBSZWdFeHA7XG59XG5cbi8qKiBAaGlkZGVuICovXG5pbnRlcmZhY2UgTWF0Y2hEZXRhaWxzIHtcbiAgaWQ6IHN0cmluZztcbiAgcmVnZXhwOiBzdHJpbmc7XG4gIHNlZ21lbnQ6IHN0cmluZztcbiAgdHlwZTogUGFyYW1UeXBlO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZGVmYXVsdENvbmZpZzogVXJsTWF0Y2hlckNvbXBpbGVDb25maWcgPSB7XG4gIHN0YXRlOiB7IHBhcmFtczoge30gfSxcbiAgc3RyaWN0OiB0cnVlLFxuICBjYXNlSW5zZW5zaXRpdmU6IHRydWUsXG59O1xuXG4vKipcbiAqIE1hdGNoZXMgVVJMcyBhZ2FpbnN0IHBhdHRlcm5zLlxuICpcbiAqIE1hdGNoZXMgVVJMcyBhZ2FpbnN0IHBhdHRlcm5zIGFuZCBleHRyYWN0cyBuYW1lZCBwYXJhbWV0ZXJzIGZyb20gdGhlIHBhdGggb3IgdGhlIHNlYXJjaFxuICogcGFydCBvZiB0aGUgVVJMLlxuICpcbiAqIEEgVVJMIHBhdHRlcm4gY29uc2lzdHMgb2YgYSBwYXRoIHBhdHRlcm4sIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgJz8nIGFuZCBhIGxpc3Qgb2Ygc2VhcmNoIChxdWVyeSlcbiAqIHBhcmFtZXRlcnMuIE11bHRpcGxlIHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYXJlIHNlcGFyYXRlZCBieSAnJicuIFNlYXJjaCBwYXJhbWV0ZXJzXG4gKiBkbyBub3QgaW5mbHVlbmNlIHdoZXRoZXIgb3Igbm90IGEgVVJMIGlzIG1hdGNoZWQsIGJ1dCB0aGVpciB2YWx1ZXMgYXJlIHBhc3NlZCB0aHJvdWdoIGludG9cbiAqIHRoZSBtYXRjaGVkIHBhcmFtZXRlcnMgcmV0dXJuZWQgYnkgW1tVcmxNYXRjaGVyLmV4ZWNdXS5cbiAqXG4gKiAtICpQYXRoIHBhcmFtZXRlcnMqIGFyZSBkZWZpbmVkIHVzaW5nIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVycyAoYC9zb21lcGF0aC97cGFyYW19YClcbiAqIG9yIGNvbG9uIHBsYWNlaG9sZGVycyAoYC9zb21lUGF0aC86cGFyYW1gKS5cbiAqXG4gKiAtICpBIHBhcmFtZXRlciBSZWdFeHAqIG1heSBiZSBkZWZpbmVkIGZvciBhIHBhcmFtIGFmdGVyIGEgY29sb25cbiAqIChgL3NvbWVQYXRoL3twYXJhbTpbYS16QS1aMC05XSt9YCkgaW4gYSBjdXJseSBicmFjZSBwbGFjZWhvbGRlci5cbiAqIFRoZSByZWdleHAgbXVzdCBtYXRjaCBmb3IgdGhlIHVybCB0byBiZSBtYXRjaGVkLlxuICogU2hvdWxkIHRoZSByZWdleHAgaXRzZWxmIGNvbnRhaW4gY3VybHkgYnJhY2VzLCB0aGV5IG11c3QgYmUgaW4gbWF0Y2hlZCBwYWlycyBvciBlc2NhcGVkIHdpdGggYSBiYWNrc2xhc2guXG4gKlxuICogTm90ZTogYSBSZWdFeHAgcGFyYW1ldGVyIHdpbGwgZW5jb2RlIGl0cyB2YWx1ZSB1c2luZyBlaXRoZXIgW1tQYXJhbVR5cGVzLnBhdGhdXSBvciBbW1BhcmFtVHlwZXMucXVlcnldXS5cbiAqXG4gKiAtICpDdXN0b20gcGFyYW1ldGVyIHR5cGVzKiBtYXkgYWxzbyBiZSBzcGVjaWZpZWQgYWZ0ZXIgYSBjb2xvbiAoYC9zb21lUGF0aC97cGFyYW06aW50fWApIGluIGN1cmx5IGJyYWNlIHBhcmFtZXRlcnMuXG4gKiAgIFNlZSBbW1VybE1hdGNoZXJGYWN0b3J5LnR5cGVdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAtICpDYXRjaC1hbGwgcGFyYW1ldGVycyogYXJlIGRlZmluZWQgdXNpbmcgYW4gYXN0ZXJpc2sgcGxhY2Vob2xkZXIgKGAvc29tZXBhdGgvKmNhdGNoYWxscGFyYW1gKS5cbiAqICAgQSBjYXRjaC1hbGwgKiBwYXJhbWV0ZXIgdmFsdWUgd2lsbCBjb250YWluIHRoZSByZW1haW5kZXIgb2YgdGhlIFVSTC5cbiAqXG4gKiAtLS1cbiAqXG4gKiBQYXJhbWV0ZXIgbmFtZXMgbWF5IGNvbnRhaW4gb25seSB3b3JkIGNoYXJhY3RlcnMgKGxhdGluIGxldHRlcnMsIGRpZ2l0cywgYW5kIHVuZGVyc2NvcmUpIGFuZFxuICogbXVzdCBiZSB1bmlxdWUgd2l0aGluIHRoZSBwYXR0ZXJuIChhY3Jvc3MgYm90aCBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycykuXG4gKiBBIHBhdGggcGFyYW1ldGVyIG1hdGNoZXMgYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gJy8nLiBGb3IgY2F0Y2gtYWxsXG4gKiBwbGFjZWhvbGRlcnMgdGhlIHBhdGggcGFyYW1ldGVyIG1hdGNoZXMgYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICogYCcvaGVsbG8vJ2AgLSBNYXRjaGVzIG9ubHkgaWYgdGhlIHBhdGggaXMgZXhhY3RseSAnL2hlbGxvLycuIFRoZXJlIGlzIG5vIHNwZWNpYWwgdHJlYXRtZW50IGZvclxuICogICB0cmFpbGluZyBzbGFzaGVzLCBhbmQgcGF0dGVybnMgaGF2ZSB0byBtYXRjaCB0aGUgZW50aXJlIHBhdGgsIG5vdCBqdXN0IGEgcHJlZml4LlxuICogKiBgJy91c2VyLzppZCdgIC0gTWF0Y2hlcyAnL3VzZXIvYm9iJyBvciAnL3VzZXIvMTIzNCEhIScgb3IgZXZlbiAnL3VzZXIvJyBidXQgbm90ICcvdXNlcicgb3JcbiAqICAgJy91c2VyL2JvYi9kZXRhaWxzJy4gVGhlIHNlY29uZCBwYXRoIHNlZ21lbnQgd2lsbCBiZSBjYXB0dXJlZCBhcyB0aGUgcGFyYW1ldGVyICdpZCcuXG4gKiAqIGAnL3VzZXIve2lkfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZSwgYnV0IHVzaW5nIGN1cmx5IGJyYWNlIHN5bnRheC5cbiAqICogYCcvdXNlci97aWQ6W14vXSp9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLlxuICogKiBgJy91c2VyL3tpZDpbMC05YS1mQS1GXXsxLDh9fSdgIC0gU2ltaWxhciB0byB0aGUgcHJldmlvdXMgZXhhbXBsZSwgYnV0IG9ubHkgbWF0Y2hlcyBpZiB0aGUgaWRcbiAqICAgcGFyYW1ldGVyIGNvbnNpc3RzIG9mIDEgdG8gOCBoZXggZGlnaXRzLlxuICogKiBgJy9maWxlcy97cGF0aDouKn0nYCAtIE1hdGNoZXMgYW55IFVSTCBzdGFydGluZyB3aXRoICcvZmlsZXMvJyBhbmQgY2FwdHVyZXMgdGhlIHJlc3Qgb2YgdGhlXG4gKiAgIHBhdGggaW50byB0aGUgcGFyYW1ldGVyICdwYXRoJy5cbiAqICogYCcvZmlsZXMvKnBhdGgnYCAtIGRpdHRvLlxuICogKiBgJy9jYWxlbmRhci97c3RhcnQ6ZGF0ZX0nYCAtIE1hdGNoZXMgXCIvY2FsZW5kYXIvMjAxNC0xMS0xMlwiIChiZWNhdXNlIHRoZSBwYXR0ZXJuIGRlZmluZWRcbiAqICAgaW4gdGhlIGJ1aWx0LWluICBgZGF0ZWAgUGFyYW1UeXBlIG1hdGNoZXMgYDIwMTQtMTEtMTJgKSBhbmQgcHJvdmlkZXMgYSBEYXRlIG9iamVjdCBpbiAkc3RhdGVQYXJhbXMuc3RhcnRcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxNYXRjaGVyIHtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgc3RhdGljIG5hbWVWYWxpZGF0b3I6IFJlZ0V4cCA9IC9eXFx3KyhbLS5dK1xcdyspKig/OlxcW1xcXSk/JC87XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfY2FjaGU6IFVybE1hdGNoZXJDYWNoZSA9IHsgcGF0aDogW3RoaXNdIH07XG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2NoaWxkcmVuOiBVcmxNYXRjaGVyW10gPSBbXTtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfcGFyYW1zOiBQYXJhbVtdID0gW107XG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX3NlZ21lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9jb21waWxlZDogc3RyaW5nW10gPSBbXTtcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IFVybE1hdGNoZXJDb21waWxlQ29uZmlnO1xuXG4gIC8qKiBUaGUgcGF0dGVybiB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IgKi9cbiAgcHVibGljIHBhdHRlcm46IHN0cmluZztcblxuICAvKiogQGhpZGRlbiAqL1xuICBzdGF0aWMgZW5jb2RlRGFzaGVzKHN0cjogc3RyaW5nKSB7XG4gICAgLy8gUmVwbGFjZSBkYXNoZXMgd2l0aCBlbmNvZGVkIFwiXFwtXCJcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZShcbiAgICAgIC8tL2csXG4gICAgICBjID0+XG4gICAgICAgIGAlNUMlJHtjXG4gICAgICAgICAgLmNoYXJDb2RlQXQoMClcbiAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgLnRvVXBwZXJDYXNlKCl9YFxuICAgICk7XG4gIH1cblxuICAvKiogQGhpZGRlbiBHaXZlbiBhIG1hdGNoZXIsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBtYXRjaGVyJ3MgcGF0aCBzZWdtZW50cyBhbmQgcGF0aCBwYXJhbXMsIGluIG9yZGVyICovXG4gIHN0YXRpYyBwYXRoU2VnbWVudHNBbmRQYXJhbXMobWF0Y2hlcjogVXJsTWF0Y2hlcikge1xuICAgIGNvbnN0IHN0YXRpY1NlZ21lbnRzID0gbWF0Y2hlci5fc2VnbWVudHM7XG4gICAgY29uc3QgcGF0aFBhcmFtcyA9IG1hdGNoZXIuX3BhcmFtcy5maWx0ZXIocCA9PiBwLmxvY2F0aW9uID09PSBEZWZUeXBlLlBBVEgpO1xuICAgIHJldHVybiBhcnJheVR1cGxlcyhzdGF0aWNTZWdtZW50cywgcGF0aFBhcmFtcy5jb25jYXQodW5kZWZpbmVkKSlcbiAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgICAuZmlsdGVyKHggPT4geCAhPT0gJycgJiYgaXNEZWZpbmVkKHgpKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBxdWVyeSBwYXJhbXMgKi9cbiAgc3RhdGljIHF1ZXJ5UGFyYW1zKG1hdGNoZXI6IFVybE1hdGNoZXIpOiBQYXJhbVtdIHtcbiAgICByZXR1cm4gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihwID0+IHAubG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIHR3byBVcmxNYXRjaGVyc1xuICAgKlxuICAgKiBUaGlzIGNvbXBhcmlzb24gZnVuY3Rpb24gY29udmVydHMgYSBVcmxNYXRjaGVyIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhdGggc2VnbWVudHMuXG4gICAqIEVhY2ggc3RhdGljIHBhdGggc2VnbWVudCBpcyBhIHN0YXRpYyBzdHJpbmcgYmV0d2VlbiBhIHBhdGggc2VwYXJhdG9yIChzbGFzaCBjaGFyYWN0ZXIpLlxuICAgKiBFYWNoIGR5bmFtaWMgc2VnbWVudCBpcyBhIHBhdGggcGFyYW1ldGVyLlxuICAgKlxuICAgKiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiBzb3J0cyBzdGF0aWMgc2VnbWVudHMgYmVmb3JlIGR5bmFtaWMgb25lcy5cbiAgICovXG4gIHN0YXRpYyBjb21wYXJlKGE6IFVybE1hdGNoZXIsIGI6IFVybE1hdGNoZXIpOiBudW1iZXIge1xuICAgIC8qKlxuICAgICAqIFR1cm4gYSBVcmxNYXRjaGVyIGFuZCBhbGwgaXRzIHBhcmVudCBtYXRjaGVycyBpbnRvIGFuIGFycmF5XG4gICAgICogb2Ygc2xhc2ggbGl0ZXJhbHMgJy8nLCBzdHJpbmcgbGl0ZXJhbHMsIGFuZCBQYXJhbSBvYmplY3RzXG4gICAgICpcbiAgICAgKiBUaGlzIGV4YW1wbGUgbWF0Y2hlciBtYXRjaGVzIHN0cmluZ3MgbGlrZSBcIi9mb28vOnBhcmFtL3RhaWxcIjpcbiAgICAgKiB2YXIgbWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb29cIikuYXBwZW5kKCR1bWYuY29tcGlsZShcIi86cGFyYW1cIikpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCIvXCIpKS5hcHBlbmQoJHVtZi5jb21waWxlKFwidGFpbFwiKSk7XG4gICAgICogdmFyIHJlc3VsdCA9IHNlZ21lbnRzKG1hdGNoZXIpOyAvLyBbICcvJywgJ2ZvbycsICcvJywgUGFyYW0sICcvJywgJ3RhaWwnIF1cbiAgICAgKlxuICAgICAqIENhY2hlcyB0aGUgcmVzdWx0IGFzIGBtYXRjaGVyLl9jYWNoZS5zZWdtZW50c2BcbiAgICAgKi9cbiAgICBjb25zdCBzZWdtZW50cyA9IChtYXRjaGVyOiBVcmxNYXRjaGVyKSA9PlxuICAgICAgKG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzID1cbiAgICAgICAgbWF0Y2hlci5fY2FjaGUuc2VnbWVudHMgfHxcbiAgICAgICAgbWF0Y2hlci5fY2FjaGUucGF0aFxuICAgICAgICAgIC5tYXAoVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMpXG4gICAgICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgICAgICAucmVkdWNlKGpvaW5OZWlnaGJvcnNSLCBbXSlcbiAgICAgICAgICAubWFwKHggPT4gKGlzU3RyaW5nKHgpID8gc3BsaXRPblNsYXNoKHgpIDogeCkpXG4gICAgICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSkpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc29ydCB3ZWlnaHQgZm9yIGVhY2ggc2VnbWVudCBvZiBhIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIENhY2hlcyB0aGUgcmVzdWx0IGFzIGBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzYFxuICAgICAqL1xuICAgIGNvbnN0IHdlaWdodHMgPSAobWF0Y2hlcjogVXJsTWF0Y2hlcikgPT5cbiAgICAgIChtYXRjaGVyLl9jYWNoZS53ZWlnaHRzID1cbiAgICAgICAgbWF0Y2hlci5fY2FjaGUud2VpZ2h0cyB8fFxuICAgICAgICBzZWdtZW50cyhtYXRjaGVyKS5tYXAoc2VnbWVudCA9PiB7XG4gICAgICAgICAgLy8gU29ydCBzbGFzaGVzIGZpcnN0LCB0aGVuIHN0YXRpYyBzdHJpbmdzLCB0aGUgUGFyYW1zXG4gICAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcvJykgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHNlZ21lbnQpKSByZXR1cm4gMjtcbiAgICAgICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIFBhcmFtKSByZXR1cm4gMztcbiAgICAgICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBzaG9ydGVyIGFycmF5IGluLXBsYWNlIChtdXRhdGVzKVxuICAgICAqL1xuICAgIGNvbnN0IHBhZEFycmF5cyA9IChsOiBhbnlbXSwgcjogYW55W10sIHBhZFZhbDogYW55KSA9PiB7XG4gICAgICBjb25zdCBsZW4gPSBNYXRoLm1heChsLmxlbmd0aCwgci5sZW5ndGgpO1xuICAgICAgd2hpbGUgKGwubGVuZ3RoIDwgbGVuKSBsLnB1c2gocGFkVmFsKTtcbiAgICAgIHdoaWxlIChyLmxlbmd0aCA8IGxlbikgci5wdXNoKHBhZFZhbCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdlaWdodHNBID0gd2VpZ2h0cyhhKSxcbiAgICAgIHdlaWdodHNCID0gd2VpZ2h0cyhiKTtcbiAgICBwYWRBcnJheXMod2VpZ2h0c0EsIHdlaWdodHNCLCAwKTtcblxuICAgIGNvbnN0IF9wYWlycyA9IGFycmF5VHVwbGVzKHdlaWdodHNBLCB3ZWlnaHRzQik7XG4gICAgbGV0IGNtcCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBfcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNtcCA9IF9wYWlyc1tpXVswXSAtIF9wYWlyc1tpXVsxXTtcbiAgICAgIGlmIChjbXAgIT09IDApIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gY29tcGlsZSBpbnRvIGEgbWF0Y2hlci5cbiAgICogQHBhcmFtIHBhcmFtVHlwZXMgVGhlIFtbUGFyYW1UeXBlc11dIHJlZ2lzdHJ5XG4gICAqIEBwYXJhbSBwYXJhbUZhY3RvcnkgQSBbW1BhcmFtRmFjdG9yeV1dIG9iamVjdFxuICAgKiBAcGFyYW0gY29uZmlnICBBIFtbVXJsTWF0Y2hlckNvbXBpbGVDb25maWddXSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0dGVybjogc3RyaW5nLCBwYXJhbVR5cGVzOiBQYXJhbVR5cGVzLCBwYXJhbUZhY3Rvcnk6IFBhcmFtRmFjdG9yeSwgY29uZmlnPzogVXJsTWF0Y2hlckNvbXBpbGVDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyA9IGRlZmF1bHRzKGNvbmZpZywgZGVmYXVsdENvbmZpZyk7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcblxuICAgIC8vIEZpbmQgYWxsIHBsYWNlaG9sZGVycyBhbmQgY3JlYXRlIGEgY29tcGlsZWQgcGF0dGVybiwgdXNpbmcgZWl0aGVyIGNsYXNzaWMgb3IgY3VybHkgc3ludGF4OlxuICAgIC8vICAgJyonIG5hbWVcbiAgICAvLyAgICc6JyBuYW1lXG4gICAgLy8gICAneycgbmFtZSAnfSdcbiAgICAvLyAgICd7JyBuYW1lICc6JyByZWdleHAgJ30nXG4gICAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBzb21ld2hhdCBjb21wbGljYXRlZCBkdWUgdG8gdGhlIG5lZWQgdG8gYWxsb3cgY3VybHkgYnJhY2VzXG4gICAgLy8gaW5zaWRlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uIFRoZSBwbGFjZWhvbGRlciByZWdleHAgYnJlYWtzIGRvd24gYXMgZm9sbG93czpcbiAgICAvLyAgICAoWzoqXSkoW1xcd1xcW1xcXV0rKSAgICAgICAgICAgICAgLSBjbGFzc2ljIHBsYWNlaG9sZGVyICgkMSAvICQyKSAoc2VhcmNoIHZlcnNpb24gaGFzIC0gZm9yIHNuYWtlLWNhc2UpXG4gICAgLy8gICAgXFx7KFtcXHdcXFtcXF1dKykoPzpcXDpcXHMqKCAuLi4gKSk/XFx9ICAtIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyICgkMykgd2l0aCBvcHRpb25hbCByZWdleHAvdHlwZSAuLi4gKCQ0KSAoc2VhcmNoIHZlcnNpb24gaGFzIC0gZm9yIHNuYWtlLWNhc2VcbiAgICAvLyAgICAoPzogLi4uIHwgLi4uIHwgLi4uICkrICAgICAgICAgLSB0aGUgcmVnZXhwIGNvbnNpc3RzIG9mIGFueSBudW1iZXIgb2YgYXRvbXMsIGFuIGF0b20gYmVpbmcgZWl0aGVyXG4gICAgLy8gICAgW157fVxcXFxdKyAgICAgICAgICAgICAgICAgICAgICAgLSBhbnl0aGluZyBvdGhlciB0aGFuIGN1cmx5IGJyYWNlcyBvciBiYWNrc2xhc2hcbiAgICAvLyAgICBcXFxcLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGEgYmFja3NsYXNoIGVzY2FwZVxuICAgIC8vICAgIFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSAgICAgICAgICAtIGEgbWF0Y2hlZCBzZXQgb2YgY3VybHkgYnJhY2VzIGNvbnRhaW5pbmcgb3RoZXIgYXRvbXNcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IC8oWzoqXSkoW1xcd1xcW1xcXV0rKXxcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nO1xuICAgIGNvbnN0IHNlYXJjaFBsYWNlaG9sZGVyID0gLyhbOl0/KShbXFx3XFxbXFxdLi1dKyl8XFx7KFtcXHdcXFtcXF0uLV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nO1xuICAgIGNvbnN0IHBhdHRlcm5zOiBhbnlbXVtdID0gW107XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGxldCBtYXRjaEFycmF5OiBSZWdFeHBFeGVjQXJyYXk7XG5cbiAgICBjb25zdCBjaGVja1BhcmFtRXJyb3JzID0gKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICghVXJsTWF0Y2hlci5uYW1lVmFsaWRhdG9yLnRlc3QoaWQpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW1ldGVyIG5hbWUgJyR7aWR9JyBpbiBwYXR0ZXJuICcke3BhdHRlcm59J2ApO1xuICAgICAgaWYgKGZpbmQodGhpcy5fcGFyYW1zLCBwcm9wRXEoJ2lkJywgaWQpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWUgJyR7aWR9JyBpbiBwYXR0ZXJuICcke3BhdHRlcm59J2ApO1xuICAgIH07XG5cbiAgICAvLyBTcGxpdCBpbnRvIHN0YXRpYyBzZWdtZW50cyBzZXBhcmF0ZWQgYnkgcGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzLlxuICAgIC8vIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaXMgYWx3YXlzIDEgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycy5cbiAgICBjb25zdCBtYXRjaERldGFpbHMgPSAobTogUmVnRXhwRXhlY0FycmF5LCBpc1NlYXJjaDogYm9vbGVhbik6IE1hdGNoRGV0YWlscyA9PiB7XG4gICAgICAvLyBJRVs3OF0gcmV0dXJucyAnJyBmb3IgdW5tYXRjaGVkIGdyb3VwcyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgIGNvbnN0IGlkOiBzdHJpbmcgPSBtWzJdIHx8IG1bM107XG4gICAgICBjb25zdCByZWdleHA6IHN0cmluZyA9IGlzU2VhcmNoID8gbVs0XSA6IG1bNF0gfHwgKG1bMV0gPT09ICcqJyA/ICdbXFxcXHNcXFxcU10qJyA6IG51bGwpO1xuXG4gICAgICBjb25zdCBtYWtlUmVnZXhwVHlwZSA9IHN0ciA9PlxuICAgICAgICBpbmhlcml0KHBhcmFtVHlwZXMudHlwZShpc1NlYXJjaCA/ICdxdWVyeScgOiAncGF0aCcpLCB7XG4gICAgICAgICAgcGF0dGVybjogbmV3IFJlZ0V4cChzdHIsIHRoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCksXG4gICAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgcmVnZXhwLFxuICAgICAgICBzZWdtZW50OiBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0LCBtLmluZGV4KSxcbiAgICAgICAgdHlwZTogIXJlZ2V4cCA/IG51bGwgOiBwYXJhbVR5cGVzLnR5cGUocmVnZXhwKSB8fCBtYWtlUmVnZXhwVHlwZShyZWdleHApLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgbGV0IGRldGFpbHM6IE1hdGNoRGV0YWlscztcbiAgICBsZXQgc2VnbWVudDogc3RyaW5nO1xuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgICB3aGlsZSAoKG1hdGNoQXJyYXkgPSBwbGFjZWhvbGRlci5leGVjKHBhdHRlcm4pKSkge1xuICAgICAgZGV0YWlscyA9IG1hdGNoRGV0YWlscyhtYXRjaEFycmF5LCBmYWxzZSk7XG4gICAgICBpZiAoZGV0YWlscy5zZWdtZW50LmluZGV4T2YoJz8nKSA+PSAwKSBicmVhazsgLy8gd2UncmUgaW50byB0aGUgc2VhcmNoIHBhcnRcblxuICAgICAgY2hlY2tQYXJhbUVycm9ycyhkZXRhaWxzLmlkKTtcbiAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKHBhcmFtRmFjdG9yeS5mcm9tUGF0aChkZXRhaWxzLmlkLCBkZXRhaWxzLnR5cGUsIGNvbmZpZy5zdGF0ZSkpO1xuICAgICAgdGhpcy5fc2VnbWVudHMucHVzaChkZXRhaWxzLnNlZ21lbnQpO1xuICAgICAgcGF0dGVybnMucHVzaChbZGV0YWlscy5zZWdtZW50LCB0YWlsKHRoaXMuX3BhcmFtcyldKTtcbiAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgfVxuICAgIHNlZ21lbnQgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0KTtcblxuICAgIC8vIEZpbmQgYW55IHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxhc3Qgc2VnbWVudFxuICAgIGNvbnN0IGkgPSBzZWdtZW50LmluZGV4T2YoJz8nKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xuICAgICAgc2VnbWVudCA9IHNlZ21lbnQuc3Vic3RyaW5nKDAsIGkpO1xuXG4gICAgICBpZiAoc2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGFzdCA9IDA7XG5cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgICAgICAgd2hpbGUgKChtYXRjaEFycmF5ID0gc2VhcmNoUGxhY2Vob2xkZXIuZXhlYyhzZWFyY2gpKSkge1xuICAgICAgICAgIGRldGFpbHMgPSBtYXRjaERldGFpbHMobWF0Y2hBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgY2hlY2tQYXJhbUVycm9ycyhkZXRhaWxzLmlkKTtcbiAgICAgICAgICB0aGlzLl9wYXJhbXMucHVzaChwYXJhbUZhY3RvcnkuZnJvbVNlYXJjaChkZXRhaWxzLmlkLCBkZXRhaWxzLnR5cGUsIGNvbmZpZy5zdGF0ZSkpO1xuICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgPyZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3NlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgdGhpcy5fY29tcGlsZWQgPSBwYXR0ZXJucy5tYXAoX3BhdHRlcm4gPT4gcXVvdGVSZWdFeHAuYXBwbHkobnVsbCwgX3BhdHRlcm4pKS5jb25jYXQocXVvdGVSZWdFeHAoc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uY2F0ZW5hdGVkIFVybE1hdGNoZXJcbiAgICpcbiAgICogQnVpbGRzIGEgbmV3IFVybE1hdGNoZXIgYnkgYXBwZW5kaW5nIGFub3RoZXIgVXJsTWF0Y2hlciB0byB0aGlzIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHVybCBBIGBVcmxNYXRjaGVyYCBpbnN0YW5jZSB0byBhcHBlbmQgYXMgYSBjaGlsZCBvZiB0aGUgY3VycmVudCBgVXJsTWF0Y2hlcmAuXG4gICAqL1xuICBhcHBlbmQodXJsOiBVcmxNYXRjaGVyKTogVXJsTWF0Y2hlciB7XG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaCh1cmwpO1xuICAgIHVybC5fY2FjaGUgPSB7XG4gICAgICBwYXRoOiB0aGlzLl9jYWNoZS5wYXRoLmNvbmNhdCh1cmwpLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgcGF0dGVybjogbnVsbCxcbiAgICB9O1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBpc1Jvb3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnBhdGhbMF0gPT09IHRoaXM7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgaW5wdXQgcGF0dGVybiBzdHJpbmcgKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHRoZSBzcGVjaWZpZWQgdXJsL3BhdGggYWdhaW5zdCB0aGlzIG1hdGNoZXIuXG4gICAqXG4gICAqIFRlc3RzIGlmIHRoZSBnaXZlbiB1cmwgbWF0Y2hlcyB0aGlzIG1hdGNoZXIncyBwYXR0ZXJuLCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FwdHVyZWRcbiAgICogcGFyYW1ldGVyIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiB0aGUgcGF0aCBkb2VzIG5vdCBtYXRjaC5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgdmFsdWVzXG4gICAqIG9mIGFueSBzZWFyY2ggcGFyYW1ldGVycyB0aGF0IGFyZSBtZW50aW9uZWQgaW4gdGhlIHBhdHRlcm4sIGJ1dCB0aGVpciB2YWx1ZSBtYXkgYmUgbnVsbCBpZlxuICAgKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxuICAgKiBhcyBvcHRpb25hbC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJnInKS5leGVjKCcvdXNlci9ib2InLCB7XG4gICAqICAgeDogJzEnLCBxOiAnaGVsbG8nXG4gICAqIH0pO1xuICAgKiAvLyByZXR1cm5zIHsgaWQ6ICdib2InLCBxOiAnaGVsbG8nLCByOiBudWxsIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoICAgIFRoZSBVUkwgcGF0aCB0byBtYXRjaCwgZS5nLiBgJGxvY2F0aW9uLnBhdGgoKWAuXG4gICAqIEBwYXJhbSBzZWFyY2ggIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cbiAgICogQHBhcmFtIGhhc2ggICAgVVJMIGhhc2ggZS5nLiBgJGxvY2F0aW9uLmhhc2goKWAuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjYXB0dXJlZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKi9cbiAgZXhlYyhwYXRoOiBzdHJpbmcsIHNlYXJjaDogYW55ID0ge30sIGhhc2g/OiBzdHJpbmcsIG9wdGlvbnM6IGFueSA9IHt9KTogUmF3UGFyYW1zIHtcbiAgICBjb25zdCBtYXRjaCA9IG1lbW9pemVUbyh0aGlzLl9jYWNoZSwgJ3BhdHRlcm4nLCAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgICAgW1xuICAgICAgICAgICdeJyxcbiAgICAgICAgICB1bm5lc3QodGhpcy5fY2FjaGUucGF0aC5tYXAocHJvcCgnX2NvbXBpbGVkJykpKS5qb2luKCcnKSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy5zdHJpY3QgPT09IGZhbHNlID8gJy8/JyA6ICcnLFxuICAgICAgICAgICckJyxcbiAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgICAgdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0pLmV4ZWMocGF0aCk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7IGlzb2xhdGU6IGZhbHNlIH0pO1xuXG4gICAgY29uc3QgYWxsUGFyYW1zOiBQYXJhbVtdID0gdGhpcy5wYXJhbWV0ZXJzKCksXG4gICAgICBwYXRoUGFyYW1zOiBQYXJhbVtdID0gYWxsUGFyYW1zLmZpbHRlcihwYXJhbSA9PiAhcGFyYW0uaXNTZWFyY2goKSksXG4gICAgICBzZWFyY2hQYXJhbXM6IFBhcmFtW10gPSBhbGxQYXJhbXMuZmlsdGVyKHBhcmFtID0+IHBhcmFtLmlzU2VhcmNoKCkpLFxuICAgICAgblBhdGhTZWdtZW50cyA9IHRoaXMuX2NhY2hlLnBhdGgubWFwKHVybG0gPT4gdXJsbS5fc2VnbWVudHMubGVuZ3RoIC0gMSkucmVkdWNlKChhLCB4KSA9PiBhICsgeCksXG4gICAgICB2YWx1ZXM6IFJhd1BhcmFtcyA9IHt9O1xuXG4gICAgaWYgKG5QYXRoU2VnbWVudHMgIT09IG1hdGNoLmxlbmd0aCAtIDEpIHRocm93IG5ldyBFcnJvcihgVW5iYWxhbmNlZCBjYXB0dXJlIGdyb3VwIGluIHJvdXRlICcke3RoaXMucGF0dGVybn0nYCk7XG5cbiAgICBmdW5jdGlvbiBkZWNvZGVQYXRoQXJyYXkocGFyYW1WYWw6IHN0cmluZykge1xuICAgICAgY29uc3QgcmV2ZXJzZVN0cmluZyA9IChzdHI6IHN0cmluZykgPT5cbiAgICAgICAgc3RyXG4gICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAuam9pbignJyk7XG4gICAgICBjb25zdCB1bnF1b3RlRGFzaGVzID0gKHN0cjogc3RyaW5nKSA9PiBzdHIucmVwbGFjZSgvXFxcXC0vZywgJy0nKTtcblxuICAgICAgY29uc3Qgc3BsaXQgPSByZXZlcnNlU3RyaW5nKHBhcmFtVmFsKS5zcGxpdCgvLSg/IVxcXFwpLyk7XG4gICAgICBjb25zdCBhbGxSZXZlcnNlZCA9IG1hcChzcGxpdCwgcmV2ZXJzZVN0cmluZyk7XG4gICAgICByZXR1cm4gbWFwKGFsbFJldmVyc2VkLCB1bnF1b3RlRGFzaGVzKS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUGF0aFNlZ21lbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtOiBQYXJhbSA9IHBhdGhQYXJhbXNbaV07XG4gICAgICBsZXQgdmFsdWU6IGFueSB8IGFueVtdID0gbWF0Y2hbaSArIDFdO1xuXG4gICAgICAvLyBpZiB0aGUgcGFyYW0gdmFsdWUgbWF0Y2hlcyBhIHByZS1yZXBsYWNlIHBhaXIsIHJlcGxhY2UgdGhlIHZhbHVlIGJlZm9yZSBkZWNvZGluZy5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocGFyYW0ucmVwbGFjZVtqXS5mcm9tID09PSB2YWx1ZSkgdmFsdWUgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICYmIHBhcmFtLmFycmF5ID09PSB0cnVlKSB2YWx1ZSA9IGRlY29kZVBhdGhBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkgdmFsdWUgPSBwYXJhbS50eXBlLmRlY29kZSh2YWx1ZSk7XG4gICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBzZWFyY2hbcGFyYW0uaWRdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHZhbHVlKSB2YWx1ZSA9IHBhcmFtLnJlcGxhY2Vbal0udG87XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkgdmFsdWUgPSBwYXJhbS50eXBlLmRlY29kZSh2YWx1ZSk7XG4gICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGhhc2gpIHZhbHVlc1snIyddID0gaGFzaDtcblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogQGhpZGRlblxuICAgKiBSZXR1cm5zIGFsbCB0aGUgW1tQYXJhbV1dIG9iamVjdHMgb2YgYWxsIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoaXMgcGF0dGVybiBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPFBhcmFtPn0gIEFuIGFycmF5IG9mIFtbUGFyYW1dXSBvYmplY3RzLiBNdXN0IGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5LiBJZiB0aGVcbiAgICogICAgcGF0dGVybiBoYXMgbm8gcGFyYW1ldGVycywgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBwYXJhbWV0ZXJzKG9wdHM6IGFueSA9IHt9KTogUGFyYW1bXSB7XG4gICAgaWYgKG9wdHMuaW5oZXJpdCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgcmV0dXJuIHVubmVzdCh0aGlzLl9jYWNoZS5wYXRoLm1hcChtYXRjaGVyID0+IG1hdGNoZXIuX3BhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICogUmV0dXJucyBhIHNpbmdsZSBwYXJhbWV0ZXIgZnJvbSB0aGlzIFVybE1hdGNoZXIgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIGlkXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqIEByZXR1cm5zIHtUfFBhcmFtfGFueXxib29sZWFufFVybE1hdGNoZXJ8bnVsbH1cbiAgICovXG4gIHBhcmFtZXRlcihpZDogc3RyaW5nLCBvcHRzOiBhbnkgPSB7fSk6IFBhcmFtIHtcbiAgICBjb25zdCBmaW5kUGFyYW0gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMuX3BhcmFtcykge1xuICAgICAgICBpZiAocGFyYW0uaWQgPT09IGlkKSByZXR1cm4gcGFyYW07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2NhY2hlLnBhcmVudDtcbiAgICByZXR1cm4gZmluZFBhcmFtKCkgfHwgKG9wdHMuaW5oZXJpdCAhPT0gZmFsc2UgJiYgcGFyZW50ICYmIHBhcmVudC5wYXJhbWV0ZXIoaWQsIG9wdHMpKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgaW5wdXQgcGFyYW1ldGVyIHZhbHVlcyBhZ2FpbnN0IHRoaXMgVXJsTWF0Y2hlclxuICAgKlxuICAgKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxuICAgKiB0eXBlcyBvZiB0aGlzIGBVcmxNYXRjaGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cbiAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYHBhcmFtc2AgdmFsaWRhdGVzLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIHZhbGlkYXRlcyhwYXJhbXM6IFJhd1BhcmFtcyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHZhbGlkUGFyYW1WYWwgPSAocGFyYW06IFBhcmFtLCB2YWw6IGFueSkgPT4gIXBhcmFtIHx8IHBhcmFtLnZhbGlkYXRlcyh2YWwpO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gSSdtIG5vdCBzdXJlIHdoeSB0aGlzIGNoZWNrcyBvbmx5IHRoZSBwYXJhbSBrZXlzIHBhc3NlZCBpbiwgYW5kIG5vdCBhbGwgdGhlIHBhcmFtcyBrbm93biB0byB0aGUgbWF0Y2hlclxuICAgIGNvbnN0IHBhcmFtU2NoZW1hID0gdGhpcy5wYXJhbWV0ZXJzKCkuZmlsdGVyKHBhcmFtRGVmID0+IHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbURlZi5pZCkpO1xuICAgIHJldHVybiBwYXJhbVNjaGVtYS5tYXAocGFyYW1EZWYgPT4gdmFsaWRQYXJhbVZhbChwYXJhbURlZiwgcGFyYW1zW3BhcmFtRGVmLmlkXSkpLnJlZHVjZShhbGxUcnVlUiwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcywgY3JlYXRlcyBhIFVSTCBmcm9tIHRoaXMgVXJsTWF0Y2hlci5cbiAgICpcbiAgICogQ3JlYXRlcyBhIFVSTCB0aGF0IG1hdGNoZXMgdGhpcyBwYXR0ZXJuIGJ5IHN1YnN0aXR1dGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgKiBmb3IgdGhlIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EnKS5mb3JtYXQoeyBpZDonYm9iJywgcToneWVzJyB9KTtcbiAgICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXG4gICAqIEByZXR1cm5zIHRoZSBmb3JtYXR0ZWQgVVJMIChwYXRoIGFuZCBvcHRpb25hbGx5IHNlYXJjaCBwYXJ0KS5cbiAgICovXG4gIGZvcm1hdCh2YWx1ZXM6IFJhd1BhcmFtcyA9IHt9KSB7XG4gICAgLy8gQnVpbGQgdGhlIGZ1bGwgcGF0aCBvZiBVcmxNYXRjaGVycyAoaW5jbHVkaW5nIGFsbCBwYXJlbnQgVXJsTWF0Y2hlcnMpXG4gICAgY29uc3QgdXJsTWF0Y2hlcnMgPSB0aGlzLl9jYWNoZS5wYXRoO1xuXG4gICAgLy8gRXh0cmFjdCBhbGwgdGhlIHN0YXRpYyBzZWdtZW50cyBhbmQgUGFyYW1zIChwcm9jZXNzZWQgYXMgUGFyYW1EZXRhaWxzKVxuICAgIC8vIGludG8gYW4gb3JkZXJlZCBhcnJheVxuICAgIGNvbnN0IHBhdGhTZWdtZW50c0FuZFBhcmFtczogQXJyYXk8c3RyaW5nIHwgUGFyYW1EZXRhaWxzPiA9IHVybE1hdGNoZXJzXG4gICAgICAubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxuICAgICAgLnJlZHVjZSh1bm5lc3RSLCBbXSlcbiAgICAgIC5tYXAoeCA9PiAoaXNTdHJpbmcoeCkgPyB4IDogZ2V0RGV0YWlscyh4KSkpO1xuXG4gICAgLy8gRXh0cmFjdCB0aGUgcXVlcnkgcGFyYW1zIGludG8gYSBzZXBhcmF0ZSBhcnJheVxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zOiBBcnJheTxQYXJhbURldGFpbHM+ID0gdXJsTWF0Y2hlcnNcbiAgICAgIC5tYXAoVXJsTWF0Y2hlci5xdWVyeVBhcmFtcylcbiAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgICAubWFwKGdldERldGFpbHMpO1xuXG4gICAgY29uc3QgaXNJbnZhbGlkID0gKHBhcmFtOiBQYXJhbURldGFpbHMpID0+IHBhcmFtLmlzVmFsaWQgPT09IGZhbHNlO1xuICAgIGlmIChwYXRoU2VnbWVudHNBbmRQYXJhbXMuY29uY2F0KHF1ZXJ5UGFyYW1zKS5maWx0ZXIoaXNJbnZhbGlkKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgUGFyYW0sIGFwcGxpZXMgdGhlIHBhcmFtZXRlciB2YWx1ZSwgdGhlbiByZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RGV0YWlscyhwYXJhbTogUGFyYW0pOiBQYXJhbURldGFpbHMge1xuICAgICAgLy8gTm9ybWFsaXplIHRvIHR5cGVkIHZhbHVlXG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtLnZhbHVlKHZhbHVlc1twYXJhbS5pZF0pO1xuICAgICAgY29uc3QgaXNWYWxpZCA9IHBhcmFtLnZhbGlkYXRlcyh2YWx1ZSk7XG4gICAgICBjb25zdCBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtLmlzRGVmYXVsdFZhbHVlKHZhbHVlKTtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIHNxdWFzaCBtb2RlIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICBjb25zdCBzcXVhc2ggPSBpc0RlZmF1bHRWYWx1ZSA/IHBhcmFtLnNxdWFzaCA6IGZhbHNlO1xuICAgICAgLy8gQWxsb3cgdGhlIFBhcmFtZXRlcidzIFR5cGUgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgY29uc3QgZW5jb2RlZCA9IHBhcmFtLnR5cGUuZW5jb2RlKHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHsgcGFyYW0sIHZhbHVlLCBpc1ZhbGlkLCBpc0RlZmF1bHRWYWx1ZSwgc3F1YXNoLCBlbmNvZGVkIH07XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHBhdGgtcG9ydGlvbiBmcm9tIHRoZSBsaXN0IG9mIHN0YXRpYyBzZWdtZW50cyBhbmQgcGFyYW1ldGVyc1xuICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBwYXRoU2VnbWVudHNBbmRQYXJhbXMucmVkdWNlKChhY2M6IHN0cmluZywgeDogc3RyaW5nIHwgUGFyYW1EZXRhaWxzKSA9PiB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBhIHN0YXRpYyBzZWdtZW50IChhIHJhdyBzdHJpbmcpOyBqdXN0IGFwcGVuZCBpdFxuICAgICAgaWYgKGlzU3RyaW5nKHgpKSByZXR1cm4gYWNjICsgeDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgUGFyYW1EZXRhaWxzLlxuICAgICAgY29uc3QgeyBzcXVhc2gsIGVuY29kZWQsIHBhcmFtIH0gPSB4O1xuXG4gICAgICAvLyBJZiBzcXVhc2ggaXMgPT09IHRydWUsIHRyeSB0byByZW1vdmUgYSBzbGFzaCBmcm9tIHRoZSBwYXRoXG4gICAgICBpZiAoc3F1YXNoID09PSB0cnVlKSByZXR1cm4gYWNjLm1hdGNoKC9cXC8kLykgPyBhY2Muc2xpY2UoMCwgLTEpIDogYWNjO1xuICAgICAgLy8gSWYgc3F1YXNoIGlzIGEgc3RyaW5nLCB1c2UgdGhlIHN0cmluZyBmb3IgdGhlIHBhcmFtIHZhbHVlXG4gICAgICBpZiAoaXNTdHJpbmcoc3F1YXNoKSkgcmV0dXJuIGFjYyArIHNxdWFzaDtcbiAgICAgIGlmIChzcXVhc2ggIT09IGZhbHNlKSByZXR1cm4gYWNjOyAvLyA/XG4gICAgICBpZiAoZW5jb2RlZCA9PSBudWxsKSByZXR1cm4gYWNjO1xuICAgICAgLy8gSWYgdGhpcyBwYXJhbWV0ZXIgdmFsdWUgaXMgYW4gYXJyYXksIGVuY29kZSB0aGUgdmFsdWUgdXNpbmcgZW5jb2RlRGFzaGVzXG4gICAgICBpZiAoaXNBcnJheShlbmNvZGVkKSkgcmV0dXJuIGFjYyArIG1hcCg8c3RyaW5nW10+ZW5jb2RlZCwgVXJsTWF0Y2hlci5lbmNvZGVEYXNoZXMpLmpvaW4oJy0nKTtcbiAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdHlwZSBpcyBcInJhd1wiLCB0aGVuIGRvIG5vdCBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgIGlmIChwYXJhbS5yYXcpIHJldHVybiBhY2MgKyBlbmNvZGVkO1xuICAgICAgLy8gRW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgcmV0dXJuIGFjYyArIGVuY29kZVVSSUNvbXBvbmVudCg8c3RyaW5nPmVuY29kZWQpO1xuICAgIH0sICcnKTtcblxuICAgIC8vIEJ1aWxkIHRoZSBxdWVyeSBzdHJpbmcgYnkgYXBwbHlpbmcgcGFyYW1ldGVyIHZhbHVlcyAoYXJyYXkgb3IgcmVndWxhcilcbiAgICAvLyB0aGVuIG1hcHBpbmcgdG8ga2V5PXZhbHVlLCB0aGVuIGZsYXR0ZW5pbmcgYW5kIGpvaW5pbmcgdXNpbmcgXCImXCJcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHF1ZXJ5UGFyYW1zXG4gICAgICAubWFwKChwYXJhbURldGFpbHM6IFBhcmFtRGV0YWlscykgPT4ge1xuICAgICAgICBsZXQgeyBwYXJhbSwgc3F1YXNoLCBlbmNvZGVkLCBpc0RlZmF1bHRWYWx1ZSB9ID0gcGFyYW1EZXRhaWxzO1xuICAgICAgICBpZiAoZW5jb2RlZCA9PSBudWxsIHx8IChpc0RlZmF1bHRWYWx1ZSAmJiBzcXVhc2ggIT09IGZhbHNlKSkgcmV0dXJuO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZW5jb2RlZCkpIGVuY29kZWQgPSBbPHN0cmluZz5lbmNvZGVkXTtcbiAgICAgICAgaWYgKGVuY29kZWQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmICghcGFyYW0ucmF3KSBlbmNvZGVkID0gbWFwKDxzdHJpbmdbXT5lbmNvZGVkLCBlbmNvZGVVUklDb21wb25lbnQpO1xuXG4gICAgICAgIHJldHVybiAoPHN0cmluZ1tdPmVuY29kZWQpLm1hcCh2YWwgPT4gYCR7cGFyYW0uaWR9PSR7dmFsfWApO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoaWRlbnRpdHkpXG4gICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgLmpvaW4oJyYnKTtcblxuICAgIC8vIENvbmNhdCB0aGUgcGF0aHN0cmluZyB3aXRoIHRoZSBxdWVyeVN0cmluZyAoaWYgZXhpc3RzKSBhbmQgdGhlIGhhc2hTdHJpbmcgKGlmIGV4aXN0cylcbiAgICByZXR1cm4gcGF0aFN0cmluZyArIChxdWVyeVN0cmluZyA/IGA/JHtxdWVyeVN0cmluZ31gIDogJycpICsgKHZhbHVlc1snIyddID8gJyMnICsgdmFsdWVzWycjJ10gOiAnJyk7XG4gIH1cbn1cblxuLyoqIEBoaWRkZW4gKi9cbmludGVyZmFjZSBQYXJhbURldGFpbHMge1xuICBwYXJhbTogUGFyYW07XG4gIHZhbHVlOiBhbnk7XG4gIGlzVmFsaWQ6IGJvb2xlYW47XG4gIGlzRGVmYXVsdFZhbHVlOiBib29sZWFuO1xuICBzcXVhc2g6IGJvb2xlYW4gfCBzdHJpbmc7XG4gIGVuY29kZWQ6IHN0cmluZyB8IHN0cmluZ1tdO1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQgeyBleHRlbmQsIGZvckVhY2gsIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNPYmplY3QgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgVXJsTWF0Y2hlciB9IGZyb20gJy4vdXJsTWF0Y2hlcic7XG5pbXBvcnQgeyBEZWZUeXBlLCBQYXJhbSwgUGFyYW1UeXBlLCBQYXJhbVR5cGVEZWZpbml0aW9uIH0gZnJvbSAnLi4vcGFyYW1zJztcbmltcG9ydCB7IFVybE1hdGNoZXJDb21waWxlQ29uZmlnIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0IGNsYXNzIFBhcmFtRmFjdG9yeSB7XG4gIGZyb21Db25maWcoaWQ6IHN0cmluZywgdHlwZTogUGFyYW1UeXBlLCBzdGF0ZTogU3RhdGVEZWNsYXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUGFyYW0oaWQsIHR5cGUsIERlZlR5cGUuQ09ORklHLCB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZywgc3RhdGUpO1xuICB9XG5cbiAgZnJvbVBhdGgoaWQ6IHN0cmluZywgdHlwZTogUGFyYW1UeXBlLCBzdGF0ZTogU3RhdGVEZWNsYXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUGFyYW0oaWQsIHR5cGUsIERlZlR5cGUuUEFUSCwgdGhpcy5yb3V0ZXIudXJsU2VydmljZS5jb25maWcsIHN0YXRlKTtcbiAgfVxuXG4gIGZyb21TZWFyY2goaWQ6IHN0cmluZywgdHlwZTogUGFyYW1UeXBlLCBzdGF0ZTogU3RhdGVEZWNsYXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUGFyYW0oaWQsIHR5cGUsIERlZlR5cGUuU0VBUkNILCB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZywgc3RhdGUpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFVJUm91dGVyKSB7fVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZm9yIFtbVXJsTWF0Y2hlcl1dIGluc3RhbmNlcy5cbiAqXG4gKiBUaGUgZmFjdG9yeSBpcyBhdmFpbGFibGUgdG8gbmcxIHNlcnZpY2VzIGFzXG4gKiBgJHVybE1hdGNoZXJGYWN0b3J5YCBvciBuZzEgcHJvdmlkZXJzIGFzIGAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcmAuXG4gKlxuICogQGludGVybmFsYXBpXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxNYXRjaGVyRmFjdG9yeSB7XG4gIC8qKiBAaW50ZXJuYWxhcGkgQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZm9yIGEgZ2l2ZW4gbG9jYXRpb24gKERlZlR5cGUpICovXG4gIHBhcmFtRmFjdG9yeSA9IG5ldyBQYXJhbUZhY3RvcnkodGhpcy5yb3V0ZXIpO1xuXG4gIC8vIFRPRE86IG1vdmUgaW1wbGVtZW50YXRpb25zIHRvIFVybENvbmZpZyAodXJsU2VydmljZS5jb25maWcpXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge1xuICAgIGV4dGVuZCh0aGlzLCB7IFVybE1hdGNoZXIsIFBhcmFtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBbW1VybE1hdGNoZXJdXSBmb3IgdGhlIHNwZWNpZmllZCBwYXR0ZXJuLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0dGVybiAgVGhlIFVSTCBwYXR0ZXJuLlxuICAgKiBAcGFyYW0gY29uZmlnICBUaGUgY29uZmlnIG9iamVjdCBoYXNoLlxuICAgKiBAcmV0dXJucyBUaGUgVXJsTWF0Y2hlci5cbiAgICovXG4gIGNvbXBpbGUocGF0dGVybjogc3RyaW5nLCBjb25maWc/OiBVcmxNYXRjaGVyQ29tcGlsZUNvbmZpZykge1xuICAgIGNvbnN0IHVybENvbmZpZyA9IHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnO1xuICAgIC8vIGJhY2t3YXJkLWNvbXBhdGlibGUgc3VwcG9ydCBmb3IgY29uZmlnLnBhcmFtcyAtPiBjb25maWcuc3RhdGUucGFyYW1zXG4gICAgY29uc3QgcGFyYW1zID0gY29uZmlnICYmICFjb25maWcuc3RhdGUgJiYgKGNvbmZpZyBhcyBhbnkpLnBhcmFtcztcbiAgICBjb25maWcgPSBwYXJhbXMgPyB7IHN0YXRlOiB7IHBhcmFtcyB9LCAuLi5jb25maWcgfSA6IGNvbmZpZztcbiAgICBjb25zdCBnbG9iYWxDb25maWcgPSB7IHN0cmljdDogdXJsQ29uZmlnLl9pc1N0cmljdE1vZGUsIGNhc2VJbnNlbnNpdGl2ZTogdXJsQ29uZmlnLl9pc0Nhc2VJbnNlbnNpdGl2ZSB9O1xuICAgIHJldHVybiBuZXcgVXJsTWF0Y2hlcihwYXR0ZXJuLCB1cmxDb25maWcucGFyYW1UeXBlcywgdGhpcy5wYXJhbUZhY3RvcnksIGV4dGVuZChnbG9iYWxDb25maWcsIGNvbmZpZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIFtbVXJsTWF0Y2hlcl1dLCBvciBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSBvYmplY3QgIFRoZSBvYmplY3QgdG8gcGVyZm9ybSB0aGUgdHlwZSBjaGVjayBhZ2FpbnN0LlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBtYXRjaGVzIHRoZSBgVXJsTWF0Y2hlcmAgaW50ZXJmYWNlLCBieVxuICAgKiAgICAgICAgICBpbXBsZW1lbnRpbmcgYWxsIHRoZSBzYW1lIG1ldGhvZHMuXG4gICAqL1xuICBpc01hdGNoZXIob2JqZWN0OiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiB0eXBlb2Y/XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICBmb3JFYWNoKFVybE1hdGNoZXIucHJvdG90eXBlLCAodmFsLCBuYW1lKSA9PiB7XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSByZXN1bHQgPSByZXN1bHQgJiYgKGlzRGVmaW5lZChvYmplY3RbbmFtZV0pICYmIGlzRnVuY3Rpb24ob2JqZWN0W25hbWVdKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gICRnZXQoKSB7XG4gICAgY29uc3QgdXJsQ29uZmlnID0gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgdXJsQ29uZmlnLnBhcmFtVHlwZXMuZW5xdWV1ZSA9IGZhbHNlO1xuICAgIHVybENvbmZpZy5wYXJhbVR5cGVzLl9mbHVzaFR5cGVRdWV1ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybENvbmZpZy5jYXNlSW5zZW5zaXRpdmVdXSAqL1xuICBjYXNlSW5zZW5zaXRpdmUgPSAodmFsdWU/OiBib29sZWFuKSA9PiB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZy5jYXNlSW5zZW5zaXRpdmUodmFsdWUpO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxDb25maWcuZGVmYXVsdFNxdWFzaFBvbGljeV1dICovXG4gIGRlZmF1bHRTcXVhc2hQb2xpY3kgPSAodmFsdWU/OiBib29sZWFuIHwgc3RyaW5nKSA9PiB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZy5kZWZhdWx0U3F1YXNoUG9saWN5KHZhbHVlKTtcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsQ29uZmlnLnN0cmljdE1vZGVdXSAqL1xuICBzdHJpY3RNb2RlID0gKHZhbHVlPzogYm9vbGVhbikgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5jb25maWcuc3RyaWN0TW9kZSh2YWx1ZSk7XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybENvbmZpZy50eXBlXV0gKi9cbiAgdHlwZSA9IChuYW1lOiBzdHJpbmcsIGRlZmluaXRpb24/OiBQYXJhbVR5cGVEZWZpbml0aW9uLCBkZWZpbml0aW9uRm4/OiAoKSA9PiBQYXJhbVR5cGVEZWZpbml0aW9uKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVyLnVybFNlcnZpY2UuY29uZmlnLnR5cGUobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB8fCB0aGlzO1xuICB9O1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQgeyBVcmxNYXRjaGVyIH0gZnJvbSAnLi91cmxNYXRjaGVyJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0RlZmluZWQsIGlzRnVuY3Rpb24gfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBpZGVudGl0eSwgZXh0ZW5kIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBpcywgcGF0dGVybiB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgU3RhdGVPYmplY3QgfSBmcm9tICcuLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMvaW50ZXJmYWNlJztcbmltcG9ydCB7XG4gIFVybFJ1bGUsXG4gIFVybFJ1bGVNYXRjaEZuLFxuICBVcmxSdWxlSGFuZGxlckZuLFxuICBVcmxSdWxlVHlwZSxcbiAgVXJsUGFydHMsXG4gIE1hdGNoZXJVcmxSdWxlLFxuICBTdGF0ZVJ1bGUsXG4gIFJlZ0V4cFJ1bGUsXG59IGZyb20gJy4vaW50ZXJmYWNlJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgW1tVcmxSdWxlXV1cbiAqXG4gKiBDcmVhdGVzIGEgW1tVcmxSdWxlXV0gZnJvbSBhOlxuICpcbiAqIC0gYHN0cmluZ2BcbiAqIC0gW1tVcmxNYXRjaGVyXV1cbiAqIC0gYFJlZ0V4cGBcbiAqIC0gW1tTdGF0ZU9iamVjdF1dXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIFVybFJ1bGVGYWN0b3J5IHtcbiAgc3RhdGljIGlzVXJsUnVsZSA9IG9iaiA9PiBvYmogJiYgWyd0eXBlJywgJ21hdGNoJywgJ2hhbmRsZXInXS5ldmVyeShrZXkgPT4gaXNEZWZpbmVkKG9ialtrZXldKSk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJvdXRlcjogVUlSb3V0ZXIpIHt9XG5cbiAgY29tcGlsZShzdHI6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHN0cik7XG4gIH1cblxuICBjcmVhdGUoXG4gICAgd2hhdDogc3RyaW5nIHwgVXJsTWF0Y2hlciB8IFN0YXRlT2JqZWN0IHwgUmVnRXhwIHwgVXJsUnVsZU1hdGNoRm4sXG4gICAgaGFuZGxlcj86IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm5cbiAgKTogVXJsUnVsZSB7XG4gICAgY29uc3QgaXNTdGF0ZSA9IFN0YXRlT2JqZWN0LmlzU3RhdGU7XG4gICAgY29uc3QgbWFrZVJ1bGUgPSBwYXR0ZXJuKFtcbiAgICAgIFtpc1N0cmluZywgKF93aGF0OiBzdHJpbmcpID0+IG1ha2VSdWxlKHRoaXMuY29tcGlsZShfd2hhdCkpXSxcbiAgICAgIFtpcyhVcmxNYXRjaGVyKSwgKF93aGF0OiBVcmxNYXRjaGVyKSA9PiB0aGlzLmZyb21VcmxNYXRjaGVyKF93aGF0LCBoYW5kbGVyKV0sXG4gICAgICBbaXNTdGF0ZSwgKF93aGF0OiBTdGF0ZU9iamVjdCkgPT4gdGhpcy5mcm9tU3RhdGUoX3doYXQsIHRoaXMucm91dGVyKV0sXG4gICAgICBbaXMoUmVnRXhwKSwgKF93aGF0OiBSZWdFeHApID0+IHRoaXMuZnJvbVJlZ0V4cChfd2hhdCwgaGFuZGxlcildLFxuICAgICAgW2lzRnVuY3Rpb24sIChfd2hhdDogVXJsUnVsZU1hdGNoRm4pID0+IG5ldyBCYXNlVXJsUnVsZShfd2hhdCwgaGFuZGxlciBhcyBVcmxSdWxlSGFuZGxlckZuKV0sXG4gICAgXSk7XG5cbiAgICBjb25zdCBydWxlID0gbWFrZVJ1bGUod2hhdCk7XG4gICAgaWYgKCFydWxlKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkICd3aGF0JyBpbiB3aGVuKClcIik7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cblxuICAvKipcbiAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYmFzZWQgb24gYSBVcmxNYXRjaGVyXG4gICAqXG4gICAqIFRoZSBgaGFuZGxlcmAgbWF5IGJlIGVpdGhlciBhIGBzdHJpbmdgLCBhIFtbVXJsUnVsZUhhbmRsZXJGbl1dIG9yIGFub3RoZXIgW1tVcmxNYXRjaGVyXV1cbiAgICpcbiAgICogIyMgSGFuZGxlciBhcyBhIGZ1bmN0aW9uXG4gICAqXG4gICAqIElmIGBoYW5kbGVyYCBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoOlxuICAgKlxuICAgKiAtIG1hdGNoZWQgcGFyYW1ldGVyIHZhbHVlcyAoW1tSYXdQYXJhbXNdXSBmcm9tIFtbVXJsTWF0Y2hlci5leGVjXV0pXG4gICAqIC0gdXJsOiB0aGUgY3VycmVudCBVcmwgKFtbVXJsUGFydHNdXSlcbiAgICogLSByb3V0ZXI6IHRoZSByb3V0ZXIgb2JqZWN0IChbW1VJUm91dGVyXV0pXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHVybE1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vLzpmb29JZC86YmFySWRcIik7XG4gICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyLCBtYXRjaCA9PiBcIi9ob21lL1wiICsgbWF0Y2guZm9vSWQgKyBcIi9cIiArIG1hdGNoLmJhcklkKTtcbiAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvMTIzLzQ1NidcbiAgICogYGBgXG4gICAqXG4gICAqICMjIEhhbmRsZXIgYXMgVXJsTWF0Y2hlclxuICAgKlxuICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBVcmxNYXRjaGVyLCB0aGUgaGFuZGxlciBtYXRjaGVyIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBuZXcgdXJsLlxuICAgKiBUaGUgYGhhbmRsZXJgIFVybE1hdGNoZXIgaXMgZm9ybWF0dGVkIHVzaW5nIHRoZSBtYXRjaGVkIHBhcmFtIGZyb20gdGhlIGZpcnN0IG1hdGNoZXIuXG4gICAqIFRoZSB1cmwgaXMgcmVwbGFjZWQgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciB1cmxNYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvby86Zm9vSWQvOmJhcklkXCIpO1xuICAgKiB2YXIgaGFuZGxlciA9ICR1bWYuY29tcGlsZShcIi9ob21lLzpmb29JZC86YmFySWRcIik7XG4gICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyLCBoYW5kbGVyKTtcbiAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvMTIzLzQ1NidcbiAgICogYGBgXG4gICAqL1xuICBmcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyOiBVcmxNYXRjaGVyLCBoYW5kbGVyOiBzdHJpbmcgfCBVcmxNYXRjaGVyIHwgVXJsUnVsZUhhbmRsZXJGbik6IE1hdGNoZXJVcmxSdWxlIHtcbiAgICBsZXQgX2hhbmRsZXI6IFVybFJ1bGVIYW5kbGVyRm4gPSBoYW5kbGVyIGFzIGFueTtcbiAgICBpZiAoaXNTdHJpbmcoaGFuZGxlcikpIGhhbmRsZXIgPSB0aGlzLnJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKGhhbmRsZXIpO1xuICAgIGlmIChpcyhVcmxNYXRjaGVyKShoYW5kbGVyKSkgX2hhbmRsZXIgPSAobWF0Y2g6IFJhd1BhcmFtcykgPT4gKGhhbmRsZXIgYXMgVXJsTWF0Y2hlcikuZm9ybWF0KG1hdGNoKTtcblxuICAgIGZ1bmN0aW9uIG1hdGNoVXJsUGFyYW10ZXJzKHVybDogVXJsUGFydHMpOiBSYXdQYXJhbXMge1xuICAgICAgY29uc3QgcGFyYW1zID0gdXJsTWF0Y2hlci5leGVjKHVybC5wYXRoLCB1cmwuc2VhcmNoLCB1cmwuaGFzaCk7XG4gICAgICByZXR1cm4gdXJsTWF0Y2hlci52YWxpZGF0ZXMocGFyYW1zKSAmJiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLy8gUHJpb3JpdGl6ZSBVUkxzLCBsb3dlc3QgdG8gaGlnaGVzdDpcbiAgICAvLyAtIFNvbWUgb3B0aW9uYWwgVVJMIHBhcmFtZXRlcnMsIGJ1dCBub25lIG1hdGNoZWRcbiAgICAvLyAtIE5vIG9wdGlvbmFsIHBhcmFtZXRlcnMgaW4gVVJMXG4gICAgLy8gLSBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMsIHNvbWUgbWF0Y2hlZFxuICAgIC8vIC0gU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzLCBhbGwgbWF0Y2hlZFxuICAgIGZ1bmN0aW9uIG1hdGNoUHJpb3JpdHkocGFyYW1zOiBSYXdQYXJhbXMpOiBudW1iZXIge1xuICAgICAgY29uc3Qgb3B0aW9uYWwgPSB1cmxNYXRjaGVyLnBhcmFtZXRlcnMoKS5maWx0ZXIocGFyYW0gPT4gcGFyYW0uaXNPcHRpb25hbCk7XG4gICAgICBpZiAoIW9wdGlvbmFsLmxlbmd0aCkgcmV0dXJuIDAuMDAwMDAxO1xuICAgICAgY29uc3QgbWF0Y2hlZCA9IG9wdGlvbmFsLmZpbHRlcihwYXJhbSA9PiBwYXJhbXNbcGFyYW0uaWRdKTtcbiAgICAgIHJldHVybiBtYXRjaGVkLmxlbmd0aCAvIG9wdGlvbmFsLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBkZXRhaWxzID0geyB1cmxNYXRjaGVyLCBtYXRjaFByaW9yaXR5LCB0eXBlOiAnVVJMTUFUQ0hFUicgfTtcbiAgICByZXR1cm4gZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaFVybFBhcmFtdGVycywgX2hhbmRsZXIpLCBkZXRhaWxzKSBhcyBNYXRjaGVyVXJsUnVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFVybFJ1bGUgd2hpY2ggbWF0Y2hlcyBhIHN0YXRlIGJ5IGl0cyB1cmxcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVN0YXRlKCRzdGF0ZS5nZXQoJ2ZvbycpLCByb3V0ZXIpO1xuICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7XG4gICAqIC8vIFN0YXJ0cyBhIHRyYW5zaXRpb24gdG8gJ2Zvbycgd2l0aCBwYXJhbXM6IHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgKiBgYGBcbiAgICovXG4gIGZyb21TdGF0ZShzdGF0ZTogU3RhdGVPYmplY3QsIHJvdXRlcjogVUlSb3V0ZXIpOiBTdGF0ZVJ1bGUge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbWF0Y2ggYnkgdHJhbnNpdGlvbmluZyB0byBtYXRjaGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBGaXJzdCBjaGVja3MgaWYgdGhlIHJvdXRlciBzaG91bGQgc3RhcnQgYSBuZXcgdHJhbnNpdGlvbi5cbiAgICAgKiBBIG5ldyB0cmFuc2l0aW9uIGlzIG5vdCByZXF1aXJlZCBpZiB0aGUgY3VycmVudCBzdGF0ZSdzIFVSTFxuICAgICAqIGFuZCB0aGUgbmV3IFVSTCBhcmUgYWxyZWFkeSBpZGVudGljYWxcbiAgICAgKi9cbiAgICBjb25zdCBoYW5kbGVyID0gKG1hdGNoOiBSYXdQYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0ICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICBjb25zdCBnbG9iYWxzID0gcm91dGVyLmdsb2JhbHM7XG4gICAgICBpZiAoJHN0YXRlLmhyZWYoc3RhdGUsIG1hdGNoKSAhPT0gJHN0YXRlLmhyZWYoZ2xvYmFscy5jdXJyZW50LCBnbG9iYWxzLnBhcmFtcykpIHtcbiAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgbWF0Y2gsIHsgaW5oZXJpdDogdHJ1ZSwgc291cmNlOiAndXJsJyB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZGV0YWlscyA9IHsgc3RhdGUsIHR5cGU6ICdTVEFURScgfTtcbiAgICByZXR1cm4gZXh0ZW5kKHRoaXMuZnJvbVVybE1hdGNoZXIoc3RhdGUudXJsLCBoYW5kbGVyKSwgZGV0YWlscykgYXMgU3RhdGVSdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGJhc2VkIG9uIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAqXG4gICAqIFRoZSBgaGFuZGxlcmAgbWF5IGJlIGVpdGhlciBhIFtbVXJsUnVsZUhhbmRsZXJGbl1dIG9yIGEgc3RyaW5nLlxuICAgKlxuICAgKiAjIyBIYW5kbGVyIGFzIGEgZnVuY3Rpb25cbiAgICpcbiAgICogSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGg6XG4gICAqXG4gICAqIC0gcmVnZXhwIG1hdGNoIGFycmF5IChmcm9tIGByZWdleHBgKVxuICAgKiAtIHVybDogdGhlIGN1cnJlbnQgVXJsIChbW1VybFBhcnRzXV0pXG4gICAqIC0gcm91dGVyOiB0aGUgcm91dGVyIG9iamVjdCAoW1tVSVJvdXRlcl1dKVxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tUmVnRXhwKC9eXFwvZm9vXFwvKGJhcnxiYXopJC8sIG1hdGNoID0+IFwiL2hvbWUvXCIgKyBtYXRjaFsxXSlcbiAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby9iYXInKTsgLy8gcmVzdWx0cyBpbiBbICcvZm9vL2JhcicsICdiYXInIF1cbiAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS9iYXInXG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyBIYW5kbGVyIGFzIHN0cmluZ1xuICAgKlxuICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBzdHJpbmcsIHRoZSB1cmwgaXMgKnJlcGxhY2VkIGJ5IHRoZSBzdHJpbmcqIHdoZW4gdGhlIFJ1bGUgaXMgaW52b2tlZC5cbiAgICogVGhlIHN0cmluZyBpcyBmaXJzdCBpbnRlcnBvbGF0ZWQgdXNpbmcgYHN0cmluZy5yZXBsYWNlKClgIHN0eWxlIHBhdHRlcm4uXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgXCIvaG9tZS8kMVwiKVxuICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vL2JhcicpOyAvLyByZXN1bHRzIGluIFsgJy9mb28vYmFyJywgJ2JhcicgXVxuICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lL2JhcidcbiAgICogYGBgXG4gICAqL1xuICBmcm9tUmVnRXhwKHJlZ2V4cDogUmVnRXhwLCBoYW5kbGVyOiBzdHJpbmcgfCBVcmxSdWxlSGFuZGxlckZuKTogUmVnRXhwUnVsZSB7XG4gICAgaWYgKHJlZ2V4cC5nbG9iYWwgfHwgcmVnZXhwLnN0aWNreSkgdGhyb3cgbmV3IEVycm9yKCdSdWxlIFJlZ0V4cCBtdXN0IG5vdCBiZSBnbG9iYWwgb3Igc3RpY2t5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiBoYW5kbGVyIGlzIGEgc3RyaW5nLCB0aGUgdXJsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHN0cmluZy5cbiAgICAgKiBJZiB0aGUgc3RyaW5nIGhhcyBhbnkgU3RyaW5nLnJlcGxhY2UoKSBzdHlsZSB2YXJpYWJsZXMgaW4gaXQgKGxpa2UgYCQyYCksXG4gICAgICogdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjYXB0dXJlcyBmcm9tIFtbbWF0Y2hdXVxuICAgICAqL1xuICAgIGNvbnN0IHJlZGlyZWN0VXJsVG8gPSAobWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSkgPT5cbiAgICAgIC8vIEludGVycG9sYXRlcyBtYXRjaGVkIHZhbHVlcyBpbnRvICQxICQyLCBldGMgdXNpbmcgYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cbiAgICAgIChoYW5kbGVyIGFzIHN0cmluZykucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCAobSwgd2hhdCkgPT4gbWF0Y2hbd2hhdCA9PT0gJyQnID8gMCA6IE51bWJlcih3aGF0KV0pO1xuXG4gICAgY29uc3QgX2hhbmRsZXIgPSBpc1N0cmluZyhoYW5kbGVyKSA/IHJlZGlyZWN0VXJsVG8gOiBoYW5kbGVyO1xuXG4gICAgY29uc3QgbWF0Y2hQYXJhbXNGcm9tUmVnZXhwID0gKHVybDogVXJsUGFydHMpOiBSZWdFeHBFeGVjQXJyYXkgPT4gcmVnZXhwLmV4ZWModXJsLnBhdGgpO1xuXG4gICAgY29uc3QgZGV0YWlscyA9IHsgcmVnZXhwLCB0eXBlOiAnUkVHRVhQJyB9O1xuICAgIHJldHVybiBleHRlbmQobmV3IEJhc2VVcmxSdWxlKG1hdGNoUGFyYW1zRnJvbVJlZ2V4cCwgX2hhbmRsZXIpLCBkZXRhaWxzKSBhcyBSZWdFeHBSdWxlO1xuICB9XG59XG5cbi8qKlxuICogQSBiYXNlIHJ1bGUgd2hpY2ggY2FsbHMgYG1hdGNoYFxuICpcbiAqIFRoZSB2YWx1ZSBmcm9tIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBgaGFuZGxlcmAuXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VVcmxSdWxlIGltcGxlbWVudHMgVXJsUnVsZSB7XG4gICRpZDogbnVtYmVyO1xuICBwcmlvcml0eTogbnVtYmVyO1xuICBfZ3JvdXA6IG51bWJlcjtcbiAgdHlwZTogVXJsUnVsZVR5cGUgPSAnUkFXJztcbiAgaGFuZGxlcjogVXJsUnVsZUhhbmRsZXJGbjtcbiAgbWF0Y2hQcmlvcml0eSA9IG1hdGNoID0+IDAgLSB0aGlzLiRpZDtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF0Y2g6IFVybFJ1bGVNYXRjaEZuLCBoYW5kbGVyPzogVXJsUnVsZUhhbmRsZXJGbikge1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXIgfHwgaWRlbnRpdHk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdXJsICovIC8qKiAqL1xuaW1wb3J0IHsgc3RyaXBMYXN0UGF0aEVsZW1lbnQgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgVXJsTWF0Y2hlciB9IGZyb20gJy4vdXJsTWF0Y2hlcic7XG5pbXBvcnQgeyBSYXdQYXJhbXMgfSBmcm9tICcuLi9wYXJhbXMnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgVXJsUnVsZUZhY3RvcnkgfSBmcm9tICcuL3VybFJ1bGUnO1xuaW1wb3J0IHsgTWF0Y2hSZXN1bHQsIFVybFBhcnRzLCBVcmxSdWxlLCBVcmxSdWxlSGFuZGxlckZuIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUsIFRhcmdldFN0YXRlRGVmIH0gZnJvbSAnLi4vc3RhdGUnO1xuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYXBwZW5kQmFzZVBhdGgodXJsOiBzdHJpbmcsIGlzSHRtbDU6IGJvb2xlYW4sIGFic29sdXRlOiBib29sZWFuLCBiYXNlSHJlZjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKGJhc2VIcmVmID09PSAnLycpIHJldHVybiB1cmw7XG4gIGlmIChpc0h0bWw1KSByZXR1cm4gc3RyaXBMYXN0UGF0aEVsZW1lbnQoYmFzZUhyZWYpICsgdXJsO1xuICBpZiAoYWJzb2x1dGUpIHJldHVybiBiYXNlSHJlZi5zbGljZSgxKSArIHVybDtcbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIFVSTCBhbmQgcmVzcG9uZHMgdG8gVVJMIGNoYW5nZXNcbiAqXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzpcbiAqIFRoaXMgY2xhc3MgaXMgbm93IGNvbnNpZGVyZWQgdG8gYmUgYW4gaW50ZXJuYWwgQVBJXG4gKiBVc2UgdGhlIFtbVXJsU2VydmljZV1dIGluc3RlYWQuXG4gKiBGb3IgY29uZmlndXJpbmcgVVJMIHJ1bGVzLCB1c2UgdGhlIFtbVXJsUnVsZXNdXSB3aGljaCBjYW4gYmUgZm91bmQgYXMgW1tVcmxTZXJ2aWNlLnJ1bGVzXV0uXG4gKlxuICogQGludGVybmFsYXBpXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxSb3V0ZXIge1xuICAvKiogdXNlZCB0byBjcmVhdGUgW1tVcmxSdWxlXV0gb2JqZWN0cyBmb3IgY29tbW9uIGNhc2VzICovXG4gIHB1YmxpYyB1cmxSdWxlRmFjdG9yeTogVXJsUnVsZUZhY3Rvcnk7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgbG9jYXRpb246IHN0cmluZztcblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3RvcigvKiogQGhpZGRlbiAqLyBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICB0aGlzLnVybFJ1bGVGYWN0b3J5ID0gbmV3IFVybFJ1bGVGYWN0b3J5KHJvdXRlcik7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgQVBJLlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICovXG4gIHVwZGF0ZShyZWFkPzogYm9vbGVhbikge1xuICAgIGNvbnN0ICR1cmwgPSB0aGlzLnJvdXRlci5sb2NhdGlvblNlcnZpY2U7XG4gICAgaWYgKHJlYWQpIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSAkdXJsLnVybCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJHVybC51cmwoKSA9PT0gdGhpcy5sb2NhdGlvbikgcmV0dXJuO1xuXG4gICAgJHVybC51cmwodGhpcy5sb2NhdGlvbiwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgQVBJLlxuICAgKlxuICAgKiBQdXNoZXMgYSBuZXcgbG9jYXRpb24gdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICpcbiAgICogQGludGVybmFsYXBpXG4gICAqIEBwYXJhbSB1cmxNYXRjaGVyXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsTWF0Y2hlcjogVXJsTWF0Y2hlciwgcGFyYW1zPzogUmF3UGFyYW1zLCBvcHRpb25zPzogeyByZXBsYWNlPzogc3RyaW5nIHwgYm9vbGVhbiB9KSB7XG4gICAgY29uc3QgcmVwbGFjZSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnJlcGxhY2U7XG4gICAgdGhpcy5yb3V0ZXIudXJsU2VydmljZS51cmwodXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zIHx8IHt9KSwgcmVwbGFjZSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuZCByZXR1cm5zIGEgVVJMIHdpdGggaW50ZXJwb2xhdGVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Fib3V0LzpwZXJzb25cIik7XG4gICAqIHBhcmFtcyA9IHsgcGVyc29uOiBcImJvYlwiIH07XG4gICAqICRib2IgPSAkdXJsUm91dGVyLmhyZWYobWF0Y2hlciwgcGFyYW1zKTtcbiAgICogLy8gJGJvYiA9PSBcIi9hYm91dC9ib2JcIjtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB1cmxNYXRjaGVyIFRoZSBbW1VybE1hdGNoZXJdXSBvYmplY3Qgd2hpY2ggaXMgdXNlZCBhcyB0aGUgdGVtcGxhdGUgb2YgdGhlIFVSTCB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyB0byBmaWxsIHRoZSBtYXRjaGVyJ3MgcmVxdWlyZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogLSAqKmBhYnNvbHV0ZWAqKiAtIHtib29sZWFuPWZhbHNlfSwgIElmIHRydWUgd2lsbCBnZW5lcmF0ZSBhbiBhYnNvbHV0ZSB1cmwsIGUuZy4gXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL2Z1bGx1cmxcIi5cbiAgICpcbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZnVsbHkgY29tcGlsZWQgVVJMLCBvciBgbnVsbGAgaWYgYHBhcmFtc2AgZmFpbCB2YWxpZGF0aW9uIGFnYWluc3QgYHVybE1hdGNoZXJgXG4gICAqL1xuICBocmVmKHVybE1hdGNoZXI6IFVybE1hdGNoZXIsIHBhcmFtcz86IGFueSwgb3B0aW9ucz86IHsgYWJzb2x1dGU6IGJvb2xlYW4gfSk6IHN0cmluZyB7XG4gICAgbGV0IHVybCA9IHVybE1hdGNoZXIuZm9ybWF0KHBhcmFtcyk7XG4gICAgaWYgKHVybCA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgYWJzb2x1dGU6IGZhbHNlIH07XG5cbiAgICBjb25zdCBjZmcgPSB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICBjb25zdCBpc0h0bWw1ID0gY2ZnLmh0bWw1TW9kZSgpO1xuICAgIGlmICghaXNIdG1sNSAmJiB1cmwgIT09IG51bGwpIHtcbiAgICAgIHVybCA9ICcjJyArIGNmZy5oYXNoUHJlZml4KCkgKyB1cmw7XG4gICAgfVxuICAgIHVybCA9IGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgb3B0aW9ucy5hYnNvbHV0ZSwgY2ZnLmJhc2VIcmVmKCkpO1xuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlIHx8ICF1cmwpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgY29uc3Qgc2xhc2ggPSAhaXNIdG1sNSAmJiB1cmwgPyAnLycgOiAnJztcbiAgICBjb25zdCBjZmdQb3J0ID0gY2ZnLnBvcnQoKTtcbiAgICBjb25zdCBwb3J0ID0gPGFueT4oY2ZnUG9ydCA9PT0gODAgfHwgY2ZnUG9ydCA9PT0gNDQzID8gJycgOiAnOicgKyBjZmdQb3J0KTtcblxuICAgIHJldHVybiBbY2ZnLnByb3RvY29sKCksICc6Ly8nLCBjZmcuaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcbiAgfVxuXG4gIC8vIERlbGVnYXRlIHRoZXNlIGNhbGxzIHRvIFtbVXJsU2VydmljZV1dXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgW1tVcmxTZXJ2aWNlLnN5bmNdXSovXG4gIHB1YmxpYyBzeW5jID0gKGV2dD8pID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2Uuc3luYyhldnQpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsU2VydmljZS5saXN0ZW5dXSovXG4gIHB1YmxpYyBsaXN0ZW4gPSAoZW5hYmxlZD86IGJvb2xlYW4pOiBGdW5jdGlvbiA9PiB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLmxpc3RlbihlbmFibGVkKTtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHRdXSovXG4gIHB1YmxpYyBkZWZlckludGVyY2VwdCA9IChkZWZlcj86IGJvb2xlYW4pID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHQoZGVmZXIpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsU2VydmljZS5pbnRlcmNlcHREZWZlcnJlZF1dKi9cbiAgcHVibGljIGdldCBpbnRlcmNlcHREZWZlcnJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5pbnRlcmNlcHREZWZlcnJlZDtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsU2VydmljZS5tYXRjaF1dKi9cbiAgcHVibGljIG1hdGNoID0gKHVybFBhcnRzOiBVcmxQYXJ0cyk6IE1hdGNoUmVzdWx0ID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UubWF0Y2godXJsUGFydHMpO1xuXG4gIC8vIERlbGVnYXRlIHRoZXNlIGNhbGxzIHRvIFtbVXJsUnVsZXNdXVxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMuaW5pdGlhbF1dKi9cbiAgcHVibGljIGluaXRpYWwgPSAoaGFuZGxlcjogc3RyaW5nIHwgVXJsUnVsZUhhbmRsZXJGbiB8IFRhcmdldFN0YXRlIHwgVGFyZ2V0U3RhdGVEZWYpOiB2b2lkID0+XG4gICAgdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5pbml0aWFsKGhhbmRsZXIpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMub3RoZXJ3aXNlXV0qL1xuICBwdWJsaWMgb3RoZXJ3aXNlID0gKGhhbmRsZXI6IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm4gfCBUYXJnZXRTdGF0ZSB8IFRhcmdldFN0YXRlRGVmKTogdm9pZCA9PlxuICAgIHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMub3RoZXJ3aXNlKGhhbmRsZXIpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMucmVtb3ZlUnVsZV1dKi9cbiAgcHVibGljIHJlbW92ZVJ1bGUgPSAocnVsZTogVXJsUnVsZSk6IHZvaWQgPT4gdGhpcy5yb3V0ZXIudXJsU2VydmljZS5ydWxlcy5yZW1vdmVSdWxlKHJ1bGUpO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMucnVsZV1dKi9cbiAgcHVibGljIHJ1bGUgPSAocnVsZTogVXJsUnVsZSk6IEZ1bmN0aW9uID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMucnVsZShydWxlKTtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybFJ1bGVzLnJ1bGVzXV0qL1xuICBwdWJsaWMgcnVsZXMgPSAoKTogVXJsUnVsZVtdID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMucnVsZXMoKTtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBbW1VybFJ1bGVzLnNvcnRdXSovXG4gIHB1YmxpYyBzb3J0ID0gKGNvbXBhcmVGbj86IChhOiBVcmxSdWxlLCBiOiBVcmxSdWxlKSA9PiBudW1iZXIpID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMuc29ydChjb21wYXJlRm4pO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIFtbVXJsUnVsZXMud2hlbl1dKi9cbiAgcHVibGljIHdoZW4gPSAoXG4gICAgbWF0Y2hlcjogUmVnRXhwIHwgVXJsTWF0Y2hlciB8IHN0cmluZyxcbiAgICBoYW5kbGVyOiBzdHJpbmcgfCBVcmxSdWxlSGFuZGxlckZuLFxuICAgIG9wdGlvbnM/OiB7IHByaW9yaXR5OiBudW1iZXIgfVxuICApOiBVcmxSdWxlID0+IHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMud2hlbihtYXRjaGVyLCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdmlldyAqLyAvKiogKi9cbmltcG9ydCB7IGVxdWFscywgYXBwbHlQYWlycywgcmVtb3ZlRnJvbSwgVHlwZWRNYXAsIGluQXJyYXksIGZpbmQgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IGN1cnJ5LCBwcm9wIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSAnLi4vY29tbW9uL3RyYWNlJztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aC9wYXRoTm9kZSc7XG5pbXBvcnQgeyBBY3RpdmVVSVZpZXcsIFZpZXdDb250ZXh0LCBWaWV3Q29uZmlnIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgX1ZpZXdEZWNsYXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5cbmV4cG9ydCB0eXBlIFZpZXdDb25maWdGYWN0b3J5ID0gKHBhdGg6IFBhdGhOb2RlW10sIGRlY2w6IF9WaWV3RGVjbGFyYXRpb24pID0+IFZpZXdDb25maWcgfCBWaWV3Q29uZmlnW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld1NlcnZpY2VQbHVnaW5BUEkge1xuICBfcm9vdFZpZXdDb250ZXh0KGNvbnRleHQ/OiBWaWV3Q29udGV4dCk6IFZpZXdDb250ZXh0O1xuICBfdmlld0NvbmZpZ0ZhY3Rvcnkodmlld1R5cGU6IHN0cmluZywgZmFjdG9yeTogVmlld0NvbmZpZ0ZhY3RvcnkpO1xuICAvKiogQHBhcmFtIGlkIHJvdXRlci4kaWQgKyBcIi5cIiArIHVpVmlldy5pZCAqL1xuICBfcmVnaXN0ZXJlZFVJVmlldyhpZDogc3RyaW5nKTogQWN0aXZlVUlWaWV3O1xuICBfcmVnaXN0ZXJlZFVJVmlld3MoKTogQWN0aXZlVUlWaWV3W107XG4gIF9hY3RpdmVWaWV3Q29uZmlncygpOiBWaWV3Q29uZmlnW107XG4gIF9vblN5bmMobGlzdGVuZXI6IFZpZXdTeW5jTGlzdGVuZXIpOiBGdW5jdGlvbjtcbn1cblxuLy8gQSB1aVZpZXcgYW5kIGl0cyBtYXRjaGluZyB2aWV3Q29uZmlnXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdUdXBsZSB7XG4gIHVpVmlldzogQWN0aXZlVUlWaWV3O1xuICB2aWV3Q29uZmlnOiBWaWV3Q29uZmlnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdTeW5jTGlzdGVuZXIge1xuICAodmlld1R1cGxlczogVmlld1R1cGxlW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIFRoZSBWaWV3IHNlcnZpY2VcbiAqXG4gKiBUaGlzIHNlcnZpY2UgcGFpcnMgZXhpc3RpbmcgYHVpLXZpZXdgIGNvbXBvbmVudHMgKHdoaWNoIGxpdmUgaW4gdGhlIERPTSlcbiAqIHdpdGggdmlldyBjb25maWdzIChmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3RzOiBbW1N0YXRlRGVjbGFyYXRpb24udmlld3NdXSkuXG4gKlxuICogLSBBZnRlciBhIHN1Y2Nlc3NmdWwgVHJhbnNpdGlvbiwgdGhlIHZpZXdzIGZyb20gdGhlIG5ld2x5IGVudGVyZWQgc3RhdGVzIGFyZSBhY3RpdmF0ZWQgdmlhIFtbYWN0aXZhdGVWaWV3Q29uZmlnXV0uXG4gKiAgIFRoZSB2aWV3cyBmcm9tIGV4aXRlZCBzdGF0ZXMgYXJlIGRlYWN0aXZhdGVkIHZpYSBbW2RlYWN0aXZhdGVWaWV3Q29uZmlnXV0uXG4gKiAgIChTZWU6IHRoZSBbW3JlZ2lzdGVyQWN0aXZhdGVWaWV3c11dIFRyYW5zaXRpb24gSG9vaylcbiAqXG4gKiAtIEFzIGB1aS12aWV3YCBjb21wb25lbnRzIHBvcCBpbiBhbmQgb3V0IG9mIGV4aXN0ZW5jZSwgdGhleSByZWdpc3RlciB0aGVtc2VsdmVzIHVzaW5nIFtbcmVnaXN0ZXJVSVZpZXddXS5cbiAqXG4gKiAtIFdoZW4gdGhlIFtbc3luY11dIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHJlZ2lzdGVyZWQgYHVpLXZpZXdgKHMpIChbW0FjdGl2ZVVJVmlld11dKVxuICogYXJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgbWF0Y2hpbmcgW1tWaWV3Q29uZmlnXV0ocylcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWV3U2VydmljZSB7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3VpVmlld3M6IEFjdGl2ZVVJVmlld1tdID0gW107XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3ZpZXdDb25maWdzOiBWaWV3Q29uZmlnW10gPSBbXTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfcm9vdENvbnRleHQ6IFZpZXdDb250ZXh0O1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF92aWV3Q29uZmlnRmFjdG9yaWVzOiB7IFtrZXk6IHN0cmluZ106IFZpZXdDb25maWdGYWN0b3J5IH0gPSB7fTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfbGlzdGVuZXJzOiBWaWV3U3luY0xpc3RlbmVyW10gPSBbXTtcblxuICAvKiogQGludGVybmFsYXBpICovXG4gIHB1YmxpYyBfcGx1Z2luYXBpOiBWaWV3U2VydmljZVBsdWdpbkFQSSA9IHtcbiAgICBfcm9vdFZpZXdDb250ZXh0OiB0aGlzLl9yb290Vmlld0NvbnRleHQuYmluZCh0aGlzKSxcbiAgICBfdmlld0NvbmZpZ0ZhY3Rvcnk6IHRoaXMuX3ZpZXdDb25maWdGYWN0b3J5LmJpbmQodGhpcyksXG4gICAgX3JlZ2lzdGVyZWRVSVZpZXc6IChpZDogc3RyaW5nKSA9PiBmaW5kKHRoaXMuX3VpVmlld3MsIHZpZXcgPT4gYCR7dGhpcy5yb3V0ZXIuJGlkfS4ke3ZpZXcuaWR9YCA9PT0gaWQpLFxuICAgIF9yZWdpc3RlcmVkVUlWaWV3czogKCkgPT4gdGhpcy5fdWlWaWV3cyxcbiAgICBfYWN0aXZlVmlld0NvbmZpZ3M6ICgpID0+IHRoaXMuX3ZpZXdDb25maWdzLFxuICAgIF9vblN5bmM6IChsaXN0ZW5lcjogVmlld1N5bmNMaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgcmV0dXJuICgpID0+IHJlbW92ZUZyb20odGhpcy5fbGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSB1aS12aWV3IGFuZCBhIFZpZXdDb25maWcsIGRldGVybWluZXMgaWYgdGhleSBcIm1hdGNoXCIuXG4gICAqXG4gICAqIEEgdWktdmlldyBoYXMgYSBmdWxseSBxdWFsaWZpZWQgbmFtZSAoZnFuKSBhbmQgYSBjb250ZXh0IG9iamVjdC4gIFRoZSBmcW4gaXMgYnVpbHQgZnJvbSBpdHMgb3ZlcmFsbCBsb2NhdGlvbiBpblxuICAgKiB0aGUgRE9NLCBkZXNjcmliaW5nIGl0cyBuZXN0aW5nIHJlbGF0aW9uc2hpcCB0byBhbnkgcGFyZW50IHVpLXZpZXcgdGFncyBpdCBpcyBuZXN0ZWQgaW5zaWRlIG9mLlxuICAgKlxuICAgKiBBIFZpZXdDb25maWcgaGFzIGEgdGFyZ2V0IHVpLXZpZXcgbmFtZSBhbmQgYSBjb250ZXh0IGFuY2hvci4gIFRoZSB1aS12aWV3IG5hbWUgY2FuIGJlIGEgc2ltcGxlIG5hbWUsIG9yXG4gICAqIGNhbiBiZSBhIHNlZ21lbnRlZCB1aS12aWV3IHBhdGgsIGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIGEgdWktdmlldyBmcW4uXG4gICAqXG4gICAqIEluIG9yZGVyIGZvciBhIHVpLXZpZXcgdG8gbWF0Y2ggVmlld0NvbmZpZywgdWktdmlldydzICR0eXBlIG11c3QgbWF0Y2ggdGhlIFZpZXdDb25maWcncyAkdHlwZVxuICAgKlxuICAgKiBJZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCB1aS12aWV3IG5hbWUgaXMgYSBzaW1wbGUgbmFtZSAobm8gZG90cyksIHRoZW4gYSB1aS12aWV3IG1hdGNoZXMgaWY6XG4gICAqIC0gdGhlIHVpLXZpZXcncyBuYW1lIG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgKiAtIHRoZSB1aS12aWV3J3MgY29udGV4dCBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yXG4gICAqXG4gICAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNlZ21lbnRlZCBuYW1lICh3aXRoIGRvdHMpLCB0aGVuIGEgdWktdmlldyBtYXRjaGVzIGlmOlxuICAgKiAtIFRoZXJlIGV4aXN0cyBhIHBhcmVudCB1aS12aWV3IHdoZXJlOlxuICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIG5hbWUgbWF0Y2hlcyB0aGUgZmlyc3Qgc2VnbWVudCAoaW5kZXggMCkgb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvclxuICAgKiAtIEFuZCB0aGUgcmVtYWluaW5nIHNlZ21lbnRzIChpbmRleCAxLi5uKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lIG1hdGNoIHRoZSB0YWlsIG9mIHRoZSB1aS12aWV3J3MgZnFuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIERPTTpcbiAgICogPHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSByb290IGNvbnRleHQgKG5hbWU6IFwiXCIpIC0tPlxuICAgKiAgIDx1aS12aWV3IG5hbWU9XCJmb29cIj4gICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSBjb250ZXh0IG5hbWVkOiBcIkFcIiAgICAgIC0tPlxuICAgKiAgICAgPHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CXCIgICAgLS0+XG4gICAqICAgICAgIDx1aS12aWV3IG5hbWU9XCJiYXJcIj4gICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CLkNcIiAgLS0+XG4gICAqICAgICAgIDwvdWktdmlldz5cbiAgICogICAgIDwvdWktdmlldz5cbiAgICogICA8L3VpLXZpZXc+XG4gICAqIDwvdWktdmlldz5cbiAgICpcbiAgICogdWlWaWV3czogW1xuICAgKiAgeyBmcW46IFwiJGRlZmF1bHRcIiwgICAgICAgICAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJcIiB9IH0sXG4gICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb29cIiwgICAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkFcIiB9IH0sXG4gICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHRcIiwgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQlwiIH0gfVxuICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiLCBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBLkIuQ1wiIH0gfVxuICAgKiBdXG4gICAqXG4gICAqIFRoZXNlIGZvdXIgdmlldyBjb25maWdzIGFsbCBtYXRjaCB0aGUgdWktdmlldyB3aXRoIHRoZSBmcW46IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiOlxuICAgKlxuICAgKiAtIFZpZXdDb25maWcxOiB7IHVpVmlld05hbWU6IFwiYmFyXCIsICAgICAgICAgICAgICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkEuQi5DXCIgfVxuICAgKiAtIFZpZXdDb25maWcyOiB7IHVpVmlld05hbWU6IFwiJGRlZmF1bHQuYmFyXCIsICAgICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkEuQlwiIH1cbiAgICogLSBWaWV3Q29uZmlnMzogeyB1aVZpZXdOYW1lOiBcImZvby4kZGVmYXVsdC5iYXJcIiwgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBXCIgfVxuICAgKiAtIFZpZXdDb25maWc0OiB7IHVpVmlld05hbWU6IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiLCB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIlwiIH1cbiAgICpcbiAgICogVXNpbmcgVmlld0NvbmZpZzMgYXMgYW4gZXhhbXBsZSwgaXQgbWF0Y2hlcyB0aGUgdWktdmlldyB3aXRoIGZxbiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiBiZWNhdXNlOlxuICAgKiAtIFRoZSBWaWV3Q29uZmlnJ3Mgc2VnbWVudGVkIHRhcmdldCBuYW1lIGlzOiBbIFwiZm9vXCIsIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdXG4gICAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgKHdoaWNoIGhhcyBmcW46IFwiJGRlZmF1bHQuZm9vXCIpIHdoZXJlOlxuICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIG5hbWUgXCJmb29cIiBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IFwiZm9vXCIgb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgXCJBXCIgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvciBjb250ZXh0IFwiQVwiXG4gICAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgWyBcIiRkZWZhdWx0XCIsIFwiYmFyXCIgXS5qb2luKFwiLlwiXyBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lIG1hdGNoXG4gICAqICAgdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW4gXCJkZWZhdWx0LmJhclwiXG4gICAqXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgc3RhdGljIG1hdGNoZXMgPSAodWlWaWV3c0J5RnFuOiBUeXBlZE1hcDxBY3RpdmVVSVZpZXc+LCB1aVZpZXc6IEFjdGl2ZVVJVmlldykgPT4gKHZpZXdDb25maWc6IFZpZXdDb25maWcpID0+IHtcbiAgICAvLyBEb24ndCBzdXBwbHkgYW4gbmcxIHVpLXZpZXcgd2l0aCBhbiBuZzIgVmlld0NvbmZpZywgZXRjXG4gICAgaWYgKHVpVmlldy4kdHlwZSAhPT0gdmlld0NvbmZpZy52aWV3RGVjbC4kdHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gU3BsaXQgbmFtZXMgYXBhcnQgZnJvbSBib3RoIHZpZXdDb25maWcgYW5kIHVpVmlldyBpbnRvIHNlZ21lbnRzXG4gICAgY29uc3QgdmMgPSB2aWV3Q29uZmlnLnZpZXdEZWNsO1xuICAgIGNvbnN0IHZjU2VnbWVudHMgPSB2Yy4kdWlWaWV3TmFtZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHVpdlNlZ21lbnRzID0gdWlWaWV3LmZxbi5zcGxpdCgnLicpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhaWxzIG9mIHRoZSBzZWdtZW50IGFycmF5cyBtYXRjaC4gZXgsIHRoZXNlIGFycmF5cycgdGFpbHMgbWF0Y2g6XG4gICAgLy8gdmM6IFtcImZvb1wiLCBcImJhclwiXSwgdWl2IGZxbjogW1wiJGRlZmF1bHRcIiwgXCJmb29cIiwgXCJiYXJcIl1cbiAgICBpZiAoIWVxdWFscyh2Y1NlZ21lbnRzLCB1aXZTZWdtZW50cy5zbGljZSgwIC0gdmNTZWdtZW50cy5sZW5ndGgpKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gTm93IGNoZWNrIGlmIHRoZSBmcW4gZW5kaW5nIGF0IHRoZSBmaXJzdCBzZWdtZW50IG9mIHRoZSB2aWV3Q29uZmlnIG1hdGNoZXMgdGhlIGNvbnRleHQ6XG4gICAgLy8gW1wiJGRlZmF1bHRcIiwgXCJmb29cIl0uam9pbihcIi5cIikgPT0gXCIkZGVmYXVsdC5mb29cIiwgZG9lcyB0aGUgdWktdmlldyAkZGVmYXVsdC5mb28gY29udGV4dCBtYXRjaD9cbiAgICBjb25zdCBuZWdPZmZzZXQgPSAxIC0gdmNTZWdtZW50cy5sZW5ndGggfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZxblRvRmlyc3RTZWdtZW50ID0gdWl2U2VnbWVudHMuc2xpY2UoMCwgbmVnT2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgY29uc3QgdWlWaWV3Q29udGV4dCA9IHVpVmlld3NCeUZxbltmcW5Ub0ZpcnN0U2VnbWVudF0uY3JlYXRpb25Db250ZXh0O1xuICAgIHJldHVybiB2Yy4kdWlWaWV3Q29udGV4dEFuY2hvciA9PT0gKHVpVmlld0NvbnRleHQgJiYgdWlWaWV3Q29udGV4dC5uYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhIHZpZXcncyBuYW1lIGZyb20gYSBzdGF0ZS52aWV3cyBjb25maWd1cmF0aW9uIGJsb2NrLlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGJ5IGEgZnJhbWV3b3JrIGltcGxlbWVudGF0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvclxuICAgKiBbW19WaWV3RGVjbGFyYXRpb24uJHVpVmlld05hbWVdXSBhbmQgW1tfVmlld0RlY2xhcmF0aW9uLiR1aVZpZXdDb250ZXh0QW5jaG9yXV0uXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0IG9iamVjdCAoc3RhdGUgZGVjbGFyYXRpb24pIHRoYXQgdGhlIHZpZXcgYmVsb25ncyB0b1xuICAgKiBAcGFyYW0gcmF3Vmlld05hbWUgdGhlIG5hbWUgb2YgdGhlIHZpZXcsIGFzIGRlY2xhcmVkIGluIHRoZSBbW1N0YXRlRGVjbGFyYXRpb24udmlld3NdXVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB1aVZpZXdOYW1lIGFuZCB1aVZpZXdDb250ZXh0QW5jaG9yIHRoYXQgdGhlIHZpZXcgdGFyZ2V0c1xuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVVJVmlld1RhcmdldChjb250ZXh0OiBWaWV3Q29udGV4dCwgcmF3Vmlld05hbWUgPSAnJykge1xuICAgIC8vIFRPRE86IFZhbGlkYXRlIGluY29taW5nIHZpZXcgbmFtZSB3aXRoIGEgcmVnZXhwIHRvIGFsbG93OlxuICAgIC8vIGV4OiBcInZpZXcubmFtZUBmb28uYmFyXCIgLCBcIl4uXi52aWV3Lm5hbWVcIiAsIFwidmlldy5uYW1lQF4uXlwiICwgXCJcIiAsXG4gICAgLy8gXCJAXCIgLCBcIiRkZWZhdWx0QF5cIiAsIFwiISRkZWZhdWx0LiRkZWZhdWx0XCIgLCBcIiFmb28uYmFyXCJcbiAgICBjb25zdCB2aWV3QXRDb250ZXh0OiBzdHJpbmdbXSA9IHJhd1ZpZXdOYW1lLnNwbGl0KCdAJyk7XG4gICAgbGV0IHVpVmlld05hbWUgPSB2aWV3QXRDb250ZXh0WzBdIHx8ICckZGVmYXVsdCc7IC8vIGRlZmF1bHQgdG8gdW5uYW1lZCB2aWV3XG4gICAgbGV0IHVpVmlld0NvbnRleHRBbmNob3IgPSBpc1N0cmluZyh2aWV3QXRDb250ZXh0WzFdKSA/IHZpZXdBdENvbnRleHRbMV0gOiAnXic7IC8vIGRlZmF1bHQgdG8gcGFyZW50IGNvbnRleHRcblxuICAgIC8vIEhhbmRsZSByZWxhdGl2ZSB2aWV3LW5hbWUgc3VnYXIgc3ludGF4LlxuICAgIC8vIE1hdGNoZXMgcmF3Vmlld05hbWUgXCJeLl4uXi5mb28uYmFyXCIgaW50byBhcnJheTogW1wiXi5eLl4uZm9vLmJhclwiLCBcIl4uXi5eXCIsIFwiZm9vLmJhclwiXSxcbiAgICBjb25zdCByZWxhdGl2ZVZpZXdOYW1lU3VnYXIgPSAvXihcXF4oPzpcXC5cXF4pKilcXC4oLiokKS8uZXhlYyh1aVZpZXdOYW1lKTtcbiAgICBpZiAocmVsYXRpdmVWaWV3TmFtZVN1Z2FyKSB7XG4gICAgICAvLyBDbG9iYmVycyBleGlzdGluZyBjb250ZXh0QW5jaG9yIChyYXdWaWV3TmFtZSB2YWxpZGF0aW9uIHdpbGwgZml4IHRoaXMpXG4gICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gcmVsYXRpdmVWaWV3TmFtZVN1Z2FyWzFdOyAvLyBzZXQgYW5jaG9yIHRvIFwiXi5eLl5cIlxuICAgICAgdWlWaWV3TmFtZSA9IHJlbGF0aXZlVmlld05hbWVTdWdhclsyXTsgLy8gc2V0IHZpZXctbmFtZSB0byBcImZvby5iYXJcIlxuICAgIH1cblxuICAgIGlmICh1aVZpZXdOYW1lLmNoYXJBdCgwKSA9PT0gJyEnKSB7XG4gICAgICB1aVZpZXdOYW1lID0gdWlWaWV3TmFtZS5zdWJzdHIoMSk7XG4gICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gJyc7IC8vIHRhcmdldCBhYnNvbHV0ZWx5IGZyb20gcm9vdFxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBwYXJlbnQgcmVsYXRpdmUgdGFyZ2V0aW5nIFwiXi5eLl5cIlxuICAgIGNvbnN0IHJlbGF0aXZlTWF0Y2ggPSAvXihcXF4oPzpcXC5cXF4pKikkLztcbiAgICBpZiAocmVsYXRpdmVNYXRjaC5leGVjKHVpVmlld0NvbnRleHRBbmNob3IpKSB7XG4gICAgICBjb25zdCBhbmNob3JTdGF0ZSA9IHVpVmlld0NvbnRleHRBbmNob3Iuc3BsaXQoJy4nKS5yZWR1Y2UoKGFuY2hvciwgeCkgPT4gYW5jaG9yLnBhcmVudCwgY29udGV4dCk7XG4gICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gYW5jaG9yU3RhdGUubmFtZTtcbiAgICB9IGVsc2UgaWYgKHVpVmlld0NvbnRleHRBbmNob3IgPT09ICcuJykge1xuICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IGNvbnRleHQubmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB1aVZpZXdOYW1lLCB1aVZpZXdDb250ZXh0QW5jaG9yIH07XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3RvcigvKiogQGhpZGRlbiAqLyBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHt9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfcm9vdFZpZXdDb250ZXh0KGNvbnRleHQ/OiBWaWV3Q29udGV4dCk6IFZpZXdDb250ZXh0IHtcbiAgICByZXR1cm4gKHRoaXMuX3Jvb3RDb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLl9yb290Q29udGV4dCk7XG4gIH1cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfdmlld0NvbmZpZ0ZhY3Rvcnkodmlld1R5cGU6IHN0cmluZywgZmFjdG9yeTogVmlld0NvbmZpZ0ZhY3RvcnkpIHtcbiAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW3ZpZXdUeXBlXSA9IGZhY3Rvcnk7XG4gIH1cblxuICBjcmVhdGVWaWV3Q29uZmlnKHBhdGg6IFBhdGhOb2RlW10sIGRlY2w6IF9WaWV3RGVjbGFyYXRpb24pOiBWaWV3Q29uZmlnW10ge1xuICAgIGNvbnN0IGNmZ0ZhY3RvcnkgPSB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW2RlY2wuJHR5cGVdO1xuICAgIGlmICghY2ZnRmFjdG9yeSkgdGhyb3cgbmV3IEVycm9yKCdWaWV3U2VydmljZTogTm8gdmlldyBjb25maWcgZmFjdG9yeSByZWdpc3RlcmVkIGZvciB0eXBlICcgKyBkZWNsLiR0eXBlKTtcbiAgICBjb25zdCBjZmdzID0gY2ZnRmFjdG9yeShwYXRoLCBkZWNsKTtcbiAgICByZXR1cm4gaXNBcnJheShjZmdzKSA/IGNmZ3MgOiBbY2Znc107XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgYSBWaWV3Q29uZmlnLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRlYWN0aXZhdGVzIGEgYFZpZXdDb25maWdgLlxuICAgKiBBZnRlciBjYWxsaW5nIFtbc3luY11dLCBpdCB3aWxsIHVuLXBhaXIgZnJvbSBhbnkgYHVpLXZpZXdgIHdpdGggd2hpY2ggaXQgaXMgY3VycmVudGx5IHBhaXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHZpZXdDb25maWcgVGhlIFZpZXdDb25maWcgdmlldyB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgZGVhY3RpdmF0ZVZpZXdDb25maWcodmlld0NvbmZpZzogVmlld0NvbmZpZykge1xuICAgIHRyYWNlLnRyYWNlVmlld1NlcnZpY2VFdmVudCgnPC0gUmVtb3ZpbmcnLCB2aWV3Q29uZmlnKTtcbiAgICByZW1vdmVGcm9tKHRoaXMuX3ZpZXdDb25maWdzLCB2aWV3Q29uZmlnKTtcbiAgfVxuXG4gIGFjdGl2YXRlVmlld0NvbmZpZyh2aWV3Q29uZmlnOiBWaWV3Q29uZmlnKSB7XG4gICAgdHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KCctPiBSZWdpc3RlcmluZycsIDxhbnk+dmlld0NvbmZpZyk7XG4gICAgdGhpcy5fdmlld0NvbmZpZ3MucHVzaCh2aWV3Q29uZmlnKTtcbiAgfVxuXG4gIHN5bmMoKSB7XG4gICAgY29uc3QgdWlWaWV3c0J5RnFuOiBUeXBlZE1hcDxBY3RpdmVVSVZpZXc+ID0gdGhpcy5fdWlWaWV3cy5tYXAodWl2ID0+IFt1aXYuZnFuLCB1aXZdKS5yZWR1Y2UoYXBwbHlQYWlycywgPGFueT57fSk7XG5cbiAgICAvLyBSZXR1cm4gYSB3ZWlnaHRlZCBkZXB0aCB2YWx1ZSBmb3IgYSB1aVZpZXcuXG4gICAgLy8gVGhlIGRlcHRoIGlzIHRoZSBuZXN0aW5nIGRlcHRoIG9mIHVpLXZpZXdzIChiYXNlZCBvbiBGUU47IHRpbWVzIDEwLDAwMClcbiAgICAvLyBwbHVzIHRoZSBkZXB0aCBvZiB0aGUgc3RhdGUgdGhhdCBpcyBwb3B1bGF0aW5nIHRoZSB1aVZpZXdcbiAgICBmdW5jdGlvbiB1aVZpZXdEZXB0aCh1aVZpZXc6IEFjdGl2ZVVJVmlldykge1xuICAgICAgY29uc3Qgc3RhdGVEZXB0aCA9IChjb250ZXh0OiBWaWV3Q29udGV4dCkgPT4gKGNvbnRleHQgJiYgY29udGV4dC5wYXJlbnQgPyBzdGF0ZURlcHRoKGNvbnRleHQucGFyZW50KSArIDEgOiAxKTtcbiAgICAgIHJldHVybiB1aVZpZXcuZnFuLnNwbGl0KCcuJykubGVuZ3RoICogMTAwMDAgKyBzdGF0ZURlcHRoKHVpVmlldy5jcmVhdGlvbkNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgVmlld0NvbmZpZydzIGNvbnRleHQncyBkZXB0aCBpbiB0aGUgY29udGV4dCB0cmVlLlxuICAgIGZ1bmN0aW9uIHZpZXdDb25maWdEZXB0aChjb25maWc6IFZpZXdDb25maWcpIHtcbiAgICAgIGxldCBjb250ZXh0OiBWaWV3Q29udGV4dCA9IGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCxcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgd2hpbGUgKCsrY291bnQgJiYgY29udGV4dC5wYXJlbnQpIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICAvLyBHaXZlbiBhIGRlcHRoIGZ1bmN0aW9uLCByZXR1cm5zIGEgY29tcGFyZSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGVpdGhlciBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBvcmRlclxuICAgIGNvbnN0IGRlcHRoQ29tcGFyZSA9IGN1cnJ5KChkZXB0aEZuLCBwb3NOZWcsIGxlZnQsIHJpZ2h0KSA9PiBwb3NOZWcgKiAoZGVwdGhGbihsZWZ0KSAtIGRlcHRoRm4ocmlnaHQpKSk7XG5cbiAgICBjb25zdCBtYXRjaGluZ0NvbmZpZ1BhaXIgPSAodWlWaWV3OiBBY3RpdmVVSVZpZXcpOiBWaWV3VHVwbGUgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hpbmdDb25maWdzID0gdGhpcy5fdmlld0NvbmZpZ3MuZmlsdGVyKFZpZXdTZXJ2aWNlLm1hdGNoZXModWlWaWV3c0J5RnFuLCB1aVZpZXcpKTtcbiAgICAgIGlmIChtYXRjaGluZ0NvbmZpZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBUaGlzIGlzIE9LLiAgQ2hpbGQgc3RhdGVzIGNhbiB0YXJnZXQgYSB1aS12aWV3IHRoYXQgdGhlIHBhcmVudCBzdGF0ZSBhbHNvIHRhcmdldHMgKHRoZSBjaGlsZCB3aW5zKVxuICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoIGFuZCByZXR1cm4gdGhlIG1hdGNoIGZyb20gdGhlIGRlZXBlc3QgY2hpbGRcbiAgICAgICAgLy8gY29uc29sZS5sb2coYE11bHRpcGxlIG1hdGNoaW5nIHZpZXcgY29uZmlncyBmb3IgJHt1aVZpZXcuZnFufWAsIG1hdGNoaW5nQ29uZmlncyk7XG4gICAgICAgIG1hdGNoaW5nQ29uZmlncy5zb3J0KGRlcHRoQ29tcGFyZSh2aWV3Q29uZmlnRGVwdGgsIC0xKSk7IC8vIGRlc2NlbmRpbmdcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHVpVmlldywgdmlld0NvbmZpZzogbWF0Y2hpbmdDb25maWdzWzBdIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbmZpZ3VyZVVJVmlldyA9ICh0dXBsZTogVmlld1R1cGxlKSA9PiB7XG4gICAgICAvLyBJZiBhIHBhcmVudCB1aS12aWV3IGlzIHJlY29uZmlndXJlZCwgaXQgY291bGQgZGVzdHJveSBjaGlsZCB1aS12aWV3cy5cbiAgICAgIC8vIEJlZm9yZSBjb25maWd1cmluZyBhIGNoaWxkIHVpLXZpZXcsIG1ha2Ugc3VyZSBpdCdzIHN0aWxsIGluIHRoZSBhY3RpdmUgdWlWaWV3cyBhcnJheS5cbiAgICAgIGlmICh0aGlzLl91aVZpZXdzLmluZGV4T2YodHVwbGUudWlWaWV3KSAhPT0gLTEpIHR1cGxlLnVpVmlldy5jb25maWdVcGRhdGVkKHR1cGxlLnZpZXdDb25maWcpO1xuICAgIH07XG5cbiAgICAvLyBTb3J0IHZpZXdzIGJ5IEZRTiBhbmQgc3RhdGUgZGVwdGguIFByb2Nlc3MgdWl2aWV3cyBuZWFyZXN0IHRoZSByb290IGZpcnN0LlxuICAgIGNvbnN0IHVpVmlld1R1cGxlcyA9IHRoaXMuX3VpVmlld3Muc29ydChkZXB0aENvbXBhcmUodWlWaWV3RGVwdGgsIDEpKS5tYXAobWF0Y2hpbmdDb25maWdQYWlyKTtcbiAgICBjb25zdCBtYXRjaGVkVmlld0NvbmZpZ3MgPSB1aVZpZXdUdXBsZXMubWFwKHR1cGxlID0+IHR1cGxlLnZpZXdDb25maWcpO1xuICAgIGNvbnN0IHVubWF0Y2hlZENvbmZpZ1R1cGxlcyA9IHRoaXMuX3ZpZXdDb25maWdzXG4gICAgICAuZmlsdGVyKGNvbmZpZyA9PiAhaW5BcnJheShtYXRjaGVkVmlld0NvbmZpZ3MsIGNvbmZpZykpXG4gICAgICAubWFwKHZpZXdDb25maWcgPT4gKHsgdWlWaWV3OiB1bmRlZmluZWQsIHZpZXdDb25maWcgfSkpO1xuXG4gICAgdWlWaWV3VHVwbGVzLmZvckVhY2goY29uZmlndXJlVUlWaWV3KTtcblxuICAgIGNvbnN0IGFsbFR1cGxlczogVmlld1R1cGxlW10gPSB1aVZpZXdUdXBsZXMuY29uY2F0KHVubWF0Y2hlZENvbmZpZ1R1cGxlcyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goY2IgPT4gY2IoYWxsVHVwbGVzKSk7XG4gICAgdHJhY2UudHJhY2VWaWV3U3luYyhhbGxUdXBsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGB1aS12aWV3YCBjb21wb25lbnRcbiAgICpcbiAgICogV2hlbiBhIGB1aS12aWV3YCBjb21wb25lbnQgaXMgY3JlYXRlZCwgaXQgdXNlcyB0aGlzIG1ldGhvZCB0byByZWdpc3RlciBpdHNlbGYuXG4gICAqIEFmdGVyIHJlZ2lzdHJhdGlvbiB0aGUgW1tzeW5jXV0gbWV0aG9kIGlzIHVzZWQgdG8gZW5zdXJlIGFsbCBgdWktdmlld2AgYXJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgcHJvcGVyIFtbVmlld0NvbmZpZ11dLlxuICAgKlxuICAgKiBOb3RlOiB0aGUgYHVpLXZpZXdgIGNvbXBvbmVudCB1c2VzIHRoZSBgVmlld0NvbmZpZ2AgdG8gZGV0ZXJtaW5lIHdoYXQgdmlldyBzaG91bGQgYmUgbG9hZGVkIGluc2lkZSB0aGUgYHVpLXZpZXdgLFxuICAgKiBhbmQgd2hhdCB0aGUgdmlldydzIHN0YXRlIGNvbnRleHQgaXMuXG4gICAqXG4gICAqIE5vdGU6IFRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgYGRlcmVnaXN0ZXJVSVZpZXdgLlxuICAgKiAgICAgICBBIGB1aS12aWV3YCBzaG91bGQgaGFuZyBvbiB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIGByZWdpc3RlclVJVmlld2AgYW5kIGludm9rZSBpdCB0byBkZXJlZ2lzdGVyIGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHVpVmlldyBUaGUgbWV0YWRhdGEgZm9yIGEgVUlWaWV3XG4gICAqIEByZXR1cm4gYSBkZS1yZWdpc3RyYXRpb24gZnVuY3Rpb24gdXNlZCB3aGVuIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICovXG4gIHJlZ2lzdGVyVUlWaWV3KHVpVmlldzogQWN0aXZlVUlWaWV3KSB7XG4gICAgdHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KCctPiBSZWdpc3RlcmluZycsIHVpVmlldyk7XG4gICAgY29uc3QgdWlWaWV3cyA9IHRoaXMuX3VpVmlld3M7XG4gICAgY29uc3QgZnFuQW5kVHlwZU1hdGNoZXMgPSAodWl2OiBBY3RpdmVVSVZpZXcpID0+IHVpdi5mcW4gPT09IHVpVmlldy5mcW4gJiYgdWl2LiR0eXBlID09PSB1aVZpZXcuJHR5cGU7XG4gICAgaWYgKHVpVmlld3MuZmlsdGVyKGZxbkFuZFR5cGVNYXRjaGVzKS5sZW5ndGgpXG4gICAgICB0cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoJyEhISEgZHVwbGljYXRlIHVpVmlldyBuYW1lZDonLCB1aVZpZXcpO1xuXG4gICAgdWlWaWV3cy5wdXNoKHVpVmlldyk7XG4gICAgdGhpcy5zeW5jKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gdWlWaWV3cy5pbmRleE9mKHVpVmlldyk7XG4gICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICB0cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoJ1RyaWVkIHJlbW92aW5nIG5vbi1yZWdpc3RlcmVkIHVpVmlldycsIHVpVmlldyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCgnPC0gRGVyZWdpc3RlcmluZycsIHVpVmlldyk7XG4gICAgICByZW1vdmVGcm9tKHVpVmlld3MpKHVpVmlldyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZpZXdzIGN1cnJlbnRseSBhdmFpbGFibGUgb24gdGhlIHBhZ2UsIGJ5IGZ1bGx5LXF1YWxpZmllZCBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICovXG4gIGF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5tYXAocHJvcCgnZnFuJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3Mgb24gdGhlIHBhZ2UgY29udGFpbmluZyBsb2FkZWQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZnVsbHktcXVhbGlmaWVkIHZpZXcgbmFtZXMuXG4gICAqL1xuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpVmlld3MuZmlsdGVyKHByb3AoJyRjb25maWcnKSkubWFwKHByb3AoJ25hbWUnKSk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgY29yZSAqLyAvKiogKi9cbmltcG9ydCB7IFN0YXRlUGFyYW1zIH0gZnJvbSAnLi9wYXJhbXMvc3RhdGVQYXJhbXMnO1xuaW1wb3J0IHsgU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4vc3RhdGUvaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi9zdGF0ZS9zdGF0ZU9iamVjdCc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgUXVldWUgfSBmcm9tICcuL2NvbW1vbi9xdWV1ZSc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEdsb2JhbCByb3V0ZXIgc3RhdGVcbiAqXG4gKiBUaGlzIGlzIHdoZXJlIHdlIGhvbGQgdGhlIGdsb2JhbCBtdXRhYmxlIHN0YXRlIHN1Y2ggYXMgY3VycmVudCBzdGF0ZSwgY3VycmVudFxuICogcGFyYW1zLCBjdXJyZW50IHRyYW5zaXRpb24sIGV0Yy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVJUm91dGVyR2xvYmFscyBpbXBsZW1lbnRzIERpc3Bvc2FibGUge1xuICAvKipcbiAgICogQ3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqXG4gICAqIFRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gdGhlIGxhdGVzdCBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAgICovXG4gIHBhcmFtczogU3RhdGVQYXJhbXMgPSBuZXcgU3RhdGVQYXJhbXMoKTtcblxuICAvKipcbiAgICogQ3VycmVudCBzdGF0ZVxuICAgKlxuICAgKiBUaGUgdG8tc3RhdGUgZnJvbSB0aGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgKi9cbiAgY3VycmVudDogU3RhdGVEZWNsYXJhdGlvbjtcblxuICAvKipcbiAgICogQ3VycmVudCBzdGF0ZSAoaW50ZXJuYWwgb2JqZWN0KVxuICAgKlxuICAgKiBUaGUgdG8tc3RhdGUgZnJvbSB0aGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICovXG4gICRjdXJyZW50OiBTdGF0ZU9iamVjdDtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhcnRlZC9ydW5uaW5nIHRyYW5zaXRpb24uXG4gICAqIFRoaXMgdHJhbnNpdGlvbiBoYXMgcmVhY2hlZCBhdCBsZWFzdCB0aGUgb25TdGFydCBwaGFzZSwgYnV0IGlzIG5vdCB5ZXQgY29tcGxldGVcbiAgICovXG4gIHRyYW5zaXRpb246IFRyYW5zaXRpb247XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBsYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IC0xO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgdHJhbnNpdGlvbkhpc3RvcnkgPSBuZXcgUXVldWU8VHJhbnNpdGlvbj4oW10sIDEpO1xuXG4gIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgc3VjY2Vzc2Z1bFRyYW5zaXRpb25zID0gbmV3IFF1ZXVlPFRyYW5zaXRpb24+KFtdLCAxKTtcblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkuY2xlYXIoKTtcbiAgICB0aGlzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMudHJhbnNpdGlvbiA9IG51bGw7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdXJsICovIC8qKiAqL1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBNYXRjaGVyVXJsUnVsZSwgVXJsUnVsZSwgVXJsUnVsZUhhbmRsZXJGbiwgVXJsUnVsZU1hdGNoRm4sIFVybFJ1bGVzQXBpIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUsIFRhcmdldFN0YXRlRGVmIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgVXJsTWF0Y2hlciB9IGZyb20gJy4vdXJsTWF0Y2hlcic7XG5pbXBvcnQgeyBpcywgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgcmVtb3ZlRnJvbSwgdmFsIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IFVybFJ1bGVGYWN0b3J5IH0gZnJvbSAnLi91cmxSdWxlJztcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHByaW9yaXR5U29ydCA9IChhOiBVcmxSdWxlLCBiOiBVcmxSdWxlKSA9PiAoYi5wcmlvcml0eSB8fCAwKSAtIChhLnByaW9yaXR5IHx8IDApO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgdHlwZVNvcnQgPSAoYTogVXJsUnVsZSwgYjogVXJsUnVsZSkgPT4ge1xuICBjb25zdCB3ZWlnaHRzID0geyBTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxIH07XG4gIHJldHVybiAod2VpZ2h0c1thLnR5cGVdIHx8IDApIC0gKHdlaWdodHNbYi50eXBlXSB8fCAwKTtcbn07XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCB1cmxNYXRjaGVyU29ydCA9IChhOiBNYXRjaGVyVXJsUnVsZSwgYjogTWF0Y2hlclVybFJ1bGUpID0+XG4gICFhLnVybE1hdGNoZXIgfHwgIWIudXJsTWF0Y2hlciA/IDAgOiBVcmxNYXRjaGVyLmNvbXBhcmUoYS51cmxNYXRjaGVyLCBiLnVybE1hdGNoZXIpO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgaWRTb3J0ID0gKGE6IFVybFJ1bGUsIGI6IFVybFJ1bGUpID0+IHtcbiAgLy8gSWRlbnRpY2FsbHkgc29ydGVkIFNUQVRFIGFuZCBVUkxNQVRDSEVSIGJlc3QgcnVsZSB3aWxsIGJlIGNob3NlbiBieSBgbWF0Y2hQcmlvcml0eWAgYWZ0ZXIgZWFjaCBydWxlIG1hdGNoZXMgdGhlIFVSTFxuICBjb25zdCB1c2VNYXRjaFByaW9yaXR5ID0geyBTVEFURTogdHJ1ZSwgVVJMTUFUQ0hFUjogdHJ1ZSB9O1xuICBjb25zdCBlcXVhbCA9IHVzZU1hdGNoUHJpb3JpdHlbYS50eXBlXSAmJiB1c2VNYXRjaFByaW9yaXR5W2IudHlwZV07XG4gIHJldHVybiBlcXVhbCA/IDAgOiAoYS4kaWQgfHwgMCkgLSAoYi4kaWQgfHwgMCk7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgcnVsZSBwcmlvcml0eSBzb3J0aW5nIGZ1bmN0aW9uLlxuICpcbiAqIFNvcnRzIHJ1bGVzIGJ5OlxuICpcbiAqIC0gRXhwbGljaXQgcHJpb3JpdHkgKHNldCBydWxlIHByaW9yaXR5IHVzaW5nIFtbVXJsUnVsZXMud2hlbl1dKVxuICogLSBSdWxlIHR5cGUgKFNUQVRFOiA0LCBVUkxNQVRDSEVSOiA0LCBSRUdFWFA6IDMsIFJBVzogMiwgT1RIRVI6IDEpXG4gKiAtIGBVcmxNYXRjaGVyYCBzcGVjaWZpY2l0eSAoW1tVcmxNYXRjaGVyLmNvbXBhcmVdXSk6IHdvcmtzIGZvciBTVEFURSBhbmQgVVJMTUFUQ0hFUiB0eXBlcyB0byBwaWNrIHRoZSBtb3N0IHNwZWNpZmljIHJ1bGUuXG4gKiAtIFJ1bGUgcmVnaXN0cmF0aW9uIG9yZGVyIChmb3IgcnVsZSB0eXBlcyBvdGhlciB0aGFuIFNUQVRFIGFuZCBVUkxNQVRDSEVSKVxuICogICAtIEVxdWFsbHkgc29ydGVkIFN0YXRlIGFuZCBVcmxNYXRjaGVyIHJ1bGVzIHdpbGwgZWFjaCBtYXRjaCB0aGUgVVJMLlxuICogICAgIFRoZW4sIHRoZSAqYmVzdCogbWF0Y2ggaXMgY2hvc2VuIGJhc2VkIG9uIGhvdyBtYW55IHBhcmFtZXRlciB2YWx1ZXMgd2VyZSBtYXRjaGVkLlxuICpcbiAqIEBwdWJsaWNhcGlcbiAqL1xubGV0IGRlZmF1bHRSdWxlU29ydEZuOiAoYTogVXJsUnVsZSwgYjogVXJsUnVsZSkgPT4gbnVtYmVyO1xuZGVmYXVsdFJ1bGVTb3J0Rm4gPSAoYSwgYikgPT4ge1xuICBsZXQgY21wID0gcHJpb3JpdHlTb3J0KGEsIGIpO1xuICBpZiAoY21wICE9PSAwKSByZXR1cm4gY21wO1xuXG4gIGNtcCA9IHR5cGVTb3J0KGEsIGIpO1xuICBpZiAoY21wICE9PSAwKSByZXR1cm4gY21wO1xuXG4gIGNtcCA9IHVybE1hdGNoZXJTb3J0KGEgYXMgTWF0Y2hlclVybFJ1bGUsIGIgYXMgTWF0Y2hlclVybFJ1bGUpO1xuICBpZiAoY21wICE9PSAwKSByZXR1cm4gY21wO1xuXG4gIHJldHVybiBpZFNvcnQoYSwgYik7XG59O1xuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0SGFuZGxlckZuKGhhbmRsZXI6IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm4gfCBUYXJnZXRTdGF0ZSB8IFRhcmdldFN0YXRlRGVmKTogVXJsUnVsZUhhbmRsZXJGbiB7XG4gIGlmICghaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhaXNTdHJpbmcoaGFuZGxlcikgJiYgIWlzKFRhcmdldFN0YXRlKShoYW5kbGVyKSAmJiAhVGFyZ2V0U3RhdGUuaXNEZWYoaGFuZGxlcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInaGFuZGxlcicgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIFRhcmdldFN0YXRlLCBvciBoYXZlIGEgc3RhdGU6ICduZXd0YXJnZXQnIHByb3BlcnR5XCIpO1xuICB9XG4gIHJldHVybiBpc0Z1bmN0aW9uKGhhbmRsZXIpID8gKGhhbmRsZXIgYXMgVXJsUnVsZUhhbmRsZXJGbikgOiB2YWwoaGFuZGxlcik7XG59XG5cbi8qKlxuICogQVBJIGZvciBtYW5hZ2luZyBVUkwgcnVsZXNcbiAqXG4gKiBUaGlzIEFQSSBpcyB1c2VkIHRvIGNyZWF0ZSBhbmQgbWFuYWdlIFVSTCBydWxlcy5cbiAqIFVSTCBydWxlcyBhcmUgYSBtZWNoYW5pc20gdG8gcmVzcG9uZCB0byBzcGVjaWZpYyBVUkwgcGF0dGVybnMuXG4gKlxuICogVGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFyZSBbW290aGVyd2lzZV1dIGFuZCBbW3doZW5dXS5cbiAqXG4gKiBUaGlzIEFQSSBpcyBhIHByb3BlcnR5IG9mIFtbVXJsU2VydmljZV1dIGFzIFtbVXJsU2VydmljZS5ydWxlc11dXG4gKlxuICogQHB1YmxpY2FwaVxuICovXG5leHBvcnQgY2xhc3MgVXJsUnVsZXMgaW1wbGVtZW50cyBEaXNwb3NhYmxlIHtcbiAgLyoqIHVzZWQgdG8gY3JlYXRlIFtbVXJsUnVsZV1dIG9iamVjdHMgZm9yIGNvbW1vbiBjYXNlcyAqL1xuICBwdWJsaWMgdXJsUnVsZUZhY3Rvcnk6IFVybFJ1bGVGYWN0b3J5O1xuXG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3NvcnRGbiA9IGRlZmF1bHRSdWxlU29ydEZuO1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9vdGhlcndpc2VGbjogVXJsUnVsZTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfc29ydGVkOiBib29sZWFuO1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9ydWxlczogVXJsUnVsZVtdID0gW107XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX2lkID0gMDtcblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3RvcigvKiogQGhpZGRlbiAqLyBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICB0aGlzLnVybFJ1bGVGYWN0b3J5ID0gbmV3IFVybFJ1bGVGYWN0b3J5KHJvdXRlcik7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBwdWJsaWMgZGlzcG9zZShyb3V0ZXI/OiBVSVJvdXRlcikge1xuICAgIHRoaXMuX3J1bGVzID0gW107XG4gICAgZGVsZXRlIHRoaXMuX290aGVyd2lzZUZuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIGluaXRpYWwgc3RhdGUsIHBhdGgsIG9yIGJlaGF2aW9yIHRvIHVzZSB3aGVuIHRoZSBhcHAgc3RhcnRzLlxuICAgKlxuICAgKiBUaGlzIHJ1bGUgZGVmaW5lcyB0aGUgaW5pdGlhbC9zdGFydGluZyBzdGF0ZSBmb3IgdGhlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBUaGlzIHJ1bGUgaXMgdHJpZ2dlcmVkIHRoZSBmaXJzdCB0aW1lIHRoZSBVUkwgaXMgY2hlY2tlZCAod2hlbiB0aGUgYXBwIGluaXRpYWxseSBsb2FkcykuXG4gICAqIFRoZSBydWxlIGlzIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIHVybCBtYXRjaGVzIGVpdGhlciBgXCJcImAgb3IgYFwiL1wiYC5cbiAgICpcbiAgICogTm90ZTogVGhlIHJ1bGUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aGVuIHRoZSByb290IG9mIHRoZSBhcHBsaWNhdGlvbiBpcyBkaXJlY3RseSBsaW5rZWQgdG8uXG4gICAqIFdoZW4gdGhlIFVSTCBpcyAqbm90KiBgXCJcImAgb3IgYFwiL1wiYCBhbmQgZG9lc24ndCBtYXRjaCBvdGhlciBydWxlcywgdGhlIFtbb3RoZXJ3aXNlXV0gcnVsZSBpcyB0cmlnZ2VyZWQuXG4gICAqIFRoaXMgYWxsb3dzIDQwNC1saWtlIGJlaGF2aW9yIHdoZW4gYW4gdW5rbm93biBVUkwgaXMgZGVlcC1saW5rZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogU3RhcnQgYXBwIGF0IGBob21lYCBzdGF0ZS5cbiAgICogYGBganNcbiAgICogLmluaXRpYWwoeyBzdGF0ZTogJ2hvbWUnIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBTdGFydCBhcHAgYXQgYC9ob21lYCAoYnkgdXJsKVxuICAgKiBgYGBqc1xuICAgKiAuaW5pdGlhbCgnL2hvbWUnKTtcbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogV2hlbiBubyBvdGhlciB1cmwgcnVsZSBtYXRjaGVzLCBnbyB0byBgaG9tZWAgc3RhdGVcbiAgICogYGBganNcbiAgICogLmluaXRpYWwoKG1hdGNoVmFsdWUsIHVybCwgcm91dGVyKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coJ2luaXRpYWwgc3RhdGUnKTtcbiAgICogICByZXR1cm4geyBzdGF0ZTogJ2hvbWUnIH07XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlciBUaGUgaW5pdGlhbCBzdGF0ZSBvciB1cmwgcGF0aCwgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBzdGF0ZSBvciB1cmwgcGF0aCAob3IgcGVyZm9ybXMgY3VzdG9tIGxvZ2ljKS5cbiAgICovXG4gIHB1YmxpYyBpbml0aWFsKGhhbmRsZXI6IHN0cmluZyB8IFVybFJ1bGVIYW5kbGVyRm4gfCBUYXJnZXRTdGF0ZSB8IFRhcmdldFN0YXRlRGVmKSB7XG4gICAgY29uc3QgaGFuZGxlckZuOiBVcmxSdWxlSGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgIGNvbnN0IG1hdGNoRm46IFVybFJ1bGVNYXRjaEZuID0gKHVybFBhcnRzLCByb3V0ZXIpID0+XG4gICAgICByb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5zaXplKCkgPT09IDAgJiYgISEvXlxcLz8kLy5leGVjKHVybFBhcnRzLnBhdGgpO1xuXG4gICAgdGhpcy5ydWxlKHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoRm4sIGhhbmRsZXJGbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIHN0YXRlLCB1cmwsIG9yIGJlaGF2aW9yIHRvIHVzZSB3aGVuIG5vIG90aGVyIHJ1bGUgbWF0Y2hlcyB0aGUgVVJMLlxuICAgKlxuICAgKiBUaGlzIHJ1bGUgaXMgbWF0Y2hlZCB3aGVuICpubyBvdGhlciBydWxlKiBtYXRjaGVzLlxuICAgKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCB0byBoYW5kbGUgdW5rbm93biBVUkxzIChzaW1pbGFyIHRvIFwiNDA0XCIgYmVoYXZpb3IsIGJ1dCBvbiB0aGUgY2xpZW50IHNpZGUpLlxuICAgKlxuICAgKiAtIElmIGBoYW5kbGVyYCBhIHN0cmluZywgaXQgaXMgdHJlYXRlZCBhcyBhIHVybCByZWRpcmVjdFxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFdoZW4gbm8gb3RoZXIgdXJsIHJ1bGUgbWF0Y2hlcywgcmVkaXJlY3QgdG8gYC9pbmRleGBcbiAgICogYGBganNcbiAgICogLm90aGVyd2lzZSgnL2luZGV4Jyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAtIElmIGBoYW5kbGVyYCBpcyBhbiBvYmplY3Qgd2l0aCBhIGBzdGF0ZWAgcHJvcGVydHksIHRoZSBzdGF0ZSBpcyBhY3RpdmF0ZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogV2hlbiBubyBvdGhlciB1cmwgcnVsZSBtYXRjaGVzLCByZWRpcmVjdCB0byBgaG9tZWAgYW5kIHByb3ZpZGUgYSBgZGFzaGJvYXJkYCBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqIGBgYGpzXG4gICAqIC5vdGhlcndpc2UoeyBzdGF0ZTogJ2hvbWUnLCBwYXJhbXM6IHsgZGFzaGJvYXJkOiAnZGVmYXVsdCcgfSB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIC0gSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgY3VycmVudCB1cmwgKFtbVXJsUGFydHNdXSkgYW5kIHRoZSBbW1VJUm91dGVyXV0gb2JqZWN0LlxuICAgKiAgIFRoZSBmdW5jdGlvbiBjYW4gcGVyZm9ybSBhY3Rpb25zLCBhbmQvb3IgcmV0dXJuIGEgdmFsdWUuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogV2hlbiBubyBvdGhlciB1cmwgcnVsZSBtYXRjaGVzLCBtYW51YWxseSB0cmlnZ2VyIGEgdHJhbnNpdGlvbiB0byB0aGUgYGhvbWVgIHN0YXRlXG4gICAqIGBgYGpzXG4gICAqIC5vdGhlcndpc2UoKG1hdGNoVmFsdWUsIHVybFBhcnRzLCByb3V0ZXIpID0+IHtcbiAgICogICByb3V0ZXIuc3RhdGVTZXJ2aWNlLmdvKCdob21lJyk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBXaGVuIG5vIG90aGVyIHVybCBydWxlIG1hdGNoZXMsIGdvIHRvIGBob21lYCBzdGF0ZVxuICAgKiBgYGBqc1xuICAgKiAub3RoZXJ3aXNlKChtYXRjaFZhbHVlLCB1cmxQYXJ0cywgcm91dGVyKSA9PiB7XG4gICAqICAgcmV0dXJuIHsgc3RhdGU6ICdob21lJyB9O1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGVyIFRoZSB1cmwgcGF0aCB0byByZWRpcmVjdCB0bywgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSB1cmwgcGF0aCAob3IgcGVyZm9ybXMgY3VzdG9tIGxvZ2ljKS5cbiAgICovXG4gIHB1YmxpYyBvdGhlcndpc2UoaGFuZGxlcjogc3RyaW5nIHwgVXJsUnVsZUhhbmRsZXJGbiB8IFRhcmdldFN0YXRlIHwgVGFyZ2V0U3RhdGVEZWYpIHtcbiAgICBjb25zdCBoYW5kbGVyRm46IFVybFJ1bGVIYW5kbGVyRm4gPSBnZXRIYW5kbGVyRm4oaGFuZGxlcik7XG5cbiAgICB0aGlzLl9vdGhlcndpc2VGbiA9IHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKHZhbCh0cnVlKSwgaGFuZGxlckZuKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBydWxlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZFxuICAgKlxuICAgKiBAcGFyYW0gcnVsZSB0aGUgbWF0Y2hlciBydWxlIHRoYXQgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB1c2luZyBbW3J1bGVdXVxuICAgKi9cbiAgcHVibGljIHJlbW92ZVJ1bGUocnVsZSk6IHZvaWQge1xuICAgIHJlbW92ZUZyb20odGhpcy5fcnVsZXMsIHJ1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGFkZHMgYSBVUkwgUnVsZS5cbiAgICpcbiAgICogVXN1YWxseSwgYSB1cmwgcnVsZSBpcyBhZGRlZCB1c2luZyBbW1N0YXRlRGVjbGFyYXRpb24udXJsXV0gb3IgW1t3aGVuXV0uXG4gICAqIFRoaXMgYXBpIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGZvciBtb3JlIGNvbnRyb2wgKHRvIHJlZ2lzdGVyIGEgW1tCYXNlVXJsUnVsZV1dLCBmb3IgZXhhbXBsZSkuXG4gICAqIFJ1bGVzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIFtbdXJsUnVsZUZhY3RvcnldXSwgb3IgY3JlYXRlZCBtYW51YWxseSBhcyBzaW1wbGUgb2JqZWN0cy5cbiAgICpcbiAgICogQSBydWxlIHNob3VsZCBoYXZlIGEgYG1hdGNoYCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRydXRoeSBpZiB0aGUgcnVsZSBtYXRjaGVkLlxuICAgKiBJdCBzaG91bGQgYWxzbyBoYXZlIGEgYGhhbmRsZXJgIGZ1bmN0aW9uIHdoaWNoIGlzIGludm9rZWQgaWYgdGhlIHJ1bGUgaXMgdGhlIGJlc3QgbWF0Y2guXG4gICAqXG4gICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBydWxlXG4gICAqL1xuICBwdWJsaWMgcnVsZShydWxlOiBVcmxSdWxlKTogRnVuY3Rpb24ge1xuICAgIGlmICghVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlKHJ1bGUpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcnVsZScpO1xuICAgIHJ1bGUuJGlkID0gdGhpcy5faWQrKztcbiAgICBydWxlLnByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSB8fCAwO1xuXG4gICAgdGhpcy5fcnVsZXMucHVzaChydWxlKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZVJ1bGUocnVsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgcmVnaXN0ZXJlZCBydWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIHJlZ2lzdGVyZWQgcnVsZXNcbiAgICovXG4gIHB1YmxpYyBydWxlcygpOiBVcmxSdWxlW10ge1xuICAgIHRoaXMuZW5zdXJlU29ydGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVzLmNvbmNhdCh0aGlzLl9vdGhlcndpc2VGbiA/IFt0aGlzLl9vdGhlcndpc2VGbl0gOiBbXSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBVUkwgUnVsZSBwcmlvcml0aWVzXG4gICAqXG4gICAqIE1vcmUgdGhhbiBvbmUgcnVsZSAoW1tVcmxSdWxlXV0pIG1pZ2h0IG1hdGNoIGEgZ2l2ZW4gVVJMLlxuICAgKiBUaGlzIGBjb21wYXJlRm5gIGlzIHVzZWQgdG8gc29ydCB0aGUgcnVsZXMgYnkgcHJpb3JpdHkuXG4gICAqIEhpZ2hlciBwcmlvcml0eSBydWxlcyBzaG91bGQgc29ydCBlYXJsaWVyLlxuICAgKlxuICAgKiBUaGUgW1tkZWZhdWx0UnVsZVNvcnRGbl1dIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogWW91IG9ubHkgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gb25jZS5cbiAgICogVGhlIGBjb21wYXJlRm5gIHdpbGwgYmUgdXNlZCB0byBzb3J0IHRoZSBydWxlcyBhcyBlYWNoIGlzIHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIElmIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIsIGl0IHdpbGwgcmUtc29ydCB0aGUgcnVsZXMuXG4gICAqXG4gICAqIC0tLVxuICAgKlxuICAgKiBVcmwgcnVsZXMgbWF5IGNvbWUgZnJvbSBtdWx0aXBsZSBzb3VyY2VzOiBzdGF0ZXMncyB1cmxzIChbW1N0YXRlRGVjbGFyYXRpb24udXJsXV0pLCBbW3doZW5dXSwgYW5kIFtbcnVsZV1dLlxuICAgKiBFYWNoIHJ1bGUgaGFzIGEgKHVzZXItcHJvdmlkZWQpIFtbVXJsUnVsZS5wcmlvcml0eV1dLCBhIFtbVXJsUnVsZS50eXBlXV0sIGFuZCBhIFtbVXJsUnVsZS4kaWRdXVxuICAgKiBUaGUgYCRpZGAgaXMgaXMgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBydWxlIHdhcyByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBUaGUgc29ydCBmdW5jdGlvbiBzaG91bGQgdXNlIHRoZXNlIGRhdGEsIG9yIGRhdGEgZm91bmQgb24gYSBzcGVjaWZpYyB0eXBlXG4gICAqIG9mIFtbVXJsUnVsZV1dIChzdWNoIGFzIFtbU3RhdGVSdWxlLnN0YXRlXV0pLCB0byBvcmRlciB0aGUgcnVsZXMgYXMgZGVzaXJlZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBUaGlzIGNvbXBhcmUgZnVuY3Rpb24gcHJpb3JpdGl6ZXMgcnVsZXMgYnkgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBydWxlcyB3ZXJlIHJlZ2lzdGVyZWQuXG4gICAqIEEgcnVsZSByZWdpc3RlcmVkIGVhcmxpZXIgaGFzIGhpZ2hlciBwcmlvcml0eS5cbiAgICpcbiAgICogYGBganNcbiAgICogZnVuY3Rpb24gY29tcGFyZUZuKGEsIGIpIHtcbiAgICogICByZXR1cm4gYS4kaWQgLSBiLiRpZDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNvbXBhcmVGbiBhIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgdG8gW1tVcmxSdWxlXV0gb2JqZWN0cy5cbiAgICogICAgVGhlIGBjb21wYXJlRm5gIHNob3VsZCBhYmlkZSBieSB0aGUgYEFycmF5LnNvcnRgIGNvbXBhcmUgZnVuY3Rpb24gcnVsZXMuXG4gICAqICAgIEdpdmVuIHR3byBydWxlcywgYGFgIGFuZCBgYmAsIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciBpZiBgYWAgc2hvdWxkIGJlIGhpZ2hlciBwcmlvcml0eS5cbiAgICogICAgUmV0dXJuIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGBiYCBzaG91bGQgYmUgaGlnaGVyIHByaW9yaXR5LlxuICAgKiAgICBSZXR1cm4gYDBgIGlmIHRoZSBydWxlcyBhcmUgaWRlbnRpY2FsLlxuICAgKlxuICAgKiAgICBTZWUgdGhlIFttb3ppbGxhIHJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNEZXNjcmlwdGlvbilcbiAgICogICAgZm9yIGRldGFpbHMuXG4gICAqL1xuICBzb3J0KGNvbXBhcmVGbj86IChhOiBVcmxSdWxlLCBiOiBVcmxSdWxlKSA9PiBudW1iZXIpIHtcbiAgICBjb25zdCBzb3J0ZWQgPSB0aGlzLnN0YWJsZVNvcnQodGhpcy5fcnVsZXMsICh0aGlzLl9zb3J0Rm4gPSBjb21wYXJlRm4gfHwgdGhpcy5fc29ydEZuKSk7XG5cbiAgICAvLyBwcmVjb21wdXRlIF9zb3J0R3JvdXAgdmFsdWVzIGFuZCBhcHBseSB0byBlYWNoIHJ1bGVcbiAgICBsZXQgZ3JvdXAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3J0ZWRbaV0uX2dyb3VwID0gZ3JvdXA7XG4gICAgICBpZiAoaSA8IHNvcnRlZC5sZW5ndGggLSAxICYmIHRoaXMuX3NvcnRGbihzb3J0ZWRbaV0sIHNvcnRlZFtpICsgMV0pICE9PSAwKSB7XG4gICAgICAgIGdyb3VwKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcnVsZXMgPSBzb3J0ZWQ7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgZW5zdXJlU29ydGVkKCkge1xuICAgIHRoaXMuX3NvcnRlZCB8fCB0aGlzLnNvcnQoKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgc3RhYmxlU29ydChhcnIsIGNvbXBhcmVGbikge1xuICAgIGNvbnN0IGFyck9mV3JhcHBlciA9IGFyci5tYXAoKGVsZW0sIGlkeCkgPT4gKHsgZWxlbSwgaWR4IH0pKTtcblxuICAgIGFyck9mV3JhcHBlci5zb3J0KCh3cmFwcGVyQSwgd3JhcHBlckIpID0+IHtcbiAgICAgIGNvbnN0IGNtcERpZmYgPSBjb21wYXJlRm4od3JhcHBlckEuZWxlbSwgd3JhcHBlckIuZWxlbSk7XG4gICAgICByZXR1cm4gY21wRGlmZiA9PT0gMCA/IHdyYXBwZXJBLmlkeCAtIHdyYXBwZXJCLmlkeCA6IGNtcERpZmY7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJyT2ZXcmFwcGVyLm1hcCh3cmFwcGVyID0+IHdyYXBwZXIuZWxlbSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgYG1hdGNoZXJgIGFuZCBgaGFuZGxlcmAgZm9yIGN1c3RvbSBVUkxzIGhhbmRsaW5nLlxuICAgKlxuICAgKiBUaGUgYG1hdGNoZXJgIGNhbiBiZTpcbiAgICpcbiAgICogLSBhIFtbVXJsTWF0Y2hlcl1dOiBTZWU6IFtbVXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZV1dXG4gICAqIC0gYSBgc3RyaW5nYDogVGhlIHN0cmluZyBpcyBjb21waWxlZCB0byBhIFtbVXJsTWF0Y2hlcl1dXG4gICAqIC0gYSBgUmVnRXhwYDogVGhlIHJlZ2V4cCBpcyB1c2VkIHRvIG1hdGNoIHRoZSB1cmwuXG4gICAqXG4gICAqIFRoZSBgaGFuZGxlcmAgY2FuIGJlOlxuICAgKlxuICAgKiAtIGEgc3RyaW5nOiBUaGUgdXJsIGlzIHJlZGlyZWN0ZWQgdG8gdGhlIHZhbHVlIG9mIHRoZSBzdHJpbmcuXG4gICAqIC0gYSBmdW5jdGlvbjogVGhlIHVybCBpcyByZWRpcmVjdGVkIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAtLS1cbiAgICpcbiAgICogV2hlbiB0aGUgYGhhbmRsZXJgIGlzIGEgYHN0cmluZ2AgYW5kIHRoZSBgbWF0Y2hlcmAgaXMgYSBgVXJsTWF0Y2hlcmAgKG9yIHN0cmluZyksIHRoZSByZWRpcmVjdFxuICAgKiBzdHJpbmcgaXMgaW50ZXJwb2xhdGVkIHdpdGggcGFyYW1ldGVyIHZhbHVlcy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBXaGVuIHRoZSBVUkwgaXMgYC9mb28vMTIzYCB0aGUgcnVsZSB3aWxsIHJlZGlyZWN0IHRvIGAvYmFyLzEyM2AuXG4gICAqIGBgYGpzXG4gICAqIC53aGVuKFwiL2Zvby86cGFyYW0xXCIsIFwiL2Jhci86cGFyYW0xXCIpXG4gICAqIGBgYFxuICAgKlxuICAgKiAtLS1cbiAgICpcbiAgICogV2hlbiB0aGUgYGhhbmRsZXJgIGlzIGEgc3RyaW5nIGFuZCB0aGUgYG1hdGNoZXJgIGlzIGEgYFJlZ0V4cGAsIHRoZSByZWRpcmVjdCBzdHJpbmcgaXNcbiAgICogaW50ZXJwb2xhdGVkIHdpdGggY2FwdHVyZSBncm91cHMgZnJvbSB0aGUgUmVnRXhwLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIFdoZW4gdGhlIFVSTCBpcyBgL2Zvby8xMjNgIHRoZSBydWxlIHdpbGwgcmVkaXJlY3QgdG8gYC9iYXIvMTIzYC5cbiAgICogYGBganNcbiAgICogLndoZW4obmV3IFJlZ0V4cChcIl4vZm9vLyguKikkXCIpLCBcIi9iYXIvJDFcIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiAtLS1cbiAgICpcbiAgICogV2hlbiB0aGUgaGFuZGxlciBpcyBhIGZ1bmN0aW9uLCBpdCByZWNlaXZlcyB0aGUgbWF0Y2hlZCB2YWx1ZSwgdGhlIGN1cnJlbnQgVVJMLCBhbmQgdGhlIGBVSVJvdXRlcmAgb2JqZWN0IChTZWUgW1tVcmxSdWxlSGFuZGxlckZuXV0pLlxuICAgKiBUaGUgXCJtYXRjaGVkIHZhbHVlXCIgZGlmZmVycyBiYXNlZCBvbiB0aGUgYG1hdGNoZXJgLlxuICAgKiBGb3IgW1tVcmxNYXRjaGVyXV1zLCBpdCB3aWxsIGJlIHRoZSBtYXRjaGVkIHN0YXRlIHBhcmFtcy5cbiAgICogRm9yIGBSZWdFeHBgLCBpdCB3aWxsIGJlIHRoZSBtYXRjaCBhcnJheSBmcm9tIGByZWdleHAuZXhlYygpYC5cbiAgICpcbiAgICogSWYgdGhlIGhhbmRsZXIgcmV0dXJucyBhIHN0cmluZywgdGhlIFVSTCBpcyByZWRpcmVjdGVkIHRvIHRoZSBzdHJpbmcuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogV2hlbiB0aGUgVVJMIGlzIGAvZm9vLzEyM2AgdGhlIHJ1bGUgd2lsbCByZWRpcmVjdCB0byBgL2Jhci8xMjNgLlxuICAgKiBgYGBqc1xuICAgKiAud2hlbihuZXcgUmVnRXhwKFwiXi9mb28vKC4qKSRcIiksIG1hdGNoID0+IFwiL2Jhci9cIiArIG1hdGNoWzFdKTtcbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGU6IHRoZSBgaGFuZGxlcmAgbWF5IGFsc28gaW52b2tlIGFyYml0cmFyeSBjb2RlLCBzdWNoIGFzIGAkc3RhdGUuZ28oKWBcbiAgICpcbiAgICogQHBhcmFtIG1hdGNoZXIgQSBwYXR0ZXJuIGBzdHJpbmdgIHRvIG1hdGNoLCBjb21waWxlZCBhcyBhIFtbVXJsTWF0Y2hlcl1dLCBvciBhIGBSZWdFeHBgLlxuICAgKiBAcGFyYW0gaGFuZGxlciBUaGUgcGF0aCB0byByZWRpcmVjdCB0bywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHBhdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIGB7IHByaW9yaXR5OiBudW1iZXIgfWBcbiAgICpcbiAgICogQHJldHVybiB0aGUgcmVnaXN0ZXJlZCBbW1VybFJ1bGVdXVxuICAgKi9cbiAgcHVibGljIHdoZW4oXG4gICAgbWF0Y2hlcjogUmVnRXhwIHwgVXJsTWF0Y2hlciB8IHN0cmluZyxcbiAgICBoYW5kbGVyOiBzdHJpbmcgfCBVcmxSdWxlSGFuZGxlckZuLFxuICAgIG9wdGlvbnM/OiB7IHByaW9yaXR5OiBudW1iZXIgfVxuICApOiBVcmxSdWxlIHtcbiAgICBjb25zdCBydWxlID0gdGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUobWF0Y2hlciwgaGFuZGxlcik7XG4gICAgaWYgKGlzRGVmaW5lZChvcHRpb25zICYmIG9wdGlvbnMucHJpb3JpdHkpKSBydWxlLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgICB0aGlzLnJ1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdXJsICovIC8qKiAqL1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBQYXJhbVR5cGVEZWZpbml0aW9uLCBQYXJhbVR5cGVzIH0gZnJvbSAnLi4vcGFyYW1zJztcbmltcG9ydCB7IGlzRGVmaW5lZCwgaXNTdHJpbmcgfSBmcm9tICcuLi9jb21tb24nO1xuXG4vKipcbiAqIEFuIEFQSSB0byBjdXN0b21pemUgdGhlIFVSTCBiZWhhdmlvciBhbmQgcmV0cmlldmUgVVJMIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBUaGlzIEFQSSBpcyB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2YgdGhlIFVSTC5cbiAqIFRoaXMgaW5jbHVkZXMgb3B0aW9uYWwgdHJhaWxpbmcgc2xhc2hlcyAoW1tzdHJpY3RNb2RlXV0pLCBjYXNlIHNlbnNpdGl2aXR5IChbW2Nhc2VJbnNlbnNpdGl2ZV1dKSxcbiAqIGFuZCBjdXN0b20gcGFyYW1ldGVyIGVuY29kaW5nIChjdXN0b20gW1t0eXBlXV0pLlxuICpcbiAqIEl0IGFsc28gaGFzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2NhdGlvbiAodXJsKSBjb25maWd1cmF0aW9uIHN1Y2ggYXMgW1twb3J0XV0gYW5kIFtbYmFzZUhyZWZdXS5cbiAqIFRoaXMgaW5mb3JtYXRpb24gY2FuIGJlIHVzZWQgdG8gYnVpbGQgYWJzb2x1dGUgVVJMcywgc3VjaCBhc1xuICogYGh0dHBzOi8vZXhhbXBsZS5jb206NDQzL2Jhc2VwYXRoL3N0YXRlL3N1YnN0YXRlP3BhcmFtMT1hI2hhc2h2YWx1ZWA7XG4gKlxuICogVGhpcyBBUEkgaXMgYSBwcm9wZXJ0eSBvZiBbW1VybFNlcnZpY2VdXSBhcyBbW1VybFNlcnZpY2UuY29uZmlnXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxDb25maWcgaW1wbGVtZW50cyBEaXNwb3NhYmxlIHtcbiAgLyoqIEBoaWRkZW4gKi8gcGFyYW1UeXBlcyA9IG5ldyBQYXJhbVR5cGVzKCk7XG4gIC8qKiBAaGlkZGVuICovIF9pc0Nhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAvKiogQGhpZGRlbiAqLyBfaXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgLyoqIEBoaWRkZW4gKi8gX2RlZmF1bHRTcXVhc2hQb2xpY3k6IGJvb2xlYW4gfCBzdHJpbmcgPSBmYWxzZTtcblxuICAvKiogQGhpZGRlbiAqLyBjb25zdHJ1Y3RvcigvKiogQGhpZGRlbiAqLyBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHt9XG4gIC8qKiBAaW50ZXJuYWxhcGkgKi8gcHVibGljIGRpc3Bvc2UgPSAoKSA9PiB0aGlzLnBhcmFtVHlwZXMuZGlzcG9zZSgpO1xuXG4gIC8vIERlbGVnYXRlIHRoZXNlIGNhbGxzIHRvIHRoZSBjdXJyZW50IExvY2F0aW9uQ29uZmlnIGltcGxlbWVudGF0aW9uXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGJhc2UgSHJlZiwgZS5nLiwgYGh0dHA6Ly9sb2NhbGhvc3QvYXBwcm9vdC9gXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGFwcGxpY2F0aW9uJ3MgYmFzZSBocmVmXG4gICAqL1xuICBwdWJsaWMgYmFzZUhyZWYgPSAoKTogc3RyaW5nID0+IHRoaXMucm91dGVyLmxvY2F0aW9uQ29uZmlnLmJhc2VIcmVmKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgaGFzaFByZWZpeFxuICAgKlxuICAgKiBUaGlzIG9ubHkgYXBwbGllcyB3aGVuIG5vdCBydW5uaW5nIGluIFtbaHRtbDVNb2RlXV0gKHB1c2hzdGF0ZSBtb2RlKVxuICAgKlxuICAgKiBJZiB0aGUgY3VycmVudCB1cmwgaXMgYGh0dHA6Ly9sb2NhbGhvc3QvYXBwIyEvdWlyb3V0ZXIvcGF0aC8jYW5jaG9yYCwgaXQgcmV0dXJucyBgIWAgd2hpY2ggaXMgdGhlIHByZWZpeCBmb3IgdGhlIFwiaGFzaGJhbmdcIiBwb3J0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBoYXNoIHByZWZpeFxuICAgKi9cblxuICBwdWJsaWMgaGFzaFByZWZpeCA9IChuZXdwcmVmaXg/OiBzdHJpbmcpOiBzdHJpbmcgPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25Db25maWcuaGFzaFByZWZpeChuZXdwcmVmaXgpO1xuICAvKipcbiAgICogR2V0cyB0aGUgaG9zdCwgZS5nLiwgYGxvY2FsaG9zdGBcbiAgICpcbiAgICogQHJldHVybiB0aGUgcHJvdG9jb2xcbiAgICovXG4gIHB1YmxpYyBob3N0ID0gKCk6IHN0cmluZyA9PiB0aGlzLnJvdXRlci5sb2NhdGlvbkNvbmZpZy5ob3N0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGVuIHJ1bm5pbmcgaW4gcHVzaHN0YXRlIG1vZGVcbiAgICpcbiAgICogQHJldHVybiB0cnVlIHdoZW4gcnVubmluZyBpbiBodG1sNSBtb2RlIChwdXNoc3RhdGUgbW9kZSkuXG4gICAqL1xuICBwdWJsaWMgaHRtbDVNb2RlID0gKCk6IGJvb2xlYW4gPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25Db25maWcuaHRtbDVNb2RlKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBvcnQsIGUuZy4sIGA4MGBcbiAgICpcbiAgICogQHJldHVybiB0aGUgcG9ydCBudW1iZXJcbiAgICovXG4gIHB1YmxpYyBwb3J0ID0gKCk6IG51bWJlciA9PiB0aGlzLnJvdXRlci5sb2NhdGlvbkNvbmZpZy5wb3J0KCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHByb3RvY29sLCBlLmcuLCBgaHR0cGBcbiAgICpcbiAgICogQHJldHVybiB0aGUgcHJvdG9jb2xcbiAgICovXG4gIHB1YmxpYyBwcm90b2NvbCA9ICgpOiBzdHJpbmcgPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25Db25maWcucHJvdG9jb2woKTtcblxuICAvKipcbiAgICogRGVmaW5lcyB3aGV0aGVyIFVSTCBtYXRjaGluZyBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUgKHRoZSBkZWZhdWx0IGJlaGF2aW9yKSwgb3Igbm90LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vIEFsbG93IGNhc2UgaW5zZW5zaXRpdmUgdXJsIG1hdGNoZXNcbiAgICogdXJsU2VydmljZS5jb25maWcuY2FzZUluc2Vuc2l0aXZlKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIGBmYWxzZWAgdG8gbWF0Y2ggVVJMIGluIGEgY2FzZSBzZW5zaXRpdmUgbWFubmVyOyBvdGhlcndpc2UgYHRydWVgO1xuICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBjYXNlSW5zZW5zaXRpdmVcbiAgICovXG4gIHB1YmxpYyBjYXNlSW5zZW5zaXRpdmUodmFsdWU/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSA9IGlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gZ2VuZXJhdGluZyBvciBtYXRjaGluZyBVUkxzIHdpdGggZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vIFJlbW92ZSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgdXJsXG4gICAqIHVybFNlcnZpY2UuY29uZmlnLmRlZmF1bHRTcXVhc2hQb2xpY3kodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBkZWZhdWx0IHBhcmFtZXRlciBVUkwgc3F1YXNoaW5nIGJlaGF2aW9yLlxuICAgKiAgICAtIGBub3NxdWFzaGA6IFdoZW4gZ2VuZXJhdGluZyBhbiBocmVmIHdpdGggYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSwgZG8gbm90IHNxdWFzaCB0aGUgcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlIFVSTFxuICAgKiAgICAtIGBzbGFzaGA6IFdoZW4gZ2VuZXJhdGluZyBhbiBocmVmIHdpdGggYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSwgc3F1YXNoIChyZW1vdmUpIHRoZSBwYXJhbWV0ZXIgdmFsdWUsIGFuZCwgaWYgdGhlXG4gICAqICAgICAgcGFyYW1ldGVyIGlzIHN1cnJvdW5kZWQgYnkgc2xhc2hlcywgc3F1YXNoIChyZW1vdmUpIG9uZSBzbGFzaCBmcm9tIHRoZSBVUkxcbiAgICogICAgLSBhbnkgb3RoZXIgc3RyaW5nLCBlLmcuIFwiflwiOiBXaGVuIGdlbmVyYXRpbmcgYW4gaHJlZiB3aXRoIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUsIHNxdWFzaCAocmVtb3ZlKVxuICAgKiAgICAgIHRoZSBwYXJhbWV0ZXIgdmFsdWUgZnJvbSB0aGUgVVJMIGFuZCByZXBsYWNlIGl0IHdpdGggdGhpcyBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGRlZmF1bHRTcXVhc2hQb2xpY3lcbiAgICovXG4gIHB1YmxpYyBkZWZhdWx0U3F1YXNoUG9saWN5KHZhbHVlPzogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmIChpc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSAmJiAhaXNTdHJpbmcodmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNxdWFzaCBwb2xpY3k6ICR7dmFsdWV9LiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIGFyYml0cmFyeS1zdHJpbmdgKTtcbiAgICByZXR1cm4gKHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3kgPSBpc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoZXRoZXIgVVJMcyBzaG91bGQgbWF0Y2ggdHJhaWxpbmcgc2xhc2hlcywgb3Igbm90ICh0aGUgZGVmYXVsdCBiZWhhdmlvcikuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogLy8gQWxsb3cgb3B0aW9uYWwgdHJhaWxpbmcgc2xhc2hlc1xuICAgKiB1cmxTZXJ2aWNlLmNvbmZpZy5zdHJpY3RNb2RlKGZhbHNlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBgZmFsc2VgIHRvIG1hdGNoIHRyYWlsaW5nIHNsYXNoZXMgaW4gVVJMcywgb3RoZXJ3aXNlIGB0cnVlYC5cbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2Ygc3RyaWN0TW9kZVxuICAgKi9cbiAgcHVibGljIHN0cmljdE1vZGUodmFsdWU/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLl9pc1N0cmljdE1vZGUgPSBpc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9pc1N0cmljdE1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIGN1c3RvbSBbW1BhcmFtVHlwZV1dIG9iamVjdFxuICAgKlxuICAgKiBBIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBVUkxzIHdpdGggdHlwZWQgcGFyYW1ldGVycyBvciBjdXN0b20gZW5jb2RpbmcvZGVjb2RpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTogUmVnaXN0ZXIgY3VzdG9tIHR5cGVzICpiZWZvcmUgdXNpbmcgdGhlbSogaW4gYSBzdGF0ZSBkZWZpbml0aW9uLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vIEVuY29kZSBvYmplY3QgcGFyYW1ldGVyIGFzIEpTT04gc3RyaW5nXG4gICAqIHVybFNlcnZpY2UuY29uZmlnLnR5cGUoJ215anNvbicsIHtcbiAgICogICBlbmNvZGU6IChvYmopID0+IEpTT04uc3RyaW5naWZ5KG9iaiksXG4gICAqICAgZGVjb2RlOiAoc3RyKSA9PiBKU09OLnBhcnNlKHN0ciksXG4gICAqICAgaXM6ICh2YWwpID0+IHR5cGVvZih2YWwpID09PSAnb2JqZWN0JyxcbiAgICogICBwYXR0ZXJuOiAvW14vXSsvLFxuICAgKiAgIGVxdWFsczogKGEsIGIpID0+IF8uaXNFcXVhbChhLCBiKSxcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gZm9yIG1vcmUgZXhhbXBsZXNcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIHR5cGUgbmFtZS5cbiAgICogQHBhcmFtIGRlZmluaXRpb24gVGhlIHR5cGUgZGVmaW5pdGlvbi4gU2VlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0gZGVmaW5pdGlvbkZuIEEgZnVuY3Rpb24gdGhhdCBpcyBpbmplY3RlZCBiZWZvcmUgdGhlIGFwcCBydW50aW1lIHN0YXJ0cy5cbiAgICogICAgICAgIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgYSBbW1BhcmFtVHlwZURlZmluaXRpb25dXS5cbiAgICogICAgICAgIFRoZSByZXN1bHQgaXMgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGBkZWZpbml0aW9uYC5cbiAgICogICAgICAgIFNlZSBbW1BhcmFtVHlwZV1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBpZiBvbmx5IHRoZSBgbmFtZWAgcGFyYW1ldGVyIHdhcyBzcGVjaWZpZWQ6IHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBbW1BhcmFtVHlwZV1dIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAqL1xuICB0eXBlKG5hbWU6IHN0cmluZywgZGVmaW5pdGlvbj86IFBhcmFtVHlwZURlZmluaXRpb24sIGRlZmluaXRpb25Gbj86ICgpID0+IFBhcmFtVHlwZURlZmluaXRpb24pIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5wYXJhbVR5cGVzLnR5cGUobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKTtcbiAgICByZXR1cm4gIWlzRGVmaW5lZChkZWZpbml0aW9uKSA/IHR5cGUgOiB0aGlzO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHVybCAqLyAvKiogKi9cbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IGV4dGVuZCwgaXMsIGlzU3RyaW5nLCBMb2NhdGlvblNlcnZpY2VzLCBwYXR0ZXJuIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IE1hdGNoUmVzdWx0LCBVcmxQYXJ0cywgVXJsUnVsZSwgVXJsU3luY0FwaSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFVybFJ1bGVzIH0gZnJvbSAnLi91cmxSdWxlcyc7XG5pbXBvcnQgeyBVcmxDb25maWcgfSBmcm9tICcuL3VybENvbmZpZyc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSwgVGFyZ2V0U3RhdGVEZWYgfSBmcm9tICcuLi9zdGF0ZSc7XG5cbi8qKiBBUEkgZm9yIFVSTCBtYW5hZ2VtZW50ICovXG5leHBvcnQgY2xhc3MgVXJsU2VydmljZSBpbXBsZW1lbnRzIExvY2F0aW9uU2VydmljZXMsIFVybFN5bmNBcGkge1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlIF9zdG9wTGlzdGVuaW5nRm46IEZ1bmN0aW9uO1xuICAvKiogQGhpZGRlbiAqLyBpbnRlcmNlcHREZWZlcnJlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmVzdGVkIFtbVXJsUnVsZXNdXSBBUEkgZm9yIG1hbmFnaW5nIFVSTCBydWxlcyBhbmQgcmV3cml0ZXNcbiAgICpcbiAgICogU2VlOiBbW1VybFJ1bGVzXV0gZm9yIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBydWxlcyA9IG5ldyBVcmxSdWxlcyh0aGlzLnJvdXRlcik7XG5cbiAgLyoqXG4gICAqIFRoZSBuZXN0ZWQgW1tVcmxDb25maWddXSBBUEkgdG8gY29uZmlndXJlIHRoZSBVUkwgYW5kIHJldHJpZXZlIFVSTCBpbmZvcm1hdGlvblxuICAgKlxuICAgKiBTZWU6IFtbVXJsQ29uZmlnXV0gZm9yIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBjb25maWcgPSBuZXcgVXJsQ29uZmlnKHRoaXMucm91dGVyKTtcblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3RvcigvKiogQGhpZGRlbiAqLyBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHt9XG4gIC8qKiBAaGlkZGVuICovXG4gIHB1YmxpYyBkaXNwb3NlKCkge1xuICAgIHRoaXMubGlzdGVuKGZhbHNlKTtcbiAgICAodGhpcy5ydWxlcyBhcyBVcmxSdWxlcykuZGlzcG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgVVJMIHBhcnRzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRpZmZlcmVudCBwYXJ0cyBvZiB0aGUgY3VycmVudCBVUkwgKHRoZSBbW3BhdGhdXSwgW1tzZWFyY2hdXSwgYW5kIFtbaGFzaF1dKSBhcyBhIFtbVXJsUGFydHNdXSBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgcGFydHMoKTogVXJsUGFydHMge1xuICAgIHJldHVybiB7IHBhdGg6IHRoaXMucGF0aCgpLCBzZWFyY2g6IHRoaXMuc2VhcmNoKCksIGhhc2g6IHRoaXMuaGFzaCgpIH07XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBiZXN0IHJ1bGUgZm9yIHRoZSBjdXJyZW50IFVSTFxuICAgKlxuICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgVVJMIGZvciBhIG1hdGNoaW5nIFtbVXJsUnVsZV1dLCB0aGVuIGludm9rZXMgdGhhdCBydWxlJ3MgaGFuZGxlci5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGludGVybmFsbHkgYW55IHRpbWUgdGhlIFVSTCBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogVGhpcyBlZmZlY3RpdmVseSBhY3RpdmF0ZXMgdGhlIHN0YXRlIChvciByZWRpcmVjdCwgZXRjKSB3aGljaCBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB1cmxTZXJ2aWNlLmRlZmVySW50ZXJjZXB0KCk7XG4gICAqXG4gICAqIGZldGNoKCcvc3RhdGVzLmpzb24nKS50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpLnRoZW4oZGF0YSA9PiB7XG4gICAqICAgZGF0YS5mb3JFYWNoKHN0YXRlID0+ICRzdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyKHN0YXRlKSk7XG4gICAqICAgdXJsU2VydmljZS5saXN0ZW4oKTtcbiAgICogICAvLyBGaW5kIHRoZSBtYXRjaGluZyBVUkwgYW5kIGludm9rZSB0aGUgaGFuZGxlci5cbiAgICogICB1cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIHN5bmMoZXZ0Pykge1xuICAgIGlmIChldnQgJiYgZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHVybFNlcnZpY2UsIHN0YXRlU2VydmljZSB9ID0gdGhpcy5yb3V0ZXI7XG5cbiAgICBjb25zdCB1cmw6IFVybFBhcnRzID0geyBwYXRoOiB1cmxTZXJ2aWNlLnBhdGgoKSwgc2VhcmNoOiB1cmxTZXJ2aWNlLnNlYXJjaCgpLCBoYXNoOiB1cmxTZXJ2aWNlLmhhc2goKSB9O1xuICAgIGNvbnN0IGJlc3QgPSB0aGlzLm1hdGNoKHVybCk7XG5cbiAgICBjb25zdCBhcHBseVJlc3VsdCA9IHBhdHRlcm4oW1xuICAgICAgW2lzU3RyaW5nLCAobmV3dXJsOiBzdHJpbmcpID0+IHVybFNlcnZpY2UudXJsKG5ld3VybCwgdHJ1ZSldLFxuICAgICAgW1RhcmdldFN0YXRlLmlzRGVmLCAoZGVmOiBUYXJnZXRTdGF0ZURlZikgPT4gc3RhdGVTZXJ2aWNlLmdvKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpXSxcbiAgICAgIFtpcyhUYXJnZXRTdGF0ZSksICh0YXJnZXQ6IFRhcmdldFN0YXRlKSA9PiBzdGF0ZVNlcnZpY2UuZ28odGFyZ2V0LnN0YXRlKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSldLFxuICAgIF0pO1xuXG4gICAgYXBwbHlSZXN1bHQoYmVzdCAmJiBiZXN0LnJ1bGUuaGFuZGxlcihiZXN0Lm1hdGNoLCB1cmwsIHRoaXMucm91dGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIG9yIHN0b3BzIGxpc3RlbmluZyBmb3IgVVJMIGNoYW5nZXNcbiAgICpcbiAgICogQ2FsbCB0aGlzIHNvbWV0aW1lIGFmdGVyIGNhbGxpbmcgW1tkZWZlckludGVyY2VwdF1dIHRvIHN0YXJ0IG1vbml0b3JpbmcgdGhlIHVybC5cbiAgICogVGhpcyBjYXVzZXMgVUktUm91dGVyIHRvIHN0YXJ0IGxpc3RlbmluZyBmb3IgY2hhbmdlcyB0byB0aGUgVVJMLCBpZiBpdCB3YXNuJ3QgYWxyZWFkeSBsaXN0ZW5pbmcuXG4gICAqXG4gICAqIElmIGNhbGxlZCB3aXRoIGBmYWxzZWAsIFVJLVJvdXRlciB3aWxsIHN0b3AgbGlzdGVuaW5nIChjYWxsIGxpc3Rlbih0cnVlKSB0byBzdGFydCBsaXN0ZW5pbmcgYWdhaW4pLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHVybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHQoKTtcbiAgICpcbiAgICogZmV0Y2goJy9zdGF0ZXMuanNvbicpLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSkudGhlbihkYXRhID0+IHtcbiAgICogICBkYXRhLmZvckVhY2goc3RhdGUgPT4gJHN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoc3RhdGUpKTtcbiAgICogICAvLyBTdGFydCByZXNwb25kaW5nIHRvIFVSTCBjaGFuZ2VzXG4gICAqICAgdXJsU2VydmljZS5saXN0ZW4oKTtcbiAgICogICB1cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZW5hYmxlZCBgdHJ1ZWAgb3IgYGZhbHNlYCB0byBzdGFydCBvciBzdG9wIGxpc3RlbmluZyB0byBVUkwgY2hhbmdlc1xuICAgKi9cbiAgcHVibGljIGxpc3RlbihlbmFibGVkPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcbiAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3N0b3BMaXN0ZW5pbmdGbiAmJiB0aGlzLl9zdG9wTGlzdGVuaW5nRm4oKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9wTGlzdGVuaW5nRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAodGhpcy5fc3RvcExpc3RlbmluZ0ZuID0gdGhpcy5fc3RvcExpc3RlbmluZ0ZuIHx8IHRoaXMucm91dGVyLnVybFNlcnZpY2Uub25DaGFuZ2UoZXZ0ID0+IHRoaXMuc3luYyhldnQpKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIG1vbml0b3Jpbmcgb2YgdGhlIFVSTC5cbiAgICpcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgVUktUm91dGVyIGhhcyBib290c3RyYXBwZWQuXG4gICAqIEl0IHdpbGwgc3RvcCBVSS1Sb3V0ZXIgZnJvbSBwZXJmb3JtaW5nIHRoZSBpbml0aWFsIHVybCBzeW5jLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gcGVyZm9ybSBzb21lIGFzeW5jaHJvbm91cyBpbml0aWFsaXphdGlvbiBiZWZvcmUgdGhlIHJvdXRlciBzdGFydHMuXG4gICAqIE9uY2UgdGhlIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlLCBjYWxsIFtbbGlzdGVuXV0gdG8gdGVsbCBVSS1Sb3V0ZXIgdG8gc3RhcnQgd2F0Y2hpbmcgYW5kIHN5bmNocm9uaXppbmcgdGhlIFVSTC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAvLyBQcmV2ZW50IFVJLVJvdXRlciBmcm9tIGF1dG9tYXRpY2FsbHkgaW50ZXJjZXB0aW5nIFVSTCBjaGFuZ2VzIHdoZW4gaXQgc3RhcnRzO1xuICAgKiB1cmxTZXJ2aWNlLmRlZmVySW50ZXJjZXB0KCk7XG4gICAqXG4gICAqIGZldGNoKCcvc3RhdGVzLmpzb24nKS50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpLnRoZW4oZGF0YSA9PiB7XG4gICAqICAgZGF0YS5mb3JFYWNoKHN0YXRlID0+ICRzdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyKHN0YXRlKSk7XG4gICAqICAgdXJsU2VydmljZS5saXN0ZW4oKTtcbiAgICogICB1cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZGVmZXIgSW5kaWNhdGVzIHdoZXRoZXIgdG8gZGVmZXIgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi5cbiAgICogICAgICAgIFBhc3Npbmcgbm8gcGFyYW1ldGVyIGlzIGVxdWl2YWxlbnQgdG8gYHRydWVgLlxuICAgKi9cbiAgcHVibGljIGRlZmVySW50ZXJjZXB0KGRlZmVyPzogYm9vbGVhbikge1xuICAgIGlmIChkZWZlciA9PT0gdW5kZWZpbmVkKSBkZWZlciA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmNlcHREZWZlcnJlZCA9IGRlZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgYSBVUkxcbiAgICpcbiAgICogR2l2ZW4gYSBVUkwgKGFzIGEgW1tVcmxQYXJ0c11dIG9iamVjdCksIGNoZWNrIGFsbCBydWxlcyBhbmQgZGV0ZXJtaW5lIHRoZSBiZXN0IG1hdGNoaW5nIHJ1bGUuXG4gICAqIFJldHVybiB0aGUgcmVzdWx0IGFzIGEgW1tNYXRjaFJlc3VsdF1dLlxuICAgKi9cbiAgcHVibGljIG1hdGNoKHVybDogVXJsUGFydHMpOiBNYXRjaFJlc3VsdCB7XG4gICAgdXJsID0gZXh0ZW5kKHsgcGF0aDogJycsIHNlYXJjaDoge30sIGhhc2g6ICcnIH0sIHVybCk7XG4gICAgY29uc3QgcnVsZXMgPSB0aGlzLnJ1bGVzLnJ1bGVzKCk7XG5cbiAgICAvLyBDaGVja3MgYSBzaW5nbGUgcnVsZS4gUmV0dXJucyB7IHJ1bGU6IHJ1bGUsIG1hdGNoOiBtYXRjaCwgd2VpZ2h0OiB3ZWlnaHQgfSBpZiBpdCBtYXRjaGVkLCBvciB1bmRlZmluZWRcbiAgICBjb25zdCBjaGVja1J1bGUgPSAocnVsZTogVXJsUnVsZSk6IE1hdGNoUmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcnVsZS5tYXRjaCh1cmwsIHRoaXMucm91dGVyKTtcbiAgICAgIHJldHVybiBtYXRjaCAmJiB7IG1hdGNoLCBydWxlLCB3ZWlnaHQ6IHJ1bGUubWF0Y2hQcmlvcml0eShtYXRjaCkgfTtcbiAgICB9O1xuXG4gICAgLy8gVGhlIHJ1bGVzIGFyZSBwcmUtc29ydGVkLlxuICAgIC8vIC0gRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgcnVsZS5cbiAgICAvLyAtIEZpbmQgYW55IG90aGVyIG1hdGNoaW5nIHJ1bGUgdGhhdCBzb3J0ZWQgKmV4YWN0bHkgdGhlIHNhbWUqLCBhY2NvcmRpbmcgdG8gYC5zb3J0KClgLlxuICAgIC8vIC0gQ2hvb3NlIHRoZSBydWxlIHdpdGggdGhlIGhpZ2hlc3QgbWF0Y2ggd2VpZ2h0LlxuICAgIGxldCBiZXN0OiBNYXRjaFJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBTdG9wIHdoZW4gdGhlcmUgaXMgYSAnYmVzdCcgcnVsZSBhbmQgdGhlIG5leHQgcnVsZSBzb3J0cyBkaWZmZXJlbnRseSB0aGFuIGl0LlxuICAgICAgaWYgKGJlc3QgJiYgYmVzdC5ydWxlLl9ncm91cCAhPT0gcnVsZXNbaV0uX2dyb3VwKSBicmVhaztcblxuICAgICAgY29uc3QgY3VycmVudCA9IGNoZWNrUnVsZShydWxlc1tpXSk7XG4gICAgICAvLyBQaWNrIHRoZSBiZXN0IE1hdGNoUmVzdWx0XG4gICAgICBiZXN0ID0gIWJlc3QgfHwgKGN1cnJlbnQgJiYgY3VycmVudC53ZWlnaHQgPiBiZXN0LndlaWdodCkgPyBjdXJyZW50IDogYmVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdDtcbiAgfVxuXG4gIC8vIERlbGVnYXRlIHRoZXNlIGNhbGxzIHRvIHRoZSBjdXJyZW50IExvY2F0aW9uU2VydmljZXMgaW1wbGVtZW50YXRpb25cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdXJsLCBvciB1cGRhdGVzIHRoZSB1cmxcbiAgICpcbiAgICogIyMjIEdldHRpbmcgdGhlIGN1cnJlbnQgVVJMXG4gICAqXG4gICAqIFdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQsIHJldHVybnMgdGhlIGN1cnJlbnQgVVJMLlxuICAgKiBUaGUgVVJMIGlzIG5vcm1hbGl6ZWQgdXNpbmcgdGhlIGludGVybmFsIFtbcGF0aF1dL1tbc2VhcmNoXV0vW1toYXNoXV0gdmFsdWVzLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdGhlIFVSTCBtYXkgYmUgc3RvcmVkIGluIHRoZSBoYXNoIChbW0hhc2hMb2NhdGlvblNlcnZpY2VzXV0pIG9yXG4gICAqIGhhdmUgYSBiYXNlIEhSRUYgcHJlcGVuZGVkIChbW1B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZXNdXSkuXG4gICAqXG4gICAqIFRoZSByYXcgVVJMIGluIHRoZSBicm93c2VyIG1pZ2h0IGJlOlxuICAgKlxuICAgKiBgYGBcbiAgICogaHR0cDovL215c2l0ZS5jb20vc29tZXBhdGgvaW5kZXguaHRtbCMvaW50ZXJuYWwvcGF0aC8xMjM/cGFyYW0xPWZvbyNhbmNob3JcbiAgICogYGBgXG4gICAqXG4gICAqIG9yXG4gICAqXG4gICAqIGBgYFxuICAgKiBodHRwOi8vbXlzaXRlLmNvbS9iYXNlcGF0aC9pbnRlcm5hbC9wYXRoLzEyMz9wYXJhbTE9Zm9vI2FuY2hvclxuICAgKiBgYGBcbiAgICpcbiAgICogdGhlbiB0aGlzIG1ldGhvZCByZXR1cm5zOlxuICAgKlxuICAgKiBgYGBcbiAgICogL2ludGVybmFsL3BhdGgvMTIzP3BhcmFtMT1mb28jYW5jaG9yXG4gICAqIGBgYFxuICAgKlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGxvY2F0aW9uU2VydmljZXMudXJsKCk7IC8vIFwiL3NvbWUvcGF0aD9xdWVyeT12YWx1ZSNhbmNob3JcIlxuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIFVwZGF0aW5nIHRoZSBVUkxcbiAgICpcbiAgICogV2hlbiBgbmV3dXJsYCBhcmd1bWVudHMgaXMgcHJvdmlkZWQsIGNoYW5nZXMgdGhlIFVSTCB0byByZWZsZWN0IGBuZXd1cmxgXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbG9jYXRpb25TZXJ2aWNlcy51cmwoXCIvc29tZS9wYXRoP3F1ZXJ5PXZhbHVlI2FuY2hvclwiLCB0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBuZXd1cmwgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIFVSTC5cbiAgICogICAgICAgICAgICAgICBUaGlzIHVybCBzaG91bGQgcmVmbGVjdCBvbmx5IHRoZSBuZXcgaW50ZXJuYWwgW1twYXRoXV0sIFtbc2VhcmNoXV0sIGFuZCBbW2hhc2hdXSB2YWx1ZXMuXG4gICAqICAgICAgICAgICAgICAgSXQgc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBwcm90b2NvbCwgc2l0ZSwgcG9ydCwgb3IgYmFzZSBwYXRoIG9mIGFuIGFic29sdXRlIEhSRUYuXG4gICAqIEBwYXJhbSByZXBsYWNlIFdoZW4gdHJ1ZSwgcmVwbGFjZXMgdGhlIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSAoaW5zdGVhZCBvZiBhcHBlbmRpbmcgaXQpIHdpdGggdGhpcyBuZXcgdXJsXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgaGlzdG9yeSdzIHN0YXRlIG9iamVjdCwgaS5lLiwgcHVzaFN0YXRlIChpZiB0aGUgTG9jYXRpb25TZXJ2aWNlcyBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0cyBpdClcbiAgICpcbiAgICogQHJldHVybiB0aGUgdXJsIChhZnRlciBwb3RlbnRpYWxseSBiZWluZyBwcm9jZXNzZWQpXG4gICAqL1xuICBwdWJsaWMgdXJsID0gKG5ld3VybD86IHN0cmluZywgcmVwbGFjZT86IGJvb2xlYW4sIHN0YXRlPzogYW55KTogc3RyaW5nID0+XG4gICAgdGhpcy5yb3V0ZXIubG9jYXRpb25TZXJ2aWNlLnVybChuZXd1cmwsIHJlcGxhY2UsIHN0YXRlKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgcGF0aCBwYXJ0IG9mIHRoZSBjdXJyZW50IHVybFxuICAgKlxuICAgKiBJZiB0aGUgY3VycmVudCBVUkwgaXMgYC9zb21lL3BhdGg/cXVlcnk9dmFsdWUjYW5jaG9yYCwgdGhpcyByZXR1cm5zIGAvc29tZS9wYXRoYFxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIHVybFxuICAgKi9cbiAgcHVibGljIHBhdGggPSAoKTogc3RyaW5nID0+IHRoaXMucm91dGVyLmxvY2F0aW9uU2VydmljZS5wYXRoKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlYXJjaCBwYXJ0IG9mIHRoZSBjdXJyZW50IHVybCBhcyBhbiBvYmplY3RcbiAgICpcbiAgICogSWYgdGhlIGN1cnJlbnQgVVJMIGlzIGAvc29tZS9wYXRoP3F1ZXJ5PXZhbHVlI2FuY2hvcmAsIHRoaXMgcmV0dXJucyBgeyBxdWVyeTogJ3ZhbHVlJyB9YFxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzZWFyY2ggKHF1ZXJ5KSBwb3J0aW9uIG9mIHRoZSB1cmwsIGFzIGFuIG9iamVjdFxuICAgKi9cbiAgcHVibGljIHNlYXJjaCA9ICgpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0+IHRoaXMucm91dGVyLmxvY2F0aW9uU2VydmljZS5zZWFyY2goKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgaGFzaCBwYXJ0IG9mIHRoZSBjdXJyZW50IHVybFxuICAgKlxuICAgKiBJZiB0aGUgY3VycmVudCBVUkwgaXMgYC9zb21lL3BhdGg/cXVlcnk9dmFsdWUjYW5jaG9yYCwgdGhpcyByZXR1cm5zIGBhbmNob3JgXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGhhc2ggKGFuY2hvcikgcG9ydGlvbiBvZiB0aGUgdXJsXG4gICAqL1xuICBwdWJsaWMgaGFzaCA9ICgpOiBzdHJpbmcgPT4gdGhpcy5yb3V0ZXIubG9jYXRpb25TZXJ2aWNlLmhhc2goKTtcblxuICAvKipcbiAgICogQGludGVybmFsYXBpXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIGxvdyBsZXZlbCB1cmwgY2hhbmdlIGhhbmRsZXJcbiAgICpcbiAgICogTm90ZTogQmVjYXVzZSB0aGlzIGlzIGEgbG93IGxldmVsIGhhbmRsZXIsIGl0J3Mgbm90IHJlY29tbWVuZGVkIGZvciBnZW5lcmFsIHVzZS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBsZXQgZGVyZWdpc3RlckZuID0gbG9jYXRpb25TZXJ2aWNlcy5vbkNoYW5nZSgoZXZ0KSA9PiBjb25zb2xlLmxvZyhcInVybCBjaGFuZ2VcIiwgZXZ0KSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHVybCBpcyBjaGFuZ2luZ1xuICAgKiBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBkZS1yZWdpc3RlcnMgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgb25DaGFuZ2UgPSAoY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXIpOiBGdW5jdGlvbiA9PiB0aGlzLnJvdXRlci5sb2NhdGlvblNlcnZpY2Uub25DaGFuZ2UoY2FsbGJhY2spO1xufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBjb3JlICovIC8qKiAqL1xuaW1wb3J0IHsgVXJsTWF0Y2hlckZhY3RvcnkgfSBmcm9tICcuL3VybC91cmxNYXRjaGVyRmFjdG9yeSc7XG5pbXBvcnQgeyBVcmxSb3V0ZXIgfSBmcm9tICcuL3VybC91cmxSb3V0ZXInO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tICcuL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld1NlcnZpY2UgfSBmcm9tICcuL3ZpZXcvdmlldyc7XG5pbXBvcnQgeyBTdGF0ZVJlZ2lzdHJ5IH0gZnJvbSAnLi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5JztcbmltcG9ydCB7IFN0YXRlU2VydmljZSB9IGZyb20gJy4vc3RhdGUvc3RhdGVTZXJ2aWNlJztcbmltcG9ydCB7IFVJUm91dGVyR2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscyc7XG5pbXBvcnQgeyBVSVJvdXRlclBsdWdpbiwgRGlzcG9zYWJsZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IHZhbHVlcywgcmVtb3ZlRnJvbSB9IGZyb20gJy4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBVcmxTZXJ2aWNlIH0gZnJvbSAnLi91cmwvdXJsU2VydmljZSc7XG5pbXBvcnQgeyBMb2NhdGlvblNlcnZpY2VzLCBMb2NhdGlvbkNvbmZpZyB9IGZyb20gJy4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBUcmFjZSwgdHJhY2UgfSBmcm9tICcuL2NvbW1vbi90cmFjZSc7XG5pbXBvcnQgeyBtYWtlU3R1YiB9IGZyb20gJy4vY29tbW9uJztcblxuLyoqIEBoaWRkZW4gKi9cbmxldCBfcm91dGVySW5zdGFuY2UgPSAwO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgbG9jU3ZjRm5zOiAoa2V5b2YgTG9jYXRpb25TZXJ2aWNlcylbXSA9IFsndXJsJywgJ3BhdGgnLCAnc2VhcmNoJywgJ2hhc2gnLCAnb25DaGFuZ2UnXTtcbi8qKiBAaGlkZGVuICovXG5jb25zdCBsb2NDZmdGbnM6IChrZXlvZiBMb2NhdGlvbkNvbmZpZylbXSA9IFsncG9ydCcsICdwcm90b2NvbCcsICdob3N0JywgJ2Jhc2VIcmVmJywgJ2h0bWw1TW9kZScsICdoYXNoUHJlZml4J107XG4vKiogQGhpZGRlbiAqL1xuY29uc3QgbG9jYXRpb25TZXJ2aWNlU3R1YiA9IG1ha2VTdHViPExvY2F0aW9uU2VydmljZXM+KCdMb2NhdGlvblNlcnZpY2VzJywgbG9jU3ZjRm5zKTtcbi8qKiBAaGlkZGVuICovXG5jb25zdCBsb2NhdGlvbkNvbmZpZ1N0dWIgPSBtYWtlU3R1YjxMb2NhdGlvbkNvbmZpZz4oJ0xvY2F0aW9uQ29uZmlnJywgbG9jQ2ZnRm5zKTtcblxuLyoqXG4gKiBUaGUgbWFzdGVyIGNsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgYW4gaW5zdGFuY2Ugb2YgVUktUm91dGVyLlxuICpcbiAqIFVJLVJvdXRlciAoZm9yIGVhY2ggc3BlY2lmaWMgZnJhbWV3b3JrKSB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGR1cmluZyBib290c3RyYXAuXG4gKiBUaGlzIGNsYXNzIGluc3RhbnRpYXRlcyBhbmQgd2lyZXMgdGhlIFVJLVJvdXRlciBzZXJ2aWNlcyB0b2dldGhlci5cbiAqXG4gKiBBZnRlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgVUlSb3V0ZXIgY2xhc3MgaXMgY3JlYXRlZCwgaXQgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgZm9yIHlvdXIgYXBwLlxuICogRm9yIGluc3RhbmNlLCBhcHAgc3RhdGVzIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggdGhlIFtbVUlSb3V0ZXIuc3RhdGVSZWdpc3RyeV1dLlxuICpcbiAqIC0tLVxuICpcbiAqIE5vcm1hbGx5IHRoZSBmcmFtZXdvcmsgY29kZSB3aWxsIGJvb3RzdHJhcCBVSS1Sb3V0ZXIuXG4gKiBJZiB5b3UgYXJlIGJvb3RzdHJhcHBpbmcgVUlSb3V0ZXIgbWFudWFsbHksIHRlbGwgaXQgdG8gbW9uaXRvciB0aGUgVVJMIGJ5IGNhbGxpbmdcbiAqIFtbVXJsU2VydmljZS5saXN0ZW5dXSB0aGVuIFtbVXJsU2VydmljZS5zeW5jXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVSVJvdXRlciB7XG4gIC8qKiBAaGlkZGVuICovICRpZCA9IF9yb3V0ZXJJbnN0YW5jZSsrO1xuICAvKiogQGhpZGRlbiAqLyBfZGlzcG9zZWQgPSBmYWxzZTtcbiAgLyoqIEBoaWRkZW4gKi8gcHJpdmF0ZSBfZGlzcG9zYWJsZXM6IERpc3Bvc2FibGVbXSA9IFtdO1xuXG4gIC8qKiBQcm92aWRlcyB0cmFjZSBpbmZvcm1hdGlvbiB0byB0aGUgY29uc29sZSAqL1xuICB0cmFjZTogVHJhY2UgPSB0cmFjZTtcblxuICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB1aS12aWV3IHN5bmNocm9uaXphdGlvbiAqL1xuICB2aWV3U2VydmljZSA9IG5ldyBWaWV3U2VydmljZSh0aGlzKTtcblxuICAvKiogR2xvYmFsIHJvdXRlciBzdGF0ZSAqL1xuICBnbG9iYWxzOiBVSVJvdXRlckdsb2JhbHMgPSBuZXcgVUlSb3V0ZXJHbG9iYWxzKCk7XG5cbiAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gVHJhbnNpdGlvbnMgKi9cbiAgdHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlID0gbmV3IFRyYW5zaXRpb25TZXJ2aWNlKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICovXG4gIHVybE1hdGNoZXJGYWN0b3J5OiBVcmxNYXRjaGVyRmFjdG9yeSA9IG5ldyBVcmxNYXRjaGVyRmFjdG9yeSh0aGlzKTtcblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBmb3IgcHVibGljIHVzZS4gVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkXG4gICAqL1xuICB1cmxSb3V0ZXI6IFVybFJvdXRlciA9IG5ldyBVcmxSb3V0ZXIodGhpcyk7XG5cbiAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdGhlIFVSTCAqL1xuICB1cmxTZXJ2aWNlOiBVcmxTZXJ2aWNlID0gbmV3IFVybFNlcnZpY2UodGhpcyk7XG5cbiAgLyoqIFByb3ZpZGVzIGEgcmVnaXN0cnkgZm9yIHN0YXRlcywgYW5kIHJlbGF0ZWQgcmVnaXN0cmF0aW9uIHNlcnZpY2VzICovXG4gIHN0YXRlUmVnaXN0cnk6IFN0YXRlUmVnaXN0cnkgPSBuZXcgU3RhdGVSZWdpc3RyeSh0aGlzKTtcblxuICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBzdGF0ZXMgKi9cbiAgc3RhdGVTZXJ2aWNlID0gbmV3IFN0YXRlU2VydmljZSh0aGlzKTtcblxuICAvKiogQGhpZGRlbiBwbHVnaW4gaW5zdGFuY2VzIGFyZSByZWdpc3RlcmVkIGhlcmUgKi9cbiAgcHJpdmF0ZSBfcGx1Z2luczogeyBba2V5OiBzdHJpbmddOiBVSVJvdXRlclBsdWdpbiB9ID0ge307XG5cbiAgLyoqIFJlZ2lzdGVycyBhbiBvYmplY3QgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgcm91dGVyIGlzIGRpc3Bvc2VkICovXG4gIGRpc3Bvc2FibGUoZGlzcG9zYWJsZTogRGlzcG9zYWJsZSkge1xuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyByb3V0ZXIgaW5zdGFuY2VcbiAgICpcbiAgICogV2hlbiBjYWxsZWQsIGNsZWFycyByZXNvdXJjZXMgcmV0YWluZWQgYnkgdGhlIHJvdXRlciBieSBjYWxsaW5nIGBkaXNwb3NlKHRoaXMpYCBvbiBhbGxcbiAgICogcmVnaXN0ZXJlZCBbW2Rpc3Bvc2FibGVdXSBvYmplY3RzLlxuICAgKlxuICAgKiBPciwgaWYgYSBgZGlzcG9zYWJsZWAgb2JqZWN0IGlzIHByb3ZpZGVkLCBjYWxscyBgZGlzcG9zZSh0aGlzKWAgb24gdGhhdCBvYmplY3Qgb25seS5cbiAgICpcbiAgICogQHBhcmFtIGRpc3Bvc2FibGUgKG9wdGlvbmFsKSB0aGUgZGlzcG9zYWJsZSB0byBkaXNwb3NlXG4gICAqL1xuICBkaXNwb3NlKGRpc3Bvc2FibGU/OiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoZGlzcG9zYWJsZSAmJiBpc0Z1bmN0aW9uKGRpc3Bvc2FibGUuZGlzcG9zZSkpIHtcbiAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSh0aGlzKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnNsaWNlKCkuZm9yRWFjaChkID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR5cGVvZiBkLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgJiYgZC5kaXNwb3NlKHRoaXMpO1xuICAgICAgICByZW1vdmVGcm9tKHRoaXMuX2Rpc3Bvc2FibGVzLCBkKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHt9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgVUlSb3V0ZXJgIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gbG9jYXRpb25TZXJ2aWNlIGEgW1tMb2NhdGlvblNlcnZpY2VzXV0gaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIGxvY2F0aW9uQ29uZmlnIGEgW1tMb2NhdGlvbkNvbmZpZ11dIGltcGxlbWVudGF0aW9uXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGxvY2F0aW9uU2VydmljZTogTG9jYXRpb25TZXJ2aWNlcyA9IGxvY2F0aW9uU2VydmljZVN0dWIsXG4gICAgcHVibGljIGxvY2F0aW9uQ29uZmlnOiBMb2NhdGlvbkNvbmZpZyA9IGxvY2F0aW9uQ29uZmlnU3R1YlxuICApIHtcbiAgICB0aGlzLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3Jvb3RWaWV3Q29udGV4dCh0aGlzLnN0YXRlUmVnaXN0cnkucm9vdCgpKTtcbiAgICB0aGlzLmdsb2JhbHMuJGN1cnJlbnQgPSB0aGlzLnN0YXRlUmVnaXN0cnkucm9vdCgpO1xuICAgIHRoaXMuZ2xvYmFscy5jdXJyZW50ID0gdGhpcy5nbG9iYWxzLiRjdXJyZW50LnNlbGY7XG5cbiAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5nbG9iYWxzKTtcbiAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5zdGF0ZVNlcnZpY2UpO1xuICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnN0YXRlUmVnaXN0cnkpO1xuICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnRyYW5zaXRpb25TZXJ2aWNlKTtcbiAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy51cmxTZXJ2aWNlKTtcbiAgICB0aGlzLmRpc3Bvc2FibGUobG9jYXRpb25TZXJ2aWNlKTtcbiAgICB0aGlzLmRpc3Bvc2FibGUobG9jYXRpb25Db25maWcpO1xuICB9XG5cbiAgLyoqIEFkZCBwbHVnaW4gKGFzIEVTNiBjbGFzcykgKi9cbiAgcGx1Z2luPFQgZXh0ZW5kcyBVSVJvdXRlclBsdWdpbj4ocGx1Z2luOiB7IG5ldyAocm91dGVyOiBVSVJvdXRlciwgb3B0aW9ucz86IGFueSk6IFQgfSwgb3B0aW9ucz86IGFueSk6IFQ7XG4gIC8qKiBBZGQgcGx1Z2luIChhcyBqYXZhc2NyaXB0IGNvbnN0cnVjdG9yIGZ1bmN0aW9uKSAqL1xuICBwbHVnaW48VCBleHRlbmRzIFVJUm91dGVyUGx1Z2luPihwbHVnaW46IHsgKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM/OiBhbnkpOiB2b2lkIH0sIG9wdGlvbnM/OiBhbnkpOiBUO1xuICAvKiogQWRkIHBsdWdpbiAoYXMgamF2YXNjcmlwdCBmYWN0b3J5IGZ1bmN0aW9uKSAqL1xuICBwbHVnaW48VCBleHRlbmRzIFVJUm91dGVyUGx1Z2luPihwbHVnaW46IFBsdWdpbkZhY3Rvcnk8VD4sIG9wdGlvbnM/OiBhbnkpOiBUO1xuICAvKipcbiAgICogQWRkcyBhIHBsdWdpbiB0byBVSS1Sb3V0ZXJcbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIFVJLVJvdXRlciBQbHVnaW4uXG4gICAqIEEgcGx1Z2luIGNhbiBlbmhhbmNlIG9yIGNoYW5nZSBVSS1Sb3V0ZXIgYmVoYXZpb3IgdXNpbmcgYW55IHB1YmxpYyBBUEkuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgTXlDb29sUGx1Z2luIH0gZnJvbSBcInVpLXJvdXRlci1jb29sLXBsdWdpblwiO1xuICAgKlxuICAgKiB2YXIgcGx1Z2luID0gcm91dGVyLmFkZFBsdWdpbihNeUNvb2xQbHVnaW4pO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIFBsdWdpbiBhdXRob3JpbmdcbiAgICpcbiAgICogQSBwbHVnaW4gaXMgc2ltcGx5IGEgY2xhc3MgKG9yIGNvbnN0cnVjdG9yIGZ1bmN0aW9uKSB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlIGFuZCAob3B0aW9uYWxseSkgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBwbHVnaW4gY2FuIGltcGxlbWVudCBpdHMgZnVuY3Rpb25hbGl0eSB1c2luZyBhbnkgb2YgdGhlIHB1YmxpYyBBUElzIG9mIFtbVUlSb3V0ZXJdXS5cbiAgICogRm9yIGV4YW1wbGUsIGl0IG1heSBjb25maWd1cmUgcm91dGVyIG9wdGlvbnMgb3IgYWRkIGEgVHJhbnNpdGlvbiBIb29rLlxuICAgKlxuICAgKiBUaGUgcGx1Z2luIGNhbiB0aGVuIGJlIHB1Ymxpc2hlZCBhcyBhIHNlcGFyYXRlIG1vZHVsZS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBleHBvcnQgY2xhc3MgTXlBdXRoUGx1Z2luIGltcGxlbWVudHMgVUlSb3V0ZXJQbHVnaW4ge1xuICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM6IGFueSkge1xuICAgKiAgICAgdGhpcy5uYW1lID0gXCJNeUF1dGhQbHVnaW5cIjtcbiAgICogICAgIGxldCAkdHJhbnNpdGlvbnMgPSByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAqICAgICBsZXQgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICpcbiAgICogICAgIGxldCBhdXRoQ3JpdGVyaWEgPSB7XG4gICAqICAgICAgIHRvOiAoc3RhdGUpID0+IHN0YXRlLmRhdGEgJiYgc3RhdGUuZGF0YS5yZXF1aXJlc0F1dGhcbiAgICogICAgIH07XG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBhdXRoSG9vayh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XG4gICAqICAgICAgIGxldCBhdXRoU2VydmljZSA9IHRyYW5zaXRpb24uaW5qZWN0b3IoKS5nZXQoJ0F1dGhTZXJ2aWNlJyk7XG4gICAqICAgICAgIGlmICghYXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICogICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldCgnbG9naW4nKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgJHRyYW5zaXRpb25zLm9uU3RhcnQoYXV0aENyaXRlcmlhLCBhdXRoSG9vayk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcGx1Z2luIG9uZSBvZjpcbiAgICogICAgICAgIC0gYSBwbHVnaW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBbW1VJUm91dGVyUGx1Z2luXV1cbiAgICogICAgICAgIC0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgYSBbW1VJUm91dGVyUGx1Z2luXV0gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZVxuICAgKiAgICAgICAgLSBhIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgcmV0dXJucyBhIFtbVUlSb3V0ZXJQbHVnaW5dXSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHBsdWdpbiBjbGFzcy9mYWN0b3J5XG4gICAqIEByZXR1cm5zIHRoZSByZWdpc3RlcmVkIHBsdWdpbiBpbnN0YW5jZVxuICAgKi9cbiAgcGx1Z2luPFQgZXh0ZW5kcyBVSVJvdXRlclBsdWdpbj4ocGx1Z2luOiBhbnksIG9wdGlvbnM6IGFueSA9IHt9KTogVCB7XG4gICAgY29uc3QgcGx1Z2luSW5zdGFuY2UgPSBuZXcgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICAgIGlmICghcGx1Z2luSW5zdGFuY2UubmFtZSkgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBwcm9wZXJ0eSBgbmFtZWAgbWlzc2luZyBvbiBwbHVnaW46ICcgKyBwbHVnaW5JbnN0YW5jZSk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChwbHVnaW5JbnN0YW5jZSk7XG4gICAgcmV0dXJuICh0aGlzLl9wbHVnaW5zW3BsdWdpbkluc3RhbmNlLm5hbWVdID0gcGx1Z2luSW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcmVnaXN0ZXJlZCBwbHVnaW5zXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgcGx1Z2luIG9mIHRoZSBnaXZlbiBgcGx1Z2luTmFtZWAuXG4gICAqIElmIG5vIGBwbHVnaW5OYW1lYCBpcyBnaXZlbiwgcmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zXG4gICAqXG4gICAqIEBwYXJhbSBwbHVnaW5OYW1lIChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0byBnZXRcbiAgICogQHJldHVybiB0aGUgbmFtZWQgcGx1Z2luICh1bmRlZmluZWQgaWYgbm90IGZvdW5kKSwgb3IgYWxsIHBsdWdpbnMgKGlmIGBwbHVnaW5OYW1lYCBpcyBvbWl0dGVkKVxuICAgKi9cbiAgZ2V0UGx1Z2luKHBsdWdpbk5hbWU6IHN0cmluZyk6IFVJUm91dGVyUGx1Z2luO1xuICBnZXRQbHVnaW4oKTogVUlSb3V0ZXJQbHVnaW5bXTtcbiAgZ2V0UGx1Z2luKHBsdWdpbk5hbWU/OiBzdHJpbmcpOiBVSVJvdXRlclBsdWdpbiB8IFVJUm91dGVyUGx1Z2luW10ge1xuICAgIHJldHVybiBwbHVnaW5OYW1lID8gdGhpcy5fcGx1Z2luc1twbHVnaW5OYW1lXSA6IHZhbHVlcyh0aGlzLl9wbHVnaW5zKTtcbiAgfVxufVxuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgdHlwZSBQbHVnaW5GYWN0b3J5PFQ+ID0gKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM/OiBhbnkpID0+IFQ7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBSZXNvbHZhYmxlIH0gZnJvbSAnLi4vcmVzb2x2ZSc7XG5pbXBvcnQgeyBpbkFycmF5LCB1bmlxUiwgdW5uZXN0UiwgdmFsdWVzIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IFBhdGhOb2RlIH0gZnJvbSAnLi4vcGF0aCc7XG5cbmZ1bmN0aW9uIGFkZENvcmVSZXNvbHZhYmxlcyh0cmFuczogVHJhbnNpdGlvbikge1xuICB0cmFucy5hZGRSZXNvbHZhYmxlKFJlc29sdmFibGUuZnJvbURhdGEoVUlSb3V0ZXIsIHRyYW5zLnJvdXRlciksICcnKTtcbiAgdHJhbnMuYWRkUmVzb2x2YWJsZShSZXNvbHZhYmxlLmZyb21EYXRhKFRyYW5zaXRpb24sIHRyYW5zKSwgJycpO1xuICB0cmFucy5hZGRSZXNvbHZhYmxlKFJlc29sdmFibGUuZnJvbURhdGEoJyR0cmFuc2l0aW9uJCcsIHRyYW5zKSwgJycpO1xuICB0cmFucy5hZGRSZXNvbHZhYmxlKFJlc29sdmFibGUuZnJvbURhdGEoJyRzdGF0ZVBhcmFtcycsIHRyYW5zLnBhcmFtcygpKSwgJycpO1xuXG4gIHRyYW5zLmVudGVyaW5nKCkuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZShSZXNvbHZhYmxlLmZyb21EYXRhKCckc3RhdGUkJywgc3RhdGUpLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXMgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vbkNyZWF0ZSh7fSwgYWRkQ29yZVJlc29sdmFibGVzKTtcblxuY29uc3QgVFJBTlNJVElPTl9UT0tFTlMgPSBbJyR0cmFuc2l0aW9uJCcsIFRyYW5zaXRpb25dO1xuY29uc3QgaXNUcmFuc2l0aW9uID0gaW5BcnJheShUUkFOU0lUSU9OX1RPS0VOUyk7XG5cbi8vIFJlZmVyZW5jZXMgdG8gVHJhbnNpdGlvbiBpbiB0aGUgdHJlZUNoYW5nZXMgcGF0aG5vZGVzIG1ha2VzIGFsbFxuLy8gcHJldmlvdXMgVHJhbnNpdGlvbnMgcmVhY2hhYmxlIGluIG1lbW9yeSwgY2F1c2luZyBhIG1lbW9yeSBsZWFrXG4vLyBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgcmVzb2x2ZXMgZm9yICckdHJhbnNpdGlvbiQnIGFuZCBgVHJhbnNpdGlvbmAgZnJvbSB0aGUgdHJlZUNoYW5nZXMuXG4vLyBEbyBub3QgdXNlIHRoaXMgb24gY3VycmVudCB0cmFuc2l0aW9ucywgb25seSBvbiBvbGQgb25lcy5cbmV4cG9ydCBjb25zdCB0cmVlQ2hhbmdlc0NsZWFudXAgPSAodHJhbnM6IFRyYW5zaXRpb24pID0+IHtcbiAgY29uc3Qgbm9kZXMgPSB2YWx1ZXModHJhbnMudHJlZUNoYW5nZXMoKSlcbiAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgIC5yZWR1Y2UodW5pcVIsIFtdKTtcblxuICAvLyBJZiB0aGUgcmVzb2x2YWJsZSBpcyBhIFRyYW5zaXRpb24sIHJldHVybiBhIG5ldyByZXNvbHZhYmxlIHdpdGggbnVsbCBkYXRhXG4gIGNvbnN0IHJlcGxhY2VUcmFuc2l0aW9uV2l0aE51bGwgPSAocjogUmVzb2x2YWJsZSk6IFJlc29sdmFibGUgPT4ge1xuICAgIHJldHVybiBpc1RyYW5zaXRpb24oci50b2tlbikgPyBSZXNvbHZhYmxlLmZyb21EYXRhKHIudG9rZW4sIG51bGwpIDogcjtcbiAgfTtcblxuICBub2Rlcy5mb3JFYWNoKChub2RlOiBQYXRoTm9kZSkgPT4ge1xuICAgIG5vZGUucmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLm1hcChyZXBsYWNlVHJhbnNpdGlvbldpdGhOdWxsKTtcbiAgfSk7XG59O1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24gfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBUYXJnZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL3RhcmdldFN0YXRlJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uSG9va0ZuIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgc3RhdGUgb3IgcGFyYW1zXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7IHRvOiAoc3RhdGUpID0+ICEhc3RhdGUucmVkaXJlY3RUbyB9LCByZWRpcmVjdEhvb2spO2BcbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlZGlyZWN0VG9dXVxuICovXG5jb25zdCByZWRpcmVjdFRvSG9vazogVHJhbnNpdGlvbkhvb2tGbiA9ICh0cmFuczogVHJhbnNpdGlvbikgPT4ge1xuICBjb25zdCByZWRpcmVjdCA9IHRyYW5zLnRvKCkucmVkaXJlY3RUbztcbiAgaWYgKCFyZWRpcmVjdCkgcmV0dXJuO1xuXG4gIGNvbnN0ICRzdGF0ZSA9IHRyYW5zLnJvdXRlci5zdGF0ZVNlcnZpY2U7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHJlc3VsdDogYW55KSB7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybjtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGFyZ2V0U3RhdGUpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGlzU3RyaW5nKHJlc3VsdCkpIHJldHVybiAkc3RhdGUudGFyZ2V0KDxhbnk+cmVzdWx0LCB0cmFucy5wYXJhbXMoKSwgdHJhbnMub3B0aW9ucygpKTtcbiAgICBpZiAocmVzdWx0WydzdGF0ZSddIHx8IHJlc3VsdFsncGFyYW1zJ10pXG4gICAgICByZXR1cm4gJHN0YXRlLnRhcmdldChyZXN1bHRbJ3N0YXRlJ10gfHwgdHJhbnMudG8oKSwgcmVzdWx0WydwYXJhbXMnXSB8fCB0cmFucy5wYXJhbXMoKSwgdHJhbnMub3B0aW9ucygpKTtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHJlZGlyZWN0KSkge1xuICAgIHJldHVybiBzZXJ2aWNlcy4kcS53aGVuKHJlZGlyZWN0KHRyYW5zKSkudGhlbihoYW5kbGVSZXN1bHQpO1xuICB9XG4gIHJldHVybiBoYW5kbGVSZXN1bHQocmVkaXJlY3QpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyUmVkaXJlY3RUb0hvb2sgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHsgdG86IHN0YXRlID0+ICEhc3RhdGUucmVkaXJlY3RUbyB9LCByZWRpcmVjdFRvSG9vayk7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBUcmFuc2l0aW9uU3RhdGVIb29rRm4gfSBmcm9tICcuLi90cmFuc2l0aW9uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vc3RhdGUvaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlT2JqZWN0IH0gZnJvbSAnLi4vc3RhdGUvc3RhdGVPYmplY3QnO1xuXG4vKipcbiAqIEEgZmFjdG9yeSB3aGljaCBjcmVhdGVzIGFuIG9uRW50ZXIsIG9uRXhpdCBvciBvblJldGFpbiB0cmFuc2l0aW9uIGhvb2sgZnVuY3Rpb25cbiAqXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gaW52b2tlcyB0aGUgKGZvciBpbnN0YW5jZSkgc3RhdGUub25FbnRlciBob29rIHdoZW4gdGhlXG4gKiBzdGF0ZSBpcyBiZWluZyBlbnRlcmVkLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soaG9va05hbWU6IHN0cmluZyk6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiB7XG4gIHJldHVybiAodHJhbnNpdGlvbjogVHJhbnNpdGlvbiwgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pID0+IHtcbiAgICBjb25zdCBfc3RhdGU6IFN0YXRlT2JqZWN0ID0gc3RhdGUuJCRzdGF0ZSgpO1xuICAgIGNvbnN0IGhvb2tGbjogVHJhbnNpdGlvblN0YXRlSG9va0ZuID0gX3N0YXRlW2hvb2tOYW1lXTtcbiAgICByZXR1cm4gaG9va0ZuKHRyYW5zaXRpb24sIHN0YXRlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25FeGl0XG4gKlxuICogV2hlbiB0aGUgc3RhdGUgaXMgYmVpbmcgZXhpdGVkLCB0aGUgc3RhdGUncyAub25FeGl0IGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogKHN0YXRlKSA9PiAhIXN0YXRlLm9uRXhpdCB9LCBvbkV4aXRIb29rKTtgXG4gKlxuICogU2VlOiBbW0lIb29rUmVnaXN0cnkub25FeGl0XV1cbiAqL1xuY29uc3Qgb25FeGl0SG9vazogVHJhbnNpdGlvblN0YXRlSG9va0ZuID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRXhpdCcpO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyT25FeGl0SG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IHN0YXRlID0+ICEhc3RhdGUub25FeGl0IH0sIG9uRXhpdEhvb2spO1xuXG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvblJldGFpblxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIHdhcyBhbHJlYWR5IGVudGVyZWQsIGFuZCBpcyBub3QgYmVpbmcgZXhpdGVkIG9yIHJlLWVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vblJldGFpbiBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IChzdGF0ZSkgPT4gISFzdGF0ZS5vblJldGFpbiB9LCBvblJldGFpbkhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXG4gKi9cbmNvbnN0IG9uUmV0YWluSG9vazogVHJhbnNpdGlvblN0YXRlSG9va0ZuID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uUmV0YWluJyk7XG5leHBvcnQgY29uc3QgcmVnaXN0ZXJPblJldGFpbkhvb2sgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vblJldGFpbih7IHJldGFpbmVkOiBzdGF0ZSA9PiAhIXN0YXRlLm9uUmV0YWluIH0sIG9uUmV0YWluSG9vayk7XG5cbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uRW50ZXJcbiAqXG4gKiBXaGVuIHRoZSBzdGF0ZSBpcyBiZWluZyBlbnRlcmVkLCB0aGUgc3RhdGUncyAub25FbnRlciBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogKHN0YXRlKSA9PiAhIXN0YXRlLm9uRW50ZXIgfSwgb25FbnRlckhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vbkVudGVyXV1cbiAqL1xuY29uc3Qgb25FbnRlckhvb2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiA9IG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKCdvbkVudGVyJyk7XG5leHBvcnQgY29uc3QgcmVnaXN0ZXJPbkVudGVySG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogc3RhdGUgPT4gISFzdGF0ZS5vbkVudGVyIH0sIG9uRW50ZXJIb29rKTtcbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgUmVzb2x2ZUNvbnRleHQgfSBmcm9tICcuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0JztcbmltcG9ydCB7IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgVHJhbnNpdGlvbkhvb2tGbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyB2YWwgfSBmcm9tICcuLi9jb21tb24vaG9mJztcbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuLi9zdGF0ZS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgY29uc3QgUkVTT0xWRV9IT09LX1BSSU9SSVRZID0gMTAwMDtcblxuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFsbCBFQUdFUiBSZXNvbHZhYmxlcyBpbiB0aGUgVG8gUGF0aFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IDEwMDAgfSk7YFxuICpcbiAqIFdoZW4gYSBUcmFuc2l0aW9uIHN0YXJ0cywgdGhpcyBob29rIHJlc29sdmVzIGFsbCB0aGUgRUFHRVIgUmVzb2x2YWJsZXMsIHdoaWNoIHRoZSB0cmFuc2l0aW9uIHRoZW4gd2FpdHMgZm9yLlxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dXG4gKi9cbmNvbnN0IGVhZ2VyUmVzb2x2ZVBhdGg6IFRyYW5zaXRpb25Ib29rRm4gPSAodHJhbnM6IFRyYW5zaXRpb24pID0+XG4gIG5ldyBSZXNvbHZlQ29udGV4dCh0cmFucy50cmVlQ2hhbmdlcygpLnRvKS5yZXNvbHZlUGF0aCgnRUFHRVInLCB0cmFucykudGhlbihub29wKTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyRWFnZXJSZXNvbHZlUGF0aCA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IFJFU09MVkVfSE9PS19QUklPUklUWSB9KTtcblxuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFsbCBMQVpZIFJlc29sdmFibGVzIGZvciB0aGUgc3RhdGUgKGFuZCBhbGwgaXRzIGFuY2VzdG9ycykgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6ICgpID0+IHRydWUgfSwgbGF6eVJlc29sdmVTdGF0ZSwgeyBwcmlvcml0eTogMTAwMCB9KTtgXG4gKlxuICogV2hlbiBhIFN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoaXMgaG9vayByZXNvbHZlcyBhbGwgdGhlIFJlc29sdmFibGVzIGZvciB0aGlzIHN0YXRlLCB3aGljaCB0aGUgdHJhbnNpdGlvbiB0aGVuIHdhaXRzIGZvci5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG5jb25zdCBsYXp5UmVzb2x2ZVN0YXRlOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4gPSAodHJhbnM6IFRyYW5zaXRpb24sIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uKSA9PlxuICBuZXcgUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcbiAgICAuc3ViQ29udGV4dChzdGF0ZS4kJHN0YXRlKCkpXG4gICAgLnJlc29sdmVQYXRoKCdMQVpZJywgdHJhbnMpXG4gICAgLnRoZW4obm9vcCk7XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlckxhenlSZXNvbHZlU3RhdGUgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6IHZhbCh0cnVlKSB9LCBsYXp5UmVzb2x2ZVN0YXRlLCB7IHByaW9yaXR5OiBSRVNPTFZFX0hPT0tfUFJJT1JJVFkgfSk7XG5cbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCByZXNvbHZlcyBhbnkgZHluYW1pY2FsbHkgYWRkZWQgKExBWlkgb3IgRUFHRVIpIFJlc29sdmFibGVzLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBlYWdlclJlc29sdmVQYXRoLCB7IHByaW9yaXR5OiAxMDAwIH0pO2BcbiAqXG4gKiBBZnRlciBhbGwgZW50ZXJpbmcgc3RhdGVzIGhhdmUgYmVlbiBlbnRlcmVkLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYW55IHJlbWFpbmluZyBSZXNvbHZhYmxlcy5cbiAqIFRoZXNlIGFyZSB0eXBpY2FsbHkgZHluYW1pYyByZXNvbHZlcyB3aGljaCB3ZXJlIGFkZGVkIGJ5IHNvbWUgVHJhbnNpdGlvbiBIb29rIHVzaW5nIFtbVHJhbnNpdGlvbi5hZGRSZXNvbHZhYmxlXV0uXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xuY29uc3QgcmVzb2x2ZVJlbWFpbmluZzogVHJhbnNpdGlvbkhvb2tGbiA9ICh0cmFuczogVHJhbnNpdGlvbikgPT5cbiAgbmV3IFJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKCkudG8pLnJlc29sdmVQYXRoKCdMQVpZJywgdHJhbnMpLnRoZW4obm9vcCk7XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclJlc29sdmVSZW1haW5pbmcgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vbkZpbmlzaCh7fSwgcmVzb2x2ZVJlbWFpbmluZywgeyBwcmlvcml0eTogUkVTT0xWRV9IT09LX1BSSU9SSVRZIH0pO1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICcuLi9jb21tb24vY29yZXNlcnZpY2VzJztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb24nO1xuaW1wb3J0IHsgVmlld1NlcnZpY2UgfSBmcm9tICcuLi92aWV3L3ZpZXcnO1xuaW1wb3J0IHsgVmlld0NvbmZpZyB9IGZyb20gJy4uL3ZpZXcvaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rRm4gfSBmcm9tICcuLi90cmFuc2l0aW9uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UnO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggd2FpdHMgZm9yIHRoZSB2aWV3cyB0byBsb2FkXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgbG9hZEVudGVyaW5nVmlld3MpO2BcbiAqXG4gKiBBbGxvd3MgdGhlIHZpZXdzIHRvIGRvIGFzeW5jIHdvcmsgaW4gW1tWaWV3Q29uZmlnLmxvYWRdXSBiZWZvcmUgdGhlIHRyYW5zaXRpb24gY29udGludWVzLlxuICogSW4gYW5ndWxhciAxLCB0aGlzIGluY2x1ZGVzIGxvYWRpbmcgdGhlIHRlbXBsYXRlcy5cbiAqL1xuY29uc3QgbG9hZEVudGVyaW5nVmlld3M6IFRyYW5zaXRpb25Ib29rRm4gPSAodHJhbnNpdGlvbjogVHJhbnNpdGlvbikgPT4ge1xuICBjb25zdCAkcSA9IHNlcnZpY2VzLiRxO1xuICBjb25zdCBlbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cygnZW50ZXJpbmcnKTtcbiAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aCkgcmV0dXJuO1xuICByZXR1cm4gJHEuYWxsKGVudGVyaW5nVmlld3MubWFwKHZpZXcgPT4gJHEud2hlbih2aWV3LmxvYWQoKSkpKS50aGVuKG5vb3ApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyTG9hZEVudGVyaW5nVmlld3MgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vbkZpbmlzaCh7fSwgbG9hZEVudGVyaW5nVmlld3MpO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggYWN0aXZhdGVzIHRoZSBuZXcgdmlld3Mgd2hlbiBhIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO2BcbiAqXG4gKiBBZnRlciBhIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHRoaXMgaG9vayBkZWFjdGl2YXRlcyB0aGUgb2xkIHZpZXdzIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLFxuICogYW5kIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIGZyb20gdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICpcbiAqIFNlZSBbW1ZpZXdTZXJ2aWNlXV1cbiAqL1xuY29uc3QgYWN0aXZhdGVWaWV3czogVHJhbnNpdGlvbkhvb2tGbiA9ICh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSA9PiB7XG4gIGNvbnN0IGVudGVyaW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKCdlbnRlcmluZycpO1xuICBjb25zdCBleGl0aW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKCdleGl0aW5nJyk7XG4gIGlmICghZW50ZXJpbmdWaWV3cy5sZW5ndGggJiYgIWV4aXRpbmdWaWV3cy5sZW5ndGgpIHJldHVybjtcblxuICBjb25zdCAkdmlldzogVmlld1NlcnZpY2UgPSB0cmFuc2l0aW9uLnJvdXRlci52aWV3U2VydmljZTtcblxuICBleGl0aW5nVmlld3MuZm9yRWFjaCgodmM6IFZpZXdDb25maWcpID0+ICR2aWV3LmRlYWN0aXZhdGVWaWV3Q29uZmlnKHZjKSk7XG4gIGVudGVyaW5nVmlld3MuZm9yRWFjaCgodmM6IFZpZXdDb25maWcpID0+ICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2YykpO1xuXG4gICR2aWV3LnN5bmMoKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlckFjdGl2YXRlVmlld3MgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBjb3B5IH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbic7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UnO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggdXBkYXRlcyBnbG9iYWwgVUktUm91dGVyIHN0YXRlXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtgXG4gKlxuICogQmVmb3JlIGEgW1tUcmFuc2l0aW9uXV0gc3RhcnRzLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWUgb2YgXCJ0aGUgY3VycmVudCB0cmFuc2l0aW9uXCIgKFtbR2xvYmFscy50cmFuc2l0aW9uXV0pLlxuICogQWZ0ZXIgYSBzdWNjZXNzZnVsIFtbVHJhbnNpdGlvbl1dLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWVzIG9mIFwidGhlIGN1cnJlbnQgc3RhdGVcIlxuICogKFtbR2xvYmFscy5jdXJyZW50XV0gYW5kIFtbR2xvYmFscy4kY3VycmVudF1dKSBhbmQgXCJ0aGUgY3VycmVudCBwYXJhbSB2YWx1ZXNcIiAoW1tHbG9iYWxzLnBhcmFtc11dKS5cbiAqXG4gKiBTZWUgYWxzbyB0aGUgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzOlxuICogW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvbl1dLCBbW1N0YXRlU2VydmljZS5jdXJyZW50XV0sIFtbU3RhdGVTZXJ2aWNlLnBhcmFtc11dXG4gKi9cbmNvbnN0IHVwZGF0ZUdsb2JhbFN0YXRlID0gKHRyYW5zOiBUcmFuc2l0aW9uKSA9PiB7XG4gIGNvbnN0IGdsb2JhbHMgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscztcblxuICBjb25zdCB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCA9ICgpID0+IHtcbiAgICBnbG9iYWxzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5lbnF1ZXVlKHRyYW5zKTtcbiAgICBnbG9iYWxzLiRjdXJyZW50ID0gdHJhbnMuJHRvKCk7XG4gICAgZ2xvYmFscy5jdXJyZW50ID0gZ2xvYmFscy4kY3VycmVudC5zZWxmO1xuXG4gICAgY29weSh0cmFucy5wYXJhbXMoKSwgZ2xvYmFscy5wYXJhbXMpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFyQ3VycmVudFRyYW5zaXRpb24gPSAoKSA9PiB7XG4gICAgLy8gRG8gbm90IGNsZWFyIGdsb2JhbHMudHJhbnNpdGlvbiBpZiBhIGRpZmZlcmVudCB0cmFuc2l0aW9uIGhhcyBzdGFydGVkIGluIHRoZSBtZWFudGltZVxuICAgIGlmIChnbG9iYWxzLnRyYW5zaXRpb24gPT09IHRyYW5zKSBnbG9iYWxzLnRyYW5zaXRpb24gPSBudWxsO1xuICB9O1xuXG4gIHRyYW5zLm9uU3VjY2Vzcyh7fSwgdHJhbnNpdGlvblN1Y2Nlc3NmdWwsIHsgcHJpb3JpdHk6IDEwMDAwIH0pO1xuICB0cmFucy5wcm9taXNlLnRoZW4oY2xlYXJDdXJyZW50VHJhbnNpdGlvbiwgY2xlYXJDdXJyZW50VHJhbnNpdGlvbik7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCB1cGRhdGVHbG9iYWxTdGF0ZSk7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5pbXBvcnQgeyBVcmxSb3V0ZXIgfSBmcm9tICcuLi91cmwvdXJsUm91dGVyJztcbmltcG9ydCB7IFN0YXRlU2VydmljZSB9IGZyb20gJy4uL3N0YXRlL3N0YXRlU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rRm4gfSBmcm9tICcuLi90cmFuc2l0aW9uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UnO1xuXG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggdXBkYXRlcyB0aGUgVVJMIGFmdGVyIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGVVcmwpO2BcbiAqL1xuY29uc3QgdXBkYXRlVXJsOiBUcmFuc2l0aW9uSG9va0ZuID0gKHRyYW5zaXRpb246IFRyYW5zaXRpb24pID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRyYW5zaXRpb24ub3B0aW9ucygpO1xuICBjb25zdCAkc3RhdGU6IFN0YXRlU2VydmljZSA9IHRyYW5zaXRpb24ucm91dGVyLnN0YXRlU2VydmljZTtcbiAgY29uc3QgJHVybFJvdXRlcjogVXJsUm91dGVyID0gdHJhbnNpdGlvbi5yb3V0ZXIudXJsUm91dGVyO1xuXG4gIC8vIERvbnQgdXBkYXRlIHRoZSB1cmwgaW4gdGhlc2Ugc2l0dWF0aW9uczpcbiAgLy8gVGhlIHRyYW5zaXRpb24gd2FzIHRyaWdnZXJlZCBieSBhIFVSTCBzeW5jIChvcHRpb25zLnNvdXJjZSA9PT0gJ3VybCcpXG4gIC8vIFRoZSB1c2VyIGRvZXNuJ3Qgd2FudCB0aGUgdXJsIHRvIHVwZGF0ZSAob3B0aW9ucy5sb2NhdGlvbiA9PT0gZmFsc2UpXG4gIC8vIFRoZSBkZXN0aW5hdGlvbiBzdGF0ZSwgYW5kIGFsbCBwYXJlbnRzIGhhdmUgbm8gbmF2aWdhYmxlIHVybFxuICBpZiAob3B0aW9ucy5zb3VyY2UgIT09ICd1cmwnICYmIG9wdGlvbnMubG9jYXRpb24gJiYgJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSkge1xuICAgIGNvbnN0IHVybE9wdGlvbnMgPSB7IHJlcGxhY2U6IG9wdGlvbnMubG9jYXRpb24gPT09ICdyZXBsYWNlJyB9O1xuICAgICR1cmxSb3V0ZXIucHVzaCgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlLnVybCwgJHN0YXRlLnBhcmFtcywgdXJsT3B0aW9ucyk7XG4gIH1cblxuICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclVwZGF0ZVVybCA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsLCB7IHByaW9yaXR5OiA5OTk5IH0pO1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBUcmFuc2l0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkhvb2tGbiB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlRGVjbGFyYXRpb24sIExhenlMb2FkUmVzdWx0IH0gZnJvbSAnLi4vc3RhdGUvaW50ZXJmYWNlJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5pbXBvcnQgeyBTdGF0ZVJ1bGUgfSBmcm9tICcuLi91cmwvaW50ZXJmYWNlJztcblxuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcGVyZm9ybXMgbGF6eSBsb2FkaW5nXG4gKlxuICogV2hlbiBlbnRlcmluZyBhIHN0YXRlIFwiYWJjXCIgd2hpY2ggaGFzIGEgYGxhenlMb2FkYCBmdW5jdGlvbiBkZWZpbmVkOlxuICogLSBJbnZva2UgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gKHVubGVzcyBpdCBpcyBhbHJlYWR5IGluIHByb2Nlc3MpXG4gKiAgIC0gRmxhZyB0aGUgaG9vayBmdW5jdGlvbiBhcyBcImluIHByb2Nlc3NcIlxuICogICAtIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZSAodGhhdCByZXNvbHZlcyB3aGVuIGxhenkgbG9hZGluZyBpcyBjb21wbGV0ZSlcbiAqIC0gV2FpdCBmb3IgdGhlIHByb21pc2UgdG8gc2V0dGxlXG4gKiAgIC0gSWYgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBbW0xhenlMb2FkUmVzdWx0XV0sIHRoZW4gcmVnaXN0ZXIgdGhvc2Ugc3RhdGVzXG4gKiAgIC0gRmxhZyB0aGUgaG9vayBmdW5jdGlvbiBhcyBcIm5vdCBpbiBwcm9jZXNzXCJcbiAqIC0gSWYgdGhlIGhvb2sgd2FzIHN1Y2Nlc3NmdWxcbiAqICAgLSBSZW1vdmUgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gZnJvbSB0aGUgc3RhdGUgZGVjbGFyYXRpb25cbiAqIC0gSWYgYWxsIHRoZSBob29rcyB3ZXJlIHN1Y2Nlc3NmdWxcbiAqICAgLSBSZXRyeSB0aGUgdHJhbnNpdGlvbiAoYnkgcmV0dXJuaW5nIGEgVGFyZ2V0U3RhdGUpXG4gKlxuICogYGBgXG4gKiAuc3RhdGUoJ2FiYycsIHtcbiAqICAgY29tcG9uZW50OiAnZm9vQ29tcG9uZW50JyxcbiAqICAgbGF6eUxvYWQ6ICgpID0+IGltcG9ydCgnLi9mb29Db21wb25lbnQnKVxuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXVxuICovXG5jb25zdCBsYXp5TG9hZEhvb2s6IFRyYW5zaXRpb25Ib29rRm4gPSAodHJhbnNpdGlvbjogVHJhbnNpdGlvbikgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlcjtcblxuICBmdW5jdGlvbiByZXRyeVRyYW5zaXRpb24oKSB7XG4gICAgaWYgKHRyYW5zaXRpb24ub3JpZ2luYWxUcmFuc2l0aW9uKCkub3B0aW9ucygpLnNvdXJjZSAhPT0gJ3VybCcpIHtcbiAgICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBub3QgdHJpZ2dlcmVkIHZpYSB1cmwgc3luY1xuICAgICAgLy8gVGhlIGxhenkgc3RhdGUgc2hvdWxkIGJlIGxvYWRlZCBub3csIHNvIHJlLXRyeSB0aGUgb3JpZ2luYWwgdHJhbnNpdGlvblxuICAgICAgY29uc3Qgb3JpZyA9IHRyYW5zaXRpb24udGFyZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChvcmlnLmlkZW50aWZpZXIoKSwgb3JpZy5wYXJhbXMoKSwgb3JpZy5vcHRpb25zKCkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyB0cmlnZ2VyZWQgdmlhIHVybCBzeW5jXG4gICAgLy8gUnVuIHRoZSBVUkwgcnVsZXMgYW5kIGZpbmQgdGhlIGJlc3QgbWF0Y2hcbiAgICBjb25zdCAkdXJsID0gcm91dGVyLnVybFNlcnZpY2U7XG4gICAgY29uc3QgcmVzdWx0ID0gJHVybC5tYXRjaCgkdXJsLnBhcnRzKCkpO1xuICAgIGNvbnN0IHJ1bGUgPSByZXN1bHQgJiYgcmVzdWx0LnJ1bGU7XG5cbiAgICAvLyBJZiB0aGUgYmVzdCBtYXRjaCBpcyBhIHN0YXRlLCByZWRpcmVjdCB0aGUgdHJhbnNpdGlvbiAoaW5zdGVhZFxuICAgIC8vIG9mIGNhbGxpbmcgc3luYygpIHdoaWNoIHN1cGVyc2VkZXMgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbilcbiAgICBpZiAocnVsZSAmJiBydWxlLnR5cGUgPT09ICdTVEFURScpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gKHJ1bGUgYXMgU3RhdGVSdWxlKS5zdGF0ZTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHJlc3VsdC5tYXRjaDtcbiAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChzdGF0ZSwgcGFyYW1zLCB0cmFuc2l0aW9uLm9wdGlvbnMoKSk7XG4gICAgfVxuXG4gICAgLy8gTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQsIHNvIGxldCAuc3luYygpIGNob29zZSB0aGUgYmVzdCBub24tc3RhdGUgbWF0Y2gvb3RoZXJ3aXNlXG4gICAgcm91dGVyLnVybFNlcnZpY2Uuc3luYygpO1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZXMgPSB0cmFuc2l0aW9uXG4gICAgLmVudGVyaW5nKClcbiAgICAuZmlsdGVyKHN0YXRlID0+ICEhc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkKVxuICAgIC5tYXAoc3RhdGUgPT4gbGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uLCBzdGF0ZSkpO1xuXG4gIHJldHVybiBzZXJ2aWNlcy4kcS5hbGwocHJvbWlzZXMpLnRoZW4ocmV0cnlUcmFuc2l0aW9uKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlckxhenlMb2FkSG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHsgZW50ZXJpbmc6IHN0YXRlID0+ICEhc3RhdGUubGF6eUxvYWQgfSwgbGF6eUxvYWRIb29rKTtcblxuLyoqXG4gKiBJbnZva2VzIGEgc3RhdGUncyBsYXp5IGxvYWQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiBhIFRyYW5zaXRpb24gY29udGV4dFxuICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSB0byBsYXp5IGxvYWRcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgdGhlIGxhenkgbG9hZCByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbjogVHJhbnNpdGlvbiwgc3RhdGU6IFN0YXRlRGVjbGFyYXRpb24pOiBQcm9taXNlPExhenlMb2FkUmVzdWx0PiB7XG4gIGNvbnN0IGxhenlMb2FkRm4gPSBzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7XG5cbiAgLy8gU3RvcmUvZ2V0IHRoZSBsYXp5IGxvYWQgcHJvbWlzZSBvbi9mcm9tIHRoZSBob29rZm4gc28gaXQgZG9lc24ndCBnZXQgcmUtaW52b2tlZFxuICBsZXQgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gIGlmICghcHJvbWlzZSkge1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSByZXN1bHQgPT4ge1xuICAgICAgZGVsZXRlIHN0YXRlLmxhenlMb2FkO1xuICAgICAgZGVsZXRlIHN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDtcbiAgICAgIGRlbGV0ZSBsYXp5TG9hZEZuWydfcHJvbWlzZSddO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3QgZXJyb3IgPSBlcnIgPT4ge1xuICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICByZXR1cm4gc2VydmljZXMuJHEucmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHByb21pc2UgPSBsYXp5TG9hZEZuWydfcHJvbWlzZSddID0gc2VydmljZXMuJHFcbiAgICAgIC53aGVuKGxhenlMb2FkRm4odHJhbnNpdGlvbiwgc3RhdGUpKVxuICAgICAgLnRoZW4odXBkYXRlU3RhdGVSZWdpc3RyeSlcbiAgICAgIC50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlciBhbnkgbGF6eSBsb2FkZWQgc3RhdGUgZGVmaW5pdGlvbnMgKi9cbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGVSZWdpc3RyeShyZXN1bHQ6IExhenlMb2FkUmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5zdGF0ZXMpKSB7XG4gICAgICByZXN1bHQuc3RhdGVzLmZvckVhY2goX3N0YXRlID0+IHRyYW5zaXRpb24ucm91dGVyLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoX3N0YXRlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgdHJhbnNpdGlvbiAqLyAvKiogKi9cbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rUGhhc2UsIFBhdGhUeXBlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgR2V0RXJyb3JIYW5kbGVyLCBHZXRSZXN1bHRIYW5kbGVyLCBUcmFuc2l0aW9uSG9vayB9IGZyb20gJy4vdHJhbnNpdGlvbkhvb2snO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGRlZmluZXMgYSB0eXBlIG9mIGhvb2ssIHN1Y2ggYXMgYG9uQmVmb3JlYCBvciBgb25FbnRlcmAuXG4gKiBQbHVnaW5zIGNhbiBkZWZpbmUgY3VzdG9tIGhvb2sgdHlwZXMsIHN1Y2ggYXMgc3RpY2t5IHN0YXRlcyBkb2VzIGZvciBgb25JbmFjdGl2ZWAuXG4gKlxuICogQGludGVyYWxhcGlcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zaXRpb25FdmVudFR5cGUge1xuICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbmZlcnJhYmxlLXR5cGVzICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcsXG4gICAgcHVibGljIGhvb2tQaGFzZTogVHJhbnNpdGlvbkhvb2tQaGFzZSxcbiAgICBwdWJsaWMgaG9va09yZGVyOiBudW1iZXIsXG4gICAgcHVibGljIGNyaXRlcmlhTWF0Y2hQYXRoOiBQYXRoVHlwZSxcbiAgICBwdWJsaWMgcmV2ZXJzZVNvcnQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBwdWJsaWMgZ2V0UmVzdWx0SGFuZGxlcjogR2V0UmVzdWx0SGFuZGxlciA9IFRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQsXG4gICAgcHVibGljIGdldEVycm9ySGFuZGxlcjogR2V0RXJyb3JIYW5kbGVyID0gVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SLFxuICAgIHB1YmxpYyBzeW5jaHJvbm91czogYm9vbGVhbiA9IGZhbHNlXG4gICkge31cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSBob29rcyAqLyAvKiogKi9cblxuaW1wb3J0IHsgdHJhY2UgfSBmcm9tICcuLi9jb21tb24vdHJhY2UnO1xuaW1wb3J0IHsgUmVqZWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5JztcbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcblxuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgc2tpcHMgYSB0cmFuc2l0aW9uIGlmIGl0IHNob3VsZCBiZSBpZ25vcmVkXG4gKlxuICogVGhpcyBob29rIGlzIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgb25CZWZvcmUgcGhhc2UuXG4gKlxuICogSWYgdGhlIHRyYW5zaXRpb24gc2hvdWxkIGJlIGlnbm9yZWQgKGJlY2F1c2Ugbm8gcGFyYW1ldGVyIG9yIHN0YXRlcyBjaGFuZ2VkKVxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyBpZ25vcmVkIGFuZCBub3QgcHJvY2Vzc2VkLlxuICovXG5mdW5jdGlvbiBpZ25vcmVkSG9vayh0cmFuczogVHJhbnNpdGlvbikge1xuICBjb25zdCBpZ25vcmVkUmVhc29uID0gdHJhbnMuX2lnbm9yZWRSZWFzb24oKTtcbiAgaWYgKCFpZ25vcmVkUmVhc29uKSByZXR1cm47XG5cbiAgdHJhY2UudHJhY2VUcmFuc2l0aW9uSWdub3JlZCh0cmFucyk7XG5cbiAgY29uc3QgcGVuZGluZyA9IHRyYW5zLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb247XG5cbiAgLy8gVGhlIHVzZXIgY2xpY2tlZCBhIGxpbmsgZ29pbmcgYmFjayB0byB0aGUgKmN1cnJlbnQgc3RhdGUqICgnQScpXG4gIC8vIEhvd2V2ZXIsIHRoZXJlIGlzIGFsc28gYSBwZW5kaW5nIHRyYW5zaXRpb24gaW4gZmxpZ2h0ICh0byAnQicpXG4gIC8vIEFib3J0IHRoZSB0cmFuc2l0aW9uIHRvICdCJyBiZWNhdXNlIHRoZSB1c2VyIG5vdyB3YW50cyB0byBiZSBiYWNrIGF0ICdBJy5cbiAgaWYgKGlnbm9yZWRSZWFzb24gPT09ICdTYW1lQXNDdXJyZW50JyAmJiBwZW5kaW5nKSB7XG4gICAgcGVuZGluZy5hYm9ydCgpO1xuICB9XG5cbiAgcmV0dXJuIFJlamVjdGlvbi5pZ25vcmVkKCkudG9Qcm9taXNlKCk7XG59XG5cbmV4cG9ydCBjb25zdCByZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayA9ICh0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UpID0+XG4gIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpZ25vcmVkSG9vaywgeyBwcmlvcml0eTogLTk5OTkgfSk7XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5cbmltcG9ydCB7IFRyYW5zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcblxuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcmVqZWN0cyB0aGUgVHJhbnNpdGlvbiBpZiBpdCBpcyBpbnZhbGlkXG4gKlxuICogVGhpcyBob29rIGlzIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgb25CZWZvcmUgcGhhc2UuXG4gKiBJZiB0aGUgdHJhbnNpdGlvbiBpcyBpbnZhbGlkIChmb3IgZXhhbXBsZSwgcGFyYW0gdmFsdWVzIGRvIG5vdCB2YWxpZGF0ZSlcbiAqIHRoZW4gdGhlIHRyYW5zaXRpb24gaXMgcmVqZWN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRUcmFuc2l0aW9uSG9vayh0cmFuczogVHJhbnNpdGlvbikge1xuICBpZiAoIXRyYW5zLnZhbGlkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodHJhbnMuZXJyb3IoKS50b1N0cmluZygpKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJJbnZhbGlkVHJhbnNpdGlvbkhvb2sgPSAodHJhbnNpdGlvblNlcnZpY2U6IFRyYW5zaXRpb25TZXJ2aWNlKSA9PlxuICB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgaW52YWxpZFRyYW5zaXRpb25Ib29rLCB7IHByaW9yaXR5OiAtMTAwMDAgfSk7XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHRyYW5zaXRpb24gKi8gLyoqICovXG5pbXBvcnQge1xuICBJSG9va1JlZ2lzdHJ5LFxuICBUcmFuc2l0aW9uT3B0aW9ucyxcbiAgVHJhbnNpdGlvbkhvb2tTY29wZSxcbiAgVHJhbnNpdGlvbkhvb2tQaGFzZSxcbiAgVHJhbnNpdGlvbkNyZWF0ZUhvb2tGbixcbiAgSG9va01hdGNoQ3JpdGVyaWEsXG4gIEhvb2tSZWdPcHRpb25zLFxuICBQYXRoVHlwZXMsXG4gIFBhdGhUeXBlLFxuICBSZWdpc3RlcmVkSG9va3MsXG4gIFRyYW5zaXRpb25Ib29rRm4sXG4gIFRyYW5zaXRpb25TdGF0ZUhvb2tGbixcbn0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5pbXBvcnQgeyBtYWtlRXZlbnQsIFJlZ2lzdGVyZWRIb29rIH0gZnJvbSAnLi9ob29rUmVnaXN0cnknO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUgfSBmcm9tICcuLi9zdGF0ZS90YXJnZXRTdGF0ZSc7XG5pbXBvcnQgeyBQYXRoTm9kZSB9IGZyb20gJy4uL3BhdGgvcGF0aE5vZGUnO1xuaW1wb3J0IHsgVmlld1NlcnZpY2UgfSBmcm9tICcuLi92aWV3L3ZpZXcnO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgcmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXMsIHRyZWVDaGFuZ2VzQ2xlYW51cCB9IGZyb20gJy4uL2hvb2tzL2NvcmVSZXNvbHZhYmxlcyc7XG5pbXBvcnQgeyByZWdpc3RlclJlZGlyZWN0VG9Ib29rIH0gZnJvbSAnLi4vaG9va3MvcmVkaXJlY3RUbyc7XG5pbXBvcnQgeyByZWdpc3Rlck9uRXhpdEhvb2ssIHJlZ2lzdGVyT25SZXRhaW5Ib29rLCByZWdpc3Rlck9uRW50ZXJIb29rIH0gZnJvbSAnLi4vaG9va3Mvb25FbnRlckV4aXRSZXRhaW4nO1xuaW1wb3J0IHsgcmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoLCByZWdpc3RlckxhenlSZXNvbHZlU3RhdGUsIHJlZ2lzdGVyUmVzb2x2ZVJlbWFpbmluZyB9IGZyb20gJy4uL2hvb2tzL3Jlc29sdmUnO1xuaW1wb3J0IHsgcmVnaXN0ZXJMb2FkRW50ZXJpbmdWaWV3cywgcmVnaXN0ZXJBY3RpdmF0ZVZpZXdzIH0gZnJvbSAnLi4vaG9va3Mvdmlld3MnO1xuaW1wb3J0IHsgcmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSB9IGZyb20gJy4uL2hvb2tzL3VwZGF0ZUdsb2JhbHMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJVcGRhdGVVcmwgfSBmcm9tICcuLi9ob29rcy91cmwnO1xuaW1wb3J0IHsgcmVnaXN0ZXJMYXp5TG9hZEhvb2sgfSBmcm9tICcuLi9ob29rcy9sYXp5TG9hZCc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uRXZlbnRUeXBlIH0gZnJvbSAnLi90cmFuc2l0aW9uRXZlbnRUeXBlJztcbmltcG9ydCB7IFRyYW5zaXRpb25Ib29rLCBHZXRSZXN1bHRIYW5kbGVyLCBHZXRFcnJvckhhbmRsZXIgfSBmcm9tICcuL3RyYW5zaXRpb25Ib29rJztcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IHJlbW92ZUZyb20sIHZhbHVlcywgY3JlYXRlUHJveHlGdW5jdGlvbnMgfSBmcm9tICcuLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi9pbnRlcmZhY2UnOyAvLyBoYXMgb3IgaXMgdXNpbmdcbmltcG9ydCB7IHZhbCB9IGZyb20gJy4uL2NvbW1vbi9ob2YnO1xuaW1wb3J0IHsgcmVnaXN0ZXJJZ25vcmVkVHJhbnNpdGlvbkhvb2sgfSBmcm9tICcuLi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbic7XG5pbXBvcnQgeyByZWdpc3RlckludmFsaWRUcmFuc2l0aW9uSG9vayB9IGZyb20gJy4uL2hvb2tzL2ludmFsaWRUcmFuc2l0aW9uJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBbW1RyYW5zaXRpb25dXSBvcHRpb25zLlxuICpcbiAqIEluY2x1ZGUgdGhpcyBvYmplY3Qgd2hlbiBhcHBseWluZyBjdXN0b20gZGVmYXVsdHM6XG4gKiBsZXQgcmVsb2FkT3B0cyA9IHsgcmVsb2FkOiB0cnVlLCBub3RpZnk6IHRydWUgfVxuICogbGV0IG9wdGlvbnMgPSBkZWZhdWx0cyh0aGVpck9wdHMsIGN1c3RvbURlZmF1bHRzLCBkZWZhdWx0T3B0aW9ucyk7XG4gKi9cbmV4cG9ydCBsZXQgZGVmYXVsdFRyYW5zT3B0czogVHJhbnNpdGlvbk9wdGlvbnMgPSB7XG4gIGxvY2F0aW9uOiB0cnVlLFxuICByZWxhdGl2ZTogbnVsbCxcbiAgaW5oZXJpdDogZmFsc2UsXG4gIG5vdGlmeTogdHJ1ZSxcbiAgcmVsb2FkOiBmYWxzZSxcbiAgc3VwZXJjZWRlOiB0cnVlLFxuICBjdXN0b206IHt9LFxuICBjdXJyZW50OiAoKSA9PiBudWxsLFxuICBzb3VyY2U6ICd1bmtub3duJyxcbn07XG5cbi8qKlxuICogUGx1Z2luIEFQSSBmb3IgVHJhbnNpdGlvbiBTZXJ2aWNlXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2l0aW9uU2VydmljZVBsdWdpbkFQSSB7XG4gIC8qKlxuICAgKiBBZGRzIGEgUGF0aCB0byBiZSB1c2VkIGFzIGEgY3JpdGVyaW9uIGFnYWluc3QgYSBUcmVlQ2hhbmdlcyBwYXRoXG4gICAqXG4gICAqIEZvciBleGFtcGxlOiB0aGUgYGV4aXRpbmdgIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgU1RBVEUgc2NvcGVkIHBhdGguXG4gICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCdleGl0aW5nJywgVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSlgXG4gICAqIEVhY2ggc3RhdGUgaW4gdGhlIGV4aXRpbmcgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cbiAgICpcbiAgICogQW5vdGhlciBleGFtcGxlOiB0aGUgYHRvYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFRSQU5TSVRJT04gc2NvcGVkIHBhdGguXG4gICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCd0bycsIFRyYW5zaXRpb25Ib29rU2NvcGUuVFJBTlNJVElPTilgXG4gICAqIE9ubHkgdGhlIHRhaWwgb2YgdGhlIGB0b2AgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cbiAgICovXG4gIF9kZWZpbmVQYXRoVHlwZShuYW1lOiBzdHJpbmcsIGhvb2tTY29wZTogVHJhbnNpdGlvbkhvb2tTY29wZSk7XG5cbiAgLyoqXG4gICAqIEdldHMgYSBQYXRoIGRlZmluaXRpb24gdXNlZCBhcyBhIGNyaXRlcmlvbiBhZ2FpbnN0IGEgVHJlZUNoYW5nZXMgcGF0aFxuICAgKi9cbiAgX2dldFBhdGhUeXBlcygpOiBQYXRoVHlwZXM7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSB0cmFuc2l0aW9uIGhvb2sgdHlwZSBhbmQgcmV0dXJucyBhIHRyYW5zaXRpb24gaG9vayByZWdpc3RyYXRpb25cbiAgICogZnVuY3Rpb24gKHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgaG9va3Mgb2YgdGhpcyB0eXBlKS5cbiAgICovXG4gIF9kZWZpbmVFdmVudChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgaG9va1BoYXNlOiBUcmFuc2l0aW9uSG9va1BoYXNlLFxuICAgIGhvb2tPcmRlcjogbnVtYmVyLFxuICAgIGNyaXRlcmlhTWF0Y2hQYXRoOiBQYXRoVHlwZSxcbiAgICByZXZlcnNlU29ydD86IGJvb2xlYW4sXG4gICAgZ2V0UmVzdWx0SGFuZGxlcj86IEdldFJlc3VsdEhhbmRsZXIsXG4gICAgZ2V0RXJyb3JIYW5kbGVyPzogR2V0RXJyb3JIYW5kbGVyLFxuICAgIHJlamVjdElmU3VwZXJzZWRlZD86IGJvb2xlYW5cbiAgKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga25vd24gZXZlbnQgdHlwZXMsIHN1Y2ggYXMgYG9uQmVmb3JlYFxuICAgKiBJZiBhIHBoYXNlIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCByZXR1cm5zIG9ubHkgZXZlbnRzIGZvciB0aGUgZ2l2ZW4gcGhhc2UuXG4gICAqL1xuICBfZ2V0RXZlbnRzKHBoYXNlPzogVHJhbnNpdGlvbkhvb2tQaGFzZSk6IFRyYW5zaXRpb25FdmVudFR5cGVbXTtcblxuICAvKiogUmV0dXJucyB0aGUgaG9va3MgcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIGhvb2sgbmFtZSAqL1xuICBnZXRIb29rcyhob29rTmFtZTogc3RyaW5nKTogUmVnaXN0ZXJlZEhvb2tbXTtcbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gVHJhbnNpdGlvbnMuXG4gKlxuICogLSBNb3N0IGltcG9ydGFudGx5LCBpdCBhbGxvd3MgZ2xvYmFsIFRyYW5zaXRpb24gSG9va3MgdG8gYmUgcmVnaXN0ZXJlZC5cbiAqIC0gSXQgYWxsb3dzIHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gZXJyb3IgaGFuZGxlciB0byBiZSBzZXQuXG4gKiAtIEl0IGFsc28gaGFzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFtbVHJhbnNpdGlvbl1dIG9iamVjdHMsICh1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0pLlxuICpcbiAqIEF0IGJvb3RzdHJhcCwgW1tVSVJvdXRlcl1dIGNyZWF0ZXMgYSBzaW5nbGUgaW5zdGFuY2UgKHNpbmdsZXRvbikgb2YgdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zaXRpb25TZXJ2aWNlIGltcGxlbWVudHMgSUhvb2tSZWdpc3RyeSwgRGlzcG9zYWJsZSB7XG4gIC8qKiBAaGlkZGVuICovXG4gIF90cmFuc2l0aW9uQ291bnQgPSAwO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIHB1YmxpYyAkdmlldzogVmlld1NlcnZpY2U7XG5cbiAgLyoqIEBoaWRkZW4gVGhlIHRyYW5zaXRpb24gaG9vayB0eXBlcywgc3VjaCBhcyBgb25FbnRlcmAsIGBvblN0YXJ0YCwgZXRjICovXG4gIHByaXZhdGUgX2V2ZW50VHlwZXM6IFRyYW5zaXRpb25FdmVudFR5cGVbXSA9IFtdO1xuICAvKiogQGhpZGRlbiBUaGUgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tzICovXG4gIF9yZWdpc3RlcmVkSG9va3MgPSB7fSBhcyBSZWdpc3RlcmVkSG9va3M7XG4gIC8qKiBAaGlkZGVuIFRoZSAgcGF0aHMgb24gYSBjcml0ZXJpYSBvYmplY3QgKi9cbiAgcHJpdmF0ZSBfY3JpdGVyaWFQYXRocyA9IHt9IGFzIFBhdGhUeXBlcztcbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfcm91dGVyOiBVSVJvdXRlcjtcblxuICAvKiogQGludGVybmFsYXBpICovXG4gIF9wbHVnaW5hcGk6IFRyYW5zaXRpb25TZXJ2aWNlUGx1Z2luQVBJO1xuXG4gIC8qKlxuICAgKiBUaGlzIG9iamVjdCBoYXMgaG9vayBkZS1yZWdpc3RyYXRpb24gZnVuY3Rpb25zIGZvciB0aGUgYnVpbHQtaW4gaG9va3MuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgYnkgdGhpcmQgcGFydGllcyBsaWJyYXJpZXMgdGhhdCB3aXNoIHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3JzXG4gICAqXG4gICAqIEBoaWRkZW5cbiAgICovXG4gIF9kZXJlZ2lzdGVySG9va0Zuczoge1xuICAgIGFkZENvcmVSZXNvbHZlczogRnVuY3Rpb247XG4gICAgaWdub3JlZDogRnVuY3Rpb247XG4gICAgaW52YWxpZDogRnVuY3Rpb247XG4gICAgcmVkaXJlY3RUbzogRnVuY3Rpb247XG4gICAgb25FeGl0OiBGdW5jdGlvbjtcbiAgICBvblJldGFpbjogRnVuY3Rpb247XG4gICAgb25FbnRlcjogRnVuY3Rpb247XG4gICAgZWFnZXJSZXNvbHZlOiBGdW5jdGlvbjtcbiAgICBsYXp5UmVzb2x2ZTogRnVuY3Rpb247XG4gICAgcmVzb2x2ZUFsbDogRnVuY3Rpb247XG4gICAgbG9hZFZpZXdzOiBGdW5jdGlvbjtcbiAgICBhY3RpdmF0ZVZpZXdzOiBGdW5jdGlvbjtcbiAgICB1cGRhdGVHbG9iYWxzOiBGdW5jdGlvbjtcbiAgICB1cGRhdGVVcmw6IEZ1bmN0aW9uO1xuICAgIGxhenlMb2FkOiBGdW5jdGlvbjtcbiAgfTtcblxuICAvKiogQGhpZGRlbiAqL1xuICBjb25zdHJ1Y3Rvcihfcm91dGVyOiBVSVJvdXRlcikge1xuICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XG4gICAgdGhpcy4kdmlldyA9IF9yb3V0ZXIudmlld1NlcnZpY2U7XG4gICAgdGhpcy5fZGVyZWdpc3Rlckhvb2tGbnMgPSA8YW55Pnt9O1xuICAgIHRoaXMuX3BsdWdpbmFwaSA9IDxUcmFuc2l0aW9uU2VydmljZVBsdWdpbkFQST4oXG4gICAgICBjcmVhdGVQcm94eUZ1bmN0aW9ucyh2YWwodGhpcyksIHt9LCB2YWwodGhpcyksIFtcbiAgICAgICAgJ19kZWZpbmVQYXRoVHlwZScsXG4gICAgICAgICdfZGVmaW5lRXZlbnQnLFxuICAgICAgICAnX2dldFBhdGhUeXBlcycsXG4gICAgICAgICdfZ2V0RXZlbnRzJyxcbiAgICAgICAgJ2dldEhvb2tzJyxcbiAgICAgIF0pXG4gICAgKTtcblxuICAgIHRoaXMuX2RlZmluZUNvcmVQYXRocygpO1xuICAgIHRoaXMuX2RlZmluZUNvcmVFdmVudHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlckNvcmVUcmFuc2l0aW9uSG9va3MoKTtcbiAgICBfcm91dGVyLmdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLm9uRXZpY3QodHJlZUNoYW5nZXNDbGVhbnVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSwgY2FsbGVkICp3aGlsZSBhIHRyYW5zaXRpb24gaXMgYmVpbmcgY29uc3RydWN0ZWQqLlxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGR1cmluZyB0cmFuc2l0aW9uIGNvbnN0cnVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBsb3cgbGV2ZWwgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGJ5IHBsdWdpbnMuXG4gICAqIFRoaXMgY2FuIGJlIGEgdXNlZnVsIHRpbWUgZm9yIHBsdWdpbnMgdG8gYWRkIHJlc29sdmVzIG9yIG11dGF0ZSB0aGUgdHJhbnNpdGlvbiBhcyBuZWVkZWQuXG4gICAqIFRoZSBTdGlja3kgU3RhdGVzIHBsdWdpbiB1c2VzIHRoaXMgaG9vayB0byBtb2RpZnkgdGhlIHRyZWVjaGFuZ2VzLlxuICAgKlxuICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAqXG4gICAqIGBvbkNyZWF0ZWAgaG9va3MgYXJlIGludm9rZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXG4gICAqXG4gICAqICMjIyBSZXR1cm4gdmFsdWVcbiAgICpcbiAgICogVGhlIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICogQHBhcmFtIGNyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbnZva2VkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgcmVnaXN0cmF0aW9uIG9wdGlvbnNcbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICovXG4gIG9uQ3JlYXRlKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25DcmVhdGVIb29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uQmVmb3JlKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uU3RhcnQoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25FeGl0KGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25SZXRhaW4oY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvblN0YXRlSG9va0ZuLCBvcHRpb25zPzogSG9va1JlZ09wdGlvbnMpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBvbkVudGVyKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25TdGF0ZUhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25GaW5pc2goY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgb25TdWNjZXNzKGNyaXRlcmlhOiBIb29rTWF0Y2hDcml0ZXJpYSwgY2FsbGJhY2s6IFRyYW5zaXRpb25Ib29rRm4sIG9wdGlvbnM/OiBIb29rUmVnT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIG9uRXJyb3IoY3JpdGVyaWE6IEhvb2tNYXRjaENyaXRlcmlhLCBjYWxsYmFjazogVHJhbnNpdGlvbkhvb2tGbiwgb3B0aW9ucz86IEhvb2tSZWdPcHRpb25zKTogRnVuY3Rpb24ge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXNwb3NlXG4gICAqIEBpbnRlcm5hbGFwaVxuICAgKi9cbiAgZGlzcG9zZShyb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgdmFsdWVzKHRoaXMuX3JlZ2lzdGVyZWRIb29rcykuZm9yRWFjaCgoaG9va3NBcnJheTogUmVnaXN0ZXJlZEhvb2tbXSkgPT5cbiAgICAgIGhvb2tzQXJyYXkuZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgaG9vay5fZGVyZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlRnJvbShob29rc0FycmF5LCBob29rKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFtbVHJhbnNpdGlvbl1dIG9iamVjdFxuICAgKlxuICAgKiBUaGlzIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFRyYW5zaXRpb24gb2JqZWN0cy5cbiAgICogSXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbW1N0YXRlU2VydmljZV1dIGFuZCBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSBjYWxsZWQgYnkgYXBwbGljYXRpb24gY29kZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21QYXRoIHRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IHN0YXRlICh0aGUgZnJvbSBzdGF0ZSlcbiAgICogQHBhcmFtIHRhcmdldFN0YXRlIHRoZSB0YXJnZXQgc3RhdGUgKGRlc3RpbmF0aW9uKVxuICAgKiBAcmV0dXJucyBhIFRyYW5zaXRpb25cbiAgICovXG4gIGNyZWF0ZShmcm9tUGF0aDogUGF0aE5vZGVbXSwgdGFyZ2V0U3RhdGU6IFRhcmdldFN0YXRlKTogVHJhbnNpdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgdGhpcy5fcm91dGVyKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2RlZmluZUNvcmVFdmVudHMoKSB7XG4gICAgY29uc3QgUGhhc2UgPSBUcmFuc2l0aW9uSG9va1BoYXNlO1xuICAgIGNvbnN0IFRIID0gVHJhbnNpdGlvbkhvb2s7XG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLl9jcml0ZXJpYVBhdGhzO1xuICAgIGNvbnN0IE5PUk1BTF9TT1JUID0gZmFsc2UsXG4gICAgICBSRVZFUlNFX1NPUlQgPSB0cnVlO1xuICAgIGNvbnN0IFNZTkNIUk9OT1VTID0gdHJ1ZTtcblxuICAgIHRoaXMuX2RlZmluZUV2ZW50KFxuICAgICAgJ29uQ3JlYXRlJyxcbiAgICAgIFBoYXNlLkNSRUFURSxcbiAgICAgIDAsXG4gICAgICBwYXRocy50byxcbiAgICAgIE5PUk1BTF9TT1JULFxuICAgICAgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCxcbiAgICAgIFRILlRIUk9XX0VSUk9SLFxuICAgICAgU1lOQ0hST05PVVNcbiAgICApO1xuXG4gICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uQmVmb3JlJywgUGhhc2UuQkVGT1JFLCAwLCBwYXRocy50byk7XG5cbiAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25TdGFydCcsIFBoYXNlLlJVTiwgMCwgcGF0aHMudG8pO1xuICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkV4aXQnLCBQaGFzZS5SVU4sIDEwMCwgcGF0aHMuZXhpdGluZywgUkVWRVJTRV9TT1JUKTtcbiAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25SZXRhaW4nLCBQaGFzZS5SVU4sIDIwMCwgcGF0aHMucmV0YWluZWQpO1xuICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkVudGVyJywgUGhhc2UuUlVOLCAzMDAsIHBhdGhzLmVudGVyaW5nKTtcbiAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25GaW5pc2gnLCBQaGFzZS5SVU4sIDQwMCwgcGF0aHMudG8pO1xuXG4gICAgdGhpcy5fZGVmaW5lRXZlbnQoXG4gICAgICAnb25TdWNjZXNzJyxcbiAgICAgIFBoYXNlLlNVQ0NFU1MsXG4gICAgICAwLFxuICAgICAgcGF0aHMudG8sXG4gICAgICBOT1JNQUxfU09SVCxcbiAgICAgIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsXG4gICAgICBUSC5MT0dfRVJST1IsXG4gICAgICBTWU5DSFJPTk9VU1xuICAgICk7XG4gICAgdGhpcy5fZGVmaW5lRXZlbnQoXG4gICAgICAnb25FcnJvcicsXG4gICAgICBQaGFzZS5FUlJPUixcbiAgICAgIDAsXG4gICAgICBwYXRocy50byxcbiAgICAgIE5PUk1BTF9TT1JULFxuICAgICAgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCxcbiAgICAgIFRILkxPR19FUlJPUixcbiAgICAgIFNZTkNIUk9OT1VTXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIHByaXZhdGUgX2RlZmluZUNvcmVQYXRocygpIHtcbiAgICBjb25zdCB7IFNUQVRFLCBUUkFOU0lUSU9OIH0gPSBUcmFuc2l0aW9uSG9va1Njb3BlO1xuXG4gICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ3RvJywgVFJBTlNJVElPTik7XG4gICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ2Zyb20nLCBUUkFOU0lUSU9OKTtcbiAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgnZXhpdGluZycsIFNUQVRFKTtcbiAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgncmV0YWluZWQnLCBTVEFURSk7XG4gICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ2VudGVyaW5nJywgU1RBVEUpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgX2RlZmluZUV2ZW50KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBob29rUGhhc2U6IFRyYW5zaXRpb25Ib29rUGhhc2UsXG4gICAgaG9va09yZGVyOiBudW1iZXIsXG4gICAgY3JpdGVyaWFNYXRjaFBhdGg6IFBhdGhUeXBlLFxuICAgIHJldmVyc2VTb3J0ID0gZmFsc2UsXG4gICAgZ2V0UmVzdWx0SGFuZGxlcjogR2V0UmVzdWx0SGFuZGxlciA9IFRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQsXG4gICAgZ2V0RXJyb3JIYW5kbGVyOiBHZXRFcnJvckhhbmRsZXIgPSBUcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1IsXG4gICAgc3luY2hyb25vdXMgPSBmYWxzZVxuICApIHtcbiAgICBjb25zdCBldmVudFR5cGUgPSBuZXcgVHJhbnNpdGlvbkV2ZW50VHlwZShcbiAgICAgIG5hbWUsXG4gICAgICBob29rUGhhc2UsXG4gICAgICBob29rT3JkZXIsXG4gICAgICBjcml0ZXJpYU1hdGNoUGF0aCxcbiAgICAgIHJldmVyc2VTb3J0LFxuICAgICAgZ2V0UmVzdWx0SGFuZGxlcixcbiAgICAgIGdldEVycm9ySGFuZGxlcixcbiAgICAgIHN5bmNocm9ub3VzXG4gICAgKTtcblxuICAgIHRoaXMuX2V2ZW50VHlwZXMucHVzaChldmVudFR5cGUpO1xuICAgIG1ha2VFdmVudCh0aGlzLCB0aGlzLCBldmVudFR5cGUpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gIHByaXZhdGUgX2dldEV2ZW50cyhwaGFzZT86IFRyYW5zaXRpb25Ib29rUGhhc2UpOiBUcmFuc2l0aW9uRXZlbnRUeXBlW10ge1xuICAgIGNvbnN0IHRyYW5zaXRpb25Ib29rVHlwZXMgPSBpc0RlZmluZWQocGhhc2UpXG4gICAgICA/IHRoaXMuX2V2ZW50VHlwZXMuZmlsdGVyKHR5cGUgPT4gdHlwZS5ob29rUGhhc2UgPT09IHBoYXNlKVxuICAgICAgOiB0aGlzLl9ldmVudFR5cGVzLnNsaWNlKCk7XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tUeXBlcy5zb3J0KChsLCByKSA9PiB7XG4gICAgICBjb25zdCBjbXBCeVBoYXNlID0gbC5ob29rUGhhc2UgLSByLmhvb2tQaGFzZTtcbiAgICAgIHJldHVybiBjbXBCeVBoYXNlID09PSAwID8gbC5ob29rT3JkZXIgLSByLmhvb2tPcmRlciA6IGNtcEJ5UGhhc2U7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIFBhdGggdG8gYmUgdXNlZCBhcyBhIGNyaXRlcmlvbiBhZ2FpbnN0IGEgVHJlZUNoYW5nZXMgcGF0aFxuICAgKlxuICAgKiBGb3IgZXhhbXBsZTogdGhlIGBleGl0aW5nYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFNUQVRFIHNjb3BlZCBwYXRoLlxuICAgKiBJdCB3YXMgZGVmaW5lZCBieSBjYWxsaW5nIGBkZWZpbmVUcmVlQ2hhbmdlc0NyaXRlcmlvbignZXhpdGluZycsIFRyYW5zaXRpb25Ib29rU2NvcGUuU1RBVEUpYFxuICAgKiBFYWNoIHN0YXRlIGluIHRoZSBleGl0aW5nIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAqXG4gICAqIEFub3RoZXIgZXhhbXBsZTogdGhlIGB0b2AgcGF0aCBpbiBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgYSBUUkFOU0lUSU9OIHNjb3BlZCBwYXRoLlxuICAgKiBJdCB3YXMgZGVmaW5lZCBieSBjYWxsaW5nIGBkZWZpbmVUcmVlQ2hhbmdlc0NyaXRlcmlvbigndG8nLCBUcmFuc2l0aW9uSG9va1Njb3BlLlRSQU5TSVRJT04pYFxuICAgKiBPbmx5IHRoZSB0YWlsIG9mIHRoZSBgdG9gIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAqXG4gICAqIEBoaWRkZW5cbiAgICovXG4gIHByaXZhdGUgX2RlZmluZVBhdGhUeXBlKG5hbWU6IHN0cmluZywgaG9va1Njb3BlOiBUcmFuc2l0aW9uSG9va1Njb3BlKSB7XG4gICAgdGhpcy5fY3JpdGVyaWFQYXRoc1tuYW1lXSA9IHsgbmFtZSwgc2NvcGU6IGhvb2tTY29wZSB9O1xuICB9XG5cbiAgLyoqICogQGhpZGRlbiAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgcHJpdmF0ZSBfZ2V0UGF0aFR5cGVzKCk6IFBhdGhUeXBlcyB7XG4gICAgcmV0dXJuIHRoaXMuX2NyaXRlcmlhUGF0aHM7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBwdWJsaWMgZ2V0SG9va3MoaG9va05hbWU6IHN0cmluZyk6IFJlZ2lzdGVyZWRIb29rW10ge1xuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkSG9va3NbaG9va05hbWVdO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJDb3JlVHJhbnNpdGlvbkhvb2tzKCkge1xuICAgIGNvbnN0IGZucyA9IHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zO1xuXG4gICAgZm5zLmFkZENvcmVSZXNvbHZlcyA9IHJlZ2lzdGVyQWRkQ29yZVJlc29sdmFibGVzKHRoaXMpO1xuICAgIGZucy5pZ25vcmVkID0gcmVnaXN0ZXJJZ25vcmVkVHJhbnNpdGlvbkhvb2sodGhpcyk7XG4gICAgZm5zLmludmFsaWQgPSByZWdpc3RlckludmFsaWRUcmFuc2l0aW9uSG9vayh0aGlzKTtcblxuICAgIC8vIFdpcmUgdXAgcmVkaXJlY3RUbyBob29rXG4gICAgZm5zLnJlZGlyZWN0VG8gPSByZWdpc3RlclJlZGlyZWN0VG9Ib29rKHRoaXMpO1xuXG4gICAgLy8gV2lyZSB1cCBvbkV4aXQvUmV0YWluL0VudGVyIHN0YXRlIGhvb2tzXG4gICAgZm5zLm9uRXhpdCA9IHJlZ2lzdGVyT25FeGl0SG9vayh0aGlzKTtcbiAgICBmbnMub25SZXRhaW4gPSByZWdpc3Rlck9uUmV0YWluSG9vayh0aGlzKTtcbiAgICBmbnMub25FbnRlciA9IHJlZ2lzdGVyT25FbnRlckhvb2sodGhpcyk7XG5cbiAgICAvLyBXaXJlIHVwIFJlc29sdmUgaG9va3NcbiAgICBmbnMuZWFnZXJSZXNvbHZlID0gcmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoKHRoaXMpO1xuICAgIGZucy5sYXp5UmVzb2x2ZSA9IHJlZ2lzdGVyTGF6eVJlc29sdmVTdGF0ZSh0aGlzKTtcbiAgICBmbnMucmVzb2x2ZUFsbCA9IHJlZ2lzdGVyUmVzb2x2ZVJlbWFpbmluZyh0aGlzKTtcblxuICAgIC8vIFdpcmUgdXAgdGhlIFZpZXcgbWFuYWdlbWVudCBob29rc1xuICAgIGZucy5sb2FkVmlld3MgPSByZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzKHRoaXMpO1xuICAgIGZucy5hY3RpdmF0ZVZpZXdzID0gcmVnaXN0ZXJBY3RpdmF0ZVZpZXdzKHRoaXMpO1xuXG4gICAgLy8gVXBkYXRlcyBnbG9iYWwgc3RhdGUgYWZ0ZXIgYSB0cmFuc2l0aW9uXG4gICAgZm5zLnVwZGF0ZUdsb2JhbHMgPSByZWdpc3RlclVwZGF0ZUdsb2JhbFN0YXRlKHRoaXMpO1xuXG4gICAgLy8gQWZ0ZXIgZ2xvYmFscy5jdXJyZW50IGlzIHVwZGF0ZWQgYXQgcHJpb3JpdHk6IDEwMDAwXG4gICAgZm5zLnVwZGF0ZVVybCA9IHJlZ2lzdGVyVXBkYXRlVXJsKHRoaXMpO1xuXG4gICAgLy8gTGF6eSBsb2FkIHN0YXRlIHRyZWVzXG4gICAgZm5zLmxhenlMb2FkID0gcmVnaXN0ZXJMYXp5TG9hZEhvb2sodGhpcyk7XG4gIH1cbn1cbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgc3RhdGUgKi8gLyoqICovXG5pbXBvcnQge1xuICBjcmVhdGVQcm94eUZ1bmN0aW9ucyxcbiAgZGVmYXVsdHMsXG4gIGV4dGVuZCxcbiAgaW5BcnJheSxcbiAgbm9vcCxcbiAgcmVtb3ZlRnJvbSxcbiAgc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlLFxuICBzaWxlbnRSZWplY3Rpb24sXG59IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNTdHJpbmcgfSBmcm9tICcuLi9jb21tb24vcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBRdWV1ZSB9IGZyb20gJy4uL2NvbW1vbi9xdWV1ZSc7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuXG5pbXBvcnQgeyBQYXRoVXRpbHMgfSBmcm9tICcuLi9wYXRoL3BhdGhVdGlscyc7XG5pbXBvcnQgeyBQYXRoTm9kZSB9IGZyb20gJy4uL3BhdGgvcGF0aE5vZGUnO1xuXG5pbXBvcnQgeyBIb29rUmVzdWx0LCBUcmFuc2l0aW9uT3B0aW9ucyB9IGZyb20gJy4uL3RyYW5zaXRpb24vaW50ZXJmYWNlJztcbmltcG9ydCB7IGRlZmF1bHRUcmFuc09wdHMgfSBmcm9tICcuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFJlamVjdGlvbiwgUmVqZWN0VHlwZSB9IGZyb20gJy4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeSc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uJztcblxuaW1wb3J0IHsgSHJlZk9wdGlvbnMsIExhenlMb2FkUmVzdWx0LCBTdGF0ZURlY2xhcmF0aW9uLCBTdGF0ZU9yTmFtZSwgVHJhbnNpdGlvblByb21pc2UgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4vc3RhdGVPYmplY3QnO1xuaW1wb3J0IHsgVGFyZ2V0U3RhdGUgfSBmcm9tICcuL3RhcmdldFN0YXRlJztcblxuaW1wb3J0IHsgUmF3UGFyYW1zIH0gZnJvbSAnLi4vcGFyYW1zL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9wYXJhbSc7XG5pbXBvcnQgeyBHbG9iIH0gZnJvbSAnLi4vY29tbW9uL2dsb2InO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgVUlJbmplY3RvciB9IGZyb20gJy4uL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBSZXNvbHZlQ29udGV4dCB9IGZyb20gJy4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQnO1xuaW1wb3J0IHsgbGF6eUxvYWRTdGF0ZSB9IGZyb20gJy4uL2hvb2tzL2xhenlMb2FkJztcbmltcG9ydCB7IG5vdCwgdmFsIH0gZnJvbSAnLi4vY29tbW9uL2hvZic7XG5pbXBvcnQgeyBTdGF0ZVBhcmFtcyB9IGZyb20gJy4uL3BhcmFtcy9zdGF0ZVBhcmFtcyc7XG5cbmV4cG9ydCB0eXBlIE9uSW52YWxpZENhbGxiYWNrID0gKHRvU3RhdGU/OiBUYXJnZXRTdGF0ZSwgZnJvbVN0YXRlPzogVGFyZ2V0U3RhdGUsIGluamVjdG9yPzogVUlJbmplY3RvcikgPT4gSG9va1Jlc3VsdDtcblxuLyoqXG4gKiBQcm92aWRlcyBzdGF0ZSByZWxhdGVkIHNlcnZpY2UgZnVuY3Rpb25zXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHVpLXJvdXRlciBzdGF0ZXMuXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGxvY2F0ZWQgb24gdGhlIGdsb2JhbCBbW1VJUm91dGVyXV0gb2JqZWN0LlxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVTZXJ2aWNlIHtcbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBpbnZhbGlkQ2FsbGJhY2tzOiBPbkludmFsaWRDYWxsYmFja1tdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBbW1RyYW5zaXRpb25dXSBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MgKG9yIG51bGwpXG4gICAqXG4gICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLnRyYW5zaXRpb25dXVxuICAgKi9cbiAgZ2V0IHRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGxhdGVzdCBzdWNjZXNzZnVsIHN0YXRlIHBhcmFtZXRlcnNcbiAgICpcbiAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAgICovXG4gIGdldCBwYXJhbXMoKTogU3RhdGVQYXJhbXMge1xuICAgIHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLnBhcmFtcztcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgW1tTdGF0ZURlY2xhcmF0aW9uXV1cbiAgICpcbiAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMuY3VycmVudF1dXG4gICAqL1xuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBbW1N0YXRlT2JqZWN0XV1cbiAgICpcbiAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMuJGN1cnJlbnRdXVxuICAgKi9cbiAgZ2V0ICRjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLiRjdXJyZW50O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBjb25zdHJ1Y3RvcigvKiogQGhpZGRlbiAqLyBwcml2YXRlIHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBjb25zdCBnZXR0ZXJzID0gWydjdXJyZW50JywgJyRjdXJyZW50JywgJ3BhcmFtcycsICd0cmFuc2l0aW9uJ107XG4gICAgY29uc3QgYm91bmRGbnMgPSBPYmplY3Qua2V5cyhTdGF0ZVNlcnZpY2UucHJvdG90eXBlKS5maWx0ZXIobm90KGluQXJyYXkoZ2V0dGVycykpKTtcbiAgICBjcmVhdGVQcm94eUZ1bmN0aW9ucyh2YWwoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSksIHRoaXMsIHZhbCh0aGlzKSwgYm91bmRGbnMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGVmYXVsdEVycm9ySGFuZGxlcihub29wKTtcbiAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuIFtbdHJhbnNpdGlvblRvXV0gaXMgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBzdGF0ZS5cbiAgICpcbiAgICogSW52b2tlcyB0aGUgW1tvbkludmFsaWRdXSBjYWxsYmFja3MsIGluIG5hdHVyYWwgb3JkZXIuXG4gICAqIEVhY2ggY2FsbGJhY2sncyByZXR1cm4gdmFsdWUgaXMgY2hlY2tlZCBpbiBzZXF1ZW5jZSB1bnRpbCBvbmUgb2YgdGhlbSByZXR1cm5zIGFuIGluc3RhbmNlIG9mIFRhcmdldFN0YXRlLlxuICAgKiBUaGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2tzIGFyZSB3cmFwcGVkIGluICRxLndoZW4oKSwgc28gdGhlIGNhbGxiYWNrcyBtYXkgcmV0dXJuIHByb21pc2VzLlxuICAgKlxuICAgKiBJZiBhIGNhbGxiYWNrIHJldHVybnMgYW4gVGFyZ2V0U3RhdGUsIHRoZW4gaXQgaXMgdXNlZCBhcyBhcmd1bWVudHMgdG8gJHN0YXRlLnRyYW5zaXRpb25UbygpIGFuZCB0aGUgcmVzdWx0IHJldHVybmVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxhcGlcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZShmcm9tUGF0aDogUGF0aE5vZGVbXSwgdG9TdGF0ZTogVGFyZ2V0U3RhdGUpIHtcbiAgICBjb25zdCBmcm9tU3RhdGUgPSBQYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGZyb21QYXRoKTtcbiAgICBjb25zdCBnbG9iYWxzID0gdGhpcy5yb3V0ZXIuZ2xvYmFscztcbiAgICBjb25zdCBsYXRlc3RUaGluZyA9ICgpID0+IGdsb2JhbHMudHJhbnNpdGlvbkhpc3RvcnkucGVla1RhaWwoKTtcbiAgICBjb25zdCBsYXRlc3QgPSBsYXRlc3RUaGluZygpO1xuICAgIGNvbnN0IGNhbGxiYWNrUXVldWUgPSBuZXcgUXVldWU8T25JbnZhbGlkQ2FsbGJhY2s+KHRoaXMuaW52YWxpZENhbGxiYWNrcy5zbGljZSgpKTtcbiAgICBjb25zdCBpbmplY3RvciA9IG5ldyBSZXNvbHZlQ29udGV4dChmcm9tUGF0aCkuaW5qZWN0b3IoKTtcblxuICAgIGNvbnN0IGNoZWNrRm9yUmVkaXJlY3QgPSAocmVzdWx0OiBIb29rUmVzdWx0KSA9PiB7XG4gICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBUYXJnZXRTdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGFyZ2V0ID0gPFRhcmdldFN0YXRlPnJlc3VsdDtcbiAgICAgIC8vIFJlY3JlYXRlIHRoZSBUYXJnZXRTdGF0ZSwgaW4gY2FzZSB0aGUgc3RhdGUgaXMgbm93IGRlZmluZWQuXG4gICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCh0YXJnZXQuaWRlbnRpZmllcigpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpO1xuXG4gICAgICBpZiAoIXRhcmdldC52YWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBSZWplY3Rpb24uaW52YWxpZCh0YXJnZXQuZXJyb3IoKSkudG9Qcm9taXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXRlc3RUaGluZygpICE9PSBsYXRlc3QpIHtcbiAgICAgICAgcmV0dXJuIFJlamVjdGlvbi5zdXBlcnNlZGVkKCkudG9Qcm9taXNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0YXJnZXQuaWRlbnRpZmllcigpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbnZva2VOZXh0Q2FsbGJhY2soKSB7XG4gICAgICBjb25zdCBuZXh0Q2FsbGJhY2sgPSBjYWxsYmFja1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgIGlmIChuZXh0Q2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFJlamVjdGlvbi5pbnZhbGlkKHRvU3RhdGUuZXJyb3IoKSkudG9Qcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrUmVzdWx0ID0gc2VydmljZXMuJHEud2hlbihuZXh0Q2FsbGJhY2sodG9TdGF0ZSwgZnJvbVN0YXRlLCBpbmplY3RvcikpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrUmVzdWx0LnRoZW4oY2hlY2tGb3JSZWRpcmVjdCkudGhlbihyZXN1bHQgPT4gcmVzdWx0IHx8IGludm9rZU5leHRDYWxsYmFjaygpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW52b2tlTmV4dENhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIEludmFsaWQgU3RhdGUgaGFuZGxlclxuICAgKlxuICAgKiBSZWdpc3RlcnMgYSBbW09uSW52YWxpZENhbGxiYWNrXV0gZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXG4gICAqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgc3RhdGUgcmVmZXJlbmNlIHBhcmFtZXRlclxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBzdGF0ZVNlcnZpY2Uub25JbnZhbGlkKGZ1bmN0aW9uKHRvLCBmcm9tLCBpbmplY3Rvcikge1xuICAgKiAgIGlmICh0by5uYW1lKCkgPT09ICdmb28nKSB7XG4gICAqICAgICBsZXQgbGF6eUxvYWRlciA9IGluamVjdG9yLmdldCgnTGF6eUxvYWRTZXJ2aWNlJyk7XG4gICAqICAgICByZXR1cm4gbGF6eUxvYWRlci5sb2FkKCdmb28nKVxuICAgKiAgICAgICAgIC50aGVuKCgpID0+IHN0YXRlU2VydmljZS50YXJnZXQoJ2ZvbycpKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSB0b1N0YXRlIGlzIGludmFsaWRcbiAgICogICBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSAoaW52YWxpZCkgdG9TdGF0ZSwgdGhlIGZyb21TdGF0ZSwgYW5kIGFuIGluamVjdG9yLlxuICAgKiAgIFRoZSBmdW5jdGlvbiBtYXkgb3B0aW9uYWxseSByZXR1cm4gYSBbW1RhcmdldFN0YXRlXV0gb3IgYSBQcm9taXNlIGZvciBhIFRhcmdldFN0YXRlLlxuICAgKiAgIElmIG9uZSBpcyByZXR1cm5lZCwgaXQgaXMgdHJlYXRlZCBhcyBhIHJlZGlyZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBjYWxsYmFja1xuICAgKi9cbiAgb25JbnZhbGlkKGNhbGxiYWNrOiBPbkludmFsaWRDYWxsYmFjayk6IEZ1bmN0aW9uIHtcbiAgICB0aGlzLmludmFsaWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlcmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICAgIHJlbW92ZUZyb20odGhpcy5pbnZhbGlkQ2FsbGJhY2tzKShjYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICpcbiAgICogQSBtZXRob2QgdGhhdCBmb3JjZSByZWxvYWRzIHRoZSBjdXJyZW50IHN0YXRlLCBvciBhIHBhcnRpYWwgc3RhdGUgaGllcmFyY2h5LlxuICAgKiBBbGwgcmVzb2x2ZXMgYXJlIHJlLXJlc29sdmVkLCBhbmQgY29tcG9uZW50cyByZWluc3RhbnRpYXRlZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBsZXQgYXBwIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICogICAkc2NvcGUucmVsb2FkID0gZnVuY3Rpb24oKXtcbiAgICogICAgICRzdGF0ZS5yZWxvYWQoKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZTogYHJlbG9hZCgpYCBpcyBqdXN0IGFuIGFsaWFzIGZvcjpcbiAgICpcbiAgICogYGBganNcbiAgICogJHN0YXRlLnRyYW5zaXRpb25Ubygkc3RhdGUuY3VycmVudCwgJHN0YXRlLnBhcmFtcywge1xuICAgKiAgIHJlbG9hZDogdHJ1ZSwgaW5oZXJpdDogZmFsc2VcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcmVsb2FkU3RhdGUgQSBzdGF0ZSBuYW1lIG9yIGEgc3RhdGUgb2JqZWN0LlxuICAgKiAgICBJZiBwcmVzZW50LCB0aGlzIHN0YXRlIGFuZCBhbGwgaXRzIGNoaWxkcmVuIHdpbGwgYmUgcmVsb2FkZWQsIGJ1dCBhbmNlc3RvcnMgd2lsbCBub3QgcmVsb2FkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIC8vYXNzdW1pbmcgYXBwIGFwcGxpY2F0aW9uIGNvbnNpc3RzIG9mIDMgc3RhdGVzOiAnY29udGFjdHMnLCAnY29udGFjdHMuZGV0YWlsJywgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgKiAvL2FuZCBjdXJyZW50IHN0YXRlIGlzICdjb250YWN0cy5kZXRhaWwuaXRlbSdcbiAgICogbGV0IGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAqICAgICAvL3dpbGwgcmVsb2FkICdjb250YWN0LmRldGFpbCcgYW5kIG5lc3RlZCAnY29udGFjdC5kZXRhaWwuaXRlbScgc3RhdGVzXG4gICAqICAgICAkc3RhdGUucmVsb2FkKCdjb250YWN0LmRldGFpbCcpO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZSBbW1N0YXRlU2VydmljZS5nb11dXG4gICAqL1xuICByZWxvYWQocmVsb2FkU3RhdGU/OiBTdGF0ZU9yTmFtZSk6IFByb21pc2U8U3RhdGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8odGhpcy5jdXJyZW50LCB0aGlzLnBhcmFtcywge1xuICAgICAgcmVsb2FkOiBpc0RlZmluZWQocmVsb2FkU3RhdGUpID8gcmVsb2FkU3RhdGUgOiB0cnVlLFxuICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICBub3RpZnk6IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zaXRpb24gdG8gYSBkaWZmZXJlbnQgc3RhdGUgYW5kL29yIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLlxuICAgKlxuICAgKiBgJHN0YXRlLmdvYCBjYWxscyBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG9cbiAgICogYHsgbG9jYXRpb246IHRydWUsIGluaGVyaXQ6IHRydWUsIHJlbGF0aXZlOiByb3V0ZXIuZ2xvYmFscy4kY3VycmVudCwgbm90aWZ5OiB0cnVlIH1gLlxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gdXNlIGVpdGhlciBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSBgdG9gIGFyZ3VtZW50IChiZWNhdXNlIG9mIGByZWxhdGl2ZTogcm91dGVyLmdsb2JhbHMuJGN1cnJlbnRgKS5cbiAgICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlLCB3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICogaW5oZXJpdCBmcm9tIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgKGJlY2F1c2Ugb2YgYGluaGVyaXQ6IHRydWVgKS5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBsZXQgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgKiAgICRzY29wZS5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICogICB9O1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0byBBYnNvbHV0ZSBzdGF0ZSBuYW1lLCBzdGF0ZSBvYmplY3QsIG9yIHJlbGF0aXZlIHN0YXRlIHBhdGggKHJlbGF0aXZlIHRvIGN1cnJlbnQgc3RhdGUpLlxuICAgKlxuICAgKiBTb21lIGV4YW1wbGVzOlxuICAgKlxuICAgKiAtIGAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJylgIC0gd2lsbCBnbyB0byB0aGUgYGNvbnRhY3QuZGV0YWlsYCBzdGF0ZVxuICAgKiAtIGAkc3RhdGUuZ28oJ14nKWAgLSB3aWxsIGdvIHRvIHRoZSBwYXJlbnQgc3RhdGVcbiAgICogLSBgJHN0YXRlLmdvKCdeLnNpYmxpbmcnKWAgLSBpZiBjdXJyZW50IHN0YXRlIGlzIGBob21lLmNoaWxkYCwgd2lsbCBnbyB0byB0aGUgYGhvbWUuc2libGluZ2Agc3RhdGVcbiAgICogLSBgJHN0YXRlLmdvKCcuY2hpbGQuZ3JhbmRjaGlsZCcpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgaG9tZSwgd2lsbCBnbyB0byB0aGUgYGhvbWUuY2hpbGQuZ3JhbmRjaGlsZGAgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsIHdpbGwgcG9wdWxhdGUgJHN0YXRlUGFyYW1zLlxuICAgKlxuICAgKiAgICBBbnkgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gY3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzIChiZWNhdXNlIG9mIGBpbmhlcml0OiB0cnVlYCkuXG4gICAqICAgIFRoaXMgYWxsb3dzLCBmb3IgZXhhbXBsZSwgZ29pbmcgdG8gYSBzaWJsaW5nIHN0YXRlIHRoYXQgc2hhcmVzIHBhcmFtZXRlcnMgZGVmaW5lZCBieSBhIHBhcmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAqL1xuICBnbyh0bzogU3RhdGVPck5hbWUsIHBhcmFtcz86IFJhd1BhcmFtcywgb3B0aW9ucz86IFRyYW5zaXRpb25PcHRpb25zKTogVHJhbnNpdGlvblByb21pc2Uge1xuICAgIGNvbnN0IGRlZmF1dEdvT3B0cyA9IHsgcmVsYXRpdmU6IHRoaXMuJGN1cnJlbnQsIGluaGVyaXQ6IHRydWUgfTtcbiAgICBjb25zdCB0cmFuc09wdHMgPSBkZWZhdWx0cyhvcHRpb25zLCBkZWZhdXRHb09wdHMsIGRlZmF1bHRUcmFuc09wdHMpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCB0cmFuc09wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBbW1RhcmdldFN0YXRlXV1cbiAgICpcbiAgICogVGhpcyBpcyBhIGZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhIFRhcmdldFN0YXRlXG4gICAqXG4gICAqIFRoaXMgbWF5IGJlIHJldHVybmVkIGZyb20gYSBUcmFuc2l0aW9uIEhvb2sgdG8gcmVkaXJlY3QgYSB0cmFuc2l0aW9uLCBmb3IgZXhhbXBsZS5cbiAgICovXG4gIHRhcmdldChpZGVudGlmaWVyOiBTdGF0ZU9yTmFtZSwgcGFyYW1zPzogUmF3UGFyYW1zLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KTogVGFyZ2V0U3RhdGUge1xuICAgIC8vIElmIHdlJ3JlIHJlbG9hZGluZywgZmluZCB0aGUgc3RhdGUgb2JqZWN0IHRvIHJlbG9hZCBmcm9tXG4gICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMucmVsb2FkKSAmJiAhKDxhbnk+b3B0aW9ucy5yZWxvYWQpLm5hbWUpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWxvYWQgc3RhdGUgb2JqZWN0Jyk7XG4gICAgY29uc3QgcmVnID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeTtcbiAgICBvcHRpb25zLnJlbG9hZFN0YXRlID1cbiAgICAgIG9wdGlvbnMucmVsb2FkID09PSB0cnVlID8gcmVnLnJvb3QoKSA6IHJlZy5tYXRjaGVyLmZpbmQoPGFueT5vcHRpb25zLnJlbG9hZCwgb3B0aW9ucy5yZWxhdGl2ZSk7XG5cbiAgICBpZiAob3B0aW9ucy5yZWxvYWQgJiYgIW9wdGlvbnMucmVsb2FkU3RhdGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBzdWNoIHJlbG9hZCBzdGF0ZSAnJHtpc1N0cmluZyhvcHRpb25zLnJlbG9hZCkgPyBvcHRpb25zLnJlbG9hZCA6ICg8YW55Pm9wdGlvbnMucmVsb2FkKS5uYW1lfSdgXG4gICAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBUYXJnZXRTdGF0ZSh0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LCBpZGVudGlmaWVyLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50UGF0aCgpOiBQYXRoTm9kZVtdIHtcbiAgICBjb25zdCBnbG9iYWxzID0gdGhpcy5yb3V0ZXIuZ2xvYmFscztcbiAgICBjb25zdCBsYXRlc3RTdWNjZXNzOiBUcmFuc2l0aW9uID0gZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMucGVla1RhaWwoKTtcbiAgICBjb25zdCByb290UGF0aCA9ICgpID0+IFtuZXcgUGF0aE5vZGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yb290KCkpXTtcbiAgICByZXR1cm4gbGF0ZXN0U3VjY2VzcyA/IGxhdGVzdFN1Y2Nlc3MudHJlZUNoYW5nZXMoKS50byA6IHJvb3RQYXRoKCk7XG4gIH1cblxuICAvKipcbiAgICogTG93LWxldmVsIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS5cbiAgICpcbiAgICogVGhlIFtbZ29dXSBtZXRob2QgKHdoaWNoIHVzZXMgYHRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSkgaXMgcmVjb21tZW5kZWQgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgKiAgICAgJHN0YXRlLnRyYW5zaXRpb25UbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICogICB9O1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0byBTdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdC5cbiAgICogQHBhcmFtIHRvUGFyYW1zIEEgbWFwIG9mIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBzdGF0ZSxcbiAgICogICAgICB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICogQHBhcmFtIG9wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlIFtbZ29dXVxuICAgKi9cbiAgdHJhbnNpdGlvblRvKHRvOiBTdGF0ZU9yTmFtZSwgdG9QYXJhbXM6IFJhd1BhcmFtcyA9IHt9LCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KTogVHJhbnNpdGlvblByb21pc2Uge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgIGNvbnN0IGdsb2JhbHMgPSByb3V0ZXIuZ2xvYmFscztcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgY29uc3QgZ2V0Q3VycmVudCA9ICgpID0+IGdsb2JhbHMudHJhbnNpdGlvbjtcbiAgICBvcHRpb25zID0gZXh0ZW5kKG9wdGlvbnMsIHsgY3VycmVudDogZ2V0Q3VycmVudCB9KTtcblxuICAgIGNvbnN0IHJlZjogVGFyZ2V0U3RhdGUgPSB0aGlzLnRhcmdldCh0bywgdG9QYXJhbXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5nZXRDdXJyZW50UGF0aCgpO1xuXG4gICAgaWYgKCFyZWYuZXhpc3RzKCkpIHJldHVybiB0aGlzLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUoY3VycmVudFBhdGgsIHJlZik7XG5cbiAgICBpZiAoIXJlZi52YWxpZCgpKSByZXR1cm4gPFRyYW5zaXRpb25Qcm9taXNlPnNpbGVudFJlamVjdGlvbihyZWYuZXJyb3IoKSk7XG5cbiAgICBpZiAob3B0aW9ucy5zdXBlcmNlZGUgPT09IGZhbHNlICYmIGdldEN1cnJlbnQoKSkge1xuICAgICAgcmV0dXJuIDxUcmFuc2l0aW9uUHJvbWlzZT5SZWplY3Rpb24uaWdub3JlZCgnQW5vdGhlciB0cmFuc2l0aW9uIGlzIGluIHByb2dyZXNzIGFuZCBzdXBlcmNlZGUgaGFzIGJlZW4gc2V0IHRvIGZhbHNlIGluIFRyYW5zaXRpb25PcHRpb25zIGZvciB0aGUgdHJhbnNpdGlvbi4gU28gdGhlIHRyYW5zaXRpb24gd2FzIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBleGlzdGluZyBvbmUgaW4gcHJvZ3Jlc3MuJykudG9Qcm9taXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBoYW5kbGluZyBmb3IgSWdub3JlZCwgQWJvcnRlZCwgYW5kIFJlZGlyZWN0ZWQgdHJhbnNpdGlvbnNcbiAgICAgKlxuICAgICAqIFRoZSBzZW1hbnRpY3MgZm9yIHRoZSB0cmFuc2l0aW9uLnJ1bigpIHByb21pc2UgYW5kIHRoZSBTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvKClcbiAgICAgKiBwcm9taXNlIGRpZmZlci4gRm9yIGluc3RhbmNlLCB0aGUgcnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBpdCB3YXNcbiAgICAgKiBJR05PUkVELCBidXQgdGhlIHRyYW5zaXRpb25UbygpIHByb21pc2UgaXMgcmVzb2x2ZWQgYmVjYXVzZSBmcm9tIHRoZSB1c2VyIHBlcnNwZWN0aXZlXG4gICAgICogbm8gZXJyb3Igb2NjdXJyZWQuICBMaWtld2lzZSwgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBvZlxuICAgICAqIGEgUmVkaXJlY3QsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyBjaGFpbmVkIHRvIHRoZSBuZXcgVHJhbnNpdGlvbidzIHByb21pc2UuXG4gICAgICovXG4gICAgY29uc3QgcmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlciA9ICh0cmFuczogVHJhbnNpdGlvbikgPT4gKGVycm9yOiBhbnkpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVqZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGlzTGF0ZXN0ID0gcm91dGVyLmdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPD0gdHJhbnMuJGlkO1xuXG4gICAgICAgIGlmIChlcnJvci50eXBlID09PSBSZWplY3RUeXBlLklHTk9SRUQpIHtcbiAgICAgICAgICBpc0xhdGVzdCAmJiByb3V0ZXIudXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICAgIC8vIENvbnNpZGVyIGlnbm9yZWQgYFRyYW5zaXRpb24ucnVuKClgIGFzIGEgc3VjY2Vzc2Z1bCBgdHJhbnNpdGlvblRvYFxuICAgICAgICAgIHJldHVybiBzZXJ2aWNlcy4kcS53aGVuKGdsb2JhbHMuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXRhaWw6IGFueSA9IGVycm9yLmRldGFpbDtcbiAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IFJlamVjdFR5cGUuU1VQRVJTRURFRCAmJiBlcnJvci5yZWRpcmVjdGVkICYmIGRldGFpbCBpbnN0YW5jZW9mIFRhcmdldFN0YXRlKSB7XG4gICAgICAgICAgLy8gSWYgYFRyYW5zaXRpb24ucnVuKClgIHdhcyByZWRpcmVjdGVkLCBhbGxvdyB0aGUgYHRyYW5zaXRpb25UbygpYCBwcm9taXNlIHRvIHJlc29sdmUgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBwcm9taXNlIGZvciB0aGUgbmV3IChyZWRpcmVjdCkgYFRyYW5zaXRpb24ucnVuKClgLlxuICAgICAgICAgIGNvbnN0IHJlZGlyZWN0OiBUcmFuc2l0aW9uID0gdHJhbnMucmVkaXJlY3QoZGV0YWlsKTtcbiAgICAgICAgICByZXR1cm4gcmVkaXJlY3QucnVuKCkuY2F0Y2gocmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlcihyZWRpcmVjdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IFJlamVjdFR5cGUuQUJPUlRFRCkge1xuICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIHNlcnZpY2VzLiRxLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKCk7XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IpO1xuXG4gICAgICByZXR1cm4gc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZShjdXJyZW50UGF0aCwgcmVmKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uVG9Qcm9taXNlID0gdHJhbnNpdGlvbi5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHRyYW5zaXRpb24pKTtcbiAgICBzaWxlbmNlVW5jYXVnaHRJblByb21pc2UodHJhbnNpdGlvblRvUHJvbWlzZSk7IC8vIGlzc3VlICMyNjc2XG5cbiAgICAvLyBSZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgdHJhbnNpdGlvbiwgd2hpY2ggYWxzbyBoYXMgdGhlIHRyYW5zaXRpb24gb2JqZWN0IG9uIGl0LlxuICAgIHJldHVybiBleHRlbmQodHJhbnNpdGlvblRvUHJvbWlzZSwgeyB0cmFuc2l0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzdGF0ZSAqaXMqIHRoZSBwcm92aWRlZCBzdGF0ZVxuICAgKlxuICAgKiBTaW1pbGFyIHRvIFtbaW5jbHVkZXNdXSBidXQgb25seSBjaGVja3MgZm9yIHRoZSBmdWxsIHN0YXRlIG5hbWUuXG4gICAqIElmIHBhcmFtcyBpcyBzdXBwbGllZCB0aGVuIGl0IHdpbGwgYmUgdGVzdGVkIGZvciBzdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCB0aGUgY3VycmVudFxuICAgKiBhY3RpdmUgcGFyYW1zIG9iamVjdCwgc28gYWxsIHBhcmFtcyBtdXN0IG1hdGNoIHdpdGggbm9uZSBtaXNzaW5nIGFuZCBubyBleHRyYXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtJztcbiAgICpcbiAgICogLy8gYWJzb2x1dGUgbmFtZVxuICAgKiAkc3RhdGUuaXMoJ2NvbnRhY3QuZGV0YWlscy5pdGVtJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAkc3RhdGUuaXMoY29udGFjdERldGFpbEl0ZW1TdGF0ZU9iamVjdCk7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiBgYGBcbiAgICpcbiAgICogLy8gcmVsYXRpdmUgbmFtZSAoLiBhbmQgXiksIHR5cGljYWxseSBmcm9tIGEgdGVtcGxhdGVcbiAgICogLy8gRS5nLiBmcm9tIHRoZSAnY29udGFjdHMuZGV0YWlscycgdGVtcGxhdGVcbiAgICogYGBgaHRtbFxuICAgKiA8ZGl2IG5nLWNsYXNzPVwie2hpZ2hsaWdodGVkOiAkc3RhdGUuaXMoJy5pdGVtJyl9XCI+SXRlbTwvZGl2PlxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gY2hlY2suXG4gICAqIEBwYXJhbSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4gYHtzZWN0aW9uSWQ6IHNlY3Rpb24uaWR9YCwgdGhhdCB5b3UnZCBsaWtlXG4gICAqIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAqICAgLSBgcmVsYXRpdmVgOiBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgbmFtZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCwgLmlzIHdpbGxcbiAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICpcbiAgICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIGl0IGlzIHRoZSBzdGF0ZS5cbiAgICovXG4gIGlzKHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSwgcGFyYW1zPzogUmF3UGFyYW1zLCBvcHRpb25zPzogeyByZWxhdGl2ZT86IFN0YXRlT3JOYW1lIH0pOiBib29sZWFuIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcbiAgICBpZiAoIWlzRGVmaW5lZChzdGF0ZSkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuJGN1cnJlbnQgIT09IHN0YXRlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwYXJhbXMpIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3Qgc2NoZW1hOiBQYXJhbVtdID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xuICAgIHJldHVybiBQYXJhbS5lcXVhbHMoc2NoZW1hLCBQYXJhbS52YWx1ZXMoc2NoZW1hLCBwYXJhbXMpLCB0aGlzLnBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppbmNsdWRlcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAqXG4gICAqIEEgbWV0aG9kIHRvIGRldGVybWluZSBpZiB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUgaXMgZXF1YWwgdG8gb3IgaXMgdGhlIGNoaWxkIG9mIHRoZVxuICAgKiBzdGF0ZSBzdGF0ZU5hbWUuIElmIGFueSBwYXJhbXMgYXJlIHBhc3NlZCB0aGVuIHRoZXkgd2lsbCBiZSB0ZXN0ZWQgZm9yIGEgbWF0Y2ggYXMgd2VsbC5cbiAgICogTm90IGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHBhc3NlZCwganVzdCB0aGUgb25lcyB5b3UnZCBsaWtlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGUgd2hlbiBgJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nYFxuICAgKiBgYGBqc1xuICAgKiAvLyBVc2luZyBwYXJ0aWFsIG5hbWVzXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlsc1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmRldGFpbHMuaXRlbVwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmxpc3RcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiYWJvdXRcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqICMjIyMgR2xvYiBFeGFtcGxlcyB3aGVuIGAqICRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtLnVybCdgOlxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi4qXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICogJHN0YXRlLmluY2x1ZGVzKFwiKiouaXRlbS4qKlwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy5pdGVtLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qXCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAqICRzdGF0ZS5pbmNsdWRlcyhcIml0ZW0uKipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBBIHBhcnRpYWwgbmFtZSwgcmVsYXRpdmUgbmFtZSwgZ2xvYiBwYXR0ZXJuLFxuICAgKiAgIG9yIHN0YXRlIG9iamVjdCB0byBiZSBzZWFyY2hlZCBmb3Igd2l0aGluIHRoZSBjdXJyZW50IHN0YXRlIG5hbWUuXG4gICAqIEBwYXJhbSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4gYHtzZWN0aW9uSWQ6IHNlY3Rpb24uaWR9YCxcbiAgICogICB0aGF0IHlvdSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICogICAtIGByZWxhdGl2ZWA6IElmIGBzdGF0ZU9yTmFtZWAgaXMgYSByZWxhdGl2ZSBzdGF0ZSBuYW1lIGFuZCBgb3B0aW9ucy5yZWxhdGl2ZWAgaXMgc2V0LCAuaXMgd2lsbFxuICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGl0IGRvZXMgaW5jbHVkZSB0aGUgc3RhdGVcbiAgICovXG4gIGluY2x1ZGVzKHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSwgcGFyYW1zPzogUmF3UGFyYW1zLCBvcHRpb25zPzogVHJhbnNpdGlvbk9wdGlvbnMpOiBib29sZWFuIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcbiAgICBjb25zdCBnbG9iID0gaXNTdHJpbmcoc3RhdGVPck5hbWUpICYmIEdsb2IuZnJvbVN0cmluZyg8c3RyaW5nPnN0YXRlT3JOYW1lKTtcblxuICAgIGlmIChnbG9iKSB7XG4gICAgICBpZiAoIWdsb2IubWF0Y2hlcyh0aGlzLiRjdXJyZW50Lm5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGF0ZU9yTmFtZSA9IHRoaXMuJGN1cnJlbnQubmFtZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSksXG4gICAgICBpbmNsdWRlID0gdGhpcy4kY3VycmVudC5pbmNsdWRlcztcblxuICAgIGlmICghaXNEZWZpbmVkKHN0YXRlKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoIWlzRGVmaW5lZChpbmNsdWRlW3N0YXRlLm5hbWVdKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghcGFyYW1zKSByZXR1cm4gdHJ1ZTtcblxuICAgIGNvbnN0IHNjaGVtYTogUGFyYW1bXSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiB0cnVlLCBtYXRjaGluZ0tleXM6IHBhcmFtcyB9KTtcbiAgICByZXR1cm4gUGFyYW0uZXF1YWxzKHNjaGVtYSwgUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYSBzdGF0ZSBhbmQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBSZXR1cm5zIHRoZSB1cmwgZm9yIHRoZSBnaXZlbiBzdGF0ZSBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIGV4cGVjdCgkc3RhdGUuaHJlZihcImFib3V0LnBlcnNvblwiLCB7IHBlcnNvbjogXCJib2JcIiB9KSkudG9FcXVhbChcIi9hYm91dC9ib2JcIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gZ2VuZXJhdGUgYSB1cmwgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyB0byBmaWxsIHRoZSBzdGF0ZSdzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXBpbGVkIHN0YXRlIHVybFxuICAgKi9cbiAgaHJlZihzdGF0ZU9yTmFtZTogU3RhdGVPck5hbWUsIHBhcmFtcz86IFJhd1BhcmFtcywgb3B0aW9ucz86IEhyZWZPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBkZWZhdWx0SHJlZk9wdHMgPSB7XG4gICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgIGluaGVyaXQ6IHRydWUsXG4gICAgICBhYnNvbHV0ZTogZmFsc2UsXG4gICAgICByZWxhdGl2ZTogdGhpcy4kY3VycmVudCxcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0SHJlZk9wdHMpO1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuXG4gICAgaWYgKCFpc0RlZmluZWQoc3RhdGUpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5pbmhlcml0KSBwYXJhbXMgPSA8YW55PnRoaXMucGFyYW1zLiRpbmhlcml0KHBhcmFtcywgdGhpcy4kY3VycmVudCwgc3RhdGUpO1xuXG4gICAgY29uc3QgbmF2ID0gc3RhdGUgJiYgb3B0aW9ucy5sb3NzeSA/IHN0YXRlLm5hdmlnYWJsZSA6IHN0YXRlO1xuXG4gICAgaWYgKCFuYXYgfHwgbmF2LnVybCA9PT0gdW5kZWZpbmVkIHx8IG5hdi51cmwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJvdXRlci51cmxSb3V0ZXIuaHJlZihuYXYudXJsLCBwYXJhbXMsIHsgYWJzb2x1dGU6IG9wdGlvbnMuYWJzb2x1dGUgfSk7XG4gIH1cblxuICAvKiogQGhpZGRlbiAqL1xuICBwcml2YXRlIF9kZWZhdWx0RXJyb3JIYW5kbGVyOiAoKF9lcnJvcjogYW55KSA9PiB2b2lkKSA9IGZ1bmN0aW9uICRkZWZhdWx0RXJyb3JIYW5kbGVyKCRlcnJvciQpIHtcbiAgICBpZiAoJGVycm9yJCBpbnN0YW5jZW9mIEVycm9yICYmICRlcnJvciQuc3RhY2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XG4gICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQuc3RhY2spO1xuICAgIH0gZWxzZSBpZiAoJGVycm9yJCBpbnN0YW5jZW9mIFJlamVjdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKCRlcnJvciQuZGV0YWlsICYmICRlcnJvciQuZGV0YWlsLnN0YWNrKSBjb25zb2xlLmVycm9yKCRlcnJvciQuZGV0YWlsLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgZ2V0cyB0aGUgZGVmYXVsdCBbW3RyYW5zaXRpb25Ub11dIGVycm9yIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZSBlcnJvciBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuIGEgW1tUcmFuc2l0aW9uXV0gaXMgcmVqZWN0ZWQgb3Igd2hlbiBhbnkgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBUcmFuc2l0aW9uLlxuICAgKiBUaGlzIGluY2x1ZGVzIGVycm9ycyBjYXVzZWQgYnkgcmVzb2x2ZXMgYW5kIHRyYW5zaXRpb24gaG9va3MuXG4gICAqXG4gICAqIE5vdGU6XG4gICAqIFRoaXMgaGFuZGxlciBkb2VzIG5vdCByZWNlaXZlIGNlcnRhaW4gVHJhbnNpdGlvbiByZWplY3Rpb25zLlxuICAgKiBSZWRpcmVjdGVkIGFuZCBJZ25vcmVkIFRyYW5zaXRpb25zIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSBlcnJvcnMgYnkgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV0uXG4gICAqXG4gICAqIFRoZSBidWlsdC1pbiBkZWZhdWx0IGVycm9yIGhhbmRsZXIgbG9ncyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBjdXN0b20gaGFuZGxlci5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiBzdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcihmdW5jdGlvbigpIHtcbiAgICogICAvLyBEbyBub3QgbG9nIHRyYW5zaXRpb25UbyBlcnJvcnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlciBhIGdsb2JhbCBlcnJvciBoYW5kbGVyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gICAqL1xuICBkZWZhdWx0RXJyb3JIYW5kbGVyKGhhbmRsZXI/OiAoZXJyb3I6IGFueSkgPT4gdm9pZCk6IChlcnJvcjogYW55KSA9PiB2b2lkIHtcbiAgICByZXR1cm4gKHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIgPSBoYW5kbGVyIHx8IHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSByZWdpc3RlcmVkIFtbU3RhdGVEZWNsYXJhdGlvbl1dIG9iamVjdFxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3QgZm9yIGFueSBzcGVjaWZpYyBzdGF0ZSwgb3IgZm9yIGFsbCByZWdpc3RlcmVkIHN0YXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JOYW1lIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkgSWYgcHJvdmlkZWQsIHdpbGwgb25seSBnZXQgdGhlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIHJlcXVlc3RlZCBzdGF0ZS5cbiAgICogSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIGFuIGFycmF5IG9mIEFMTCBzdGF0ZXMuXG4gICAqIEBwYXJhbSBiYXNlIFdoZW4gYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIHJlZmVyZW5jZSAoc3VjaCBhcyBgLmJhci5iYXpgKSwgdGhlIHN0YXRlIHdpbGwgYmUgcmV0cmlldmVkIHJlbGF0aXZlIHRvIHRoaXMgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb2JqZWN0IChvciBhcnJheSBvZiBhbGwgcmVnaXN0ZXJlZCBbW1N0YXRlRGVjbGFyYXRpb25dXSBvYmplY3RzLilcbiAgICovXG4gIGdldChzdGF0ZU9yTmFtZTogU3RhdGVPck5hbWUsIGJhc2U6IFN0YXRlT3JOYW1lKTogU3RhdGVEZWNsYXJhdGlvbjtcbiAgZ2V0KHN0YXRlT3JOYW1lOiBTdGF0ZU9yTmFtZSk6IFN0YXRlRGVjbGFyYXRpb247XG4gIGdldCgpOiBTdGF0ZURlY2xhcmF0aW9uW107XG4gIGdldChzdGF0ZU9yTmFtZT86IFN0YXRlT3JOYW1lLCBiYXNlPzogU3RhdGVPck5hbWUpOiBhbnkge1xuICAgIGNvbnN0IHJlZyA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiByZWcuZ2V0KCk7XG4gICAgcmV0dXJuIHJlZy5nZXQoc3RhdGVPck5hbWUsIGJhc2UgfHwgdGhpcy4kY3VycmVudCk7XG4gIH1cblxuICAvKipcbiAgICogTGF6eSBsb2FkcyBhIHN0YXRlXG4gICAqXG4gICAqIEV4cGxpY2l0bHkgcnVucyBhIHN0YXRlJ3MgW1tTdGF0ZURlY2xhcmF0aW9uLmxhenlMb2FkXV0gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUgdGhhdCBzaG91bGQgYmUgbGF6eSBsb2FkZWRcbiAgICogQHBhcmFtIHRyYW5zaXRpb24gdGhlIG9wdGlvbmFsIFRyYW5zaXRpb24gY29udGV4dCB0byB1c2UgKGlmIHRoZSBsYXp5TG9hZCBmdW5jdGlvbiByZXF1aXJlcyBhbiBpbmplY3RvciwgZXRjKVxuICAgKiBOb3RlOiBJZiBubyB0cmFuc2l0aW9uIGlzIHByb3ZpZGVkLCBhIG5vb3AgdHJhbnNpdGlvbiBpcyBjcmVhdGVkIHVzaW5nIHRoZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiBUaGlzIG5vb3AgdHJhbnNpdGlvbiBpcyBub3QgYWN0dWFsbHkgcnVuLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdG8gbGF6eSBsb2FkXG4gICAqL1xuICBsYXp5TG9hZChzdGF0ZU9yTmFtZTogU3RhdGVPck5hbWUsIHRyYW5zaXRpb24/OiBUcmFuc2l0aW9uKTogUHJvbWlzZTxMYXp5TG9hZFJlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uID0gdGhpcy5nZXQoc3RhdGVPck5hbWUpO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmxhenlMb2FkKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgbGF6eSBsb2FkICcgKyBzdGF0ZU9yTmFtZSk7XG5cbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuZ2V0Q3VycmVudFBhdGgoKTtcbiAgICBjb25zdCB0YXJnZXQgPSBQYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGN1cnJlbnRQYXRoKTtcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHRhcmdldCk7XG5cbiAgICByZXR1cm4gbGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gIH1cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSB2YW5pbGxhICovIC8qKiAqL1xuaW1wb3J0IHsgaXNBcnJheSwgaXNPYmplY3QsICRRTGlrZSB9IGZyb20gJy4uL2NvbW1vbi9pbmRleCc7XG5cbi8qKlxuICogQW4gYW5ndWxhcjEtbGlrZSBwcm9taXNlIGFwaVxuICpcbiAqIFRoaXMgb2JqZWN0IGltcGxlbWVudHMgZm91ciBtZXRob2RzIHNpbWlsYXIgdG8gdGhlXG4gKiBbYW5ndWxhciAxIHByb21pc2UgYXBpXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcvc2VydmljZS8kcSlcbiAqXG4gKiBVSS1Sb3V0ZXIgZXZvbHZlZCBmcm9tIGFuIGFuZ3VsYXIgMSBsaWJyYXJ5IHRvIGEgZnJhbWV3b3JrIGFnbm9zdGljIGxpYnJhcnkuXG4gKiBIb3dldmVyLCBzb21lIG9mIHRoZSBgQHVpcm91dGVyL2NvcmVgIGNvZGUgdXNlcyB0aGVzZSBuZzEgc3R5bGUgQVBJcyB0byBzdXBwb3J0IG5nMSBzdHlsZSBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAqXG4gKiBUaGlzIEFQSSBwcm92aWRlcyBuYXRpdmUgRVM2IHByb21pc2Ugc3VwcG9ydCB3cmFwcGVkIGFzIGEgJHEtbGlrZSBBUEkuXG4gKiBJbnRlcm5hbGx5LCBVSS1Sb3V0ZXIgdXNlcyB0aGlzICRxIG9iamVjdCB0byBwZXJmb3JtIHByb21pc2Ugb3BlcmF0aW9ucy5cbiAqIFRoZSBgYW5ndWxhci11aS1yb3V0ZXJgICh1aS1yb3V0ZXIgZm9yIGFuZ3VsYXIgMSkgdXNlcyB0aGUgJHEgQVBJIHByb3ZpZGVkIGJ5IGFuZ3VsYXIuXG4gKlxuICogJHEtbGlrZSBwcm9taXNlIGFwaVxuICovXG5leHBvcnQgY29uc3QgJHEgPSB7XG4gIC8qKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBwcm9taXNlICovXG4gIHdoZW46IHZhbCA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZXNvbHZlKHZhbCkpLFxuXG4gIC8qKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBwcm9taXNlIHJlamVjdGlvbiAqL1xuICByZWplY3Q6IHZhbCA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlamVjdCh2YWwpO1xuICAgIH0pLFxuXG4gIC8qKiBAcmV0dXJucyBhIGRlZmVycmVkIG9iamVjdCwgd2hpY2ggaGFzIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zICovXG4gIGRlZmVyOiAoKSA9PiB7XG4gICAgY29uc3QgZGVmZXJyZWQ6IGFueSA9IHt9O1xuICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH0sXG5cbiAgLyoqIExpa2UgUHJvbWlzZS5hbGwoKSwgYnV0IGFsc28gc3VwcG9ydHMgb2JqZWN0IGtleS9wcm9taXNlIG5vdGF0aW9uIGxpa2UgJHEgKi9cbiAgYWxsOiAocHJvbWlzZXM6IHsgW2tleTogc3RyaW5nXTogUHJvbWlzZTxhbnk+IH0gfCBQcm9taXNlPGFueT5bXSkgPT4ge1xuICAgIGlmIChpc0FycmF5KHByb21pc2VzKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QocHJvbWlzZXMpKSB7XG4gICAgICAvLyBDb252ZXJ0IHByb21pc2VzIG1hcCB0byBwcm9taXNlcyBhcnJheS5cbiAgICAgIC8vIFdoZW4gZWFjaCBwcm9taXNlIHJlc29sdmVzLCBtYXAgaXQgdG8gYSB0dXBsZSB7IGtleToga2V5LCB2YWw6IHZhbCB9XG4gICAgICBjb25zdCBjaGFpbiA9IE9iamVjdC5rZXlzKHByb21pc2VzKS5tYXAoa2V5ID0+IHByb21pc2VzW2tleV0udGhlbih2YWwgPT4gKHsga2V5LCB2YWwgfSkpKTtcblxuICAgICAgLy8gVGhlbiB3YWl0IGZvciBhbGwgcHJvbWlzZXMgdG8gcmVzb2x2ZSwgYW5kIGNvbnZlcnQgdGhlbSBiYWNrIHRvIGFuIG9iamVjdFxuICAgICAgcmV0dXJuICRxLmFsbChjaGFpbikudGhlbih2YWx1ZXMgPT5cbiAgICAgICAgdmFsdWVzLnJlZHVjZSgoYWNjLCB0dXBsZSkgPT4ge1xuICAgICAgICAgIGFjY1t0dXBsZS5rZXldID0gdHVwbGUudmFsO1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KVxuICAgICAgKTtcbiAgICB9XG4gIH0sXG59IGFzICRRTGlrZTtcbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSB2YW5pbGxhICovIC8qKiAqL1xuaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBhc3NlcnRQcmVkaWNhdGUsXG4gIGlzRnVuY3Rpb24sXG4gIGlzQXJyYXksXG4gIGlzSW5qZWN0YWJsZSxcbiAgJEluamVjdG9yTGlrZSxcbiAgSUluamVjdGFibGUsXG59IGZyb20gJy4uL2NvbW1vbi9pbmRleCc7XG5cbi8vIGdsb2JhbGx5IGF2YWlsYWJsZSBpbmplY3RhYmxlc1xuY29uc3QgZ2xvYmFscyA9IHt9O1xuY29uc3QgU1RSSVBfQ09NTUVOVFMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvZ207XG5jb25zdCBBUkdVTUVOVF9OQU1FUyA9IC8oW15cXHMsXSspL2c7XG5cbi8qKlxuICogQSBiYXNpYyBhbmd1bGFyMS1saWtlIGluamVjdG9yIGFwaVxuICpcbiAqIFRoaXMgb2JqZWN0IGltcGxlbWVudHMgZm91ciBtZXRob2RzIHNpbWlsYXIgdG8gdGhlXG4gKiBbYW5ndWxhciAxIGRlcGVuZGVuY3kgaW5qZWN0b3JdKGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9hdXRvL3NlcnZpY2UvJGluamVjdG9yKVxuICpcbiAqIFVJLVJvdXRlciBldm9sdmVkIGZyb20gYW4gYW5ndWxhciAxIGxpYnJhcnkgdG8gYSBmcmFtZXdvcmsgYWdub3N0aWMgbGlicmFyeS5cbiAqIEhvd2V2ZXIsIHNvbWUgb2YgdGhlIGBAdWlyb3V0ZXIvY29yZWAgY29kZSB1c2VzIHRoZXNlIG5nMSBzdHlsZSBBUElzIHRvIHN1cHBvcnQgbmcxIHN0eWxlIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIFRoaXMgb2JqZWN0IHByb3ZpZGVzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb2YgYSBnbG9iYWxseSBzY29wZWQgZGVwZW5kZW5jeSBpbmplY3Rpb24gc3lzdGVtLlxuICogSXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBESSBhcHByb2FjaGVzOlxuICpcbiAqICMjIyBGdW5jdGlvbiBwYXJhbWV0ZXIgbmFtZXNcbiAqXG4gKiBBIGZ1bmN0aW9uJ3MgYC50b1N0cmluZygpYCBpcyBjYWxsZWQsIGFuZCB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZSBwYXJzZWQuXG4gKiBUaGlzIG9ubHkgd29ya3Mgd2hlbiB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZW4ndCBcIm1hbmdsZWRcIiBieSBhIG1pbmlmaWVyIHN1Y2ggYXMgVWdsaWZ5SlMuXG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oRm9vU2VydmljZSwgQmFyU2VydmljZSkge1xuICogICAvLyBGb29TZXJ2aWNlIGFuZCBCYXJTZXJ2aWNlIGFyZSBpbmplY3RlZFxuICogfVxuICogYGBgXG4gKlxuICogIyMjIEZ1bmN0aW9uIGFubm90YXRpb25cbiAqXG4gKiBBIGZ1bmN0aW9uIG1heSBiZSBhbm5vdGF0ZWQgd2l0aCBhbiBhcnJheSBvZiBkZXBlbmRlbmN5IG5hbWVzIGFzIHRoZSBgJGluamVjdGAgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGluamVjdGVkRnVuY3Rpb24uJGluamVjdCA9IFsgJ0Zvb1NlcnZpY2UnLCAnQmFyU2VydmljZScgXTtcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oZnMsIGJzKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgQXJyYXkgbm90YXRpb25cbiAqXG4gKiBBbiBhcnJheSBwcm92aWRlcyB0aGUgbmFtZXMgb2YgdGhlIGRlcGVuZGVuY2llcyB0byBpbmplY3QgKGFzIHN0cmluZ3MpLlxuICogVGhlIGZ1bmN0aW9uIGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBbICdGb29TZXJ2aWNlJywgJ0JhclNlcnZpY2UnLCBmdW5jdGlvbiAoZnMsIGJzKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXG4gKiB9XVxuICogYGBgXG4gKlxuICogQHR5cGUgeyRJbmplY3Rvckxpa2V9XG4gKi9cbmV4cG9ydCBjb25zdCAkaW5qZWN0b3IgPSB7XG4gIC8qKiBHZXRzIGFuIG9iamVjdCBmcm9tIERJIGJhc2VkIG9uIGEgc3RyaW5nIHRva2VuICovXG4gIGdldDogbmFtZSA9PiBnbG9iYWxzW25hbWVdLFxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IG5hbWVkIGBuYW1lYCBleGlzdHMgaW4gZ2xvYmFsIERJICovXG4gIGhhczogbmFtZSA9PiAkaW5qZWN0b3IuZ2V0KG5hbWUpICE9IG51bGwsXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYSBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZm4gdGhlIGZ1bmN0aW9uIHRvIGluamVjdFxuICAgKiBAcGFyYW0gY29udGV4dCB0aGUgZnVuY3Rpb24ncyBgdGhpc2AgYmluZGluZ1xuICAgKiBAcGFyYW0gbG9jYWxzIEFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgREkgdG9rZW5zIGFuZCB2YWx1ZXMsIHN1Y2ggYXMgYHsgc29tZVRva2VuOiB7IGZvbzogMSB9IH1gXG4gICAqL1xuICBpbnZva2U6IChmbjogSUluamVjdGFibGUsIGNvbnRleHQ/LCBsb2NhbHM/KSA9PiB7XG4gICAgY29uc3QgYWxsID0gZXh0ZW5kKHt9LCBnbG9iYWxzLCBsb2NhbHMgfHwge30pO1xuICAgIGNvbnN0IHBhcmFtcyA9ICRpbmplY3Rvci5hbm5vdGF0ZShmbik7XG4gICAgY29uc3QgZW5zdXJlRXhpc3QgPSBhc3NlcnRQcmVkaWNhdGUoXG4gICAgICAoa2V5OiBzdHJpbmcpID0+IGFsbC5oYXNPd25Qcm9wZXJ0eShrZXkpLFxuICAgICAga2V5ID0+IGBESSBjYW4ndCBmaW5kIGluamVjdGFibGU6ICcke2tleX0nYFxuICAgICk7XG4gICAgY29uc3QgYXJncyA9IHBhcmFtcy5maWx0ZXIoZW5zdXJlRXhpc3QpLm1hcCh4ID0+IGFsbFt4XSk7XG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgZWxzZSByZXR1cm4gKGZuIGFzIGFueVtdKS5zbGljZSgtMSlbMF0uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbidzIGRlcGVuZGVuY2llc1xuICAgKlxuICAgKiBBbmFseXplcyBhIGZ1bmN0aW9uIChvciBhcnJheSkgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgREkgdG9rZW5zIHRoYXQgdGhlIGZ1bmN0aW9uIHJlcXVpcmVzLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGBzdHJpbmdgc1xuICAgKi9cbiAgYW5ub3RhdGU6IChmbjogSUluamVjdGFibGUpOiBhbnlbXSA9PiB7XG4gICAgaWYgKCFpc0luamVjdGFibGUoZm4pKSB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uOiAke2ZufWApO1xuICAgIGlmIChmbiAmJiAoZm4gYXMgYW55KS4kaW5qZWN0KSByZXR1cm4gKGZuIGFzIGFueSkuJGluamVjdDtcbiAgICBpZiAoaXNBcnJheShmbikpIHJldHVybiBmbi5zbGljZSgwLCAtMSk7XG4gICAgY29uc3QgZm5TdHIgPSBmbi50b1N0cmluZygpLnJlcGxhY2UoU1RSSVBfQ09NTUVOVFMsICcnKTtcbiAgICBjb25zdCByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcbiAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICB9LFxufSBhcyAkSW5qZWN0b3JMaWtlO1xuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQge1xuICBMb2NhdGlvbkNvbmZpZyxcbiAgTG9jYXRpb25TZXJ2aWNlcyxcbiAgaWRlbnRpdHksXG4gIHVubmVzdFIsXG4gIGlzQXJyYXksXG4gIHNwbGl0RXF1YWwsXG4gIHNwbGl0SGFzaCxcbiAgc3BsaXRRdWVyeSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcblxuZXhwb3J0IGNvbnN0IGtleVZhbHNUb09iamVjdFIgPSAoYWNjdW0sIFtrZXksIHZhbF0pID0+IHtcbiAgaWYgKCFhY2N1bS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgYWNjdW1ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGFjY3VtW2tleV0pKSB7XG4gICAgYWNjdW1ba2V5XS5wdXNoKHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgYWNjdW1ba2V5XSA9IFthY2N1bVtrZXldLCB2YWxdO1xuICB9XG4gIHJldHVybiBhY2N1bTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRQYXJhbXMgPSAocXVlcnlTdHJpbmc6IHN0cmluZyk6IGFueSA9PlxuICBxdWVyeVN0cmluZ1xuICAgIC5zcGxpdCgnJicpXG4gICAgLmZpbHRlcihpZGVudGl0eSlcbiAgICAubWFwKHNwbGl0RXF1YWwpXG4gICAgLnJlZHVjZShrZXlWYWxzVG9PYmplY3RSLCB7fSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVybCh1cmw6IHN0cmluZykge1xuICBjb25zdCBvckVtcHR5U3RyaW5nID0geCA9PiB4IHx8ICcnO1xuICBjb25zdCBbYmVmb3JlaGFzaCwgaGFzaF0gPSBzcGxpdEhhc2godXJsKS5tYXAob3JFbXB0eVN0cmluZyk7XG4gIGNvbnN0IFtwYXRoLCBzZWFyY2hdID0gc3BsaXRRdWVyeShiZWZvcmVoYXNoKS5tYXAob3JFbXB0eVN0cmluZyk7XG5cbiAgcmV0dXJuIHsgcGF0aCwgc2VhcmNoLCBoYXNoLCB1cmwgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGJ1aWxkVXJsID0gKGxvYzogTG9jYXRpb25TZXJ2aWNlcykgPT4ge1xuICBjb25zdCBwYXRoID0gbG9jLnBhdGgoKTtcbiAgY29uc3Qgc2VhcmNoT2JqZWN0ID0gbG9jLnNlYXJjaCgpO1xuICBjb25zdCBoYXNoID0gbG9jLmhhc2goKTtcblxuICBjb25zdCBzZWFyY2ggPSBPYmplY3Qua2V5cyhzZWFyY2hPYmplY3QpXG4gICAgLm1hcChrZXkgPT4ge1xuICAgICAgY29uc3QgcGFyYW0gPSBzZWFyY2hPYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IHZhbHMgPSBpc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogW3BhcmFtXTtcbiAgICAgIHJldHVybiB2YWxzLm1hcCh2YWwgPT4ga2V5ICsgJz0nICsgdmFsKTtcbiAgICB9KVxuICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgLmpvaW4oJyYnKTtcblxuICByZXR1cm4gcGF0aCArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyAoaGFzaCA/ICcjJyArIGhhc2ggOiAnJyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9jYXRpb25QbHVnaW5GYWN0b3J5KFxuICBuYW1lOiBzdHJpbmcsXG4gIGlzSHRtbDU6IGJvb2xlYW4sXG4gIHNlcnZpY2VDbGFzczogeyBuZXcgKHVpUm91dGVyPzogVUlSb3V0ZXIpOiBMb2NhdGlvblNlcnZpY2VzIH0sXG4gIGNvbmZpZ3VyYXRpb25DbGFzczogeyBuZXcgKHVpUm91dGVyPzogVUlSb3V0ZXIsIGlzSHRtbDU/OiBib29sZWFuKTogTG9jYXRpb25Db25maWcgfVxuKSB7XG4gIHJldHVybiBmdW5jdGlvbih1aVJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gKHVpUm91dGVyLmxvY2F0aW9uU2VydmljZSA9IG5ldyBzZXJ2aWNlQ2xhc3ModWlSb3V0ZXIpKTtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gKHVpUm91dGVyLmxvY2F0aW9uQ29uZmlnID0gbmV3IGNvbmZpZ3VyYXRpb25DbGFzcyh1aVJvdXRlciwgaXNIdG1sNSkpO1xuXG4gICAgZnVuY3Rpb24gZGlzcG9zZShyb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgICByb3V0ZXIuZGlzcG9zZShzZXJ2aWNlKTtcbiAgICAgIHJvdXRlci5kaXNwb3NlKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7IG5hbWUsIHNlcnZpY2UsIGNvbmZpZ3VyYXRpb24sIGRpc3Bvc2UgfTtcbiAgfTtcbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSB2YW5pbGxhICovIC8qKiAqL1xuaW1wb3J0IHsgZGVyZWdBbGwsIGlzRGVmaW5lZCwgTG9jYXRpb25TZXJ2aWNlcywgcmVtb3ZlRnJvbSwgcm9vdCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IEhpc3RvcnlMaWtlLCBMb2NhdGlvbkxpa2UgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBidWlsZFVybCwgZ2V0UGFyYW1zLCBwYXJzZVVybCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKiogQSBiYXNlIGBMb2NhdGlvblNlcnZpY2VzYCAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VMb2NhdGlvblNlcnZpY2VzIGltcGxlbWVudHMgTG9jYXRpb25TZXJ2aWNlcywgRGlzcG9zYWJsZSB7XG4gIHByaXZhdGUgX2xpc3RlbmVyczogRnVuY3Rpb25bXSA9IFtdO1xuICBfbG9jYXRpb246IExvY2F0aW9uTGlrZTtcbiAgX2hpc3Rvcnk6IEhpc3RvcnlMaWtlO1xuXG4gIF9saXN0ZW5lciA9IGV2dCA9PiB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChjYiA9PiBjYihldnQpKTtcblxuICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFVJUm91dGVyLCBwdWJsaWMgZmlyZUFmdGVyVXBkYXRlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fbG9jYXRpb24gPSByb290LmxvY2F0aW9uO1xuICAgIHRoaXMuX2hpc3RvcnkgPSByb290Lmhpc3Rvcnk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBzaG91bGQgcmV0dXJuIHRoZSBjdXJyZW50IGludGVybmFsIFVSTCByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogVGhlIGludGVybmFsIFVSTCBpbmNsdWRlcyBvbmx5IHRoZSBwb3J0aW9uIHRoYXQgVUktUm91dGVyIG1hdGNoZXMuXG4gICAqIEl0IGRvZXMgbm90IGluY2x1ZGU6XG4gICAqIC0gcHJvdG9jb2xcbiAgICogLSBzZXJ2ZXJcbiAgICogLSBwb3J0XG4gICAqIC0gYmFzZSBocmVmIG9yIGhhc2hcbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0KCk6IHN0cmluZztcblxuICAvKipcbiAgICogVGhpcyBzaG91bGQgc2V0IHRoZSBjdXJyZW50IFVSTC5cbiAgICpcbiAgICogVGhlIGB1cmxgIHBhcmFtIHNob3VsZCBpbmNsdWRlIG9ubHkgdGhlIHBvcnRpb24gdGhhdCBVSS1Sb3V0ZXIgbWF0Y2hlcyBvbi5cbiAgICogSXQgc2hvdWxkIG5vdCBpbmNsdWRlOlxuICAgKiAtIHByb3RvY29sXG4gICAqIC0gc2VydmVyXG4gICAqIC0gcG9ydFxuICAgKiAtIGJhc2UgaHJlZiBvciBoYXNoXG4gICAqXG4gICAqIEhvd2V2ZXIsIGFmdGVyIHRoaXMgZnVuY3Rpb24gY29tcGxldGVzLCB0aGUgYnJvd3NlciBVUkwgc2hvdWxkIHJlZmxlY3QgdGhlIGVudGlyZSAoZnVsbHkgcXVhbGlmaWVkKVxuICAgKiBIUkVGIGluY2x1ZGluZyB0aG9zZSBkYXRhLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9zZXQoc3RhdGU6IGFueSwgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcsIHJlcGxhY2U6IGJvb2xlYW4pO1xuXG4gIGhhc2ggPSAoKSA9PiBwYXJzZVVybCh0aGlzLl9nZXQoKSkuaGFzaDtcbiAgcGF0aCA9ICgpID0+IHBhcnNlVXJsKHRoaXMuX2dldCgpKS5wYXRoO1xuICBzZWFyY2ggPSAoKSA9PiBnZXRQYXJhbXMocGFyc2VVcmwodGhpcy5fZ2V0KCkpLnNlYXJjaCk7XG5cbiAgdXJsKHVybD86IHN0cmluZywgcmVwbGFjZSA9IHRydWUpOiBzdHJpbmcge1xuICAgIGlmIChpc0RlZmluZWQodXJsKSAmJiB1cmwgIT09IHRoaXMuX2dldCgpKSB7XG4gICAgICB0aGlzLl9zZXQobnVsbCwgbnVsbCwgdXJsLCByZXBsYWNlKTtcblxuICAgICAgaWYgKHRoaXMuZmlyZUFmdGVyVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGNiID0+IGNiKHsgdXJsIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRVcmwodGhpcyk7XG4gIH1cblxuICBvbkNoYW5nZShjYjogRXZlbnRMaXN0ZW5lcikge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gKCkgPT4gcmVtb3ZlRnJvbSh0aGlzLl9saXN0ZW5lcnMsIGNiKTtcbiAgfVxuXG4gIGRpc3Bvc2Uocm91dGVyOiBVSVJvdXRlcikge1xuICAgIGRlcmVnQWxsKHRoaXMuX2xpc3RlbmVycyk7XG4gIH1cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSB2YW5pbGxhICovIC8qKiAqL1xuaW1wb3J0IHsgcm9vdCwgdHJpbUhhc2hWYWwgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgVUlSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IHsgQmFzZUxvY2F0aW9uU2VydmljZXMgfSBmcm9tICcuL2Jhc2VMb2NhdGlvblNlcnZpY2UnO1xuXG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCB1c2VzIHRoZSBicm93c2VyIGhhc2ggXCIjXCIgdG8gZ2V0L3NldCB0aGUgY3VycmVudCBsb2NhdGlvbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hMb2NhdGlvblNlcnZpY2UgZXh0ZW5kcyBCYXNlTG9jYXRpb25TZXJ2aWNlcyB7XG4gIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBzdXBlcihyb3V0ZXIsIGZhbHNlKTtcbiAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lciwgZmFsc2UpO1xuICB9XG5cbiAgX2dldCgpIHtcbiAgICByZXR1cm4gdHJpbUhhc2hWYWwodGhpcy5fbG9jYXRpb24uaGFzaCk7XG4gIH1cbiAgX3NldChzdGF0ZTogYW55LCB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZywgcmVwbGFjZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gIH1cblxuICBkaXNwb3NlKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBzdXBlci5kaXNwb3NlKHJvdXRlcik7XG4gICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5fbGlzdGVuZXIpO1xuICB9XG59XG4iLCIvKiogQGludGVybmFsYXBpIEBtb2R1bGUgdmFuaWxsYSAqLyAvKiogKi9cbmltcG9ydCB7IEJhc2VMb2NhdGlvblNlcnZpY2VzIH0gZnJvbSAnLi9iYXNlTG9jYXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcblxuLyoqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xuZXhwb3J0IGNsYXNzIE1lbW9yeUxvY2F0aW9uU2VydmljZSBleHRlbmRzIEJhc2VMb2NhdGlvblNlcnZpY2VzIHtcbiAgX3VybDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBzdXBlcihyb3V0ZXIsIHRydWUpO1xuICB9XG5cbiAgX2dldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgX3NldChzdGF0ZTogYW55LCB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZywgcmVwbGFjZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgfVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQgeyBVSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgeyBCYXNlTG9jYXRpb25TZXJ2aWNlcyB9IGZyb20gJy4vYmFzZUxvY2F0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBMb2NhdGlvbkNvbmZpZywgcm9vdCwgc3BsaXRIYXNoLCBzcGxpdFF1ZXJ5LCBzdHJpcExhc3RQYXRoRWxlbWVudCB9IGZyb20gJy4uL2NvbW1vbic7XG5cbi8qKlxuICogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gdXNpbmcgdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIGFuZCBgaGlzdG9yeWAgYXBpc1xuICpcbiAqIFVzZXMgYGhpc3RvcnkucHVzaFN0YXRlYCBhbmQgYGhpc3RvcnkucmVwbGFjZVN0YXRlYFxuICovXG5leHBvcnQgY2xhc3MgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlIGV4dGVuZHMgQmFzZUxvY2F0aW9uU2VydmljZXMge1xuICBfY29uZmlnOiBMb2NhdGlvbkNvbmZpZztcblxuICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgc3VwZXIocm91dGVyLCB0cnVlKTtcbiAgICB0aGlzLl9jb25maWcgPSByb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuX2xpc3RlbmVyLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYmFzZSBwcmVmaXggd2l0aG91dDpcbiAgICogLSB0cmFpbGluZyBzbGFzaFxuICAgKiAtIHRyYWlsaW5nIGZpbGVuYW1lXG4gICAqIC0gcHJvdG9jb2wgYW5kIGhvc3RuYW1lXG4gICAqXG4gICAqIElmIDxiYXNlIGhyZWY9Jy9iYXNlLyc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICogSWYgPGJhc2UgaHJlZj0nL2Zvby9iYXNlLyc+LCB0aGlzIHJldHVybnMgJy9mb28vYmFzZScuXG4gICAqIElmIDxiYXNlIGhyZWY9Jy9iYXNlL2luZGV4Lmh0bWwnPiwgdGhpcyByZXR1cm5zICcvYmFzZScuXG4gICAqIElmIDxiYXNlIGhyZWY9J2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9iYXNlL2luZGV4Lmh0bWwnPiwgdGhpcyByZXR1cm5zICcvYmFzZScuXG4gICAqIElmIDxiYXNlIGhyZWY9Jy9iYXNlJz4sIHRoaXMgcmV0dXJucyAnJy5cbiAgICogSWYgPGJhc2UgaHJlZj0naHR0cDovL2xvY2FsaG9zdDo4MDgwJz4sIHRoaXMgcmV0dXJucyAnJy5cbiAgICogSWYgPGJhc2UgaHJlZj0naHR0cDovL2xvY2FsaG9zdDo4MDgwLyc+LCB0aGlzIHJldHVybnMgJycuXG4gICAqXG4gICAqIFNlZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9kZXYvc2VtYW50aWNzLmh0bWwjdGhlLWJhc2UtZWxlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0QmFzZVByZWZpeCgpIHtcbiAgICByZXR1cm4gc3RyaXBMYXN0UGF0aEVsZW1lbnQodGhpcy5fY29uZmlnLmJhc2VIcmVmKCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXQoKSB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIGhhc2gsIHNlYXJjaCB9ID0gdGhpcy5fbG9jYXRpb247XG4gICAgc2VhcmNoID0gc3BsaXRRdWVyeShzZWFyY2gpWzFdOyAvLyBzdHJpcCA/IGlmIGZvdW5kXG4gICAgaGFzaCA9IHNwbGl0SGFzaChoYXNoKVsxXTsgLy8gc3RyaXAgIyBpZiBmb3VuZFxuXG4gICAgY29uc3QgYmFzZVByZWZpeCA9IHRoaXMuX2dldEJhc2VQcmVmaXgoKTtcbiAgICBjb25zdCBleGFjdEJhc2VIcmVmTWF0Y2ggPSBwYXRobmFtZSA9PT0gdGhpcy5fY29uZmlnLmJhc2VIcmVmKCk7XG4gICAgY29uc3Qgc3RhcnRzV2l0aEJhc2UgPSBwYXRobmFtZS5zdWJzdHIoMCwgYmFzZVByZWZpeC5sZW5ndGgpID09PSBiYXNlUHJlZml4O1xuICAgIHBhdGhuYW1lID0gZXhhY3RCYXNlSHJlZk1hdGNoID8gJy8nIDogc3RhcnRzV2l0aEJhc2UgPyBwYXRobmFtZS5zdWJzdHJpbmcoYmFzZVByZWZpeC5sZW5ndGgpIDogcGF0aG5hbWU7XG5cbiAgICByZXR1cm4gcGF0aG5hbWUgKyAoc2VhcmNoID8gJz8nICsgc2VhcmNoIDogJycpICsgKGhhc2ggPyAnIycgKyBoYXNoIDogJycpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXQoc3RhdGU6IGFueSwgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcsIHJlcGxhY2U6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBiYXNlUHJlZml4ID0gdGhpcy5fZ2V0QmFzZVByZWZpeCgpO1xuICAgIGNvbnN0IHNsYXNoID0gdXJsICYmIHVybFswXSAhPT0gJy8nID8gJy8nIDogJyc7XG4gICAgY29uc3QgZnVsbFVybCA9IHVybCA9PT0gJycgfHwgdXJsID09PSAnLycgPyB0aGlzLl9jb25maWcuYmFzZUhyZWYoKSA6IGJhc2VQcmVmaXggKyBzbGFzaCArIHVybDtcblxuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICB0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKHJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgICBzdXBlci5kaXNwb3NlKHJvdXRlcik7XG4gICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuX2xpc3RlbmVyKTtcbiAgfVxufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi8gLyoqICovXG5pbXBvcnQgeyBMb2NhdGlvbkNvbmZpZyB9IGZyb20gJy4uL2NvbW1vbi9jb3Jlc2VydmljZXMnO1xuaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi4vY29tbW9uL3ByZWRpY2F0ZXMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24nO1xuXG4vKiogQSBgTG9jYXRpb25Db25maWdgIG1vY2sgdGhhdCBnZXRzL3NldHMgYWxsIGNvbmZpZyBmcm9tIGFuIGluLW1lbW9yeSBvYmplY3QgKi9cbmV4cG9ydCBjbGFzcyBNZW1vcnlMb2NhdGlvbkNvbmZpZyBpbXBsZW1lbnRzIExvY2F0aW9uQ29uZmlnIHtcbiAgZGlzcG9zZSA9IG5vb3A7XG5cbiAgX2Jhc2VIcmVmID0gJyc7XG4gIF9wb3J0ID0gODA7XG4gIF9wcm90b2NvbCA9ICdodHRwJztcbiAgX2hvc3QgPSAnbG9jYWxob3N0JztcbiAgX2hhc2hQcmVmaXggPSAnJztcblxuICBwb3J0ID0gKCkgPT4gdGhpcy5fcG9ydDtcbiAgcHJvdG9jb2wgPSAoKSA9PiB0aGlzLl9wcm90b2NvbDtcbiAgaG9zdCA9ICgpID0+IHRoaXMuX2hvc3Q7XG4gIGJhc2VIcmVmID0gKCkgPT4gdGhpcy5fYmFzZUhyZWY7XG4gIGh0bWw1TW9kZSA9ICgpID0+IGZhbHNlO1xuICBoYXNoUHJlZml4ID0gKG5ld3ZhbD8pID0+IChpc0RlZmluZWQobmV3dmFsKSA/ICh0aGlzLl9oYXNoUHJlZml4ID0gbmV3dmFsKSA6IHRoaXMuX2hhc2hQcmVmaXgpO1xufVxuIiwiLyoqIEBpbnRlcm5hbGFwaSBAbW9kdWxlIHZhbmlsbGEgKi9cbi8qKiAqL1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL2NvbW1vbi9wcmVkaWNhdGVzJztcbmltcG9ydCB7IExvY2F0aW9uQ29uZmlnIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5cbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIG9iamVjdCAqL1xuZXhwb3J0IGNsYXNzIEJyb3dzZXJMb2NhdGlvbkNvbmZpZyBpbXBsZW1lbnRzIExvY2F0aW9uQ29uZmlnIHtcbiAgcHJpdmF0ZSBfYmFzZUhyZWYgPSB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX2hhc2hQcmVmaXggPSAnJztcblxuICBjb25zdHJ1Y3Rvcihyb3V0ZXI/LCBwcml2YXRlIF9pc0h0bWw1ID0gZmFsc2UpIHt9XG5cbiAgcG9ydCgpOiBudW1iZXIge1xuICAgIGlmIChsb2NhdGlvbi5wb3J0KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKGxvY2F0aW9uLnBvcnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3RvY29sKCkgPT09ICdodHRwcycgPyA0NDMgOiA4MDtcbiAgfVxuXG4gIHByb3RvY29sKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoLzovZywgJycpO1xuICB9XG5cbiAgaG9zdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgfVxuXG4gIGh0bWw1TW9kZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faXNIdG1sNTtcbiAgfVxuXG4gIGhhc2hQcmVmaXgoKTogc3RyaW5nO1xuICBoYXNoUHJlZml4KG5ld3ByZWZpeD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZChuZXdwcmVmaXgpID8gKHRoaXMuX2hhc2hQcmVmaXggPSBuZXdwcmVmaXgpIDogdGhpcy5faGFzaFByZWZpeDtcbiAgfVxuXG4gIGJhc2VIcmVmKGhyZWY/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChpc0RlZmluZWQoaHJlZikpIHRoaXMuX2Jhc2VIcmVmID0gaHJlZjtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5fYmFzZUhyZWYpKSB0aGlzLl9iYXNlSHJlZiA9IHRoaXMuZ2V0QmFzZUhyZWYoKTtcbiAgICByZXR1cm4gdGhpcy5fYmFzZUhyZWY7XG4gIH1cblxuICBwcml2YXRlIGdldEJhc2VIcmVmKCkge1xuICAgIGNvbnN0IGJhc2VUYWc6IEhUTUxCYXNlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJylbMF07XG4gICAgaWYgKGJhc2VUYWcgJiYgYmFzZVRhZy5ocmVmKSB7XG4gICAgICByZXR1cm4gYmFzZVRhZy5ocmVmLnJlcGxhY2UoL14oW14vOl0qOik/XFwvXFwvW14vXSovLCAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lzSHRtbDUgPyAnLycgOiBsb2NhdGlvbi5wYXRobmFtZSB8fCAnLyc7XG4gIH1cblxuICBkaXNwb3NlKCkge31cbn1cbiIsIi8qKiBAaW50ZXJuYWxhcGkgQG1vZHVsZSB2YW5pbGxhICovIC8qKiAqL1xuaW1wb3J0IHsgQnJvd3NlckxvY2F0aW9uQ29uZmlnIH0gZnJvbSAnLi9icm93c2VyTG9jYXRpb25Db25maWcnO1xuaW1wb3J0IHsgSGFzaExvY2F0aW9uU2VydmljZSB9IGZyb20gJy4vaGFzaExvY2F0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBsb2NhdGlvblBsdWdpbkZhY3RvcnkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IExvY2F0aW9uUGx1Z2luLCBTZXJ2aWNlc1BsdWdpbiB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IE1lbW9yeUxvY2F0aW9uU2VydmljZSB9IGZyb20gJy4vbWVtb3J5TG9jYXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IE1lbW9yeUxvY2F0aW9uQ29uZmlnIH0gZnJvbSAnLi9tZW1vcnlMb2NhdGlvbkNvbmZpZyc7XG5pbXBvcnQgeyAkaW5qZWN0b3IgfSBmcm9tICcuL2luamVjdG9yJztcbmltcG9ydCB7ICRxIH0gZnJvbSAnLi9xJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmVzZXJ2aWNlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2aWNlc1BsdWdpbihyb3V0ZXI6IFVJUm91dGVyKTogU2VydmljZXNQbHVnaW4ge1xuICBzZXJ2aWNlcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XG4gIHNlcnZpY2VzLiRxID0gJHE7XG5cbiAgcmV0dXJuIHsgbmFtZTogJ3ZhbmlsbGEuc2VydmljZXMnLCAkcSwgJGluamVjdG9yLCBkaXNwb3NlOiAoKSA9PiBudWxsIH07XG59XG5cbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdXNlcyB0aGUgYnJvd3NlciBoYXNoIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cbmV4cG9ydCBjb25zdCBoYXNoTG9jYXRpb25QbHVnaW46IChyb3V0ZXI6IFVJUm91dGVyKSA9PiBMb2NhdGlvblBsdWdpbiA9IGxvY2F0aW9uUGx1Z2luRmFjdG9yeShcbiAgJ3ZhbmlsbGEuaGFzaEJhbmdMb2NhdGlvbicsXG4gIGZhbHNlLFxuICBIYXNoTG9jYXRpb25TZXJ2aWNlLFxuICBCcm93c2VyTG9jYXRpb25Db25maWdcbik7XG5cbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gdXNpbmcgdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIGFuZCBgaGlzdG9yeWAgYXBpcyAqL1xuZXhwb3J0IGNvbnN0IHB1c2hTdGF0ZUxvY2F0aW9uUGx1Z2luOiAocm91dGVyOiBVSVJvdXRlcikgPT4gTG9jYXRpb25QbHVnaW4gPSBsb2NhdGlvblBsdWdpbkZhY3RvcnkoXG4gICd2YW5pbGxhLnB1c2hTdGF0ZUxvY2F0aW9uJyxcbiAgdHJ1ZSxcbiAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLFxuICBCcm93c2VyTG9jYXRpb25Db25maWdcbik7XG5cbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG5leHBvcnQgY29uc3QgbWVtb3J5TG9jYXRpb25QbHVnaW46IChyb3V0ZXI6IFVJUm91dGVyKSA9PiBMb2NhdGlvblBsdWdpbiA9IGxvY2F0aW9uUGx1Z2luRmFjdG9yeShcbiAgJ3ZhbmlsbGEubWVtb3J5TG9jYXRpb24nLFxuICBmYWxzZSxcbiAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLFxuICBNZW1vcnlMb2NhdGlvbkNvbmZpZ1xuKTtcbiIsIi8qKlxuICogIyBDb3JlIGNsYXNzZXMgYW5kIGludGVyZmFjZXNcbiAqXG4gKiBUaGUgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyB0aGF0IGFyZSBjb3JlIHRvIHVpLXJvdXRlciBhbmQgZG8gbm90IGJlbG9uZ1xuICogdG8gYSBtb3JlIHNwZWNpZmljIHN1YnN5c3RlbSAoc3VjaCBhcyByZXNvbHZlKS5cbiAqXG4gKiBAcHJlZmVycmVkIEBwdWJsaWNhcGkgQG1vZHVsZSBjb3JlXG4gKi8gLyoqICovXG5cbi8vIE5lZWQgdG8gaW1wb3J0IG9yIGV4cG9ydCBhdCBsZWFzdCBvbmUgY29uY3JldGUgc29tZXRoaW5nXG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi9jb21tb24vY29tbW9uJztcbmltcG9ydCB7IFVJUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInO1xuXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAqXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIGdldCByZXNvbHZlIHZhbHVlcyBmb3IgYSBnaXZlbiB0b2tlbi5cbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBgVUlJbmplY3RvcmAgY2FuIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gdXNpbmcgW1tUcmFuc2l0aW9uLmluamVjdG9yXV0uXG4gKlxuICogLS0tXG4gKlxuICogSWYgbm8gcmVzb2x2ZSBpcyBmb3VuZCBmb3IgYSB0b2tlbiwgdGhlbiBpdCB3aWxsIGRlbGVnYXRlIHRvIHRoZSBuYXRpdmUgaW5qZWN0b3IuXG4gKiBUaGUgbmF0aXZlIGluamVjdG9yIG1heSBiZSBBbmd1bGFyIDEgYCRpbmplY3RvcmAsIEFuZ3VsYXIgMiBgSW5qZWN0b3JgLCBvciBhIHNpbXBsZSBwb2x5ZmlsbC5cbiAqXG4gKiBJbiBBbmd1bGFyIDIsIHRoZSBuYXRpdmUgaW5qZWN0b3IgbWlnaHQgYmUgdGhlIHJvb3QgSW5qZWN0b3IsXG4gKiBvciBpdCBtaWdodCBiZSBhIGxhenkgbG9hZGVkIGBOZ01vZHVsZWAgaW5qZWN0b3Igc2NvcGVkIHRvIGEgbGF6eSBsb2FkIHN0YXRlIHRyZWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVUlJbmplY3RvciB7XG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgZnJvbSB0aGUgaW5qZWN0b3IuXG4gICAqXG4gICAqIEZvciBhIGdpdmVuIHRva2VuLCByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBpbmplY3RvciB0aGF0IG1hdGNoZXMgdGhlIHRva2VuLlxuICAgKiBJZiB0aGUgdG9rZW4gaXMgZm9yIGEgcmVzb2x2ZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gZmV0Y2hlZCwgdGhpcyB0aHJvd3MgYW4gZXJyb3IuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIG15UmVzb2x2ZSA9IGluamVjdG9yLmdldCgnbXlSZXNvbHZlJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiAjIyMjIG5nMSBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiAvLyBGZXRjaCBTdGF0ZVNlcnZpY2VcbiAgICogaW5qZWN0b3IuZ2V0KCckc3RhdGUnKS5nbygnaG9tZScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBuZzIgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHtTdGF0ZVNlcnZpY2V9IGZyb20gXCJ1aS1yb3V0ZXItbmcyXCI7XG4gICAqIC8vIEZldGNoIFN0YXRlU2VydmljZVxuICAgKiBpbmplY3Rvci5nZXQoU3RhdGVTZXJ2aWNlKS5nbygnaG9tZScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogIyMjIyBUeXBlc2NyaXB0IEV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHZhciBzdHJpbmdBcnJheSA9IGluamVjdG9yLmdldDxzdHJpbmdbXT4oJ215U3RyaW5nQXJyYXknKTtcbiAgICogYGBgXG4gICAqXG4gICAqICMjIyBgTk9XQUlUYCBwb2xpY3lcbiAgICpcbiAgICogV2hlbiB1c2luZyBbW1Jlc29sdmVQb2xpY3kuYXN5bmNdXSA9PT0gYE5PV0FJVGAsIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIGBnZXQoKWAgaXMgYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0LlxuICAgKiBUaGUgcHJvbWlzZSBpcyBub3QgYXV0b21hdGljYWxseSB1bndyYXBwZWQuXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbiB0aGUga2V5IGZvciB0aGUgdmFsdWUgdG8gZ2V0LiAgTWF5IGJlIGEgc3RyaW5nLCBhIGNsYXNzLCBvciBhbnkgYXJiaXRyYXJ5IG9iamVjdC5cbiAgICogQHJldHVybiB0aGUgRGVwZW5kZW5jeSBJbmplY3Rpb24gdmFsdWUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlblxuICAgKi9cbiAgZ2V0KHRva2VuOiBhbnkpOiBhbnk7XG4gIC8qKiBHZXRzIGEgdmFsdWUgYXMgdHlwZSBgVGAgKGdlbmVyaWNzIHBhcmFtZXRlcikgKi9cbiAgZ2V0PFQ+KHRva2VuOiBhbnkpOiBUO1xuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBnZXRzIGEgdmFsdWUgZnJvbSB0aGUgaW5qZWN0b3JcbiAgICpcbiAgICogRm9yIGEgZ2l2ZW4gdG9rZW4sIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgZnJvbSB0aGUgaW5qZWN0b3IgdGhhdCBtYXRjaGVzIHRoZSB0b2tlbi5cbiAgICogSWYgdGhlIHRva2VuIGlzIGZvciBhIHJlc29sdmUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGZldGNoZWQsIHRoaXMgdHJpZ2dlcnMgdGhlIHJlc29sdmUgdG8gbG9hZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiByZXR1cm4gaW5qZWN0b3IuZ2V0QXN5bmMoJ215UmVzb2x2ZScpLnRoZW4odmFsdWUgPT4ge1xuICAgKiAgIGlmICh2YWx1ZSA9PT0gJ2RlY2xpbmVkJykgcmV0dXJuIGZhbHNlO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbiB0aGUga2V5IGZvciB0aGUgdmFsdWUgdG8gZ2V0LiAgTWF5IGJlIGEgc3RyaW5nIG9yIGFyYml0cmFyeSBvYmplY3QuXG4gICAqIEByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgRGVwZW5kZW5jeSBJbmplY3Rpb24gdmFsdWUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlblxuICAgKi9cbiAgZ2V0QXN5bmModG9rZW46IGFueSk6IFByb21pc2U8YW55PjtcbiAgLyoqIEFzeW5jaHJvbm91c2x5IGdldHMgYSB2YWx1ZSBhcyB0eXBlIGBUYCAoZ2VuZXJpY3MgcGFyYW1ldGVyKSAqL1xuICBnZXRBc3luYzxUPih0b2tlbjogYW55KTogUHJvbWlzZTxUPjtcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGZyb20gdGhlIG5hdGl2ZSBpbmplY3RvclxuICAgKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgZnJvbSB0aGUgbmF0aXZlIGluamVjdG9yLCBieXBhc3NpbmcgYW55dGhpbmcgaW4gdGhlIFtbUmVzb2x2ZUNvbnRleHRdXS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogbGV0IHNvbWVUaGluZyA9IGluamVjdG9yLmdldE5hdGl2ZShTb21lVG9rZW4pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRva2VuIHRoZSBrZXkgZm9yIHRoZSB2YWx1ZSB0byBnZXQuICBNYXkgYmUgYSBzdHJpbmcgb3IgYXJiaXRyYXJ5IG9iamVjdC5cbiAgICogQHJldHVybiB0aGUgRGVwZW5kZW5jeSBJbmplY3Rpb24gdmFsdWUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlblxuICAgKi9cbiAgZ2V0TmF0aXZlKHRva2VuOiBhbnkpOiBhbnk7XG4gIGdldE5hdGl2ZTxUPih0b2tlbjogYW55KTogVDtcbn1cblxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0IGludGVyZmFjZSBVSVJvdXRlclBsdWdpbiBleHRlbmRzIERpc3Bvc2FibGUge1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVSVJvdXRlclBsdWdpbkJhc2UgaW1wbGVtZW50cyBVSVJvdXRlclBsdWdpbiwgRGlzcG9zYWJsZSB7XG4gIGFic3RyYWN0IG5hbWU6IHN0cmluZztcbiAgZGlzcG9zZShyb3V0ZXI6IFVJUm91dGVyKSB7fVxufVxuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgaW50ZXJmYWNlIERpc3Bvc2FibGUge1xuICAvKiogSW5zdHJ1Y3RzIHRoZSBEaXNwb3NhYmxlIHRvIGNsZWFuIHVwIGFueSByZXNvdXJjZXMgKi9cbiAgZGlzcG9zZShyb3V0ZXI/OiBVSVJvdXRlcik7XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIGNvbW1vbiAqLyAvKiogKi9cblxuZXhwb3J0ICogZnJvbSAnLi9jb21tb24vaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9wYXJhbXMvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9wYXRoL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vcmVzb2x2ZS9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3N0YXRlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdHJhbnNpdGlvbi9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3VybC9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3ZpZXcvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9nbG9iYWxzJztcblxuZXhwb3J0ICogZnJvbSAnLi9yb3V0ZXInO1xuZXhwb3J0ICogZnJvbSAnLi92YW5pbGxhJztcbmV4cG9ydCAqIGZyb20gJy4vaW50ZXJmYWNlJztcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgbmcxICovIC8qKiAqL1xuaW1wb3J0IHsgbmcgYXMgYW5ndWxhciB9IGZyb20gJy4uL2FuZ3VsYXInO1xuaW1wb3J0IHtcbiAgU3RhdGVPYmplY3QsXG4gIHBpY2ssXG4gIGZvckVhY2gsXG4gIHRhaWwsXG4gIGV4dGVuZCxcbiAgaXNBcnJheSxcbiAgaXNJbmplY3RhYmxlLFxuICBpc0RlZmluZWQsXG4gIGlzU3RyaW5nLFxuICBzZXJ2aWNlcyxcbiAgdHJhY2UsXG4gIFZpZXdDb25maWcsXG4gIFZpZXdTZXJ2aWNlLFxuICBWaWV3Q29uZmlnRmFjdG9yeSxcbiAgUGF0aE5vZGUsXG4gIFJlc29sdmVDb250ZXh0LFxuICBSZXNvbHZhYmxlLFxuICBJSW5qZWN0YWJsZSxcbn0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgTmcxVmlld0RlY2xhcmF0aW9uIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmltcG9ydCB7IFRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJy4uL3RlbXBsYXRlRmFjdG9yeSc7XG5pbXBvcnQgSUluamVjdG9yU2VydmljZSA9IGFuZ3VsYXIuYXV0by5JSW5qZWN0b3JTZXJ2aWNlO1xuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkoKTogVmlld0NvbmZpZ0ZhY3Rvcnkge1xuICBsZXQgdGVtcGxhdGVGYWN0b3J5OiBUZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xuICByZXR1cm4gKHBhdGgsIHZpZXcpID0+IHtcbiAgICB0ZW1wbGF0ZUZhY3RvcnkgPSB0ZW1wbGF0ZUZhY3RvcnkgfHwgc2VydmljZXMuJGluamVjdG9yLmdldCgnJHRlbXBsYXRlRmFjdG9yeScpO1xuICAgIHJldHVybiBbbmV3IE5nMVZpZXdDb25maWcocGF0aCwgdmlldywgdGVtcGxhdGVGYWN0b3J5KV07XG4gIH07XG59XG5cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmNvbnN0IGhhc0FueUtleSA9IChrZXlzLCBvYmopID0+IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjIHx8IGlzRGVmaW5lZChvYmpba2V5XSksIGZhbHNlKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciBhbmd1bGFyMSBgdmlld3NgLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIGhhbmRsZXMgdGhlIGB2aWV3c2AgcHJvcGVydHkgd2l0aCBsb2dpYyBzcGVjaWZpYyB0byBAdWlyb3V0ZXIvYW5ndWxhcmpzIChuZzEpLlxuICpcbiAqIElmIG5vIGB2aWV3czoge31gIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoZW4gaXQgY3JlYXRlcyB0aGUgYHZpZXdzYCBvYmplY3RcbiAqIGFuZCBhcHBsaWVzIHRoZSBzdGF0ZS1sZXZlbCBjb25maWd1cmF0aW9uIHRvIGEgdmlldyBuYW1lZCBgJGRlZmF1bHRgLlxuICpcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbmcxVmlld3NCdWlsZGVyKHN0YXRlOiBTdGF0ZU9iamVjdCkge1xuICAvLyBEbyBub3QgcHJvY2VzcyByb290IHN0YXRlXG4gIGlmICghc3RhdGUucGFyZW50KSByZXR1cm4ge307XG5cbiAgY29uc3QgdHBsS2V5cyA9IFsndGVtcGxhdGVQcm92aWRlcicsICd0ZW1wbGF0ZVVybCcsICd0ZW1wbGF0ZScsICdub3RpZnknLCAnYXN5bmMnXSxcbiAgICBjdHJsS2V5cyA9IFsnY29udHJvbGxlcicsICdjb250cm9sbGVyUHJvdmlkZXInLCAnY29udHJvbGxlckFzJywgJ3Jlc29sdmVBcyddLFxuICAgIGNvbXBLZXlzID0gWydjb21wb25lbnQnLCAnYmluZGluZ3MnLCAnY29tcG9uZW50UHJvdmlkZXInXSxcbiAgICBub25Db21wS2V5cyA9IHRwbEtleXMuY29uY2F0KGN0cmxLZXlzKSxcbiAgICBhbGxWaWV3S2V5cyA9IGNvbXBLZXlzLmNvbmNhdChub25Db21wS2V5cyk7XG5cbiAgLy8gRG8gbm90IGFsbG93IGEgc3RhdGUgdG8gaGF2ZSBib3RoIHN0YXRlLWxldmVsIHByb3BzIGFuZCBhbHNvIGEgYHZpZXdzOiB7fWAgcHJvcGVydHkuXG4gIC8vIEEgc3RhdGUgd2l0aG91dCBhIGB2aWV3czoge31gIHByb3BlcnR5IGNhbiBkZWNsYXJlIHByb3BlcnRpZXMgZm9yIHRoZSBgJGRlZmF1bHRgIHZpZXcgYXMgcHJvcGVydGllcyBvZiB0aGUgc3RhdGUuXG4gIC8vIEhvd2V2ZXIsIHRoZSBgJGRlZmF1bHRgIGFwcHJvYWNoIHNob3VsZCBub3QgYmUgbWl4ZWQgd2l0aCBhIHNlcGFyYXRlIGB2aWV3czogYCBibG9jay5cbiAgaWYgKGlzRGVmaW5lZChzdGF0ZS52aWV3cykgJiYgaGFzQW55S2V5KGFsbFZpZXdLZXlzLCBzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU3RhdGUgJyR7c3RhdGUubmFtZX0nIGhhcyBhICd2aWV3cycgb2JqZWN0LiBgICtcbiAgICAgICAgYEl0IGNhbm5vdCBhbHNvIGhhdmUgXCJ2aWV3IHByb3BlcnRpZXNcIiBhdCB0aGUgc3RhdGUgbGV2ZWwuICBgICtcbiAgICAgICAgYE1vdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGludG8gYSB2aWV3IChpbiB0aGUgJ3ZpZXdzJyBvYmplY3QpOiBgICtcbiAgICAgICAgYCAke2FsbFZpZXdLZXlzLmZpbHRlcihrZXkgPT4gaXNEZWZpbmVkKHN0YXRlW2tleV0pKS5qb2luKCcsICcpfWBcbiAgICApO1xuICB9XG5cbiAgY29uc3Qgdmlld3M6IHsgW2tleTogc3RyaW5nXTogTmcxVmlld0RlY2xhcmF0aW9uIH0gPSB7fSxcbiAgICB2aWV3c09iamVjdCA9IHN0YXRlLnZpZXdzIHx8IHsgJGRlZmF1bHQ6IHBpY2soc3RhdGUsIGFsbFZpZXdLZXlzKSB9O1xuXG4gIGZvckVhY2godmlld3NPYmplY3QsIGZ1bmN0aW9uKGNvbmZpZzogTmcxVmlld0RlY2xhcmF0aW9uLCBuYW1lOiBzdHJpbmcpIHtcbiAgICAvLyBBY2NvdW50IGZvciB2aWV3czogeyBcIlwiOiB7IHRlbXBsYXRlLi4uIH0gfVxuICAgIG5hbWUgPSBuYW1lIHx8ICckZGVmYXVsdCc7XG4gICAgLy8gQWNjb3VudCBmb3Igdmlld3M6IHsgaGVhZGVyOiBcImhlYWRlckNvbXBvbmVudFwiIH1cbiAgICBpZiAoaXNTdHJpbmcoY29uZmlnKSkgY29uZmlnID0geyBjb21wb25lbnQ6IDxzdHJpbmc+Y29uZmlnIH07XG5cbiAgICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gICAgY29uZmlnID0gZXh0ZW5kKHt9LCBjb25maWcpO1xuXG4gICAgLy8gRG8gbm90IGFsbG93IGEgdmlldyB0byBtaXggcHJvcHMgZm9yIGNvbXBvbmVudC1zdHlsZSB2aWV3IHdpdGggcHJvcHMgZm9yIHRlbXBsYXRlL2NvbnRyb2xsZXItc3R5bGUgdmlld1xuICAgIGlmIChoYXNBbnlLZXkoY29tcEtleXMsIGNvbmZpZykgJiYgaGFzQW55S2V5KG5vbkNvbXBLZXlzLCBjb25maWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY29tYmluZTogJHtjb21wS2V5cy5qb2luKCd8Jyl9IHdpdGg6ICR7bm9uQ29tcEtleXMuam9pbignfCcpfSBpbiBzdGF0ZXZpZXc6ICcke25hbWV9QCR7c3RhdGUubmFtZX0nYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25maWcucmVzb2x2ZUFzID0gY29uZmlnLnJlc29sdmVBcyB8fCAnJHJlc29sdmUnO1xuICAgIGNvbmZpZy4kdHlwZSA9ICduZzEnO1xuICAgIGNvbmZpZy4kY29udGV4dCA9IHN0YXRlO1xuICAgIGNvbmZpZy4kbmFtZSA9IG5hbWU7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gVmlld1NlcnZpY2Uubm9ybWFsaXplVUlWaWV3VGFyZ2V0KGNvbmZpZy4kY29udGV4dCwgY29uZmlnLiRuYW1lKTtcbiAgICBjb25maWcuJHVpVmlld05hbWUgPSBub3JtYWxpemVkLnVpVmlld05hbWU7XG4gICAgY29uZmlnLiR1aVZpZXdDb250ZXh0QW5jaG9yID0gbm9ybWFsaXplZC51aVZpZXdDb250ZXh0QW5jaG9yO1xuXG4gICAgdmlld3NbbmFtZV0gPSBjb25maWc7XG4gIH0pO1xuICByZXR1cm4gdmlld3M7XG59XG5cbi8qKiBAaGlkZGVuICovXG5sZXQgaWQgPSAwO1xuXG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnQgY2xhc3MgTmcxVmlld0NvbmZpZyBpbXBsZW1lbnRzIFZpZXdDb25maWcge1xuICAkaWQgPSBpZCsrO1xuICBsb2FkZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlcjogRnVuY3Rpb247IC8vIGFjdHVhbGx5IElJbmplY3RhYmxlfHN0cmluZ1xuICB0ZW1wbGF0ZTogc3RyaW5nO1xuICBjb21wb25lbnQ6IHN0cmluZztcbiAgbG9jYWxzOiBhbnk7IC8vIFRPRE86IGRlbGV0ZSBtZVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXRoOiBQYXRoTm9kZVtdLCBwdWJsaWMgdmlld0RlY2w6IE5nMVZpZXdEZWNsYXJhdGlvbiwgcHVibGljIGZhY3Rvcnk6IFRlbXBsYXRlRmFjdG9yeSkge31cblxuICBsb2FkKCkge1xuICAgIGNvbnN0ICRxID0gc2VydmljZXMuJHE7XG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBSZXNvbHZlQ29udGV4dCh0aGlzLnBhdGgpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGF0aC5yZWR1Y2UoKGFjYywgbm9kZSkgPT4gZXh0ZW5kKGFjYywgbm9kZS5wYXJhbVZhbHVlcyksIHt9KTtcblxuICAgIGNvbnN0IHByb21pc2VzOiBhbnkgPSB7XG4gICAgICB0ZW1wbGF0ZTogJHEud2hlbih0aGlzLmZhY3RvcnkuZnJvbUNvbmZpZyh0aGlzLnZpZXdEZWNsLCBwYXJhbXMsIGNvbnRleHQpKSxcbiAgICAgIGNvbnRyb2xsZXI6ICRxLndoZW4odGhpcy5nZXRDb250cm9sbGVyKGNvbnRleHQpKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHRyYWNlLnRyYWNlVmlld1NlcnZpY2VFdmVudCgnTG9hZGVkJywgdGhpcyk7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSByZXN1bHRzLmNvbnRyb2xsZXI7XG4gICAgICBleHRlbmQodGhpcywgcmVzdWx0cy50ZW1wbGF0ZSk7IC8vIEVpdGhlciB7IHRlbXBsYXRlOiBcInRwbFwiIH0gb3IgeyBjb21wb25lbnQ6IFwiY21wTmFtZVwiIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0VGVtcGxhdGUgPSAodWlWaWV3LCBjb250ZXh0OiBSZXNvbHZlQ29udGV4dCkgPT5cbiAgICB0aGlzLmNvbXBvbmVudFxuICAgICAgPyB0aGlzLmZhY3RvcnkubWFrZUNvbXBvbmVudFRlbXBsYXRlKHVpVmlldywgY29udGV4dCwgdGhpcy5jb21wb25lbnQsIHRoaXMudmlld0RlY2wuYmluZGluZ3MpXG4gICAgICA6IHRoaXMudGVtcGxhdGU7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRyb2xsZXIgZm9yIGEgdmlldyBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb258UHJvbWlzZS48RnVuY3Rpb24+fSBSZXR1cm5zIGEgY29udHJvbGxlciwgb3IgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBjb250cm9sbGVyLlxuICAgKi9cbiAgZ2V0Q29udHJvbGxlcihjb250ZXh0OiBSZXNvbHZlQ29udGV4dCk6IElJbmplY3RhYmxlIHwgc3RyaW5nIHwgUHJvbWlzZTxJSW5qZWN0YWJsZSB8IHN0cmluZz4ge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy52aWV3RGVjbC5jb250cm9sbGVyUHJvdmlkZXI7XG4gICAgaWYgKCFpc0luamVjdGFibGUocHJvdmlkZXIpKSByZXR1cm4gdGhpcy52aWV3RGVjbC5jb250cm9sbGVyO1xuICAgIGNvbnN0IGRlcHMgPSBzZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVyRm4gPSBpc0FycmF5KHByb3ZpZGVyKSA/IHRhaWwoPGFueT5wcm92aWRlcikgOiBwcm92aWRlcjtcbiAgICBjb25zdCByZXNvbHZhYmxlID0gbmV3IFJlc29sdmFibGUoJycsIDxhbnk+cHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xuICB9XG59XG4iLCIvKiogQHB1YmxpY2FwaSBAbW9kdWxlIHZpZXcgKi8gLyoqICovXG5pbXBvcnQgeyBuZyBhcyBhbmd1bGFyIH0gZnJvbSAnLi9hbmd1bGFyJztcbmltcG9ydCB7IElBdWdtZW50ZWRKUXVlcnkgfSBmcm9tICdhbmd1bGFyJztcbmltcG9ydCB7XG4gIGlzQXJyYXksXG4gIGlzRGVmaW5lZCxcbiAgaXNGdW5jdGlvbixcbiAgaXNPYmplY3QsXG4gIHNlcnZpY2VzLFxuICBPYmosXG4gIElJbmplY3RhYmxlLFxuICB0YWlsLFxuICBrZWJvYlN0cmluZyxcbiAgdW5uZXN0UixcbiAgUmVzb2x2ZUNvbnRleHQsXG4gIFJlc29sdmFibGUsXG4gIFJhd1BhcmFtcyxcbn0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgTmcxVmlld0RlY2xhcmF0aW9uLCBUZW1wbGF0ZUZhY3RvcnlQcm92aWRlciB9IGZyb20gJy4vaW50ZXJmYWNlJztcblxuLyoqXG4gKiBTZXJ2aWNlIHdoaWNoIG1hbmFnZXMgbG9hZGluZyBvZiB0ZW1wbGF0ZXMgZnJvbSBhIFZpZXdDb25maWcuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUZhY3RvcnkgaW1wbGVtZW50cyBUZW1wbGF0ZUZhY3RvcnlQcm92aWRlciB7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgX3VzZUh0dHAgPSBhbmd1bGFyLnZlcnNpb24ubWlub3IgPCAzO1xuICAvKiogQGhpZGRlbiAqLyBwcml2YXRlICR0ZW1wbGF0ZVJlcXVlc3Q7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgJHRlbXBsYXRlQ2FjaGU7XG4gIC8qKiBAaGlkZGVuICovIHByaXZhdGUgJGh0dHA7XG5cbiAgLyoqIEBoaWRkZW4gKi8gJGdldCA9IFtcbiAgICAnJGh0dHAnLFxuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgJyRpbmplY3RvcicsXG4gICAgKCRodHRwLCAkdGVtcGxhdGVDYWNoZSwgJGluamVjdG9yKSA9PiB7XG4gICAgICB0aGlzLiR0ZW1wbGF0ZVJlcXVlc3QgPSAkaW5qZWN0b3IuaGFzICYmICRpbmplY3Rvci5oYXMoJyR0ZW1wbGF0ZVJlcXVlc3QnKSAmJiAkaW5qZWN0b3IuZ2V0KCckdGVtcGxhdGVSZXF1ZXN0Jyk7XG4gICAgICB0aGlzLiRodHRwID0gJGh0dHA7XG4gICAgICB0aGlzLiR0ZW1wbGF0ZUNhY2hlID0gJHRlbXBsYXRlQ2FjaGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBdO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIHVzZUh0dHBTZXJ2aWNlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fdXNlSHR0cCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHdoaWNoIHRvIGxvYWQgYSB0ZW1wbGF0ZS5cbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBzZWFyY2ggaW4gdGhlIHNwZWNpZmllZCBvcmRlciwgYW5kIHRoZSBmaXJzdCBvbmVcbiAgICogdGhhdCBpcyBkZWZpbmVkIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZW1wbGF0ZTpcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIHJlc29sdmUgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHRlbXBsYXRlJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSAgVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3JcbiAgICogdGhhdCBzdHJpbmcsb3IgYG51bGxgIGlmIG5vIHRlbXBsYXRlIGlzIGNvbmZpZ3VyZWQuXG4gICAqL1xuICBmcm9tQ29uZmlnKFxuICAgIGNvbmZpZzogTmcxVmlld0RlY2xhcmF0aW9uLFxuICAgIHBhcmFtczogYW55LFxuICAgIGNvbnRleHQ6IFJlc29sdmVDb250ZXh0XG4gICk6IFByb21pc2U8eyB0ZW1wbGF0ZT86IHN0cmluZzsgY29tcG9uZW50Pzogc3RyaW5nIH0+IHtcbiAgICBjb25zdCBkZWZhdWx0VGVtcGxhdGUgPSAnPHVpLXZpZXc+PC91aS12aWV3Pic7XG5cbiAgICBjb25zdCBhc1RlbXBsYXRlID0gcmVzdWx0ID0+IHNlcnZpY2VzLiRxLndoZW4ocmVzdWx0KS50aGVuKHN0ciA9PiAoeyB0ZW1wbGF0ZTogc3RyIH0pKTtcbiAgICBjb25zdCBhc0NvbXBvbmVudCA9IHJlc3VsdCA9PiBzZXJ2aWNlcy4kcS53aGVuKHJlc3VsdCkudGhlbihzdHIgPT4gKHsgY29tcG9uZW50OiBzdHIgfSkpO1xuXG4gICAgcmV0dXJuIGlzRGVmaW5lZChjb25maWcudGVtcGxhdGUpXG4gICAgICA/IGFzVGVtcGxhdGUodGhpcy5mcm9tU3RyaW5nKGNvbmZpZy50ZW1wbGF0ZSwgcGFyYW1zKSlcbiAgICAgIDogaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVVybClcbiAgICAgID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpKVxuICAgICAgOiBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIpXG4gICAgICA/IGFzVGVtcGxhdGUodGhpcy5mcm9tUHJvdmlkZXIoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkpXG4gICAgICA6IGlzRGVmaW5lZChjb25maWcuY29tcG9uZW50KVxuICAgICAgPyBhc0NvbXBvbmVudChjb25maWcuY29tcG9uZW50KVxuICAgICAgOiBpc0RlZmluZWQoY29uZmlnLmNvbXBvbmVudFByb3ZpZGVyKVxuICAgICAgPyBhc0NvbXBvbmVudCh0aGlzLmZyb21Db21wb25lbnRQcm92aWRlcihjb25maWcuY29tcG9uZW50UHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkpXG4gICAgICA6IGFzVGVtcGxhdGUoZGVmYXVsdFRlbXBsYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZnJvbSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfG9iamVjdH0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdFxuICAgKiBzdHJpbmcuXG4gICAqL1xuICBmcm9tU3RyaW5nKHRlbXBsYXRlOiBzdHJpbmcgfCBGdW5jdGlvbiwgcGFyYW1zPzogUmF3UGFyYW1zKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odGVtcGxhdGUpID8gKDxhbnk+dGVtcGxhdGUpKHBhcmFtcykgOiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIHRlbXBsYXRlIGZyb20gdGhlIGEgVVJMIHZpYSBgJGh0dHBgIGFuZCBgJHRlbXBsYXRlQ2FjaGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gdXJsIHVybCBvZiB0aGUgdGVtcGxhdGUgdG8gbG9hZCwgb3IgYSBmdW5jdGlvblxuICAgKiB0aGF0IHJldHVybnMgYSB1cmwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB1cmwgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlXG4gICAqIGZvciB0aGF0IHN0cmluZy5cbiAgICovXG4gIGZyb21VcmwodXJsOiBzdHJpbmcgfCBGdW5jdGlvbiwgcGFyYW1zOiBhbnkpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih1cmwpKSB1cmwgPSAoPGFueT51cmwpKHBhcmFtcyk7XG4gICAgaWYgKHVybCA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIGlmICh0aGlzLl91c2VIdHRwKSB7XG4gICAgICByZXR1cm4gdGhpcy4kaHR0cFxuICAgICAgICAuZ2V0KHVybCwgeyBjYWNoZTogdGhpcy4kdGVtcGxhdGVDYWNoZSwgaGVhZGVyczogeyBBY2NlcHQ6ICd0ZXh0L2h0bWwnIH0gfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuJHRlbXBsYXRlUmVxdWVzdCh1cmwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBieSBpbnZva2luZyBhbiBpbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvdmlkZXIgRnVuY3Rpb24gdG8gaW52b2tlIHZpYSBgbG9jYWxzYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGbiBhIGZ1bmN0aW9uIHVzZWQgdG8gaW52b2tlIHRoZSB0ZW1wbGF0ZSBwcm92aWRlclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZS48c3RyaW5nPn0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZVxuICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAqL1xuICBmcm9tUHJvdmlkZXIocHJvdmlkZXI6IElJbmplY3RhYmxlLCBwYXJhbXM6IGFueSwgY29udGV4dDogUmVzb2x2ZUNvbnRleHQpIHtcbiAgICBjb25zdCBkZXBzID0gc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICBjb25zdCBwcm92aWRlckZuID0gaXNBcnJheShwcm92aWRlcikgPyB0YWlsKDxhbnlbXT5wcm92aWRlcikgOiBwcm92aWRlcjtcbiAgICBjb25zdCByZXNvbHZhYmxlID0gbmV3IFJlc29sdmFibGUoJycsIDxGdW5jdGlvbj5wcm92aWRlckZuLCBkZXBzKTtcbiAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQoY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvbmVudCdzIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlciBGdW5jdGlvbiB0byBpbnZva2UgdmlhIGBsb2NhbHNgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZuIGEgZnVuY3Rpb24gdXNlZCB0byBpbnZva2UgdGhlIHRlbXBsYXRlIHByb3ZpZGVyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAqL1xuICBmcm9tQ29tcG9uZW50UHJvdmlkZXIocHJvdmlkZXI6IElJbmplY3RhYmxlLCBwYXJhbXM6IGFueSwgY29udGV4dDogUmVzb2x2ZUNvbnRleHQpIHtcbiAgICBjb25zdCBkZXBzID0gc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICBjb25zdCBwcm92aWRlckZuID0gaXNBcnJheShwcm92aWRlcikgPyB0YWlsKDxhbnlbXT5wcm92aWRlcikgOiBwcm92aWRlcjtcbiAgICBjb25zdCByZXNvbHZhYmxlID0gbmV3IFJlc29sdmFibGUoJycsIDxGdW5jdGlvbj5wcm92aWRlckZuLCBkZXBzKTtcbiAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQoY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb21wb25lbnQncyBuYW1lXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50cyByb3V0ZS10by1jb21wb25lbnQuXG4gICAqIEl0IHdvcmtzIGJ5IHJldHJpZXZpbmcgdGhlIGNvbXBvbmVudCAoZGlyZWN0aXZlKSBtZXRhZGF0YSBmcm9tIHRoZSBpbmplY3Rvci5cbiAgICogSXQgYW5hbHlzZXMgdGhlIGNvbXBvbmVudCdzIGJpbmRpbmdzLCB0aGVuIGNvbnN0cnVjdHMgYSB0ZW1wbGF0ZSB0aGF0IGluc3RhbnRpYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKiBUaGUgdGVtcGxhdGUgd2lyZXMgaW5wdXQgYW5kIG91dHB1dCBiaW5kaW5ncyB0byByZXNvbHZlcyBvciBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdWlWaWV3IHtvYmplY3R9IFRoZSBwYXJlbnQgdWktdmlldyAoZm9yIGJpbmRpbmcgb3V0cHV0cyB0byBjYWxsYmFja3MpXG4gICAqIEBwYXJhbSBjb250ZXh0IFRoZSBSZXNvbHZlQ29udGV4dCAoZm9yIGJpbmRpbmcgb3V0cHV0cyB0byBjYWxsYmFja3MgcmV0dXJuZWQgZnJvbSByZXNvbHZlcylcbiAgICogQHBhcmFtIGNvbXBvbmVudCB7c3RyaW5nfSBDb21wb25lbnQncyBuYW1lIGluIGNhbWVsIGNhc2UuXG4gICAqIEBwYXJhbSBiaW5kaW5ncyBBbiBvYmplY3QgZGVmaW5pbmcgdGhlIGNvbXBvbmVudCdzIGJpbmRpbmdzOiB7Zm9vOiAnPCd9XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGFzIGEgc3RyaW5nOiBcIjxjb21wb25lbnQtbmFtZSBpbnB1dDE9Jzo6JHJlc29sdmUuZm9vJz48L2NvbXBvbmVudC1uYW1lPlwiLlxuICAgKi9cbiAgbWFrZUNvbXBvbmVudFRlbXBsYXRlKHVpVmlldzogSUF1Z21lbnRlZEpRdWVyeSwgY29udGV4dDogUmVzb2x2ZUNvbnRleHQsIGNvbXBvbmVudDogc3RyaW5nLCBiaW5kaW5ncz86IGFueSkge1xuICAgIGJpbmRpbmdzID0gYmluZGluZ3MgfHwge307XG5cbiAgICAvLyBCaW5kIG9uY2UgcHJlZml4XG4gICAgY29uc3QgcHJlZml4ID0gYW5ndWxhci52ZXJzaW9uLm1pbm9yID49IDMgPyAnOjonIDogJyc7XG4gICAgLy8gQ29udmVydCB0byBrZWJvYiBuYW1lLiBBZGQgeC0gcHJlZml4IGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggYHgtYCBvciBgZGF0YS1gXG4gICAgY29uc3Qga2Vib2IgPSAoY2FtZWxDYXNlOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGtlYm9iZWQgPSBrZWJvYlN0cmluZyhjYW1lbENhc2UpO1xuICAgICAgcmV0dXJuIC9eKHh8ZGF0YSktLy5leGVjKGtlYm9iZWQpID8gYHgtJHtrZWJvYmVkfWAgOiBrZWJvYmVkO1xuICAgIH07XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVUcGwgPSAoaW5wdXQ6IEJpbmRpbmdUdXBsZSkgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBpbnB1dDtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0ga2Vib2IobmFtZSk7XG4gICAgICAvLyBJZiB0aGUgdWktdmlldyBoYXMgYW4gYXR0cmlidXRlIHdoaWNoIG1hdGNoZXMgYSBiaW5kaW5nIG9uIHRoZSByb3V0ZWQgY29tcG9uZW50XG4gICAgICAvLyB0aGVuIHBhc3MgdGhhdCBhdHRyaWJ1dGUgdGhyb3VnaCB0byB0aGUgcm91dGVkIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAgICAgIC8vIFByZWZlciB1aS12aWV3IHdpcmVkIG1hcHBpbmdzIHRvIHJlc29sdmUgZGF0YSwgdW5sZXNzIHRoZSByZXNvbHZlIHdhcyBleHBsaWNpdGx5IGJvdW5kIHVzaW5nIGBiaW5kaW5nczpgXG4gICAgICBpZiAodWlWaWV3LmF0dHIoYXR0ck5hbWUpICYmICFiaW5kaW5nc1tuYW1lXSkgcmV0dXJuIGAke2F0dHJOYW1lfT0nJHt1aVZpZXcuYXR0cihhdHRyTmFtZSl9J2A7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVOYW1lID0gYmluZGluZ3NbbmFtZV0gfHwgbmFtZTtcbiAgICAgIC8vIFByZS1ldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBmb3IgXCJAXCIgYmluZGluZ3MgYnkgZW5jbG9zaW5nIGluIHt7IH19XG4gICAgICAvLyBzb21lLWF0dHI9XCJ7eyA6OiRyZXNvbHZlLnNvbWVSZXNvbHZlTmFtZSB9fVwiXG4gICAgICBpZiAodHlwZSA9PT0gJ0AnKSByZXR1cm4gYCR7YXR0ck5hbWV9PSd7eyR7cHJlZml4fSRyZXNvbHZlLiR7cmVzb2x2ZU5hbWV9fX0nYDtcblxuICAgICAgLy8gV2lyZSBcIiZcIiBjYWxsYmFja3MgdG8gcmVzb2x2ZXMgdGhhdCByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgLy8gR2V0IHRoZSByZXN1bHQgb2YgdGhlIHJlc29sdmUgKHNob3VsZCBiZSBhIGZ1bmN0aW9uKSBhbmQgYW5ub3RhdGUgaXQgdG8gZ2V0IGl0cyBhcmd1bWVudHMuXG4gICAgICAvLyBzb21lLWF0dHI9XCIkcmVzb2x2ZS5zb21lUmVzb2x2ZVJlc3VsdE5hbWUoZm9vLCBiYXIpXCJcbiAgICAgIGlmICh0eXBlID09PSAnJicpIHtcbiAgICAgICAgY29uc3QgcmVzID0gY29udGV4dC5nZXRSZXNvbHZhYmxlKHJlc29sdmVOYW1lKTtcbiAgICAgICAgY29uc3QgZm4gPSByZXMgJiYgcmVzLmRhdGE7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoZm4gJiYgc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKGZuKSkgfHwgW107XG4gICAgICAgIC8vIGFjY291bnQgZm9yIGFycmF5IHN0eWxlIGluamVjdGlvbiwgaS5lLiwgWydmb28nLCBmdW5jdGlvbihmb28pIHt9XVxuICAgICAgICBjb25zdCBhcnJheUlkeFN0ciA9IGlzQXJyYXkoZm4pID8gYFske2ZuLmxlbmd0aCAtIDF9XWAgOiAnJztcbiAgICAgICAgcmV0dXJuIGAke2F0dHJOYW1lfT0nJHJlc29sdmUuJHtyZXNvbHZlTmFtZX0ke2FycmF5SWR4U3RyfSgke2FyZ3Muam9pbignLCcpfSknYDtcbiAgICAgIH1cblxuICAgICAgLy8gc29tZS1hdHRyPVwiOjokcmVzb2x2ZS5zb21lUmVzb2x2ZU5hbWVcIlxuICAgICAgcmV0dXJuIGAke2F0dHJOYW1lfT0nJHtwcmVmaXh9JHJlc29sdmUuJHtyZXNvbHZlTmFtZX0nYDtcbiAgICB9O1xuXG4gICAgY29uc3QgYXR0cnMgPSBnZXRDb21wb25lbnRCaW5kaW5ncyhjb21wb25lbnQpXG4gICAgICAubWFwKGF0dHJpYnV0ZVRwbClcbiAgICAgIC5qb2luKCcgJyk7XG4gICAgY29uc3Qga2Vib2JOYW1lID0ga2Vib2IoY29tcG9uZW50KTtcbiAgICByZXR1cm4gYDwke2tlYm9iTmFtZX0gJHthdHRyc30+PC8ke2tlYm9iTmFtZX0+YDtcbiAgfVxufVxuXG4vLyBHZXRzIGFsbCB0aGUgZGlyZWN0aXZlKHMpJyBpbnB1dHMgKCdAJywgJz0nLCBhbmQgJzwnKSBhbmQgb3V0cHV0cyAoJyYnKVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50QmluZGluZ3MobmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNtcERlZnMgPSA8YW55W10+c2VydmljZXMuJGluamVjdG9yLmdldChuYW1lICsgJ0RpcmVjdGl2ZScpOyAvLyBjb3VsZCBiZSBtdWx0aXBsZVxuICBpZiAoIWNtcERlZnMgfHwgIWNtcERlZnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGNvbXBvbmVudCBuYW1lZCAnJHtuYW1lfSdgKTtcbiAgcmV0dXJuIGNtcERlZnMubWFwKGdldEJpbmRpbmdzKS5yZWR1Y2UodW5uZXN0UiwgW10pO1xufVxuXG4vLyBHaXZlbiBhIGRpcmVjdGl2ZSBkZWZpbml0aW9uLCBmaW5kIGl0cyBvYmplY3QgaW5wdXQgYXR0cmlidXRlc1xuLy8gVXNlIGRpZmZlcmVudCBwcm9wZXJ0aWVzLCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZGlyZWN0aXZlIChjb21wb25lbnQsIGJpbmRUb0NvbnRyb2xsZXIsIG5vcm1hbClcbmNvbnN0IGdldEJpbmRpbmdzID0gKGRlZjogYW55KSA9PiB7XG4gIGlmIChpc09iamVjdChkZWYuYmluZFRvQ29udHJvbGxlcikpIHJldHVybiBzY29wZUJpbmRpbmdzKGRlZi5iaW5kVG9Db250cm9sbGVyKTtcbiAgcmV0dXJuIHNjb3BlQmluZGluZ3MoZGVmLnNjb3BlKTtcbn07XG5cbmludGVyZmFjZSBCaW5kaW5nVHVwbGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbn1cblxuLy8gZm9yIG5nIDEuMiBzdHlsZSwgcHJvY2VzcyB0aGUgc2NvcGU6IHsgaW5wdXQ6IFwiPWZvb1wiIH1cbi8vIGZvciBuZyAxLjMgdGhyb3VnaCBuZyAxLjUsIHByb2Nlc3MgdGhlIGNvbXBvbmVudCdzIGJpbmRUb0NvbnRyb2xsZXI6IHsgaW5wdXQ6IFwiPWZvb1wiIH0gb2JqZWN0XG5jb25zdCBzY29wZUJpbmRpbmdzID0gKGJpbmRpbmdzT2JqOiBPYmopID0+XG4gIE9iamVjdC5rZXlzKGJpbmRpbmdzT2JqIHx8IHt9KVxuICAgIC8vIFsgJ2lucHV0JywgWyAnPWZvbycsICc9JywgJ2ZvbycgXSBdXG4gICAgLm1hcChrZXkgPT4gW2tleSwgL14oWz08QCZdKVs/XT8oLiopLy5leGVjKGJpbmRpbmdzT2JqW2tleV0pXSlcbiAgICAvLyBza2lwIG1hbGZvcm1lZCB2YWx1ZXNcbiAgICAuZmlsdGVyKHR1cGxlID0+IGlzRGVmaW5lZCh0dXBsZSkgJiYgaXNBcnJheSh0dXBsZVsxXSkpXG4gICAgLy8geyBuYW1lOiAoJ2ZvbycgfHwgJ2lucHV0JyksIHR5cGU6ICc9JyB9XG4gICAgLm1hcCh0dXBsZSA9PiAoeyBuYW1lOiB0dXBsZVsxXVsyXSB8fCB0dXBsZVswXSwgdHlwZTogdHVwbGVbMV1bMV0gfSBhcyBCaW5kaW5nVHVwbGUpKTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgbmcxICovIC8qKiAqL1xuaW1wb3J0IHtcbiAgdmFsLFxuICBpc09iamVjdCxcbiAgY3JlYXRlUHJveHlGdW5jdGlvbnMsXG4gIEJ1aWxkZXJGdW5jdGlvbixcbiAgU3RhdGVSZWdpc3RyeSxcbiAgU3RhdGVTZXJ2aWNlLFxuICBPbkludmFsaWRDYWxsYmFjayxcbn0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgTmcxU3RhdGVEZWNsYXJhdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlJztcblxuLyoqXG4gKiBUaGUgQW5ndWxhciAxIGBTdGF0ZVByb3ZpZGVyYFxuICpcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHdvcmtzIHNpbWlsYXIgdG8gQW5ndWxhcidzIHYxIHJvdXRlciwgYnV0IGl0IGZvY3VzZXMgcHVyZWx5XG4gKiBvbiBzdGF0ZS5cbiAqXG4gKiBBIHN0YXRlIGNvcnJlc3BvbmRzIHRvIGEgXCJwbGFjZVwiIGluIHRoZSBhcHBsaWNhdGlvbiBpbiB0ZXJtcyBvZiB0aGUgb3ZlcmFsbCBVSSBhbmRcbiAqIG5hdmlnYXRpb24uIEEgc3RhdGUgZGVzY3JpYmVzICh2aWEgdGhlIGNvbnRyb2xsZXIgLyB0ZW1wbGF0ZSAvIHZpZXcgcHJvcGVydGllcykgd2hhdFxuICogdGhlIFVJIGxvb2tzIGxpa2UgYW5kIGRvZXMgYXQgdGhhdCBwbGFjZS5cbiAqXG4gKiBTdGF0ZXMgb2Z0ZW4gaGF2ZSB0aGluZ3MgaW4gY29tbW9uLCBhbmQgdGhlIHByaW1hcnkgd2F5IG9mIGZhY3RvcmluZyBvdXQgdGhlc2VcbiAqIGNvbW1vbmFsaXRpZXMgaW4gdGhpcyBtb2RlbCBpcyB2aWEgdGhlIHN0YXRlIGhpZXJhcmNoeSwgaS5lLiBwYXJlbnQvY2hpbGQgc3RhdGVzIGFrYVxuICogbmVzdGVkIHN0YXRlcy5cbiAqXG4gKiBUaGUgYCRzdGF0ZVByb3ZpZGVyYCBwcm92aWRlcyBpbnRlcmZhY2VzIHRvIGRlY2xhcmUgdGhlc2Ugc3RhdGVzIGZvciB5b3VyIGFwcC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0YXRlUmVnaXN0cnk6IFN0YXRlUmVnaXN0cnksIHByaXZhdGUgc3RhdGVTZXJ2aWNlOiBTdGF0ZVNlcnZpY2UpIHtcbiAgICBjcmVhdGVQcm94eUZ1bmN0aW9ucyh2YWwoU3RhdGVQcm92aWRlci5wcm90b3R5cGUpLCB0aGlzLCB2YWwodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29yYXRlcyBzdGF0ZXMgd2hlbiB0aGV5IGFyZSByZWdpc3RlcmVkXG4gICAqXG4gICAqIEFsbG93cyB5b3UgdG8gZXh0ZW5kIChjYXJlZnVsbHkpIG9yIG92ZXJyaWRlIChhdCB5b3VyIG93biBwZXJpbCkgdGhlXG4gICAqIGBzdGF0ZUJ1aWxkZXJgIG9iamVjdCB1c2VkIGludGVybmFsbHkgYnkgW1tTdGF0ZVJlZ2lzdHJ5XV0uXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gYWRkIGN1c3RvbSBmdW5jdGlvbmFsaXR5IHRvIHVpLXJvdXRlcixcbiAgICogZm9yIGV4YW1wbGUgaW5mZXJyaW5nIHRlbXBsYXRlVXJsIGJhc2VkIG9uIHRoZSBzdGF0ZSBuYW1lLlxuICAgKlxuICAgKiBXaGVuIHBhc3Npbmcgb25seSBhIG5hbWUsIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgKG9yaWdpbmFsIG9yIGRlY29yYXRlZCkgYnVpbGRlclxuICAgKiBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgYG5hbWVgLlxuICAgKlxuICAgKiBUaGUgYnVpbGRlciBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgZGVjb3JhdGVkIGFyZSBsaXN0ZWQgYmVsb3cuIFRob3VnaCBub3QgYWxsXG4gICAqIG5lY2Vzc2FyaWx5IGhhdmUgYSBnb29kIHVzZSBjYXNlIGZvciBkZWNvcmF0aW9uLCB0aGF0IGlzIHVwIHRvIHlvdSB0byBkZWNpZGUuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uLCB1c2VycyBjYW4gYXR0YWNoIGN1c3RvbSBkZWNvcmF0b3JzLCB3aGljaCB3aWxsIGdlbmVyYXRlIG5ld1xuICAgKiBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgc3RhdGUncyBpbnRlcm5hbCBkZWZpbml0aW9uLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gY2xlYXJcbiAgICogdXNlLWNhc2UgZm9yIHRoaXMgYmV5b25kIGFjY2Vzc2luZyBpbnRlcm5hbCBzdGF0ZXMgKGkuZS4gJHN0YXRlLiRjdXJyZW50KSxcbiAgICogaG93ZXZlciwgZXhwZWN0IHRoaXMgdG8gYmVjb21lIGluY3JlYXNpbmdseSByZWxldmFudCBhcyB3ZSBpbnRyb2R1Y2UgYWRkaXRpb25hbFxuICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuICAgKlxuICAgKiAqKldhcm5pbmcqKjogRGVjb3JhdG9ycyBzaG91bGQgbm90IGJlIGludGVyZGVwZW5kZW50IGJlY2F1c2UgdGhlIG9yZGVyIG9mXG4gICAqIGV4ZWN1dGlvbiBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbnMgaW4gbm9uLWRldGVybWluaXN0aWMuIEJ1aWxkZXIgZnVuY3Rpb25zXG4gICAqIHNob3VsZCBvbmx5IGJlIGRlcGVuZGVudCBvbiB0aGUgc3RhdGUgZGVmaW5pdGlvbiBvYmplY3QgYW5kIHN1cGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKlxuICAgKiBFeGlzdGluZyBidWlsZGVyIGZ1bmN0aW9ucyBhbmQgY3VycmVudCByZXR1cm4gdmFsdWVzOlxuICAgKlxuICAgKiAtICoqcGFyZW50KiogYHtvYmplY3R9YCAtIHJldHVybnMgdGhlIHBhcmVudCBzdGF0ZSBvYmplY3QuXG4gICAqIC0gKipkYXRhKiogYHtvYmplY3R9YCAtIHJldHVybnMgc3RhdGUgZGF0YSwgaW5jbHVkaW5nIGFueSBpbmhlcml0ZWQgZGF0YSB0aGF0IGlzIG5vdFxuICAgKiAgIG92ZXJyaWRkZW4gYnkgb3duIHZhbHVlcyAoaWYgYW55KS5cbiAgICogLSAqKnVybCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBVcmxNYXRjaGVyfVxuICAgKiAgIG9yIGBudWxsYC5cbiAgICogLSAqKm5hdmlnYWJsZSoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGNsb3Nlc3QgYW5jZXN0b3Igc3RhdGUgdGhhdCBoYXMgYSBVUkwgKGFrYSBpc1xuICAgKiAgIG5hdmlnYWJsZSkuXG4gICAqIC0gKipwYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBwYXJhbXMgdGhhdCBhcmUgZW5zdXJlZCB0b1xuICAgKiAgIGJlIGEgc3VwZXItc2V0IG9mIHBhcmVudCdzIHBhcmFtcy5cbiAgICogLSAqKnZpZXdzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB2aWV3cyBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYW4gYWJzb2x1dGUgdmlld1xuICAgKiAgIG5hbWUgKGkuZS4gXCJ2aWV3TmFtZUBzdGF0ZU5hbWVcIikgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIGNvbmZpZyBvYmplY3RcbiAgICogICAodGVtcGxhdGUsIGNvbnRyb2xsZXIpIGZvciB0aGUgdmlldy4gRXZlbiB3aGVuIHlvdSBkb24ndCB1c2UgdGhlIHZpZXdzIG9iamVjdFxuICAgKiAgIGV4cGxpY2l0bHkgb24gYSBzdGF0ZSBjb25maWcsIG9uZSBpcyBzdGlsbCBjcmVhdGVkIGZvciB5b3UgaW50ZXJuYWxseS5cbiAgICogICBTbyBieSBkZWNvcmF0aW5nIHRoaXMgYnVpbGRlciBmdW5jdGlvbiB5b3UgaGF2ZSBhY2Nlc3MgdG8gZGVjb3JhdGluZyB0ZW1wbGF0ZVxuICAgKiAgIGFuZCBjb250cm9sbGVyIHByb3BlcnRpZXMuXG4gICAqIC0gKipvd25QYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbXMgdGhhdCBiZWxvbmcgdG8gdGhlIHN0YXRlLFxuICAgKiAgIG5vdCBpbmNsdWRpbmcgYW55IHBhcmFtcyBkZWZpbmVkIGJ5IGFuY2VzdG9yIHN0YXRlcy5cbiAgICogLSAqKnBhdGgqKiBge3N0cmluZ31gIC0gcmV0dXJucyB0aGUgZnVsbCBwYXRoIGZyb20gdGhlIHJvb3QgZG93biB0byB0aGlzIHN0YXRlLlxuICAgKiAgIE5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICogLSAqKmluY2x1ZGVzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgZXZlcnkgc3RhdGUgdGhhdFxuICAgKiAgIHdvdWxkIHBhc3MgYSBgJHN0YXRlLmluY2x1ZGVzKClgIHRlc3QuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogT3ZlcnJpZGUgdGhlIGludGVybmFsICd2aWV3cycgYnVpbGRlciB3aXRoIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc3RhdGVcbiAgICogZGVmaW5pdGlvbiwgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBmdW5jdGlvbiBiZWluZyBvdmVycmlkZGVuOlxuICAgKiBgYGBqc1xuICAgKiAkc3RhdGVQcm92aWRlci5kZWNvcmF0b3IoJ3ZpZXdzJywgZnVuY3Rpb24gKHN0YXRlLCBwYXJlbnQpIHtcbiAgICogICBsZXQgcmVzdWx0ID0ge30sXG4gICAqICAgICAgIHZpZXdzID0gcGFyZW50KHN0YXRlKTtcbiAgICpcbiAgICogICBhbmd1bGFyLmZvckVhY2godmlld3MsIGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICogICAgIGxldCBhdXRvTmFtZSA9IChzdGF0ZS5uYW1lICsgJy4nICsgbmFtZSkucmVwbGFjZSgnLicsICcvJyk7XG4gICAqICAgICBjb25maWcudGVtcGxhdGVVcmwgPSBjb25maWcudGVtcGxhdGVVcmwgfHwgJy9wYXJ0aWFscy8nICsgYXV0b05hbWUgKyAnLmh0bWwnO1xuICAgKiAgICAgcmVzdWx0W25hbWVdID0gY29uZmlnO1xuICAgKiAgIH0pO1xuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH0pO1xuICAgKlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgnaG9tZScsIHtcbiAgICogICB2aWV3czoge1xuICAgKiAgICAgJ2NvbnRhY3QubGlzdCc6IHsgY29udHJvbGxlcjogJ0xpc3RDb250cm9sbGVyJyB9LFxuICAgKiAgICAgJ2NvbnRhY3QuaXRlbSc6IHsgY29udHJvbGxlcjogJ0l0ZW1Db250cm9sbGVyJyB9XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIEF1dG8tcG9wdWxhdGVzIGxpc3QgYW5kIGl0ZW0gdmlld3Mgd2l0aCAvcGFydGlhbHMvaG9tZS9jb250YWN0L2xpc3QuaHRtbCxcbiAgICogLy8gYW5kIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvaXRlbS5odG1sLCByZXNwZWN0aXZlbHkuXG4gICAqICRzdGF0ZS5nbygnaG9tZScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJ1aWxkZXIgZnVuY3Rpb24gdG8gZGVjb3JhdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmdW5jIEEgZnVuY3Rpb24gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgZGVjb3JhdGluZyB0aGUgb3JpZ2luYWxcbiAgICogYnVpbGRlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgIC0gYHtvYmplY3R9YCAtIHN0YXRlIC0gVGhlIHN0YXRlIGNvbmZpZyBvYmplY3QuXG4gICAqICAgLSBge29iamVjdH1gIC0gc3VwZXIgLSBUaGUgb3JpZ2luYWwgYnVpbGRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAkc3RhdGVQcm92aWRlciAtICRzdGF0ZVByb3ZpZGVyIGluc3RhbmNlXG4gICAqL1xuICBkZWNvcmF0b3IobmFtZTogc3RyaW5nLCBmdW5jOiBCdWlsZGVyRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihuYW1lLCBmdW5jKSB8fCB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHN0YXRlXG4gICAqXG4gICAqICMjIyBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdG8gW1tTdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyXV0uXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIHN0YXRlIGNvbmZpZ3VyYXRpb24gdW5kZXIgYSBnaXZlbiBzdGF0ZSBuYW1lLlxuICAgKiBUaGUgc3RhdGVDb25maWcgb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGFjY2VwdGFibGUgcHJvcGVydGllcy5cbiAgICpcbiAgICogPGEgaWQ9J3RlbXBsYXRlJz48L2E+XG4gICAqXG4gICAqIC0gKipgdGVtcGxhdGVgKiogLSB7c3RyaW5nfGZ1bmN0aW9uPX0gLSBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAqICAgYW4gaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZyB3aGljaCBzaG91bGQgYmUgdXNlZCBieSB0aGUgdWlWaWV3IGRpcmVjdGl2ZXMuIFRoaXMgcHJvcGVydHlcbiAgICogICB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGVtcGxhdGVVcmwuXG4gICAqXG4gICAqICAgSWYgYHRlbXBsYXRlYCBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICpcbiAgICogICAtIHthcnJheS4mbHQ7b2JqZWN0Jmd0O30gLSBzdGF0ZSBwYXJhbWV0ZXJzIGV4dHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50ICRsb2NhdGlvbi5wYXRoKCkgYnlcbiAgICogICAgIGFwcGx5aW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqXG4gICAqIDxhIGlkPSd0ZW1wbGF0ZVVybCc+PC9hPlxuICAgKlxuICAgKiAtICoqYHRlbXBsYXRlVXJsYCoqIC0ge3N0cmluZ3xmdW5jdGlvbj19IC0gcGF0aCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwYXRoIHRvIGFuIGh0bWxcbiAgICogICB0ZW1wbGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IHVpVmlldy5cbiAgICpcbiAgICogICBJZiBgdGVtcGxhdGVVcmxgIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgIC0ge2FycmF5LiZsdDtvYmplY3QmZ3Q7fSAtIHN0YXRlIHBhcmFtZXRlcnMgZXh0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnQgJGxvY2F0aW9uLnBhdGgoKSBieVxuICAgKiAgICAgYXBwbHlpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICpcbiAgICogPGEgaWQ9J3RlbXBsYXRlUHJvdmlkZXInPjwvYT5cbiAgICpcbiAgICogLSAqKmB0ZW1wbGF0ZVByb3ZpZGVyYCoqIC0ge2Z1bmN0aW9uPX0gLSBQcm92aWRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgSFRNTCBjb250ZW50XG4gICAqICAgc3RyaW5nLlxuICAgKlxuICAgKiA8YSBpZD0nY29udHJvbGxlcic+PC9hPlxuICAgKlxuICAgKiAtICoqYGNvbnRyb2xsZXJgKiogLSB7c3RyaW5nfGZ1bmN0aW9uPX0gLSAgQ29udHJvbGxlciBmbiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggbmV3bHlcbiAgICogICByZWxhdGVkIHNjb3BlIG9yIHRoZSBuYW1lIG9mIGEgcmVnaXN0ZXJlZCBjb250cm9sbGVyIGlmIHBhc3NlZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogPGEgaWQ9J2NvbnRyb2xsZXJQcm92aWRlcic+PC9hPlxuICAgKlxuICAgKiAtICoqYGNvbnRyb2xsZXJQcm92aWRlcmAqKiAtIHtmdW5jdGlvbj19IC0gSW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICogICB0aGUgYWN0dWFsIGNvbnRyb2xsZXIgb3Igc3RyaW5nLlxuICAgKlxuICAgKiA8YSBpZD0nY29udHJvbGxlckFzJz48L2E+XG4gICAqXG4gICAqIC0gKipgY29udHJvbGxlckFzYCoqIOKAkyB7c3RyaW5nPX0g4oCTIEEgY29udHJvbGxlciBhbGlhcyBuYW1lLiBJZiBwcmVzZW50IHRoZSBjb250cm9sbGVyIHdpbGwgYmVcbiAgICogICBwdWJsaXNoZWQgdG8gc2NvcGUgdW5kZXIgdGhlIGNvbnRyb2xsZXJBcyBuYW1lLlxuICAgKlxuICAgKiA8YSBpZD0ncmVzb2x2ZSc+PC9hPlxuICAgKlxuICAgKiAtICoqYHJlc29sdmVgKiogLSB7b2JqZWN0LiZsdDtzdHJpbmcsIGZ1bmN0aW9uJmd0Oz19IC0gQW4gb3B0aW9uYWwgbWFwIG9mIGRlcGVuZGVuY2llcyB3aGljaFxuICAgKiAgIHNob3VsZCBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb250cm9sbGVyLiBJZiBhbnkgb2YgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSBwcm9taXNlcyxcbiAgICogICB0aGUgcm91dGVyIHdpbGwgd2FpdCBmb3IgdGhlbSBhbGwgdG8gYmUgcmVzb2x2ZWQgb3Igb25lIHRvIGJlIHJlamVjdGVkIGJlZm9yZSB0aGVcbiAgICogICBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZC4gSWYgYWxsIHRoZSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgc3VjY2Vzc2Z1bGx5LCB0aGUgdmFsdWVzXG4gICAqICAgb2YgdGhlIHJlc29sdmVkIHByb21pc2VzIGFyZSBpbmplY3RlZCBhbmQgJHN0YXRlQ2hhbmdlU3VjY2VzcyBldmVudCBpcyBmaXJlZC4gSWYgYW55XG4gICAqICAgb2YgdGhlIHByb21pc2VzIGFyZSByZWplY3RlZCB0aGUgJHN0YXRlQ2hhbmdlRXJyb3IgZXZlbnQgaXMgZmlyZWQuIFRoZSBtYXAgb2JqZWN0IGlzOlxuICAgKlxuICAgKiAgIC0ga2V5IC0ge3N0cmluZ306IG5hbWUgb2YgZGVwZW5kZW5jeSB0byBiZSBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXJcbiAgICogICAtIGZhY3RvcnkgLSB7c3RyaW5nfGZ1bmN0aW9ufTogSWYgc3RyaW5nIHRoZW4gaXQgaXMgYWxpYXMgZm9yIHNlcnZpY2UuIE90aGVyd2lzZSBpZiBmdW5jdGlvbixcbiAgICogICAgIGl0IGlzIGluamVjdGVkIGFuZCByZXR1cm4gdmFsdWUgaXQgdHJlYXRlZCBhcyBkZXBlbmRlbmN5LiBJZiByZXN1bHQgaXMgYSBwcm9taXNlLCBpdCBpc1xuICAgKiAgICAgcmVzb2x2ZWQgYmVmb3JlIGl0cyB2YWx1ZSBpcyBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIDxhIGlkPSd1cmwnPjwvYT5cbiAgICpcbiAgICogLSAqKmB1cmxgKiogLSB7c3RyaW5nPX0gLSBBIHVybCB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnMuIFdoZW4gYSBzdGF0ZSBpcyBuYXZpZ2F0ZWQgb3JcbiAgICogICB0cmFuc2l0aW9uZWQgdG8sIHRoZSBgJHN0YXRlUGFyYW1zYCBzZXJ2aWNlIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggYW55XG4gICAqICAgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkLlxuICAgKlxuICAgKiA8YSBpZD0ncGFyYW1zJz48L2E+XG4gICAqXG4gICAqIC0gKipgcGFyYW1zYCoqIC0ge29iamVjdD19IC0gQW4gYXJyYXkgb2YgcGFyYW1ldGVyIG5hbWVzIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbnMuIE9ubHlcbiAgICogICB1c2UgdGhpcyB3aXRoaW4gYSBzdGF0ZSBpZiB5b3UgYXJlIG5vdCB1c2luZyB1cmwuIE90aGVyd2lzZSB5b3UgY2FuIHNwZWNpZnkgeW91clxuICAgKiAgIHBhcmFtZXRlcnMgd2l0aGluIHRoZSB1cmwuIFdoZW4gYSBzdGF0ZSBpcyBuYXZpZ2F0ZWQgb3IgdHJhbnNpdGlvbmVkIHRvLCB0aGVcbiAgICogICAkc3RhdGVQYXJhbXMgc2VydmljZSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGFueSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQuXG4gICAqXG4gICAqIDxhIGlkPSd2aWV3cyc+PC9hPlxuICAgKlxuICAgKiAtICoqYHZpZXdzYCoqIC0ge29iamVjdD19IC0gVXNlIHRoZSB2aWV3cyBwcm9wZXJ0eSB0byBzZXQgdXAgbXVsdGlwbGUgdmlld3Mgb3IgdG8gdGFyZ2V0IHZpZXdzXG4gICAqICAgbWFudWFsbHkvZXhwbGljaXRseS5cbiAgICpcbiAgICogPGEgaWQ9J2Fic3RyYWN0Jz48L2E+XG4gICAqXG4gICAqIC0gKipgYWJzdHJhY3RgKiogLSB7Ym9vbGVhbj19IC0gQW4gYWJzdHJhY3Qgc3RhdGUgd2lsbCBuZXZlciBiZSBkaXJlY3RseSBhY3RpdmF0ZWQsXG4gICAqICAgYnV0IGNhbiBwcm92aWRlIGluaGVyaXRlZCBwcm9wZXJ0aWVzIHRvIGl0cyBjb21tb24gY2hpbGRyZW4gc3RhdGVzLlxuICAgKlxuICAgKiA8YSBpZD0nb25FbnRlcic+PC9hPlxuICAgKlxuICAgKiAtICoqYG9uRW50ZXJgKiogLSB7b2JqZWN0PX0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3Igd2hlbiBhIHN0YXRlIGlzIGVudGVyZWQuIEdvb2Qgd2F5XG4gICAqICAgdG8gdHJpZ2dlciBhbiBhY3Rpb24gb3IgZGlzcGF0Y2ggYW4gZXZlbnQsIHN1Y2ggYXMgb3BlbmluZyBhIGRpYWxvZy5cbiAgICogSWYgbWluaWZ5aW5nIHlvdXIgc2NyaXB0cywgbWFrZSBzdXJlIHRvIHVzZSB0aGUgYFsnaW5qZWN0aW9uMScsICdpbmplY3Rpb24yJywgZnVuY3Rpb24oaW5qZWN0aW9uMSwgaW5qZWN0aW9uMil7fV1gIHN5bnRheC5cbiAgICpcbiAgICogPGEgaWQ9J29uRXhpdCc+PC9hPlxuICAgKlxuICAgKiAtICoqYG9uRXhpdGAqKiAtIHtvYmplY3Q9fSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIGEgc3RhdGUgaXMgZXhpdGVkLiBHb29kIHdheSB0b1xuICAgKiAgIHRyaWdnZXIgYW4gYWN0aW9uIG9yIGRpc3BhdGNoIGFuIGV2ZW50LCBzdWNoIGFzIG9wZW5pbmcgYSBkaWFsb2cuXG4gICAqIElmIG1pbmlmeWluZyB5b3VyIHNjcmlwdHMsIG1ha2Ugc3VyZSB0byB1c2UgdGhlIGBbJ2luamVjdGlvbjEnLCAnaW5qZWN0aW9uMicsIGZ1bmN0aW9uKGluamVjdGlvbjEsIGluamVjdGlvbjIpe31dYCBzeW50YXguXG4gICAqXG4gICAqIDxhIGlkPSdyZWxvYWRPblNlYXJjaCc+PC9hPlxuICAgKlxuICAgKiAtICoqYHJlbG9hZE9uU2VhcmNoID0gdHJ1ZWAqKiAtIHtib29sZWFuPX0gLSBJZiBgZmFsc2VgLCB3aWxsIG5vdCByZXRyaWdnZXIgdGhlIHNhbWUgc3RhdGVcbiAgICogICBqdXN0IGJlY2F1c2UgYSBzZWFyY2gvcXVlcnkgcGFyYW1ldGVyIGhhcyBjaGFuZ2VkICh2aWEgJGxvY2F0aW9uLnNlYXJjaCgpIG9yICRsb2NhdGlvbi5oYXNoKCkpLlxuICAgKiAgIFVzZWZ1bCBmb3Igd2hlbiB5b3UnZCBsaWtlIHRvIG1vZGlmeSAkbG9jYXRpb24uc2VhcmNoKCkgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmVsb2FkLlxuICAgKlxuICAgKiA8YSBpZD0nZGF0YSc+PC9hPlxuICAgKlxuICAgKiAtICoqYGRhdGFgKiogLSB7b2JqZWN0PX0gLSBBcmJpdHJhcnkgZGF0YSBvYmplY3QsIHVzZWZ1bCBmb3IgY3VzdG9tIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogU29tZSBzdGF0ZSBuYW1lIGV4YW1wbGVzXG4gICAqIGBgYGpzXG4gICAqIC8vIHN0YXRlTmFtZSBjYW4gYmUgYSBzaW5nbGUgdG9wLWxldmVsIG5hbWUgKG11c3QgYmUgdW5pcXVlKS5cbiAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHt9KTtcbiAgICpcbiAgICogLy8gT3IgaXQgY2FuIGJlIGEgbmVzdGVkIHN0YXRlIG5hbWUuIFRoaXMgc3RhdGUgaXMgYSBjaGlsZCBvZiB0aGVcbiAgICogLy8gYWJvdmUgXCJob21lXCIgc3RhdGUuXG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZS5uZXdlc3RcIiwge30pO1xuICAgKlxuICAgKiAvLyBOZXN0IHN0YXRlcyBhcyBkZWVwbHkgYXMgbmVlZGVkLlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWUubmV3ZXN0LmFiYy54eXouaW5jZXB0aW9uXCIsIHt9KTtcbiAgICpcbiAgICogLy8gc3RhdGUoKSByZXR1cm5zICRzdGF0ZVByb3ZpZGVyLCBzbyB5b3UgY2FuIGNoYWluIHN0YXRlIGRlY2xhcmF0aW9ucy5cbiAgICogJHN0YXRlUHJvdmlkZXJcbiAgICogICAuc3RhdGUoXCJob21lXCIsIHt9KVxuICAgKiAgIC5zdGF0ZShcImFib3V0XCIsIHt9KVxuICAgKiAgIC5zdGF0ZShcImNvbnRhY3RzXCIsIHt9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgdW5pcXVlIHN0YXRlIG5hbWUsIGUuZy4gXCJob21lXCIsIFwiYWJvdXRcIiwgXCJjb250YWN0c1wiLlxuICAgKiBUbyBjcmVhdGUgYSBwYXJlbnQvY2hpbGQgc3RhdGUgdXNlIGEgZG90LCBlLmcuIFwiYWJvdXQuc2FsZXNcIiwgXCJob21lLm5ld2VzdFwiLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmaW5pdGlvbiBTdGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIHN0YXRlKG5hbWU6IHN0cmluZywgZGVmaW5pdGlvbjogTmcxU3RhdGVEZWNsYXJhdGlvbik6IFN0YXRlUHJvdmlkZXI7XG4gIHN0YXRlKGRlZmluaXRpb246IE5nMVN0YXRlRGVjbGFyYXRpb24pOiBTdGF0ZVByb3ZpZGVyO1xuICBzdGF0ZShuYW1lOiBhbnksIGRlZmluaXRpb24/OiBhbnkpIHtcbiAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgIGRlZmluaXRpb24gPSBuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbml0aW9uLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoZGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGludmFsaWQgc3RhdGUgaGFuZGxlclxuICAgKlxuICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdG8gW1tTdGF0ZVNlcnZpY2Uub25JbnZhbGlkXV0gZm9yIG5nMS5cbiAgICovXG5cbiAgb25JbnZhbGlkKGNhbGxiYWNrOiBPbkludmFsaWRDYWxsYmFjayk6IEZ1bmN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVNlcnZpY2Uub25JbnZhbGlkKGNhbGxiYWNrKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5pbXBvcnQge1xuICBTdGF0ZU9iamVjdCxcbiAgVHJhbnNpdGlvblN0YXRlSG9va0ZuLFxuICBIb29rUmVzdWx0LFxuICBUcmFuc2l0aW9uLFxuICBzZXJ2aWNlcyxcbiAgUmVzb2x2ZUNvbnRleHQsXG4gIGV4dGVuZCxcbiAgQnVpbGRlckZ1bmN0aW9uLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBnZXRMb2NhbHMgfSBmcm9tICcuLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBOZzFTdGF0ZURlY2xhcmF0aW9uIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcblxuLyoqXG4gKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciBhbmd1bGFyMSBgb25FbnRlcmAsIGBvbkV4aXRgLFxuICogYG9uUmV0YWluYCBjYWxsYmFjayBob29rcyBvbiBhIFtbTmcxU3RhdGVEZWNsYXJhdGlvbl1dLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIGVuc3VyZXMgdGhhdCB0aG9zZSBob29rcyBhcmUgaW5qZWN0YWJsZSBmb3IgQHVpcm91dGVyL2FuZ3VsYXJqcyAobmcxKS5cbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFN0YXRlSG9va0J1aWxkZXIgPSAoaG9va05hbWU6ICdvbkVudGVyJyB8ICdvbkV4aXQnIHwgJ29uUmV0YWluJykgPT5cbiAgZnVuY3Rpb24gc3RhdGVIb29rQnVpbGRlcihzdGF0ZU9iamVjdDogU3RhdGVPYmplY3QsIHBhcmVudEZuOiBCdWlsZGVyRnVuY3Rpb24pOiBUcmFuc2l0aW9uU3RhdGVIb29rRm4ge1xuICAgIGNvbnN0IGhvb2sgPSBzdGF0ZU9iamVjdFtob29rTmFtZV07XG4gICAgY29uc3QgcGF0aG5hbWUgPSBob29rTmFtZSA9PT0gJ29uRXhpdCcgPyAnZnJvbScgOiAndG8nO1xuXG4gICAgZnVuY3Rpb24gZGVjb3JhdGVkTmcxSG9vayh0cmFuczogVHJhbnNpdGlvbiwgc3RhdGU6IE5nMVN0YXRlRGVjbGFyYXRpb24pOiBIb29rUmVzdWx0IHtcbiAgICAgIGNvbnN0IHJlc29sdmVDb250ZXh0ID0gbmV3IFJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKHBhdGhuYW1lKSk7XG4gICAgICBjb25zdCBzdWJDb250ZXh0ID0gcmVzb2x2ZUNvbnRleHQuc3ViQ29udGV4dChzdGF0ZS4kJHN0YXRlKCkpO1xuICAgICAgY29uc3QgbG9jYWxzID0gZXh0ZW5kKGdldExvY2FscyhzdWJDb250ZXh0KSwgeyAkc3RhdGUkOiBzdGF0ZSwgJHRyYW5zaXRpb24kOiB0cmFucyB9KTtcbiAgICAgIHJldHVybiBzZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKGhvb2ssIHRoaXMsIGxvY2Fscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvb2sgPyBkZWNvcmF0ZWROZzFIb29rIDogdW5kZWZpbmVkO1xuICB9O1xuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzEgKi8gLyoqICovXG5pbXBvcnQgeyBMb2NhdGlvbkNvbmZpZywgTG9jYXRpb25TZXJ2aWNlcywgVUlSb3V0ZXIsIFBhcmFtVHlwZSwgaXNEZWZpbmVkIH0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgdmFsLCBjcmVhdGVQcm94eUZ1bmN0aW9ucywgcmVtb3ZlRnJvbSwgaXNPYmplY3QgfSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBJTG9jYXRpb25TZXJ2aWNlLCBJTG9jYXRpb25Qcm92aWRlciwgSVdpbmRvd1NlcnZpY2UgfSBmcm9tICdhbmd1bGFyJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFVJLVJvdXRlciBMb2NhdGlvblNlcnZpY2VzIGFuZCBMb2NhdGlvbkNvbmZpZyB1c2luZyBBbmd1bGFyIDEncyAkbG9jYXRpb24gc2VydmljZVxuICogQGludGVybmFsYXBpXG4gKi9cbmV4cG9ydCBjbGFzcyBOZzFMb2NhdGlvblNlcnZpY2VzIGltcGxlbWVudHMgTG9jYXRpb25Db25maWcsIExvY2F0aW9uU2VydmljZXMge1xuICBwcml2YXRlICRsb2NhdGlvblByb3ZpZGVyOiBJTG9jYXRpb25Qcm92aWRlcjtcbiAgcHJpdmF0ZSAkbG9jYXRpb246IElMb2NhdGlvblNlcnZpY2U7XG4gIHByaXZhdGUgJHNuaWZmZXI6IGFueTtcbiAgcHJpdmF0ZSAkYnJvd3NlcjogYW55O1xuICBwcml2YXRlICR3aW5kb3c6IElXaW5kb3dTZXJ2aWNlO1xuXG4gIHBhdGg7XG4gIHNlYXJjaDtcbiAgaGFzaDtcbiAgaGFzaFByZWZpeDtcbiAgcG9ydDtcbiAgcHJvdG9jb2w7XG4gIGhvc3Q7XG5cbiAgcHJpdmF0ZSBfYmFzZUhyZWY6IHN0cmluZztcblxuICAvLyAub25DaGFuZ2UoKSByZWdpc3RyeVxuICBwcml2YXRlIF91cmxMaXN0ZW5lcnM6IEZ1bmN0aW9uW10gPSBbXTtcblxuICAvKipcbiAgICogQXBwbHlzIG5nMS1zcGVjaWZpYyBwYXRoIHBhcmFtZXRlciBlbmNvZGluZ1xuICAgKlxuICAgKiBUaGUgQW5ndWxhciAxIGAkbG9jYXRpb25gIHNlcnZpY2UgaXMgYSBiaXQgd2VpcmQuXG4gICAqIEl0IGRvZXNuJ3QgYWxsb3cgc2xhc2hlcyB0byBiZSBlbmNvZGVkL2RlY29kZWQgYmktZGlyZWN0aW9uYWxseS5cbiAgICpcbiAgICogU2VlIHRoZSB3cml0ZXVwIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlci9pc3N1ZXMvMjU5OFxuICAgKlxuICAgKiBUaGlzIGNvZGUgcGF0Y2hlcyB0aGUgYHBhdGhgIHBhcmFtZXRlciB0eXBlIHNvIGl0IGVuY29kZWQvZGVjb2RlcyBzbGFzaGVzIGFzIH4yRlxuICAgKlxuICAgKiBAcGFyYW0gcm91dGVyXG4gICAqL1xuICBzdGF0aWMgbW9ua2V5UGF0Y2hQYXRoUGFyYW1ldGVyVHlwZShyb3V0ZXI6IFVJUm91dGVyKSB7XG4gICAgY29uc3QgcGF0aFR5cGU6IFBhcmFtVHlwZSA9IHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS50eXBlKCdwYXRoJyk7XG5cbiAgICBwYXRoVHlwZS5lbmNvZGUgPSAoeDogYW55KSA9PlxuICAgICAgeCAhPSBudWxsID8geC50b1N0cmluZygpLnJlcGxhY2UoLyh+fFxcLykvZywgbSA9PiAoeyAnfic6ICd+ficsICcvJzogJ34yRicgfVttXSkpIDogeDtcblxuICAgIHBhdGhUeXBlLmRlY29kZSA9ICh4OiBzdHJpbmcpID0+XG4gICAgICB4ICE9IG51bGwgPyB4LnRvU3RyaW5nKCkucmVwbGFjZSgvKH5+fH4yRikvZywgbSA9PiAoeyAnfn4nOiAnficsICd+MkYnOiAnLycgfVttXSkpIDogeDtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7fVxuXG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvblByb3ZpZGVyOiBJTG9jYXRpb25Qcm92aWRlcikge1xuICAgIHRoaXMuJGxvY2F0aW9uUHJvdmlkZXIgPSAkbG9jYXRpb25Qcm92aWRlcjtcbiAgICBjb25zdCBfbHAgPSB2YWwoJGxvY2F0aW9uUHJvdmlkZXIpO1xuICAgIGNyZWF0ZVByb3h5RnVuY3Rpb25zKF9scCwgdGhpcywgX2xwLCBbJ2hhc2hQcmVmaXgnXSk7XG4gIH1cblxuICBvbkNoYW5nZShjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICB0aGlzLl91cmxMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHJlbW92ZUZyb20odGhpcy5fdXJsTGlzdGVuZXJzKShjYWxsYmFjayk7XG4gIH1cblxuICBodG1sNU1vZGUoKSB7XG4gICAgbGV0IGh0bWw1TW9kZTogYW55ID0gdGhpcy4kbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUoKTtcbiAgICBodG1sNU1vZGUgPSBpc09iamVjdChodG1sNU1vZGUpID8gaHRtbDVNb2RlLmVuYWJsZWQgOiBodG1sNU1vZGU7XG4gICAgcmV0dXJuIGh0bWw1TW9kZSAmJiB0aGlzLiRzbmlmZmVyLmhpc3Rvcnk7XG4gIH1cblxuICBiYXNlSHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZUhyZWYgfHwgKHRoaXMuX2Jhc2VIcmVmID0gdGhpcy4kYnJvd3Nlci5iYXNlSHJlZigpIHx8IHRoaXMuJHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICB1cmwobmV3VXJsPzogc3RyaW5nLCByZXBsYWNlID0gZmFsc2UsIHN0YXRlPykge1xuICAgIGlmIChpc0RlZmluZWQobmV3VXJsKSkgdGhpcy4kbG9jYXRpb24udXJsKG5ld1VybCk7XG4gICAgaWYgKHJlcGxhY2UpIHRoaXMuJGxvY2F0aW9uLnJlcGxhY2UoKTtcbiAgICBpZiAoc3RhdGUpIHRoaXMuJGxvY2F0aW9uLnN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcy4kbG9jYXRpb24udXJsKCk7XG4gIH1cblxuICBfcnVudGltZVNlcnZpY2VzKCRyb290U2NvcGUsICRsb2NhdGlvbjogSUxvY2F0aW9uU2VydmljZSwgJHNuaWZmZXIsICRicm93c2VyLCAkd2luZG93OiBJV2luZG93U2VydmljZSkge1xuICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgIHRoaXMuJHNuaWZmZXIgPSAkc25pZmZlcjtcbiAgICB0aGlzLiRicm93c2VyID0gJGJyb3dzZXI7XG4gICAgdGhpcy4kd2luZG93ID0gJHdpbmRvdztcblxuICAgIC8vIEJpbmQgJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcyB0byB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgaW4gTG9jYXRpb25TZXJ2aWNlLm9uQ2hhbmdlXG4gICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBldnQgPT4gdGhpcy5fdXJsTGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oZXZ0KSkpO1xuICAgIGNvbnN0IF9sb2MgPSB2YWwoJGxvY2F0aW9uKTtcblxuICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25TZXJ2aWNlIGZ1bmN0aW9ucyB0byAkbG9jYXRpb25cbiAgICBjcmVhdGVQcm94eUZ1bmN0aW9ucyhfbG9jLCB0aGlzLCBfbG9jLCBbJ3JlcGxhY2UnLCAncGF0aCcsICdzZWFyY2gnLCAnaGFzaCddKTtcbiAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uQ29uZmlnIGZ1bmN0aW9ucyB0byAkbG9jYXRpb25cbiAgICBjcmVhdGVQcm94eUZ1bmN0aW9ucyhfbG9jLCB0aGlzLCBfbG9jLCBbJ3BvcnQnLCAncHJvdG9jb2wnLCAnaG9zdCddKTtcbiAgfVxufVxuIiwiLyoqIEBwdWJsaWNhcGkgQG1vZHVsZSB1cmwgKi8gLyoqICovXG5pbXBvcnQge1xuICBVSVJvdXRlcixcbiAgTG9jYXRpb25TZXJ2aWNlcyxcbiAgJEluamVjdG9yTGlrZSxcbiAgQmFzZVVybFJ1bGUsXG4gIFVybFJ1bGVIYW5kbGVyRm4sXG4gIFVybE1hdGNoZXIsXG4gIElJbmplY3RhYmxlLFxuICBVcmxSb3V0ZXIsXG59IGZyb20gJ0B1aXJvdXRlci9jb3JlJztcbmltcG9ydCB7IHNlcnZpY2VzLCBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNBcnJheSwgaWRlbnRpdHkgfSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmF3TmcxUnVsZUZ1bmN0aW9uIHtcbiAgKCRpbmplY3RvcjogJEluamVjdG9yTGlrZSwgJGxvY2F0aW9uOiBMb2NhdGlvblNlcnZpY2VzKTogc3RyaW5nIHwgdm9pZDtcbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHJ1bGVzIGZvciBjbGllbnQtc2lkZSBVUkxcbiAqXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzpcbiAqIFRoaXMgY2xhc3MgaXMgbm93IGNvbnNpZGVyZWQgdG8gYmUgYW4gaW50ZXJuYWwgQVBJXG4gKiBVc2UgdGhlIFtbVXJsU2VydmljZV1dIGluc3RlYWQuXG4gKiBGb3IgY29uZmlndXJpbmcgVVJMIHJ1bGVzLCB1c2UgdGhlIFtbVXJsUnVsZXNBcGldXSB3aGljaCBjYW4gYmUgZm91bmQgYXMgW1tVcmxTZXJ2aWNlLnJ1bGVzXV0uXG4gKlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIHRoZSByb3V0ZXIgcnVsZXMgZm9yIHdoYXQgdG8gZG8gd2hlbiB0aGUgVVJMIGNoYW5nZXMuXG4gKlxuICogVGhpcyBwcm92aWRlciByZW1haW5zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxSb3V0ZXJQcm92aWRlciB7XG4gIHN0YXRpYyBpbmplY3RhYmxlSGFuZGxlcihyb3V0ZXI6IFVJUm91dGVyLCBoYW5kbGVyKTogVXJsUnVsZUhhbmRsZXJGbiB7XG4gICAgcmV0dXJuIG1hdGNoID0+IHNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UoaGFuZGxlciwgbnVsbCwgeyAkbWF0Y2g6IG1hdGNoLCAkc3RhdGVQYXJhbXM6IHJvdXRlci5nbG9iYWxzLnBhcmFtcyB9KTtcbiAgfVxuXG4gIC8qKiBAaGlkZGVuICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAaGlkZGVuICovIHByaXZhdGUgcm91dGVyOiBVSVJvdXRlcikge31cblxuICAvKiogQGhpZGRlbiAqL1xuICAkZ2V0KCk6IFVybFJvdXRlciB7XG4gICAgY29uc3QgdXJsU2VydmljZSA9IHRoaXMucm91dGVyLnVybFNlcnZpY2U7XG4gICAgdGhpcy5yb3V0ZXIudXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbiAgICBpZiAoIXVybFNlcnZpY2UuaW50ZXJjZXB0RGVmZXJyZWQpIHVybFNlcnZpY2UubGlzdGVuKCk7XG4gICAgcmV0dXJuIHRoaXMucm91dGVyLnVybFJvdXRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSB1cmwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogUmVnaXN0ZXJzIGEgbG93IGxldmVsIHVybCBoYW5kbGVyIChhIGBydWxlYCkuXG4gICAqIEEgcnVsZSBkZXRlY3RzIHNwZWNpZmljIFVSTCBwYXR0ZXJucyBhbmQgcmV0dXJucyBhIHJlZGlyZWN0LCBvciBwZXJmb3JtcyBzb21lIGFjdGlvbi5cbiAgICpcbiAgICogSWYgYSBydWxlIHJldHVybnMgYSBzdHJpbmcsIHRoZSBVUkwgaXMgcmVwbGFjZWQgd2l0aCB0aGUgc3RyaW5nLCBhbmQgYWxsIHJ1bGVzIGFyZSBmaXJlZCBhZ2Fpbi5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAqICAgLy8gSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHlvdSBtaWdodCBhbGxvdyBjYXNlIGluc2Vuc2l0aXZlIHVybHNcbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIucnVsZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcbiAgICogICAgIHZhciBwYXRoID0gJGxvY2F0aW9uLnBhdGgoKSxcbiAgICogICAgICAgICBub3JtYWxpemVkID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgKlxuICAgKiAgICAgaWYgKHBhdGggIT09IG5vcm1hbGl6ZWQpIHtcbiAgICogICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJ1bGVGblxuICAgKiBIYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gIHNlcnZpY2VzIGFzIGFyZ3VtZW50cy5cbiAgICogWW91IGNhbiB1c2UgdGhlbSB0byBkZXRlY3QgYSB1cmwgYW5kIHJldHVybiBhIGRpZmZlcmVudCB1cmwgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4gW1tVcmxSb3V0ZXJQcm92aWRlcl1dIChgdGhpc2ApXG4gICAqL1xuICBydWxlKHJ1bGVGbjogUmF3TmcxUnVsZUZ1bmN0aW9uKTogVXJsUm91dGVyUHJvdmlkZXIge1xuICAgIGlmICghaXNGdW5jdGlvbihydWxlRm4pKSB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgY29uc3QgbWF0Y2ggPSAoKSA9PiBydWxlRm4oc2VydmljZXMuJGluamVjdG9yLCB0aGlzLnJvdXRlci5sb2NhdGlvblNlcnZpY2UpO1xuXG4gICAgY29uc3QgcnVsZSA9IG5ldyBCYXNlVXJsUnVsZShtYXRjaCwgaWRlbnRpdHkpO1xuICAgIHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXMucnVsZShydWxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBwYXRoIG9yIGJlaGF2aW9yIHRvIHVzZSB3aGVuIG5vIHVybCBjYW4gYmUgbWF0Y2hlZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAqICAgLy8gaWYgdGhlIHBhdGggZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIHVybHMgeW91IGNvbmZpZ3VyZWRcbiAgICogICAvLyBvdGhlcndpc2Ugd2lsbCB0YWtlIGNhcmUgb2Ygcm91dGluZyB0aGUgdXNlciB0byB0aGVcbiAgICogICAvLyBzcGVjaWZpZWQgdXJsXG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2luZGV4Jyk7XG4gICAqXG4gICAqICAgLy8gRXhhbXBsZSBvZiB1c2luZyBmdW5jdGlvbiBydWxlIGFzIHBhcmFtXG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcbiAgICogICAgIHJldHVybiAnL2EvdmFsaWQvdXJsJztcbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcnVsZVxuICAgKiBUaGUgdXJsIHBhdGggeW91IHdhbnQgdG8gcmVkaXJlY3QgdG8gb3IgYSBmdW5jdGlvbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgdXJsIHBhdGggb3IgcGVyZm9ybXMgYSBgJHN0YXRlLmdvKClgLlxuICAgKiBUaGUgZnVuY3Rpb24gdmVyc2lvbiBpcyBwYXNzZWQgdHdvIHBhcmFtczogYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gIHNlcnZpY2VzLCBhbmQgc2hvdWxkIHJldHVybiBhIHVybCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgLSBgJHVybFJvdXRlclByb3ZpZGVyYCBpbnN0YW5jZVxuICAgKi9cbiAgb3RoZXJ3aXNlKHJ1bGU6IHN0cmluZyB8IFJhd05nMVJ1bGVGdW5jdGlvbik6IFVybFJvdXRlclByb3ZpZGVyIHtcbiAgICBjb25zdCB1cmxSdWxlcyA9IHRoaXMucm91dGVyLnVybFNlcnZpY2UucnVsZXM7XG4gICAgaWYgKGlzU3RyaW5nKHJ1bGUpKSB7XG4gICAgICB1cmxSdWxlcy5vdGhlcndpc2UocnVsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJ1bGUpKSB7XG4gICAgICB1cmxSdWxlcy5vdGhlcndpc2UoKCkgPT4gcnVsZShzZXJ2aWNlcy4kaW5qZWN0b3IsIHRoaXMucm91dGVyLmxvY2F0aW9uU2VydmljZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIGZvciBhIGdpdmVuIHVybCBtYXRjaGluZy5cbiAgICpcbiAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBzdHJpbmcsIGl0IGlzXG4gICAqIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCwgYW5kIGlzIGludGVycG9sYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHN5bnRheCBvZiBtYXRjaFxuICAgKiAoaS5lLiBsaWtlIGBTdHJpbmcucmVwbGFjZSgpYCBmb3IgYFJlZ0V4cGAsIG9yIGxpa2UgYSBgVXJsTWF0Y2hlcmAgcGF0dGVybiBvdGhlcndpc2UpLlxuICAgKlxuICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBpbmplY3RhYmxlLlxuICAgKiBJdCBnZXRzIGludm9rZWQgaWYgYCRsb2NhdGlvbmAgbWF0Y2hlcy5cbiAgICogWW91IGhhdmUgdGhlIG9wdGlvbiBvZiBpbmplY3QgdGhlIG1hdGNoIG9iamVjdCBhcyBgJG1hdGNoYC5cbiAgICpcbiAgICogVGhlIGhhbmRsZXIgY2FuIHJldHVyblxuICAgKlxuICAgKiAtICoqZmFsc3kqKiB0byBpbmRpY2F0ZSB0aGF0IHRoZSBydWxlIGRpZG4ndCBtYXRjaCBhZnRlciBhbGwsIHRoZW4gYCR1cmxSb3V0ZXJgXG4gICAqICAgd2lsbCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhbm90aGVyIG9uZSB0aGF0IG1hdGNoZXMuXG4gICAqIC0gKipzdHJpbmcqKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QgYW5kIHBhc3NlZCB0byBgJGxvY2F0aW9uLnVybCgpYFxuICAgKiAtICoqdm9pZCoqIG9yIGFueSAqKnRydXRoeSoqIHZhbHVlIHRlbGxzIGAkdXJsUm91dGVyYCB0aGF0IHRoZSB1cmwgd2FzIGhhbmRsZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICogYGBganNcbiAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKCRzdGF0ZS51cmwsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgaWYgKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUgIT09IHN0YXRlIHx8XG4gICAqICAgICAgICAgIWVxdWFsRm9yS2V5cygkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgZmFsc2UpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB3aGF0IEEgcGF0dGVybiBzdHJpbmcgdG8gbWF0Y2gsIGNvbXBpbGVkIGFzIGEgW1tVcmxNYXRjaGVyXV0uXG4gICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBwYXRoIChvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwYXRoKSB0aGF0IHlvdSB3YW50IHRvIHJlZGlyZWN0IHlvdXIgdXNlciB0by5cbiAgICogQHBhcmFtIHJ1bGVDYWxsYmFjayBbb3B0aW9uYWxdIEEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgYHJ1bGVgIHJlZ2lzdGVyZWQgd2l0aCBbW1VybE1hdGNoZXIucnVsZV1dXG4gICAqXG4gICAqIE5vdGU6IHRoZSBoYW5kbGVyIG1heSBhbHNvIGludm9rZSBhcmJpdHJhcnkgY29kZSwgc3VjaCBhcyBgJHN0YXRlLmdvKClgXG4gICAqL1xuICB3aGVuKHdoYXQ6IFJlZ0V4cCB8IFVybE1hdGNoZXIgfCBzdHJpbmcsIGhhbmRsZXI6IHN0cmluZyB8IElJbmplY3RhYmxlKSB7XG4gICAgaWYgKGlzQXJyYXkoaGFuZGxlcikgfHwgaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgaGFuZGxlciA9IFVybFJvdXRlclByb3ZpZGVyLmluamVjdGFibGVIYW5kbGVyKHRoaXMucm91dGVyLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvdXRlci51cmxTZXJ2aWNlLnJ1bGVzLndoZW4od2hhdCwgaGFuZGxlciBhcyBhbnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIG1vbml0b3Jpbmcgb2YgdGhlIFVSTC5cbiAgICpcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgVUktUm91dGVyIGhhcyBib290c3RyYXBwZWQuXG4gICAqIEl0IHdpbGwgc3RvcCBVSS1Sb3V0ZXIgZnJvbSBwZXJmb3JtaW5nIHRoZSBpbml0aWFsIHVybCBzeW5jLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gcGVyZm9ybSBzb21lIGFzeW5jaHJvbm91cyBpbml0aWFsaXphdGlvbiBiZWZvcmUgdGhlIHJvdXRlciBzdGFydHMuXG4gICAqIE9uY2UgdGhlIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlLCBjYWxsIFtbbGlzdGVuXV0gdG8gdGVsbCBVSS1Sb3V0ZXIgdG8gc3RhcnQgd2F0Y2hpbmcgYW5kIHN5bmNocm9uaXppbmcgdGhlIFVSTC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICogICAvLyBQcmV2ZW50ICR1cmxSb3V0ZXIgZnJvbSBhdXRvbWF0aWNhbGx5IGludGVyY2VwdGluZyBVUkwgY2hhbmdlcztcbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIuZGVmZXJJbnRlcmNlcHQoKTtcbiAgICogfSlcbiAgICpcbiAgICogYXBwLnJ1bihmdW5jdGlvbiAoTXlTZXJ2aWNlLCAkdXJsUm91dGVyLCAkaHR0cCkge1xuICAgKiAgICRodHRwLmdldChcIi9zdHVmZlwiKS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcbiAgICogICAgIE15U2VydmljZS5kb1N0dWZmKHJlc3AuZGF0YSk7XG4gICAqICAgICAkdXJsUm91dGVyLmxpc3RlbigpO1xuICAgKiAgICAgJHVybFJvdXRlci5zeW5jKCk7XG4gICAqICAgfSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGRlZmVyIEluZGljYXRlcyB3aGV0aGVyIHRvIGRlZmVyIGxvY2F0aW9uIGNoYW5nZSBpbnRlcmNlcHRpb24uXG4gICAqICAgICAgICBQYXNzaW5nIG5vIHBhcmFtZXRlciBpcyBlcXVpdmFsZW50IHRvIGB0cnVlYC5cbiAgICovXG4gIGRlZmVySW50ZXJjZXB0KGRlZmVyPzogYm9vbGVhbikge1xuICAgIHRoaXMucm91dGVyLnVybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHQoZGVmZXIpO1xuICB9XG59XG4iLCIvKipcbiAqICMgQW5ndWxhciAxIHR5cGVzXG4gKlxuICogVUktUm91dGVyIGNvcmUgcHJvdmlkZXMgdmFyaW91cyBUeXBlc2NyaXB0IHR5cGVzIHdoaWNoIHlvdSBjYW4gdXNlIGZvciBjb2RlIGNvbXBsZXRpb24gYW5kIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHZhbHVlcywgZXRjLlxuICogVGhlIGN1c3RvbWl6YXRpb25zIHRvIHRoZSBjb3JlIHR5cGVzIGZvciBBbmd1bGFyIFVJLVJvdXRlciBhcmUgZG9jdW1lbnRlZCBoZXJlLlxuICpcbiAqIFRoZSBvcHRpb25hbCBbWyRyZXNvbHZlXV0gc2VydmljZSBpcyBhbHNvIGRvY3VtZW50ZWQgaGVyZS5cbiAqXG4gKiBAcHJlZmVycmVkIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzFcbiAqLyAvKiogKi9cbmltcG9ydCB7IG5nIGFzIGFuZ3VsYXIgfSBmcm9tICcuL2FuZ3VsYXInO1xuaW1wb3J0IHtcbiAgSVJvb3RTY29wZVNlcnZpY2UsXG4gIElRU2VydmljZSxcbiAgSUxvY2F0aW9uU2VydmljZSxcbiAgSUxvY2F0aW9uUHJvdmlkZXIsXG4gIElIdHRwU2VydmljZSxcbiAgSVRlbXBsYXRlQ2FjaGVTZXJ2aWNlLFxufSBmcm9tICdhbmd1bGFyJztcbmltcG9ydCB7XG4gIHNlcnZpY2VzLFxuICBhcHBseVBhaXJzLFxuICBpc1N0cmluZyxcbiAgdHJhY2UsXG4gIGV4dGVuZCxcbiAgVUlSb3V0ZXIsXG4gIFN0YXRlU2VydmljZSxcbiAgVXJsUm91dGVyLFxuICBVcmxNYXRjaGVyRmFjdG9yeSxcbiAgUmVzb2x2ZUNvbnRleHQsXG4gIHVubmVzdFIsXG4gIFR5cGVkTWFwLFxufSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBuZzFWaWV3c0J1aWxkZXIsIGdldE5nMVZpZXdDb25maWdGYWN0b3J5IH0gZnJvbSAnLi9zdGF0ZWJ1aWxkZXJzL3ZpZXdzJztcbmltcG9ydCB7IFRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJy4vdGVtcGxhdGVGYWN0b3J5JztcbmltcG9ydCB7IFN0YXRlUHJvdmlkZXIgfSBmcm9tICcuL3N0YXRlUHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0U3RhdGVIb29rQnVpbGRlciB9IGZyb20gJy4vc3RhdGVidWlsZGVycy9vbkVudGVyRXhpdFJldGFpbic7XG5pbXBvcnQgeyBOZzFMb2NhdGlvblNlcnZpY2VzIH0gZnJvbSAnLi9sb2NhdGlvblNlcnZpY2VzJztcbmltcG9ydCB7IFVybFJvdXRlclByb3ZpZGVyIH0gZnJvbSAnLi91cmxSb3V0ZXJQcm92aWRlcic7XG5pbXBvcnQgSUluamVjdG9yU2VydmljZSA9IGFuZ3VsYXIuYXV0by5JSW5qZWN0b3JTZXJ2aWNlOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lXG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuYW5ndWxhcjEnLCBbXSk7XG5jb25zdCBtb2RfaW5pdCA9IGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuaW5pdCcsIFsnbmcnXSk7XG5jb25zdCBtb2RfdXRpbCA9IGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcsIFsndWkucm91dGVyLmluaXQnXSk7XG5jb25zdCBtb2RfcnRyID0gYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInLCBbJ3VpLnJvdXRlci51dGlsJ10pO1xuY29uc3QgbW9kX3N0YXRlID0gYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScsIFsndWkucm91dGVyLnJvdXRlcicsICd1aS5yb3V0ZXIudXRpbCcsICd1aS5yb3V0ZXIuYW5ndWxhcjEnXSk7XG5jb25zdCBtb2RfbWFpbiA9IGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXInLCBbJ3VpLnJvdXRlci5pbml0JywgJ3VpLnJvdXRlci5zdGF0ZScsICd1aS5yb3V0ZXIuYW5ndWxhcjEnXSk7XG5jb25zdCBtb2RfY21wdCA9IGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcblxuZGVjbGFyZSBtb2R1bGUgJ0B1aXJvdXRlci9jb3JlL2xpYi9yb3V0ZXInIHtcbiAgaW50ZXJmYWNlIFVJUm91dGVyIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXNoYWRvd2VkLXZhcmlhYmxlXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBzdGF0ZVByb3ZpZGVyOiBTdGF0ZVByb3ZpZGVyO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgdXJsUm91dGVyUHJvdmlkZXI6IFVybFJvdXRlclByb3ZpZGVyO1xuICB9XG59XG5cbmxldCByb3V0ZXI6IFVJUm91dGVyID0gbnVsbDtcblxuJHVpUm91dGVyUHJvdmlkZXIuJGluamVjdCA9IFsnJGxvY2F0aW9uUHJvdmlkZXInXTtcbi8qKiBUaGlzIGFuZ3VsYXIgMSBwcm92aWRlciBpbnN0YW50aWF0ZXMgYSBSb3V0ZXIgYW5kIGV4cG9zZXMgaXRzIHNlcnZpY2VzIHZpYSB0aGUgYW5ndWxhciBpbmplY3RvciAqL1xuZnVuY3Rpb24gJHVpUm91dGVyUHJvdmlkZXIoJGxvY2F0aW9uUHJvdmlkZXI6IElMb2NhdGlvblByb3ZpZGVyKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUm91dGVyIHdoZW4gdGhlICR1aVJvdXRlclByb3ZpZGVyIGlzIGluaXRpYWxpemVkXG4gIHJvdXRlciA9IHRoaXMucm91dGVyID0gbmV3IFVJUm91dGVyKCk7XG4gIHJvdXRlci5zdGF0ZVByb3ZpZGVyID0gbmV3IFN0YXRlUHJvdmlkZXIocm91dGVyLnN0YXRlUmVnaXN0cnksIHJvdXRlci5zdGF0ZVNlcnZpY2UpO1xuXG4gIC8vIEFwcGx5IG5nMSBzcGVjaWZpYyBTdGF0ZUJ1aWxkZXIgY29kZSBmb3IgYHZpZXdzYCwgYHJlc29sdmVgLCBhbmQgYG9uRXhpdC9SZXRhaW4vRW50ZXJgIHByb3BlcnRpZXNcbiAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCd2aWV3cycsIG5nMVZpZXdzQnVpbGRlcik7XG4gIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcignb25FeGl0JywgZ2V0U3RhdGVIb29rQnVpbGRlcignb25FeGl0JykpO1xuICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoJ29uUmV0YWluJywgZ2V0U3RhdGVIb29rQnVpbGRlcignb25SZXRhaW4nKSk7XG4gIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcignb25FbnRlcicsIGdldFN0YXRlSG9va0J1aWxkZXIoJ29uRW50ZXInKSk7XG5cbiAgcm91dGVyLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3ZpZXdDb25maWdGYWN0b3J5KCduZzEnLCBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeSgpKTtcblxuICBjb25zdCBuZzFMb2NhdGlvblNlcnZpY2UgPSAocm91dGVyLmxvY2F0aW9uU2VydmljZSA9IHJvdXRlci5sb2NhdGlvbkNvbmZpZyA9IG5ldyBOZzFMb2NhdGlvblNlcnZpY2VzKFxuICAgICRsb2NhdGlvblByb3ZpZGVyXG4gICkpO1xuXG4gIE5nMUxvY2F0aW9uU2VydmljZXMubW9ua2V5UGF0Y2hQYXRoUGFyYW1ldGVyVHlwZShyb3V0ZXIpO1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXQ6IGFsc28gZXhwb3NlIHJvdXRlciBpbnN0YW5jZSBhcyAkdWlSb3V0ZXJQcm92aWRlci5yb3V0ZXJcbiAgcm91dGVyWydyb3V0ZXInXSA9IHJvdXRlcjtcbiAgcm91dGVyWyckZ2V0J10gPSAkZ2V0O1xuICAkZ2V0LiRpbmplY3QgPSBbJyRsb2NhdGlvbicsICckYnJvd3NlcicsICckd2luZG93JywgJyRzbmlmZmVyJywgJyRyb290U2NvcGUnLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnXTtcbiAgZnVuY3Rpb24gJGdldChcbiAgICAkbG9jYXRpb246IElMb2NhdGlvblNlcnZpY2UsXG4gICAgJGJyb3dzZXI6IGFueSxcbiAgICAkd2luZG93OiBhbnksXG4gICAgJHNuaWZmZXI6IGFueSxcbiAgICAkcm9vdFNjb3BlOiBuZy5JU2NvcGUsXG4gICAgJGh0dHA6IElIdHRwU2VydmljZSxcbiAgICAkdGVtcGxhdGVDYWNoZTogSVRlbXBsYXRlQ2FjaGVTZXJ2aWNlXG4gICkge1xuICAgIG5nMUxvY2F0aW9uU2VydmljZS5fcnVudGltZVNlcnZpY2VzKCRyb290U2NvcGUsICRsb2NhdGlvbiwgJHNuaWZmZXIsICRicm93c2VyLCAkd2luZG93KTtcbiAgICBkZWxldGUgcm91dGVyWydyb3V0ZXInXTtcbiAgICBkZWxldGUgcm91dGVyWyckZ2V0J107XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuICByZXR1cm4gcm91dGVyO1xufVxuXG5jb25zdCBnZXRQcm92aWRlckZvciA9IHNlcnZpY2VOYW1lID0+IFtcbiAgJyR1aVJvdXRlclByb3ZpZGVyJyxcbiAgJHVycCA9PiB7XG4gICAgY29uc3Qgc2VydmljZSA9ICR1cnAucm91dGVyW3NlcnZpY2VOYW1lXTtcbiAgICBzZXJ2aWNlWyckZ2V0J10gPSAoKSA9PiBzZXJ2aWNlO1xuICAgIHJldHVybiBzZXJ2aWNlO1xuICB9LFxuXTtcblxuLy8gVGhpcyBlZmZlY3RpdmVseSBjYWxscyAkZ2V0KCkgb24gYCR1aVJvdXRlclByb3ZpZGVyYCB0byB0cmlnZ2VyIGluaXQgKHdoZW4gbmcgZW50ZXJzIHJ1bnRpbWUpXG5ydW5CbG9jay4kaW5qZWN0ID0gWyckaW5qZWN0b3InLCAnJHEnLCAnJHVpUm91dGVyJ107XG5mdW5jdGlvbiBydW5CbG9jaygkaW5qZWN0b3I6IElJbmplY3RvclNlcnZpY2UsICRxOiBJUVNlcnZpY2UsICR1aVJvdXRlcjogVUlSb3V0ZXIpIHtcbiAgc2VydmljZXMuJGluamVjdG9yID0gJGluamVjdG9yO1xuICBzZXJ2aWNlcy4kcSA9IDxhbnk+JHE7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8zNjc4XG4gIGlmICghJGluamVjdG9yLmhhc093blByb3BlcnR5KCdzdHJpY3REaScpKSB7XG4gICAgdHJ5IHtcbiAgICAgICRpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oY2hlY2tTdHJpY3REaSkge30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAkaW5qZWN0b3Iuc3RyaWN0RGkgPSAhIS9zdHJpY3QgbW9kZS8uZXhlYyhlcnJvciAmJiBlcnJvci50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgJGluamVjdG9yIGlzIG5vdyBhdmFpbGFibGUuXG4gIC8vIEZpbmQgYW55IHJlc29sdmFibGVzIHRoYXQgaGFkIGRlcGVuZGVuY3kgYW5ub3RhdGlvbiBkZWZlcnJlZFxuICAkdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeVxuICAgIC5nZXQoKVxuICAgIC5tYXAoeCA9PiB4LiQkc3RhdGUoKS5yZXNvbHZhYmxlcylcbiAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgIC5maWx0ZXIoeCA9PiB4LmRlcHMgPT09ICdkZWZlcnJlZCcpXG4gICAgLmZvckVhY2gocmVzb2x2YWJsZSA9PiAocmVzb2x2YWJsZS5kZXBzID0gJGluamVjdG9yLmFubm90YXRlKHJlc29sdmFibGUucmVzb2x2ZUZuLCAkaW5qZWN0b3Iuc3RyaWN0RGkpKSk7XG59XG5cbi8vICR1cmxSb3V0ZXIgc2VydmljZSBhbmQgJHVybFJvdXRlclByb3ZpZGVyXG5jb25zdCBnZXRVcmxSb3V0ZXJQcm92aWRlciA9ICh1aVJvdXRlcjogVUlSb3V0ZXIpID0+ICh1aVJvdXRlci51cmxSb3V0ZXJQcm92aWRlciA9IG5ldyBVcmxSb3V0ZXJQcm92aWRlcih1aVJvdXRlcikpO1xuXG4vLyAkc3RhdGUgc2VydmljZSBhbmQgJHN0YXRlUHJvdmlkZXJcbi8vICR1cmxSb3V0ZXIgc2VydmljZSBhbmQgJHVybFJvdXRlclByb3ZpZGVyXG5jb25zdCBnZXRTdGF0ZVByb3ZpZGVyID0gKCkgPT4gZXh0ZW5kKHJvdXRlci5zdGF0ZVByb3ZpZGVyLCB7ICRnZXQ6ICgpID0+IHJvdXRlci5zdGF0ZVNlcnZpY2UgfSk7XG5cbndhdGNoRGlnZXN0cy4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJ107XG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hEaWdlc3RzKCRyb290U2NvcGU6IElSb290U2NvcGVTZXJ2aWNlKSB7XG4gICRyb290U2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkge1xuICAgIHRyYWNlLmFwcHJveGltYXRlRGlnZXN0cysrO1xuICB9KTtcbn1cblxubW9kX2luaXQucHJvdmlkZXIoJyR1aVJvdXRlcicsIDxhbnk+JHVpUm91dGVyUHJvdmlkZXIpO1xubW9kX3J0ci5wcm92aWRlcignJHVybFJvdXRlcicsIFsnJHVpUm91dGVyUHJvdmlkZXInLCBnZXRVcmxSb3V0ZXJQcm92aWRlcl0pO1xubW9kX3V0aWwucHJvdmlkZXIoJyR1cmxTZXJ2aWNlJywgZ2V0UHJvdmlkZXJGb3IoJ3VybFNlcnZpY2UnKSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHVybE1hdGNoZXJGYWN0b3J5JywgWyckdWlSb3V0ZXJQcm92aWRlcicsICgpID0+IHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeV0pO1xubW9kX3V0aWwucHJvdmlkZXIoJyR0ZW1wbGF0ZUZhY3RvcnknLCAoKSA9PiBuZXcgVGVtcGxhdGVGYWN0b3J5KCkpO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckc3RhdGVSZWdpc3RyeScsIGdldFByb3ZpZGVyRm9yKCdzdGF0ZVJlZ2lzdHJ5JykpO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckdWlSb3V0ZXJHbG9iYWxzJywgZ2V0UHJvdmlkZXJGb3IoJ2dsb2JhbHMnKSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyR0cmFuc2l0aW9ucycsIGdldFByb3ZpZGVyRm9yKCd0cmFuc2l0aW9uU2VydmljZScpKTtcbm1vZF9zdGF0ZS5wcm92aWRlcignJHN0YXRlJywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGdldFN0YXRlUHJvdmlkZXJdKTtcblxubW9kX3N0YXRlLmZhY3RvcnkoJyRzdGF0ZVBhcmFtcycsIFsnJHVpUm91dGVyJywgKCR1aVJvdXRlcjogVUlSb3V0ZXIpID0+ICR1aVJvdXRlci5nbG9iYWxzLnBhcmFtc10pO1xubW9kX21haW4uZmFjdG9yeSgnJHZpZXcnLCAoKSA9PiByb3V0ZXIudmlld1NlcnZpY2UpO1xubW9kX21haW4uc2VydmljZSgnJHRyYWNlJywgKCkgPT4gdHJhY2UpO1xuXG5tb2RfbWFpbi5ydW4od2F0Y2hEaWdlc3RzKTtcbm1vZF91dGlsLnJ1bihbJyR1cmxNYXRjaGVyRmFjdG9yeScsIGZ1bmN0aW9uKCR1cmxNYXRjaGVyRmFjdG9yeTogVXJsTWF0Y2hlckZhY3RvcnkpIHt9XSk7XG5tb2Rfc3RhdGUucnVuKFsnJHN0YXRlJywgZnVuY3Rpb24oJHN0YXRlOiBTdGF0ZVNlcnZpY2UpIHt9XSk7XG5tb2RfcnRyLnJ1bihbJyR1cmxSb3V0ZXInLCBmdW5jdGlvbigkdXJsUm91dGVyOiBVcmxSb3V0ZXIpIHt9XSk7XG5tb2RfaW5pdC5ydW4ocnVuQmxvY2spO1xuXG4vKiogQGhpZGRlbiBUT0RPOiBmaW5kIGEgcGxhY2UgdG8gbW92ZSB0aGlzICovXG5leHBvcnQgY29uc3QgZ2V0TG9jYWxzID0gKGN0eDogUmVzb2x2ZUNvbnRleHQpOiBUeXBlZE1hcDxhbnk+ID0+IHtcbiAgY29uc3QgdG9rZW5zID0gY3R4LmdldFRva2VucygpLmZpbHRlcihpc1N0cmluZyk7XG5cbiAgY29uc3QgdHVwbGVzID0gdG9rZW5zLm1hcChrZXkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSBjdHguZ2V0UmVzb2x2YWJsZShrZXkpO1xuICAgIGNvbnN0IHdhaXRQb2xpY3kgPSBjdHguZ2V0UG9saWN5KHJlc29sdmFibGUpLmFzeW5jO1xuICAgIHJldHVybiBba2V5LCB3YWl0UG9saWN5ID09PSAnTk9XQUlUJyA/IHJlc29sdmFibGUucHJvbWlzZSA6IHJlc29sdmFibGUuZGF0YV07XG4gIH0pO1xuXG4gIHJldHVybiB0dXBsZXMucmVkdWNlKGFwcGx5UGFpcnMsIHt9KTtcbn07XG4iLCIvKipcbiAqICMgQW5ndWxhciAxIERpcmVjdGl2ZXNcbiAqXG4gKiBUaGVzZSBhcmUgdGhlIGRpcmVjdGl2ZXMgaW5jbHVkZWQgaW4gVUktUm91dGVyIGZvciBBbmd1bGFyIDEuXG4gKiBUaGVzZSBkaXJlY3RpdmVzIGFyZSB1c2VkIGluIHRlbXBsYXRlcyB0byBjcmVhdGUgdmlld3BvcnRzIGFuZCBsaW5rL25hdmlnYXRlIHRvIHN0YXRlcy5cbiAqXG4gKiBAcHJlZmVycmVkIEBwdWJsaWNhcGkgQG1vZHVsZSBkaXJlY3RpdmVzXG4gKi8gLyoqICovXG5pbXBvcnQgeyBuZyBhcyBhbmd1bGFyIH0gZnJvbSAnLi4vYW5ndWxhcic7XG5pbXBvcnQgeyBJQXVnbWVudGVkSlF1ZXJ5LCBJVGltZW91dFNlcnZpY2UsIElTY29wZSwgSUludGVycG9sYXRlU2VydmljZSB9IGZyb20gJ2FuZ3VsYXInO1xuXG5pbXBvcnQge1xuICBPYmosXG4gIGV4dGVuZCxcbiAgZm9yRWFjaCxcbiAgdGFpbCxcbiAgaXNTdHJpbmcsXG4gIGlzT2JqZWN0LFxuICBpc0FycmF5LFxuICBwYXJzZSxcbiAgbm9vcCxcbiAgdW5uZXN0UixcbiAgaWRlbnRpdHksXG4gIHVuaXFSLFxuICBpbkFycmF5LFxuICByZW1vdmVGcm9tLFxuICBSYXdQYXJhbXMsXG4gIFBhdGhOb2RlLFxuICBTdGF0ZU9yTmFtZSxcbiAgU3RhdGVTZXJ2aWNlLFxuICBTdGF0ZURlY2xhcmF0aW9uLFxuICBVSVJvdXRlcixcbn0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgVUlWaWV3RGF0YSB9IGZyb20gJy4vdmlld0RpcmVjdGl2ZSc7XG5cbi8qKiBAaGlkZGVuIFVzZWQgZm9yIHR5cGVkb2MgKi9cbmV4cG9ydCBpbnRlcmZhY2UgbmcxX2RpcmVjdGl2ZSB7fSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmNsYXNzLW5hbWVcblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVSZWYocmVmOiBzdHJpbmcpIHtcbiAgbGV0IHBhcnNlZDtcbiAgY29uc3QgcGFyYW1zT25seSA9IHJlZi5tYXRjaCgvXlxccyooe1tefV0qfSlcXHMqJC8pO1xuICBpZiAocGFyYW1zT25seSkgcmVmID0gJygnICsgcGFyYW1zT25seVsxXSArICcpJztcblxuICBwYXJzZWQgPSByZWYucmVwbGFjZSgvXFxuL2csICcgJykubWF0Y2goL15cXHMqKFteKF0qPylcXHMqKFxcKCguKilcXCkpP1xccyokLyk7XG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZC5sZW5ndGggIT09IDQpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgcmVmICdcIiArIHJlZiArIFwiJ1wiKTtcbiAgcmV0dXJuIHsgc3RhdGU6IHBhcnNlZFsxXSB8fCBudWxsLCBwYXJhbUV4cHI6IHBhcnNlZFszXSB8fCBudWxsIH07XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzdGF0ZUNvbnRleHQoZWw6IElBdWdtZW50ZWRKUXVlcnkpIHtcbiAgY29uc3QgJHVpVmlldzogVUlWaWV3RGF0YSA9IChlbC5wYXJlbnQoKSBhcyBJQXVnbWVudGVkSlF1ZXJ5KS5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XG4gIGNvbnN0IHBhdGg6IFBhdGhOb2RlW10gPSBwYXJzZSgnJGNmZy5wYXRoJykoJHVpVmlldyk7XG4gIHJldHVybiBwYXRoID8gdGFpbChwYXRoKS5zdGF0ZS5uYW1lIDogdW5kZWZpbmVkO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc2VkRGVmKCRzdGF0ZTogU3RhdGVTZXJ2aWNlLCAkZWxlbWVudDogSUF1Z21lbnRlZEpRdWVyeSwgZGVmOiBEZWYpOiBEZWYge1xuICBjb25zdCB1aVN0YXRlID0gZGVmLnVpU3RhdGUgfHwgJHN0YXRlLmN1cnJlbnQubmFtZTtcbiAgY29uc3QgdWlTdGF0ZU9wdHMgPSBleHRlbmQoZGVmYXVsdE9wdHMoJGVsZW1lbnQsICRzdGF0ZSksIGRlZi51aVN0YXRlT3B0cyB8fCB7fSk7XG4gIGNvbnN0IGhyZWYgPSAkc3RhdGUuaHJlZih1aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcywgdWlTdGF0ZU9wdHMpO1xuICByZXR1cm4geyB1aVN0YXRlLCB1aVN0YXRlUGFyYW1zOiBkZWYudWlTdGF0ZVBhcmFtcywgdWlTdGF0ZU9wdHMsIGhyZWYgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmludGVyZmFjZSBUeXBlSW5mbyB7XG4gIGF0dHI6IHN0cmluZztcbiAgaXNBbmNob3I6IGJvb2xlYW47XG4gIGNsaWNrYWJsZTogYm9vbGVhbjtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsOiBJQXVnbWVudGVkSlF1ZXJ5KTogVHlwZUluZm8ge1xuICAvLyBTVkdBRWxlbWVudCBkb2VzIG5vdCB1c2UgdGhlIGhyZWYgYXR0cmlidXRlLCBidXQgcmF0aGVyIHRoZSAneGxpbmtIcmVmJyBhdHRyaWJ1dGUuXG4gIGNvbnN0IGlzU3ZnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsLnByb3AoJ2hyZWYnKSkgPT09ICdbb2JqZWN0IFNWR0FuaW1hdGVkU3RyaW5nXSc7XG4gIGNvbnN0IGlzRm9ybSA9IGVsWzBdLm5vZGVOYW1lID09PSAnRk9STSc7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyOiBpc0Zvcm0gPyAnYWN0aW9uJyA6IGlzU3ZnID8gJ3hsaW5rOmhyZWYnIDogJ2hyZWYnLFxuICAgIGlzQW5jaG9yOiBlbC5wcm9wKCd0YWdOYW1lJykudG9VcHBlckNhc2UoKSA9PT0gJ0EnLFxuICAgIGNsaWNrYWJsZTogIWlzRm9ybSxcbiAgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGNsaWNrSG9vayhcbiAgZWw6IElBdWdtZW50ZWRKUXVlcnksXG4gICRzdGF0ZTogU3RhdGVTZXJ2aWNlLFxuICAkdGltZW91dDogSVRpbWVvdXRTZXJ2aWNlLFxuICB0eXBlOiBUeXBlSW5mbyxcbiAgZ2V0RGVmOiAoKSA9PiBEZWZcbikge1xuICByZXR1cm4gZnVuY3Rpb24oZTogSlF1ZXJ5TW91c2VFdmVudE9iamVjdCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGUud2hpY2ggfHwgZS5idXR0b24sXG4gICAgICB0YXJnZXQgPSBnZXREZWYoKTtcblxuICAgIGlmICghKGJ1dHRvbiA+IDEgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGVsLmF0dHIoJ3RhcmdldCcpKSkge1xuICAgICAgLy8gSEFDSzogVGhpcyBpcyB0byBhbGxvdyBuZy1jbGlja3MgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBpbml0aWF0ZWQ6XG4gICAgICBjb25zdCB0cmFuc2l0aW9uID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZWwuYXR0cignZGlzYWJsZWQnKSkge1xuICAgICAgICAgICRzdGF0ZS5nbyh0YXJnZXQudWlTdGF0ZSwgdGFyZ2V0LnVpU3RhdGVQYXJhbXMsIHRhcmdldC51aVN0YXRlT3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBpZiB0aGUgc3RhdGUgaGFzIG5vIFVSTCwgaWdub3JlIG9uZSBwcmV2ZW50RGVmYXVsdCBmcm9tIHRoZSA8YT4gZGlyZWN0aXZlLlxuICAgICAgbGV0IGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnQgPSB0eXBlLmlzQW5jaG9yICYmICF0YXJnZXQuaHJlZiA/IDEgOiAwO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpZ25vcmVQcmV2ZW50RGVmYXVsdENvdW50LS0gPD0gMCkgJHRpbWVvdXQuY2FuY2VsKHRyYW5zaXRpb24pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBkZWZhdWx0T3B0cyhlbDogSUF1Z21lbnRlZEpRdWVyeSwgJHN0YXRlOiBTdGF0ZVNlcnZpY2UpIHtcbiAgcmV0dXJuIHtcbiAgICByZWxhdGl2ZTogc3RhdGVDb250ZXh0KGVsKSB8fCAkc3RhdGUuJGN1cnJlbnQsXG4gICAgaW5oZXJpdDogdHJ1ZSxcbiAgICBzb3VyY2U6ICdzcmVmJyxcbiAgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudHMoZWxlbWVudDogSUF1Z21lbnRlZEpRdWVyeSwgc2NvcGU6IElTY29wZSwgaG9va0ZuOiBFdmVudExpc3RlbmVyLCB1aVN0YXRlT3B0czogYW55KTogdm9pZCB7XG4gIGxldCBldmVudHM7XG5cbiAgaWYgKHVpU3RhdGVPcHRzKSB7XG4gICAgZXZlbnRzID0gdWlTdGF0ZU9wdHMuZXZlbnRzO1xuICB9XG5cbiAgaWYgKCFpc0FycmF5KGV2ZW50cykpIHtcbiAgICBldmVudHMgPSBbJ2NsaWNrJ107XG4gIH1cblxuICBjb25zdCBvbiA9IGVsZW1lbnQub24gPyAnb24nIDogJ2JpbmQnO1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgIGVsZW1lbnRbb25dKGV2ZW50LCBob29rRm4pO1xuICB9XG5cbiAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG9mZiA9IGVsZW1lbnQub2ZmID8gJ29mZicgOiAndW5iaW5kJztcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgZWxlbWVudFtvZmZdKGV2ZW50LCBob29rRm4gYXMgYW55KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIGB1aS1zcmVmYDogQSBkaXJlY3RpdmUgZm9yIGxpbmtpbmcgdG8gYSBzdGF0ZVxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMgTGlua2VkIFN0YXRlXG4gKiBUaGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBgdWktc3JlZmAgaXMgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGxpbmsgdG8uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyB3aWxsIGFjdGl2YXRlIHRoZSBgaG9tZWAgc3RhdGUgd2hlbiB0aGUgbGluayBpcyBjbGlja2VkLlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICogYGBgXG4gKlxuICogIyMjIFJlbGF0aXZlIExpbmtzXG4gKiBZb3UgY2FuIGFsc28gdXNlIHJlbGF0aXZlIHN0YXRlIHBhdGhzIHdpdGhpbiBgdWktc3JlZmAsIGp1c3QgbGlrZSBhIHJlbGF0aXZlIHBhdGggcGFzc2VkIHRvIGAkc3RhdGUuZ28oKWAgKFtbU3RhdGVTZXJ2aWNlLmdvXV0pLlxuICogWW91IGp1c3QgbmVlZCB0byBiZSBhd2FyZSB0aGF0IHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBzdGF0ZSB0aGF0ICpjcmVhdGVkKiB0aGUgbGluay5cbiAqIFRoaXMgYWxsb3dzIGEgc3RhdGUgdG8gY3JlYXRlIGEgcmVsYXRpdmUgYHVpLXNyZWZgIHdoaWNoIGFsd2F5cyB0YXJnZXRzIHRoZSBzYW1lIGRlc3RpbmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEJvdGggdGhlc2UgbGlua3MgYXJlIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgc3RhdGUsIGV2ZW4gd2hlbiBhIGNoaWxkIHN0YXRlIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiLmNoaWxkMVwiPmNoaWxkIDEgc3RhdGU8L2E+XG4gKiA8YSB1aS1zcmVmPVwiLmNoaWxkMlwiPmNoaWxkIDIgc3RhdGU8L2E+XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGxpbmsgYWN0aXZhdGVzIHRoZSBwYXJlbnQgc3RhdGUuXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiXlwiPlJldHVybjwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBocmVmc1xuICogSWYgdGhlIGxpbmtlZCBzdGF0ZSBoYXMgYSBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGFuZFxuICogdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlICh1c2luZyB0aGUgW1tTdGF0ZVNlcnZpY2UuaHJlZl1dICBtZXRob2QpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEFzc3VtaW5nIHRoZSBgdXNlcnNgIHN0YXRlIGhhcyBhIHVybCBvZiBgL3VzZXJzL2BcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJ1c2Vyc1wiIGhyZWY9XCIvdXNlcnMvXCI+VXNlcnM8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgUGFyYW1ldGVyIFZhbHVlc1xuICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUsIGEgYHVpLXNyZWZgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cbiAqIFBhcmFtIHZhbHVlcyBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGB1aS1zcmVmYCB2YWx1ZSBhZnRlciB0aGUgc3RhdGUgbmFtZSwgZW5jbG9zZWQgYnkgcGFyZW50aGVzZXMuXG4gKiBUaGUgY29udGVudCBpbnNpZGUgdGhlIHBhcmVudGhlc2VzIGlzIGFuIGV4cHJlc3Npb24sIGV2YWx1YXRlZCB0byB0aGUgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgcmVuZGVycyBhIGxpc3Qgb2YgbGlua3MgdG8gdXNlcnMuXG4gKiBUaGUgc3RhdGUncyBgdXNlcklkYCBwYXJhbWV0ZXIgdmFsdWUgY29tZXMgZnJvbSBlYWNoIHVzZXIncyBgdXNlci5pZGAgcHJvcGVydHkuXG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwidXNlciBpbiB1c2Vyc1wiPlxuICogICA8YSB1aS1zcmVmPVwidXNlcnMuZGV0YWlsKHsgdXNlcklkOiB1c2VyLmlkIH0pXCI+e3sgdXNlci5kaXNwbGF5TmFtZSB9fTwvYT5cbiAqIDwvbGk+XG4gKiBgYGBcbiAqXG4gKiBOb3RlOlxuICogVGhlIHBhcmFtZXRlciB2YWx1ZXMgZXhwcmVzc2lvbiBpcyBgJHdhdGNoYGVkIGZvciB1cGRhdGVzLlxuICpcbiAqICMjIyBUcmFuc2l0aW9uIE9wdGlvbnNcbiAqIFlvdSBjYW4gc3BlY2lmeSBbW1RyYW5zaXRpb25PcHRpb25zXV0gdG8gcGFzcyB0byBbW1N0YXRlU2VydmljZS5nb11dIGJ5IHVzaW5nIHRoZSBgdWktc3JlZi1vcHRzYCBhdHRyaWJ1dGUuXG4gKiBPcHRpb25zIGFyZSByZXN0cmljdGVkIHRvIGBsb2NhdGlvbmAsIGBpbmhlcml0YCwgYW5kIGByZWxvYWRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJob21lXCIgdWktc3JlZi1vcHRzPVwieyByZWxvYWQ6IHRydWUgfVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgT3RoZXIgRE9NIEV2ZW50c1xuICpcbiAqIFlvdSBjYW4gYWxzbyBjdXN0b21pemUgd2hpY2ggRE9NIGV2ZW50cyB0byByZXNwb25kIHRvIChpbnN0ZWFkIG9mIGBjbGlja2ApIGJ5XG4gKiBwcm92aWRpbmcgYW4gYGV2ZW50c2AgYXJyYXkgaW4gdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgdHlwZT1cInRleHRcIiB1aS1zcmVmPVwiY29udGFjdHNcIiB1aS1zcmVmLW9wdHM9XCJ7IGV2ZW50czogWydjaGFuZ2UnLCAnYmx1ciddIH1cIj5cbiAqIGBgYFxuICpcbiAqICMjIyBIaWdobGlnaHRpbmcgdGhlIGFjdGl2ZSBsaW5rXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFtbdWlTcmVmQWN0aXZlXV0gdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluay5cbiAqXG4gKiAjIyMgRXhhbXBsZXNcbiAqIElmIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XG4gKlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICogPGEgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+XG4gKiA8YSB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxuICpcbiAqIDx1bD5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj57eyBjb250YWN0Lm5hbWUgfX08L2E+XG4gKiAgICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBUaGVuIChhc3N1bWluZyB0aGUgY3VycmVudCBzdGF0ZSBpcyBgY29udGFjdHNgKSB0aGUgcmVuZGVyZWQgaHRtbCBpbmNsdWRpbmcgaHJlZnMgd291bGQgYmU6XG4gKlxuICogYGBgaHRtbFxuICogPGEgaHJlZj1cIiMvaG9tZVwiIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT5cbiAqIDxhIGhyZWY9XCIjL2Fib3V0XCIgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+XG4gKiA8YSBocmVmPVwiIy9jb250YWN0cz9wYWdlPTJcIiB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxuICpcbiAqIDx1bD5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8xXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Sm9lPC9hPlxuICogICAgIDwvbGk+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgaHJlZj1cIiMvY29udGFjdHMvMlwiIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPkFsaWNlPC9hPlxuICogICAgIDwvbGk+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgaHJlZj1cIiMvY29udGFjdHMvM1wiIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPkJvYjwvYT5cbiAqICAgICA8L2xpPlxuICogPC91bD5cbiAqXG4gKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7cmVsb2FkOiB0cnVlfVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgTm90ZXNcbiAqXG4gKiAtIFlvdSBjYW4gdXNlIGB1aS1zcmVmYCB0byBjaGFuZ2UgKipvbmx5IHRoZSBwYXJhbWV0ZXIgdmFsdWVzKiogYnkgb21pdHRpbmcgdGhlIHN0YXRlIG5hbWUgYW5kIHBhcmVudGhlc2VzLlxuICogIyMjIyBFeGFtcGxlOlxuICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJ7IGxhbmc6ICdlbicgfVwiPkVuZ2xpc2g8L2E+XG4gKiBgYGBcbiAqXG4gKiAtIEEgbWlkZGxlLWNsaWNrLCByaWdodC1jbGljaywgb3IgY3RybC1jbGljayBpcyBoYW5kbGVkIChuYXRpdmVseSkgYnkgdGhlIGJyb3dzZXIgdG8gb3BlbiB0aGUgaHJlZiBpbiBhIG5ldyB3aW5kb3csIGZvciBleGFtcGxlLlxuICpcbiAqIC0gVW5saWtlIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGV4cHJlc3Npb24sIHRoZSBzdGF0ZSBuYW1lIGlzIG5vdCBgJHdhdGNoYGVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykuXG4gKiBJZiB5b3UgbmVlZCB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIHN0YXRlIGJlaW5nIGxpbmtlZCB0bywgdXNlIHRoZSBmdWxseSBkeW5hbWljIFtbdWlTdGF0ZV1dIGRpcmVjdGl2ZS5cbiAqL1xubGV0IHVpU3JlZkRpcmVjdGl2ZTogbmcxX2RpcmVjdGl2ZTtcbnVpU3JlZkRpcmVjdGl2ZSA9IFtcbiAgJyR1aVJvdXRlcicsXG4gICckdGltZW91dCcsXG4gIGZ1bmN0aW9uICRTdGF0ZVJlZkRpcmVjdGl2ZSgkdWlSb3V0ZXI6IFVJUm91dGVyLCAkdGltZW91dDogSVRpbWVvdXRTZXJ2aWNlKSB7XG4gICAgY29uc3QgJHN0YXRlID0gJHVpUm91dGVyLnN0YXRlU2VydmljZTtcblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVxdWlyZTogWyc/XnVpU3JlZkFjdGl2ZScsICc/XnVpU3JlZkFjdGl2ZUVxJ10sXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZTogSVNjb3BlLCBlbGVtZW50OiBJQXVnbWVudGVkSlF1ZXJ5LCBhdHRyczogYW55LCB1aVNyZWZBY3RpdmU6IGFueSkge1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG4gICAgICAgIGxldCB1bmxpbmtJbmZvRm46IEZ1bmN0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IGhvb2tGbjtcblxuICAgICAgICBjb25zdCByYXdEZWYgPSB7fSBhcyBEZWY7XG4gICAgICAgIGNvbnN0IGdldERlZiA9ICgpID0+IHByb2Nlc3NlZERlZigkc3RhdGUsIGVsZW1lbnQsIHJhd0RlZik7XG5cbiAgICAgICAgY29uc3QgcmVmID0gcGFyc2VTdGF0ZVJlZihhdHRycy51aVNyZWYpO1xuICAgICAgICByYXdEZWYudWlTdGF0ZSA9IHJlZi5zdGF0ZTtcbiAgICAgICAgcmF3RGVmLnVpU3RhdGVPcHRzID0gYXR0cnMudWlTcmVmT3B0cyA/IHNjb3BlLiRldmFsKGF0dHJzLnVpU3JlZk9wdHMpIDoge307XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgIGNvbnN0IGRlZiA9IGdldERlZigpO1xuICAgICAgICAgIGlmICh1bmxpbmtJbmZvRm4pIHVubGlua0luZm9GbigpO1xuICAgICAgICAgIGlmIChhY3RpdmUpIHVubGlua0luZm9GbiA9IGFjdGl2ZS4kJGFkZFN0YXRlSW5mbyhkZWYudWlTdGF0ZSwgZGVmLnVpU3RhdGVQYXJhbXMpO1xuICAgICAgICAgIGlmIChkZWYuaHJlZiAhPSBudWxsKSBhdHRycy4kc2V0KHR5cGUuYXR0ciwgZGVmLmhyZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZi5wYXJhbUV4cHIpIHtcbiAgICAgICAgICBzY29wZS4kd2F0Y2goXG4gICAgICAgICAgICByZWYucGFyYW1FeHByLFxuICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlUGFyYW1zID0gZXh0ZW5kKHt9LCB2YWwpO1xuICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByYXdEZWYudWlTdGF0ZVBhcmFtcyA9IGV4dGVuZCh7fSwgc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKCk7XG5cbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIDxhbnk+JHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgPGFueT4kdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGUpKTtcblxuICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKSByZXR1cm47XG4gICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xuICAgICAgICBiaW5kRXZlbnRzKGVsZW1lbnQsIHNjb3BlLCBob29rRm4sIHJhd0RlZi51aVN0YXRlT3B0cyk7XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG5dO1xuXG4vKipcbiAqIGB1aS1zdGF0ZWA6IEEgZnVsbHkgZHluYW1pYyBkaXJlY3RpdmUgZm9yIGxpbmtpbmcgdG8gYSBzdGF0ZVxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAqKlRoaXMgZGlyZWN0aXZlIGlzIHZlcnkgc2ltaWxhciB0byBbW3VpU3JlZl1dLCBidXQgaXQgYCRvYnNlcnZlYHMgYW5kIGAkd2F0Y2hgZXMvZXZhbHVhdGVzIGFsbCBpdHMgaW5wdXRzLioqXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyBMaW5rZWQgU3RhdGVcbiAqIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYHVpLXN0YXRlYCBpcyBhbiBleHByZXNzaW9uIHdoaWNoIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyB0aGUgc3RhdGUgdG8gbGluayB0by5cbiAqICoqVGhpcyBpcyBpbiBjb250cmFzdCB3aXRoIGB1aS1zcmVmYCwgd2hpY2ggdGFrZXMgYSBzdGF0ZSBuYW1lIGFzIGEgc3RyaW5nIGxpdGVyYWwuKipcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBDcmVhdGUgYSBsaXN0IG9mIGxpbmtzLlxuICogYGBgaHRtbFxuICogPGxpIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIj5cbiAqICAgPGEgdWktc3RhdGU9XCJsaW5rLnN0YXRlXCI+e3sgbGluay5kaXNwbGF5TmFtZSB9fTwvYT5cbiAqIDwvbGk+XG4gKiBgYGBcbiAqXG4gKiAjIyMgUmVsYXRpdmUgTGlua3NcbiAqIElmIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIHJlbGF0aXZlIHBhdGgsIGl0IGlzIHByb2Nlc3NlZCBsaWtlIFtbdWlTcmVmXV0uXG4gKiBZb3UganVzdCBuZWVkIHRvIGJlIGF3YXJlIHRoYXQgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIHN0YXRlIHRoYXQgKmNyZWF0ZWQqIHRoZSBsaW5rLlxuICogVGhpcyBhbGxvd3MgYSBzdGF0ZSB0byBjcmVhdGUgcmVsYXRpdmUgYHVpLXN0YXRlYCB3aGljaCBhbHdheXMgdGFyZ2V0cyB0aGUgc2FtZSBkZXN0aW5hdGlvbi5cbiAqXG4gKiAjIyMgaHJlZnNcbiAqIElmIHRoZSBsaW5rZWQgc3RhdGUgaGFzIGEgVVJMLCB0aGUgZGlyZWN0aXZlIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhbmRcbiAqIHVwZGF0ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZSAodXNpbmcgdGhlIFtbU3RhdGVTZXJ2aWNlLmhyZWZdXSAgbWV0aG9kKS5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyIFZhbHVlc1xuICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUgZXhwcmVzc2lvbiwgYSBgdWktc3RhdGVgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cbiAqIFBhcmFtIHZhbHVlcyBzaG91bGQgYmUgcHJvdmlkZWQgdXNpbmcgdGhlIGB1aS1zdGF0ZS1wYXJhbXNgIGF0dHJpYnV0ZS5cbiAqIFRoZSBgdWktc3RhdGUtcGFyYW1zYCBhdHRyaWJ1dGUgdmFsdWUgaXMgYCR3YXRjaGBlZCBhbmQgZXZhbHVhdGVkIGFzIGFuIGV4cHJlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIHJlbmRlcnMgYSBsaXN0IG9mIGxpbmtzIHdpdGggcGFyYW0gdmFsdWVzLlxuICogVGhlIHN0YXRlJ3MgYHVzZXJJZGAgcGFyYW1ldGVyIHZhbHVlIGNvbWVzIGZyb20gZWFjaCB1c2VyJ3MgYHVzZXIuaWRgIHByb3BlcnR5LlxuICogYGBgaHRtbFxuICogPGxpIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIj5cbiAqICAgPGEgdWktc3RhdGU9XCJsaW5rLnN0YXRlXCIgdWktc3RhdGUtcGFyYW1zPVwibGluay5wYXJhbXNcIj57eyBsaW5rLmRpc3BsYXlOYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqICMjIyBUcmFuc2l0aW9uIE9wdGlvbnNcbiAqIFlvdSBjYW4gc3BlY2lmeSBbW1RyYW5zaXRpb25PcHRpb25zXV0gdG8gcGFzcyB0byBbW1N0YXRlU2VydmljZS5nb11dIGJ5IHVzaW5nIHRoZSBgdWktc3RhdGUtb3B0c2AgYXR0cmlidXRlLlxuICogT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsIGFuZCBgcmVsb2FkYC5cbiAqIFRoZSB2YWx1ZSBvZiB0aGUgYHVpLXN0YXRlLW9wdHNgIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyBhbiBleHByZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXN0YXRlPVwicmV0dXJudG8uc3RhdGVcIiB1aS1zdGF0ZS1vcHRzPVwieyByZWxvYWQ6IHRydWUgfVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgT3RoZXIgRE9NIEV2ZW50c1xuICpcbiAqIFlvdSBjYW4gYWxzbyBjdXN0b21pemUgd2hpY2ggRE9NIGV2ZW50cyB0byByZXNwb25kIHRvIChpbnN0ZWFkIG9mIGBjbGlja2ApIGJ5XG4gKiBwcm92aWRpbmcgYW4gYGV2ZW50c2AgYXJyYXkgaW4gdGhlIGB1aS1zdGF0ZS1vcHRzYCBhdHRyaWJ1dGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdWktc3RhdGU9XCJjb250YWN0c1wiIHVpLXN0YXRlLW9wdHM9XCJ7IGV2ZW50czogWydjaGFuZ2UnLCAnYmx1ciddIH1cIj5cbiAqIGBgYFxuICpcbiAqICMjIyBIaWdobGlnaHRpbmcgdGhlIGFjdGl2ZSBsaW5rXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFtbdWlTcmVmQWN0aXZlXV0gdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluay5cbiAqXG4gKiAjIyMgTm90ZXNcbiAqXG4gKiAtIFlvdSBjYW4gdXNlIGB1aS1wYXJhbXNgIHRvIGNoYW5nZSAqKm9ubHkgdGhlIHBhcmFtZXRlciB2YWx1ZXMqKiBieSBvbWl0dGluZyB0aGUgc3RhdGUgbmFtZSBhbmQgc3VwcGx5aW5nIG9ubHkgYHVpLXN0YXRlLXBhcmFtc2AuXG4gKiAgIEhvd2V2ZXIsIGl0IG1pZ2h0IGJlIHNpbXBsZXIgdG8gdXNlIFtbdWlTcmVmXV0gcGFyYW1ldGVyLW9ubHkgbGlua3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXN0YXRlPVwiXCIgdWktc3RhdGUtcGFyYW1zPVwieyBsYW5nOiAnZW4nIH1cIj5FbmdsaXNoPC9hPlxuICogYGBgXG4gKlxuICogLSBBIG1pZGRsZS1jbGljaywgcmlnaHQtY2xpY2ssIG9yIGN0cmwtY2xpY2sgaXMgaGFuZGxlZCAobmF0aXZlbHkpIGJ5IHRoZSBicm93c2VyIHRvIG9wZW4gdGhlIGhyZWYgaW4gYSBuZXcgd2luZG93LCBmb3IgZXhhbXBsZS5cbiAqIGBgYFxuICovXG5sZXQgdWlTdGF0ZURpcmVjdGl2ZTogbmcxX2RpcmVjdGl2ZTtcbnVpU3RhdGVEaXJlY3RpdmUgPSBbXG4gICckdWlSb3V0ZXInLFxuICAnJHRpbWVvdXQnLFxuICBmdW5jdGlvbiAkU3RhdGVSZWZEeW5hbWljRGlyZWN0aXZlKCR1aVJvdXRlcjogVUlSb3V0ZXIsICR0aW1lb3V0OiBJVGltZW91dFNlcnZpY2UpIHtcbiAgICBjb25zdCAkc3RhdGUgPSAkdWlSb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlOiBJU2NvcGUsIGVsZW1lbnQ6IElBdWdtZW50ZWRKUXVlcnksIGF0dHJzOiBhbnksIHVpU3JlZkFjdGl2ZTogYW55KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdWlTcmVmQWN0aXZlWzFdIHx8IHVpU3JlZkFjdGl2ZVswXTtcbiAgICAgICAgbGV0IHVubGlua0luZm9GbjogRnVuY3Rpb24gPSBudWxsO1xuICAgICAgICBsZXQgaG9va0ZuO1xuXG4gICAgICAgIGNvbnN0IHJhd0RlZiA9IHt9IGFzIERlZjtcbiAgICAgICAgY29uc3QgZ2V0RGVmID0gKCkgPT4gcHJvY2Vzc2VkRGVmKCRzdGF0ZSwgZWxlbWVudCwgcmF3RGVmKTtcblxuICAgICAgICBjb25zdCBpbnB1dEF0dHJzID0gWyd1aVN0YXRlJywgJ3VpU3RhdGVQYXJhbXMnLCAndWlTdGF0ZU9wdHMnXTtcbiAgICAgICAgY29uc3Qgd2F0Y2hEZXJlZ0ZucyA9IGlucHV0QXR0cnMucmVkdWNlKChhY2MsIGF0dHIpID0+ICgoYWNjW2F0dHJdID0gbm9vcCksIGFjYyksIHt9KTtcblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gZ2V0RGVmKCk7XG4gICAgICAgICAgaWYgKHVubGlua0luZm9GbikgdW5saW5rSW5mb0ZuKCk7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkgdW5saW5rSW5mb0ZuID0gYWN0aXZlLiQkYWRkU3RhdGVJbmZvKGRlZi51aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcyk7XG4gICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dEF0dHJzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgIHJhd0RlZltmaWVsZF0gPSBhdHRyc1tmaWVsZF0gPyBzY29wZS4kZXZhbChhdHRyc1tmaWVsZF0pIDogbnVsbDtcblxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKGZpZWxkLCBleHByID0+IHtcbiAgICAgICAgICAgIHdhdGNoRGVyZWdGbnNbZmllbGRdKCk7XG4gICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSA9IHNjb3BlLiR3YXRjaChcbiAgICAgICAgICAgICAgZXhwcixcbiAgICAgICAgICAgICAgbmV3dmFsID0+IHtcbiAgICAgICAgICAgICAgICByYXdEZWZbZmllbGRdID0gbmV3dmFsO1xuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGUoKTtcblxuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgPGFueT4kdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQodXBkYXRlKSk7XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCA8YW55PiR1aVJvdXRlci50cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZSkpO1xuXG4gICAgICAgIGlmICghdHlwZS5jbGlja2FibGUpIHJldHVybjtcbiAgICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZik7XG4gICAgICAgIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgcmF3RGVmLnVpU3RhdGVPcHRzKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbl07XG5cbi8qKlxuICogYHVpLXNyZWYtYWN0aXZlYCBhbmQgYHVpLXNyZWYtYWN0aXZlLWVxYDogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGEgQ1NTIGNsYXNzIHdoZW4gYSBgdWktc3JlZmAgaXMgYWN0aXZlXG4gKlxuICogQSBkaXJlY3RpdmUgd29ya2luZyBhbG9uZ3NpZGUgW1t1aVNyZWZdXSBhbmQgW1t1aVN0YXRlXV0gdG8gYWRkIGNsYXNzZXMgdG8gYW4gZWxlbWVudCB3aGVuIHRoZVxuICogcmVsYXRlZCBkaXJlY3RpdmUncyBzdGF0ZSBpcyBhY3RpdmUgKGFuZCByZW1vdmUgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlKS5cbiAqXG4gKiBUaGUgcHJpbWFyeSB1c2UtY2FzZSBpcyB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rIGluIG5hdmlnYXRpb24gbWVudXMsXG4gKiBkaXN0aW5ndWlzaGluZyBpdCBmcm9tIHRoZSBpbmFjdGl2ZSBtZW51IGl0ZW1zLlxuICpcbiAqICMjIyBMaW5raW5nIHRvIGEgYHVpLXNyZWZgIG9yIGB1aS1zdGF0ZWBcbiAqIGB1aS1zcmVmLWFjdGl2ZWAgY2FuIGxpdmUgb24gdGhlIHNhbWUgZWxlbWVudCBhcyBgdWktc3JlZmAvYHVpLXN0YXRlYCwgb3IgaXQgY2FuIGJlIG9uIGEgcGFyZW50IGVsZW1lbnQuXG4gKiBJZiBhIGB1aS1zcmVmLWFjdGl2ZWAgaXMgYSBwYXJlbnQgdG8gbW9yZSB0aGFuIG9uZSBgdWktc3JlZmAvYHVpLXN0YXRlYCwgaXQgd2lsbCBhcHBseSB0aGUgQ1NTIGNsYXNzIHdoZW4gKiphbnkgb2YgdGhlIGxpbmtzIGFyZSBhY3RpdmUqKi5cbiAqXG4gKiAjIyMgTWF0Y2hpbmdcbiAqXG4gKiBUaGUgYHVpLXNyZWYtYWN0aXZlYCBkaXJlY3RpdmUgYXBwbGllcyB0aGUgQ1NTIGNsYXNzIHdoZW4gdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgJ3MgdGFyZ2V0IHN0YXRlICoqb3IgYW55IGNoaWxkIHN0YXRlIGlzIGFjdGl2ZSoqLlxuICogVGhpcyBpcyBhIFwiZnV6enkgbWF0Y2hcIiB3aGljaCB1c2VzIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV0uXG4gKlxuICogVGhlIGB1aS1zcmVmLWFjdGl2ZS1lcWAgZGlyZWN0aXZlIGFwcGxpZXMgdGhlIENTUyBjbGFzcyB3aGVuIHRoZSBgdWktc3JlZmAvYHVpLXN0YXRlYCdzIHRhcmdldCBzdGF0ZSBpcyBkaXJlY3RseSBhY3RpdmUgKG5vdCB3aGVuIGNoaWxkIHN0YXRlcyBhcmUgYWN0aXZlKS5cbiAqIFRoaXMgaXMgYW4gXCJleGFjdCBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaXNdXS5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyIHZhbHVlc1xuICogSWYgdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMsIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgbXVzdCBtYXRjaCB0aGUgbGluaydzIHZhbHVlcyBmb3IgdGhlIGxpbmsgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gKiBUaGlzIGFsbG93cyBhIGxpc3Qgb2YgbGlua3MgdG8gdGhlIHNhbWUgc3RhdGUgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycyB0byBiZSByZW5kZXJlZCwgYW5kIHRoZSBjb3JyZWN0IG9uZSBoaWdobGlnaHRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwidXNlciBpbiB1c2Vyc1wiIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCI+XG4gKiAgIDxhIHVpLXNyZWY9XCJ1c2VyLmRldGFpbHMoeyB1c2VySWQ6IHVzZXIuaWQgfSlcIj57eyB1c2VyLmxhc3ROYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqICMjIyBFeGFtcGxlc1xuICpcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8dWw+XG4gKiAgIDxsaSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIGNsYXNzPVwiaXRlbVwiPlxuICogICAgIDxhIGhyZWYgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCI+QGJpbGJvYmFnZ2luczwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBhcHAgc3RhdGUgaXMgYGFwcC51c2VyYCAob3IgYW55IGNoaWxkIHN0YXRlKSxcbiAqIGFuZCBjb250YWlucyB0aGUgc3RhdGUgcGFyYW1ldGVyIFwidXNlclwiIHdpdGggdmFsdWUgXCJiaWxib2JhZ2dpbnNcIixcbiAqIHRoZSByZXN1bHRpbmcgSFRNTCB3aWxsIGFwcGVhciBhcyAobm90ZSB0aGUgJ2FjdGl2ZScgY2xhc3MpOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtIGFjdGl2ZVwiPlxuICogICAgIDxhIHVpLXNyZWY9XCJhcHAudXNlcih7dXNlcjogJ2JpbGJvYmFnZ2lucyd9KVwiIGhyZWY9XCIvdXNlcnMvYmlsYm9iYWdnaW5zXCI+QGJpbGJvYmFnZ2luczwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiAjIyMgR2xvYiBtb2RlXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBgdWktc3JlZi1hY3RpdmVgIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gb2JqZWN0LlxuICogVGhlIG9iamVjdHMga2V5cyByZXByZXNlbnQgYWN0aXZlIGNsYXNzIG5hbWVzIGFuZCB2YWx1ZXMgcmVwcmVzZW50IHRoZSByZXNwZWN0aXZlIHN0YXRlIG5hbWVzL2dsb2JzLlxuICogYHVpLXNyZWYtYWN0aXZlYCB3aWxsIG1hdGNoIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSAqKmluY2x1ZGVzKiogYW55IG9mXG4gKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUsIHdpdGggXCJhZG1pblwiIGJlaW5nIGFuIGFic3RyYWN0IHN0YXRlOlxuICogYGBgaHRtbFxuICogPGRpdiB1aS1zcmVmLWFjdGl2ZT1cInsnYWN0aXZlJzogJ2FkbWluLioqJ31cIj5cbiAqICAgPGEgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiB1aS1zcmVmPVwiYWRtaW4ucm9sZXNcIj5Sb2xlczwvYT5cbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICogQXJyYXlzIGFyZSBhbHNvIHN1cHBvcnRlZCBhcyB2YWx1ZXMgaW4gdGhlIGBuZ0NsYXNzYC1saWtlIGludGVyZmFjZS5cbiAqIFRoaXMgYWxsb3dzIG11bHRpcGxlIHN0YXRlcyB0byBhZGQgYGFjdGl2ZWAgY2xhc3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogR2l2ZW4gdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSwgd2l0aCBcImFkbWluLnJvbGVzXCIgYmVpbmcgdGhlIGN1cnJlbnQgc3RhdGUsIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvbzpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgdWktc3JlZi1hY3RpdmU9XCJ7J2FjdGl2ZSc6IFsnb3duZXIuKionLCAnYWRtaW4uKionXX1cIj5cbiAqICAgPGEgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiB1aS1zcmVmPVwiYWRtaW4ucm9sZXNcIj5Sb2xlczwvYT5cbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgY3VycmVudCBzdGF0ZSBpcyBcImFkbWluLnJvbGVzXCIgdGhlIFwiYWN0aXZlXCIgY2xhc3Mgd2lsbCBiZSBhcHBsaWVkIHRvIGJvdGggdGhlIGA8ZGl2PmAgYW5kIGA8YT5gIGVsZW1lbnRzLlxuICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgc3RhdGUgbmFtZXMvZ2xvYnMgcGFzc2VkIHRvIGB1aS1zcmVmLWFjdGl2ZWAgb3ZlcnJpZGUgYW55IHN0YXRlIHByb3ZpZGVkIGJ5IGEgbGlua2VkIGB1aS1zcmVmYC5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogLSBUaGUgY2xhc3MgbmFtZSBpcyBpbnRlcnBvbGF0ZWQgKipvbmNlKiogZHVyaW5nIHRoZSBkaXJlY3RpdmVzIGxpbmsgdGltZSAoYW55IGZ1cnRoZXIgY2hhbmdlcyB0byB0aGVcbiAqIGludGVycG9sYXRlZCB2YWx1ZSBhcmUgaWdub3JlZCkuXG4gKlxuICogLSBNdWx0aXBsZSBjbGFzc2VzIG1heSBiZSBzcGVjaWZpZWQgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgZm9ybWF0OiBgdWktc3JlZi1hY3RpdmU9J2NsYXNzMSBjbGFzczIgY2xhc3MzJ2BcbiAqL1xubGV0IHVpU3JlZkFjdGl2ZURpcmVjdGl2ZTogbmcxX2RpcmVjdGl2ZTtcbnVpU3JlZkFjdGl2ZURpcmVjdGl2ZSA9IFtcbiAgJyRzdGF0ZScsXG4gICckc3RhdGVQYXJhbXMnLFxuICAnJGludGVycG9sYXRlJyxcbiAgJyR1aVJvdXRlcicsXG4gIGZ1bmN0aW9uICRTdGF0ZVJlZkFjdGl2ZURpcmVjdGl2ZShcbiAgICAkc3RhdGU6IFN0YXRlU2VydmljZSxcbiAgICAkc3RhdGVQYXJhbXM6IE9iaixcbiAgICAkaW50ZXJwb2xhdGU6IElJbnRlcnBvbGF0ZVNlcnZpY2UsXG4gICAgJHVpUm91dGVyOiBVSVJvdXRlclxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgJyRzY29wZScsXG4gICAgICAgICckZWxlbWVudCcsXG4gICAgICAgICckYXR0cnMnLFxuICAgICAgICBmdW5jdGlvbigkc2NvcGU6IElTY29wZSwgJGVsZW1lbnQ6IElBdWdtZW50ZWRKUXVlcnksICRhdHRyczogYW55KSB7XG4gICAgICAgICAgbGV0IHN0YXRlczogU3RhdGVEYXRhW10gPSBbXTtcbiAgICAgICAgICBsZXQgYWN0aXZlRXFDbGFzczogc3RyaW5nO1xuICAgICAgICAgIGxldCB1aVNyZWZBY3RpdmU6IGFueTtcblxuICAgICAgICAgIC8vIFRoZXJlIHByb2JhYmx5IGlzbid0IG11Y2ggcG9pbnQgaW4gJG9ic2VydmluZyB0aGlzXG4gICAgICAgICAgLy8gdWlTcmVmQWN0aXZlIGFuZCB1aVNyZWZBY3RpdmVFcSBzaGFyZSB0aGUgc2FtZSBkaXJlY3RpdmUgb2JqZWN0IHdpdGggc29tZVxuICAgICAgICAgIC8vIHNsaWdodCBkaWZmZXJlbmNlIGluIGxvZ2ljIHJvdXRpbmdcbiAgICAgICAgICBhY3RpdmVFcUNsYXNzID0gJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmVFcSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdWlTcmVmQWN0aXZlID0gJHNjb3BlLiRldmFsKCRhdHRycy51aVNyZWZBY3RpdmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuIHVpU3JlZkFjdGl2ZSBpcyBub3QgYSB2YWxpZCBleHByZXNzaW9uLlxuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nICRpbnRlcnBvbGF0ZSBiZWxvd1xuICAgICAgICAgIH1cbiAgICAgICAgICB1aVNyZWZBY3RpdmUgPSB1aVNyZWZBY3RpdmUgfHwgJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmUgfHwgJycsIGZhbHNlKSgkc2NvcGUpO1xuICAgICAgICAgIHNldFN0YXRlc0Zyb21EZWZpbml0aW9uT2JqZWN0KHVpU3JlZkFjdGl2ZSk7XG5cbiAgICAgICAgICAvLyBBbGxvdyB1aVNyZWYgdG8gY29tbXVuaWNhdGUgd2l0aCB1aVNyZWZBY3RpdmVbRXF1YWxzXVxuICAgICAgICAgIHRoaXMuJCRhZGRTdGF0ZUluZm8gPSBmdW5jdGlvbihuZXdTdGF0ZTogc3RyaW5nLCBuZXdQYXJhbXM6IE9iaikge1xuICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBnb3QgYW4gZXhwbGljaXQgc3RhdGUgcHJvdmlkZWQgYnkgdWktc3JlZi1hY3RpdmUsIHNvIHdlXG4gICAgICAgICAgICAvLyBzaGFkb3cgdGhlIG9uZSB0aGF0IGNvbWVzIGZyb20gdWktc3JlZlxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHVpU3JlZkFjdGl2ZSkgJiYgc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVyZWdpc3RlciA9IGFkZFN0YXRlKG5ld1N0YXRlLCBuZXdQYXJhbXMsIHVpU3JlZkFjdGl2ZSk7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZXJlZ2lzdGVyO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVBZnRlclRyYW5zaXRpb24odHJhbnMpIHtcbiAgICAgICAgICAgIHRyYW5zLnByb21pc2UudGhlbih1cGRhdGUsIG5vb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSk7XG4gICAgICAgICAgaWYgKCR1aVJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbigkdWlSb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgICAgY29uc3QgZGVyZWdpc3RlclN0YXRlc0NoYW5nZWRMaXN0ZW5lciA9ICR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZChoYW5kbGVTdGF0ZXNDaGFuZ2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcmVnaXN0ZXJPblN0YXJ0TGlzdGVuZXIgPSAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcmVnaXN0ZXJTdGF0ZUNoYW5nZVN1Y2Nlc3NMaXN0ZW5lciA9ICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgICAgICAgIGRlcmVnaXN0ZXJTdGF0ZXNDaGFuZ2VkTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgZGVyZWdpc3Rlck9uU3RhcnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICBkZXJlZ2lzdGVyU3RhdGVDaGFuZ2VTdWNjZXNzTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlU3RhdGVzQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgIHNldFN0YXRlc0Zyb21EZWZpbml0aW9uT2JqZWN0KHVpU3JlZkFjdGl2ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0U3RhdGVzRnJvbURlZmluaXRpb25PYmplY3Qoc3RhdGVzRGVmaW5pdGlvbjogb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3RhdGVzRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgc3RhdGVzID0gW107XG4gICAgICAgICAgICAgIGZvckVhY2goc3RhdGVzRGVmaW5pdGlvbiwgZnVuY3Rpb24oc3RhdGVPck5hbWU6IFN0YXRlT3JOYW1lIHwgQXJyYXk8U3RhdGVPck5hbWU+LCBhY3RpdmVDbGFzczogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFic3RyYWN0IGFkZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRTdGF0ZUZvckNsYXNzID0gZnVuY3Rpb24oc3RhdGVPck5hbWU6IHN0cmluZywgYWN0aXZlQ2xhc3M6IHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcGFyc2VTdGF0ZVJlZihzdGF0ZU9yTmFtZSk7XG4gICAgICAgICAgICAgICAgICBhZGRTdGF0ZShyZWYuc3RhdGUsICRzY29wZS4kZXZhbChyZWYucGFyYW1FeHByKSwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoc3RhdGVPck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiBzdGF0ZSBpcyBzdHJpbmcsIGp1c3QgYWRkIGl0LlxuICAgICAgICAgICAgICAgICAgYWRkU3RhdGVGb3JDbGFzcyhzdGF0ZU9yTmFtZSBhcyBzdHJpbmcsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoc3RhdGVPck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiBzdGF0ZSBpcyBhbiBhcnJheSwgaXRlcmF0ZSBvdmVyIGl0IGFuZCBhZGQgZWFjaCBhcnJheSBpdGVtIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgICAgICAgIGZvckVhY2goc3RhdGVPck5hbWUsIGZ1bmN0aW9uKHN0YXRlT3JOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGVGb3JDbGFzcyhzdGF0ZU9yTmFtZSwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhZGRTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZywgc3RhdGVQYXJhbXM6IE9iaiwgYWN0aXZlQ2xhc3M6IHN0cmluZykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSAkc3RhdGUuZ2V0KHN0YXRlTmFtZSwgc3RhdGVDb250ZXh0KCRlbGVtZW50KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlIHx8IHsgbmFtZTogc3RhdGVOYW1lIH0sXG4gICAgICAgICAgICAgIHBhcmFtczogc3RhdGVQYXJhbXMsXG4gICAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiBhY3RpdmVDbGFzcyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlSW5mbyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlRnJvbShzdGF0ZXMpKHN0YXRlSW5mbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSByb3V0ZSBzdGF0ZVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0Q2xhc3NlcyA9IHN0ciA9PiBzdHIuc3BsaXQoL1xccy8pLmZpbHRlcihpZGVudGl0eSk7XG4gICAgICAgICAgICBjb25zdCBnZXRDbGFzc2VzID0gKHN0YXRlTGlzdDogU3RhdGVEYXRhW10pID0+XG4gICAgICAgICAgICAgIHN0YXRlTGlzdFxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiB4LmFjdGl2ZUNsYXNzKVxuICAgICAgICAgICAgICAgIC5tYXAoc3BsaXRDbGFzc2VzKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pO1xuXG4gICAgICAgICAgICBjb25zdCBhbGxDbGFzc2VzID0gZ2V0Q2xhc3NlcyhzdGF0ZXMpXG4gICAgICAgICAgICAgIC5jb25jYXQoc3BsaXRDbGFzc2VzKGFjdGl2ZUVxQ2xhc3MpKVxuICAgICAgICAgICAgICAucmVkdWNlKHVuaXFSLCBbXSk7XG4gICAgICAgICAgICBjb25zdCBmdXp6eUNsYXNzZXMgPSBnZXRDbGFzc2VzKHN0YXRlcy5maWx0ZXIoeCA9PiAkc3RhdGUuaW5jbHVkZXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcykpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YWN0bHlNYXRjaGVzQW55ID0gISFzdGF0ZXMuZmlsdGVyKHggPT4gJHN0YXRlLmlzKHguc3RhdGUubmFtZSwgeC5wYXJhbXMpKS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBleGFjdENsYXNzZXMgPSBleGFjdGx5TWF0Y2hlc0FueSA/IHNwbGl0Q2xhc3NlcyhhY3RpdmVFcUNsYXNzKSA6IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBhZGRDbGFzc2VzID0gZnV6enlDbGFzc2VzLmNvbmNhdChleGFjdENsYXNzZXMpLnJlZHVjZSh1bmlxUiwgW10pO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ2xhc3NlcyA9IGFsbENsYXNzZXMuZmlsdGVyKGNscyA9PiAhaW5BcnJheShhZGRDbGFzc2VzLCBjbHMpKTtcblxuICAgICAgICAgICAgJHNjb3BlLiRldmFsQXN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICBhZGRDbGFzc2VzLmZvckVhY2goY2xhc3NOYW1lID0+ICRlbGVtZW50LmFkZENsYXNzKGNsYXNzTmFtZSkpO1xuICAgICAgICAgICAgICByZW1vdmVDbGFzc2VzLmZvckVhY2goY2xhc3NOYW1lID0+ICRlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH0sXG5dO1xuXG4vKiogQGhpZGRlbiAqL1xuaW50ZXJmYWNlIERlZiB7XG4gIHVpU3RhdGU6IHN0cmluZztcbiAgaHJlZjogc3RyaW5nO1xuICB1aVN0YXRlUGFyYW1zOiBPYmo7XG4gIHVpU3RhdGVPcHRzOiBhbnk7XG59XG4vKiogQGhpZGRlbiAqL1xuaW50ZXJmYWNlIFN0YXRlRGF0YSB7XG4gIHN0YXRlOiBTdGF0ZURlY2xhcmF0aW9uO1xuICBwYXJhbXM6IFJhd1BhcmFtcztcbiAgYWN0aXZlQ2xhc3M6IHN0cmluZztcbn1cblxuYW5ndWxhclxuICAubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKVxuICAuZGlyZWN0aXZlKCd1aVNyZWYnLCB1aVNyZWZEaXJlY3RpdmUpXG4gIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZScsIHVpU3JlZkFjdGl2ZURpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlRXEnLCB1aVNyZWZBY3RpdmVEaXJlY3RpdmUpXG4gIC5kaXJlY3RpdmUoJ3VpU3RhdGUnLCB1aVN0YXRlRGlyZWN0aXZlKTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgbmcxICovIC8qKiAqL1xuXG5pbXBvcnQgeyBuZyBhcyBhbmd1bGFyIH0gZnJvbSAnLi9hbmd1bGFyJztcbmltcG9ydCB7IE9iaiwgU3RhdGVTZXJ2aWNlLCBTdGF0ZU9yTmFtZSB9IGZyb20gJ0B1aXJvdXRlci9jb3JlJztcblxuLyoqXG4gKiBgaXNTdGF0ZWAgRmlsdGVyOiB0cnV0aHkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdGhlIHBhcmFtZXRlclxuICpcbiAqIFRyYW5zbGF0ZXMgdG8gW1tTdGF0ZVNlcnZpY2UuaXNdXSBgJHN0YXRlLmlzKFwic3RhdGVOYW1lXCIpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiJ3N0YXRlTmFtZScgfCBpc1N0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpcyAnc3RhdGVOYW1lJzwvZGl2PlxuICogYGBgXG4gKi9cbiRJc1N0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuZnVuY3Rpb24gJElzU3RhdGVGaWx0ZXIoJHN0YXRlOiBTdGF0ZVNlcnZpY2UpIHtcbiAgY29uc3QgaXNGaWx0ZXI6IGFueSA9IGZ1bmN0aW9uKHN0YXRlOiBTdGF0ZU9yTmFtZSwgcGFyYW1zOiBPYmosIG9wdGlvbnM/OiB7IHJlbGF0aXZlPzogU3RhdGVPck5hbWUgfSkge1xuICAgIHJldHVybiAkc3RhdGUuaXMoc3RhdGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH07XG4gIGlzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XG4gIHJldHVybiBpc0ZpbHRlcjtcbn1cblxuLyoqXG4gKiBgaW5jbHVkZWRCeVN0YXRlYCBGaWx0ZXI6IHRydXRoeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpbmNsdWRlcyB0aGUgcGFyYW1ldGVyXG4gKlxuICogVHJhbnNsYXRlcyB0byBbW1N0YXRlU2VydmljZS5pbmNsdWRlc11dYCAkc3RhdGUuaXMoXCJmdWxsT3JQYXJ0aWFsU3RhdGVOYW1lXCIpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiJ2Z1bGxPclBhcnRpYWxTdGF0ZU5hbWUnIHwgaW5jbHVkZWRCeVN0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpbmNsdWRlcyAnZnVsbE9yUGFydGlhbFN0YXRlTmFtZSc8L2Rpdj5cbiAqIGBgYFxuICovXG4kSW5jbHVkZWRCeVN0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuZnVuY3Rpb24gJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcigkc3RhdGU6IFN0YXRlU2VydmljZSkge1xuICBjb25zdCBpbmNsdWRlc0ZpbHRlcjogYW55ID0gZnVuY3Rpb24oc3RhdGU6IFN0YXRlT3JOYW1lLCBwYXJhbXM6IE9iaiwgb3B0aW9uczogeyByZWxhdGl2ZT86IFN0YXRlT3JOYW1lIH0pIHtcbiAgICByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9O1xuICBpbmNsdWRlc0ZpbHRlci4kc3RhdGVmdWwgPSB0cnVlO1xuICByZXR1cm4gaW5jbHVkZXNGaWx0ZXI7XG59XG5cbmFuZ3VsYXJcbiAgLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcbiAgLmZpbHRlcignaXNTdGF0ZScsICRJc1N0YXRlRmlsdGVyKVxuICAuZmlsdGVyKCdpbmNsdWRlZEJ5U3RhdGUnLCAkSW5jbHVkZWRCeVN0YXRlRmlsdGVyKTtcblxuZXhwb3J0IHsgJElzU3RhdGVGaWx0ZXIsICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIgfTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgZGlyZWN0aXZlcyAqLyAvKiogKi9cbmltcG9ydCB7XG4gICRRTGlrZSxcbiAgQWN0aXZlVUlWaWV3LFxuICBleHRlbmQsXG4gIGZpbHRlcixcbiAgSG9va1JlZ09wdGlvbnMsXG4gIGlzRGVmaW5lZCxcbiAgaXNGdW5jdGlvbixcbiAgaXNTdHJpbmcsXG4gIGtlYm9iU3RyaW5nLFxuICBub29wLFxuICBPYmosXG4gIFBhcmFtLFxuICBwYXJzZSxcbiAgUGF0aE5vZGUsXG4gIFJlc29sdmVDb250ZXh0LFxuICBTdGF0ZURlY2xhcmF0aW9uLFxuICB0YWlsLFxuICB0cmFjZSxcbiAgVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvblNlcnZpY2UsXG4gIFR5cGVkTWFwLFxuICB1bm5lc3RSLFxuICBWaWV3U2VydmljZSxcbn0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgSUF1Z21lbnRlZEpRdWVyeSwgSUludGVycG9sYXRlU2VydmljZSwgSVNjb3BlLCBJVGltZW91dFNlcnZpY2UsIElUcmFuc2NsdWRlRnVuY3Rpb24gfSBmcm9tICdhbmd1bGFyJztcbmltcG9ydCB7IG5nIGFzIGFuZ3VsYXIgfSBmcm9tICcuLi9hbmd1bGFyJztcbmltcG9ydCB7IE5nMUNvbnRyb2xsZXIsIE5nMVN0YXRlRGVjbGFyYXRpb24gfSBmcm9tICcuLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgZ2V0TG9jYWxzIH0gZnJvbSAnLi4vc2VydmljZXMnO1xuaW1wb3J0IHsgTmcxVmlld0NvbmZpZyB9IGZyb20gJy4uL3N0YXRlYnVpbGRlcnMvdmlld3MnO1xuaW1wb3J0IHsgbmcxX2RpcmVjdGl2ZSB9IGZyb20gJy4vc3RhdGVEaXJlY3RpdmVzJztcblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCB0eXBlIFVJVmlld0RhdGEgPSB7XG4gICRjZmc6IE5nMVZpZXdDb25maWc7XG4gICR1aVZpZXc6IEFjdGl2ZVVJVmlldztcbn07XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgdHlwZSBVSVZpZXdBbmltRGF0YSA9IHtcbiAgJGFuaW1FbnRlcjogUHJvbWlzZTxhbnk+O1xuICAkYW5pbUxlYXZlOiBQcm9taXNlPGFueT47XG4gICQkYW5pbUxlYXZlOiB7IHJlc29sdmU6ICgpID0+IGFueSB9OyAvLyBcImRlZmVycmVkXCJcbn07XG5cbi8qKlxuICogYHVpLXZpZXdgOiBBIHZpZXdwb3J0IGRpcmVjdGl2ZSB3aGljaCBpcyBmaWxsZWQgaW4gYnkgYSB2aWV3IGZyb20gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKiAjIyMgQXR0cmlidXRlc1xuICpcbiAqIC0gYG5hbWVgOiAoT3B0aW9uYWwpIEEgdmlldyBuYW1lLlxuICogICBUaGUgbmFtZSBzaG91bGQgYmUgdW5pcXVlIGFtb25nc3QgdGhlIG90aGVyIHZpZXdzIGluIHRoZSBzYW1lIHN0YXRlLlxuICogICBZb3UgY2FuIGhhdmUgdmlld3Mgb2YgdGhlIHNhbWUgbmFtZSB0aGF0IGxpdmUgaW4gZGlmZmVyZW50IHN0YXRlcy5cbiAqICAgVGhlIHVpLXZpZXcgY2FuIGJlIHRhcmdldGVkIGluIGEgVmlldyB1c2luZyB0aGUgbmFtZSAoW1tOZzFTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV0pLlxuICpcbiAqIC0gYGF1dG9zY3JvbGxgOiBhbiBleHByZXNzaW9uLiBXaGVuIGl0IGV2YWx1YXRlcyB0byB0cnVlLCB0aGUgYHVpLXZpZXdgIHdpbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IHdoZW4gaXQgaXMgYWN0aXZhdGVkLlxuICogICBVc2VzIFtbJHVpVmlld1Njcm9sbF1dIHRvIGRvIHRoZSBzY3JvbGxpbmcuXG4gKlxuICogLSBgb25sb2FkYDogRXhwcmVzc2lvbiB0byBldmFsdWF0ZSB3aGVuZXZlciB0aGUgdmlldyB1cGRhdGVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEEgdmlldyBjYW4gYmUgdW5uYW1lZCBvciBuYW1lZC5cbiAqIGBgYGh0bWxcbiAqIDwhLS0gVW5uYW1lZCAtLT5cbiAqIDxkaXYgdWktdmlldz48L2Rpdj5cbiAqXG4gKiA8IS0tIE5hbWVkIC0tPlxuICogPGRpdiB1aS12aWV3PVwidmlld05hbWVcIj48L2Rpdj5cbiAqXG4gKiA8IS0tIE5hbWVkIChkaWZmZXJlbnQgc3R5bGUpIC0tPlxuICogPHVpLXZpZXcgbmFtZT1cInZpZXdOYW1lXCI+PC91aS12aWV3PlxuICogYGBgXG4gKlxuICogWW91IGNhbiBvbmx5IGhhdmUgb25lIHVubmFtZWQgdmlldyB3aXRoaW4gYW55IHRlbXBsYXRlIChvciByb290IGh0bWwpLiBJZiB5b3UgYXJlIG9ubHkgdXNpbmcgYVxuICogc2luZ2xlIHZpZXcgYW5kIGl0IGlzIHVubmFtZWQgdGhlbiB5b3UgY2FuIHBvcHVsYXRlIGl0IGxpa2Ugc286XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAqICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBUaGUgYWJvdmUgaXMgYSBjb252ZW5pZW50IHNob3J0Y3V0IGVxdWl2YWxlbnQgdG8gc3BlY2lmeWluZyB5b3VyIHZpZXcgZXhwbGljaXRseSB3aXRoIHRoZVxuICogW1tOZzFTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV0gY29uZmlnIHByb3BlcnR5LCBieSBuYW1lLCBpbiB0aGlzIGNhc2UgYW4gZW1wdHkgbmFtZTpcbiAqXG4gKiBgYGBqc1xuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAqICAgdmlld3M6IHtcbiAqICAgICBcIlwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogICAgIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEJ1dCB0eXBpY2FsbHkgeW91J2xsIG9ubHkgdXNlIHRoZSB2aWV3cyBwcm9wZXJ0eSBpZiB5b3UgbmFtZSB5b3VyIHZpZXcgb3IgaGF2ZSBtb3JlIHRoYW4gb25lIHZpZXdcbiAqIGluIHRoZSBzYW1lIHRlbXBsYXRlLiBUaGVyZSdzIG5vdCByZWFsbHkgYSBjb21wZWxsaW5nIHJlYXNvbiB0byBuYW1lIGEgdmlldyBpZiBpdHMgdGhlIG9ubHkgb25lLFxuICogYnV0IHlvdSBjb3VsZCBpZiB5b3Ugd2FudGVkLCBsaWtlIHNvOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgdWktdmlldz1cIm1haW5cIj48L2Rpdj5cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwibWFpblwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogICAgIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFJlYWxseSB0aG91Z2gsIHlvdSdsbCB1c2Ugdmlld3MgdG8gc2V0IHVwIG11bHRpcGxlIHZpZXdzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgdWktdmlldz48L2Rpdj5cbiAqIDxkaXYgdWktdmlldz1cImNoYXJ0XCI+PC9kaXY+XG4gKiA8ZGl2IHVpLXZpZXc9XCJkYXRhXCI+PC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAqICAgdmlld3M6IHtcbiAqICAgICBcIlwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogICAgIH0sXG4gKiAgICAgXCJjaGFydFwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8Y2hhcnRfdGhpbmcvPlwiXG4gKiAgICAgfSxcbiAqICAgICBcImRhdGFcIjoge1xuICogICAgICAgdGVtcGxhdGU6IFwiPGRhdGFfdGhpbmcvPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlcyBmb3IgYGF1dG9zY3JvbGxgOlxuICogYGBgaHRtbFxuICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCBubyBleHByZXNzaW9uLFxuICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyAtLT5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGwvPlxuICpcbiAqIDwhLS0gSWYgYXV0b3Njcm9sbCBwcmVzZW50IHdpdGggdmFsaWQgZXhwcmVzc2lvbixcbiAqICAgICAgdGhlbiBzY3JvbGwgdWktdmlldyBpbnRvIHZpZXcgaWYgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZSAtLT5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3RydWUnLz5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J2ZhbHNlJy8+XG4gKiA8dWktdmlldyBhdXRvc2Nyb2xsPSdzY29wZVZhcmlhYmxlJy8+XG4gKiBgYGBcbiAqXG4gKiBSZXNvbHZlIGRhdGE6XG4gKlxuICogVGhlIHJlc29sdmVkIGRhdGEgZnJvbSB0aGUgc3RhdGUncyBgcmVzb2x2ZWAgYmxvY2sgaXMgcGxhY2VkIG9uIHRoZSBzY29wZSBhcyBgJHJlc29sdmVgICh0aGlzXG4gKiBjYW4gYmUgY3VzdG9taXplZCB1c2luZyBbW05nMVZpZXdEZWNsYXJhdGlvbi5yZXNvbHZlQXNdXSkuICBUaGlzIGNhbiBiZSB0aGVuIGFjY2Vzc2VkIGZyb20gdGhlIHRlbXBsYXRlLlxuICpcbiAqIE5vdGUgdGhhdCB3aGVuIGBjb250cm9sbGVyQXNgIGlzIGJlaW5nIHVzZWQsIGAkcmVzb2x2ZWAgaXMgc2V0IG9uIHRoZSBjb250cm9sbGVyIGluc3RhbmNlICphZnRlciogdGhlXG4gKiBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZC4gIFRoZSBgJG9uSW5pdCgpYCBob29rIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gY29kZSB3aGljaFxuICogZGVwZW5kcyBvbiBgJHJlc29sdmVgIGRhdGEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCdob21lJywge1xuICogICB0ZW1wbGF0ZTogJzxteS1jb21wb25lbnQgdXNlcj1cIiRyZXNvbHZlLnVzZXJcIj48L215LWNvbXBvbmVudD4nLFxuICogICByZXNvbHZlOiB7XG4gKiAgICAgdXNlcjogZnVuY3Rpb24oVXNlclNlcnZpY2UpIHsgcmV0dXJuIFVzZXJTZXJ2aWNlLmZldGNoVXNlcigpOyB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBsZXQgdWlWaWV3OiBuZzFfZGlyZWN0aXZlO1xudWlWaWV3ID0gW1xuICAnJHZpZXcnLFxuICAnJGFuaW1hdGUnLFxuICAnJHVpVmlld1Njcm9sbCcsXG4gICckaW50ZXJwb2xhdGUnLFxuICAnJHEnLFxuICBmdW5jdGlvbiAkVmlld0RpcmVjdGl2ZShcbiAgICAkdmlldzogVmlld1NlcnZpY2UsXG4gICAgJGFuaW1hdGU6IGFueSxcbiAgICAkdWlWaWV3U2Nyb2xsOiBhbnksXG4gICAgJGludGVycG9sYXRlOiBJSW50ZXJwb2xhdGVTZXJ2aWNlLFxuICAgICRxOiAkUUxpa2VcbiAgKSB7XG4gICAgZnVuY3Rpb24gZ2V0UmVuZGVyZXIoYXR0cnM6IE9iaiwgc2NvcGU6IElTY29wZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKGVsZW1lbnQ6IEpRdWVyeSwgdGFyZ2V0OiBhbnksIGNiOiBGdW5jdGlvbikge1xuICAgICAgICAgIGlmIChhbmd1bGFyLnZlcnNpb24ubWlub3IgPiAyKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihlbGVtZW50LCBudWxsLCB0YXJnZXQpLnRoZW4oY2IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihlbGVtZW50LCBudWxsLCB0YXJnZXQsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbihlbGVtZW50OiBKUXVlcnksIGNiOiBGdW5jdGlvbikge1xuICAgICAgICAgIGlmIChhbmd1bGFyLnZlcnNpb24ubWlub3IgPiAyKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50KS50aGVuKGNiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudCwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnc0VxdWFsKGNvbmZpZzE6IE5nMVZpZXdDb25maWcsIGNvbmZpZzI6IE5nMVZpZXdDb25maWcpIHtcbiAgICAgIHJldHVybiBjb25maWcxID09PSBjb25maWcyO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3REYXRhID0ge1xuICAgICAgJGNmZzogeyB2aWV3RGVjbDogeyAkY29udGV4dDogJHZpZXcuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KCkgfSB9LFxuICAgICAgJHVpVmlldzoge30sXG4gICAgfTtcblxuICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgICAgIGNvdW50OiAwLFxuICAgICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgICAgdGVybWluYWw6IHRydWUsXG4gICAgICBwcmlvcml0eTogNDAwLFxuICAgICAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxuICAgICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQ6IEpRdWVyeSwgdEF0dHJzOiBPYmosICR0cmFuc2NsdWRlOiBJVHJhbnNjbHVkZUZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZTogSVNjb3BlLCAkZWxlbWVudDogSUF1Z21lbnRlZEpRdWVyeSwgYXR0cnM6IE9iaikge1xuICAgICAgICAgIGNvbnN0IG9ubG9hZEV4cCA9IGF0dHJzWydvbmxvYWQnXSB8fCAnJyxcbiAgICAgICAgICAgIGF1dG9TY3JvbGxFeHAgPSBhdHRyc1snYXV0b3Njcm9sbCddLFxuICAgICAgICAgICAgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpLFxuICAgICAgICAgICAgaW5oZXJpdGVkID0gJGVsZW1lbnQuaW5oZXJpdGVkRGF0YSgnJHVpVmlldycpIHx8IHJvb3REYXRhLFxuICAgICAgICAgICAgbmFtZSA9ICRpbnRlcnBvbGF0ZShhdHRyc1sndWlWaWV3J10gfHwgYXR0cnNbJ25hbWUnXSB8fCAnJykoc2NvcGUpIHx8ICckZGVmYXVsdCc7XG5cbiAgICAgICAgICBsZXQgcHJldmlvdXNFbDogSlF1ZXJ5LFxuICAgICAgICAgICAgY3VycmVudEVsOiBKUXVlcnksXG4gICAgICAgICAgICBjdXJyZW50U2NvcGU6IElTY29wZSxcbiAgICAgICAgICAgIHZpZXdDb25maWc6IE5nMVZpZXdDb25maWcsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyOiBGdW5jdGlvbjtcblxuICAgICAgICAgIGNvbnN0IGFjdGl2ZVVJVmlldzogQWN0aXZlVUlWaWV3ID0ge1xuICAgICAgICAgICAgJHR5cGU6ICduZzEnLFxuICAgICAgICAgICAgaWQ6IGRpcmVjdGl2ZS5jb3VudCsrLCAvLyBHbG9iYWwgc2VxdWVudGlhbCBJRCBmb3IgdWktdmlldyB0YWdzIGFkZGVkIHRvIERPTVxuICAgICAgICAgICAgbmFtZTogbmFtZSwgLy8gdWktdmlldyBuYW1lICg8ZGl2IHVpLXZpZXc9XCJuYW1lXCI+PC9kaXY+XG4gICAgICAgICAgICBmcW46IGluaGVyaXRlZC4kdWlWaWV3LmZxbiA/IGluaGVyaXRlZC4kdWlWaWV3LmZxbiArICcuJyArIG5hbWUgOiBuYW1lLCAvLyBmdWxseSBxdWFsaWZpZWQgbmFtZSwgZGVzY3JpYmVzIGxvY2F0aW9uIGluIERPTVxuICAgICAgICAgICAgY29uZmlnOiBudWxsLCAvLyBUaGUgVmlld0NvbmZpZyBsb2FkZWQgKGZyb20gYSBzdGF0ZS52aWV3cyBkZWZpbml0aW9uKVxuICAgICAgICAgICAgY29uZmlnVXBkYXRlZDogY29uZmlnVXBkYXRlZENhbGxiYWNrLCAvLyBDYWxsZWQgd2hlbiB0aGUgbWF0Y2hpbmcgVmlld0NvbmZpZyBjaGFuZ2VzXG4gICAgICAgICAgICBnZXQgY3JlYXRpb25Db250ZXh0KCkge1xuICAgICAgICAgICAgICAvLyBUaGUgY29udGV4dCBpbiB3aGljaCB0aGlzIHVpLXZpZXcgXCJ0YWdcIiB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgICBjb25zdCBmcm9tUGFyZW50VGFnQ29uZmlnID0gcGFyc2UoJyRjZmcudmlld0RlY2wuJGNvbnRleHQnKShpbmhlcml0ZWQpO1xuICAgICAgICAgICAgICAvLyBBbGxvdyA8dWktdmlldyBuYW1lPVwiZm9vXCI+PHVpLXZpZXcgbmFtZT1cImJhclwiPjwvdWktdmlldz48L3VpLXZpZXc+XG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzMzNTVcbiAgICAgICAgICAgICAgY29uc3QgZnJvbVBhcmVudFRhZyA9IHBhcnNlKCckdWlWaWV3LmNyZWF0aW9uQ29udGV4dCcpKGluaGVyaXRlZCk7XG4gICAgICAgICAgICAgIHJldHVybiBmcm9tUGFyZW50VGFnQ29uZmlnIHx8IGZyb21QYXJlbnRUYWc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0cmFjZS50cmFjZVVJVmlld0V2ZW50KCdMaW5raW5nJywgYWN0aXZlVUlWaWV3KTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbmZpZ1VwZGF0ZWRDYWxsYmFjayhjb25maWc/OiBOZzFWaWV3Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICEoY29uZmlnIGluc3RhbmNlb2YgTmcxVmlld0NvbmZpZykpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChjb25maWdzRXF1YWwodmlld0NvbmZpZywgY29uZmlnKSkgcmV0dXJuO1xuICAgICAgICAgICAgdHJhY2UudHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKGFjdGl2ZVVJVmlldywgY29uZmlnICYmIGNvbmZpZy52aWV3RGVjbCAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQpO1xuXG4gICAgICAgICAgICB2aWV3Q29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgdXBkYXRlVmlldyhjb25maWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbGVtZW50LmRhdGEoJyR1aVZpZXcnLCB7ICR1aVZpZXc6IGFjdGl2ZVVJVmlldyB9KTtcblxuICAgICAgICAgIHVwZGF0ZVZpZXcoKTtcblxuICAgICAgICAgIHVucmVnaXN0ZXIgPSAkdmlldy5yZWdpc3RlclVJVmlldyhhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0Rlc3Ryb3lpbmcvVW5yZWdpc3RlcmluZycsIGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjbGVhbnVwTGFzdFZpZXcoKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNFbCkge1xuICAgICAgICAgICAgICB0cmFjZS50cmFjZVVJVmlld0V2ZW50KCdSZW1vdmluZyAocHJldmlvdXMpIGVsJywgcHJldmlvdXNFbC5kYXRhKCckdWlWaWV3JykpO1xuICAgICAgICAgICAgICBwcmV2aW91c0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBwcmV2aW91c0VsID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgICAgICB0cmFjZS50cmFjZVVJVmlld0V2ZW50KCdEZXN0cm95aW5nIHNjb3BlJywgYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50RWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgX3ZpZXdEYXRhID0gY3VycmVudEVsLmRhdGEoJyR1aVZpZXdBbmltJyk7XG4gICAgICAgICAgICAgIHRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0FuaW1hdGUgb3V0JywgX3ZpZXdEYXRhKTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIubGVhdmUoY3VycmVudEVsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfdmlld0RhdGEuJCRhbmltTGVhdmUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBwcmV2aW91c0VsID0gY3VycmVudEVsO1xuICAgICAgICAgICAgICBjdXJyZW50RWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXcoY29uZmlnPzogTmcxVmlld0NvbmZpZykge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS4kbmV3KCk7XG4gICAgICAgICAgICBjb25zdCBhbmltRW50ZXIgPSAkcS5kZWZlcigpLFxuICAgICAgICAgICAgICBhbmltTGVhdmUgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICBjb25zdCAkdWlWaWV3RGF0YTogVUlWaWV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgJGNmZzogY29uZmlnLFxuICAgICAgICAgICAgICAkdWlWaWV3OiBhY3RpdmVVSVZpZXcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCAkdWlWaWV3QW5pbTogVUlWaWV3QW5pbURhdGEgPSB7XG4gICAgICAgICAgICAgICRhbmltRW50ZXI6IGFuaW1FbnRlci5wcm9taXNlLFxuICAgICAgICAgICAgICAkYW5pbUxlYXZlOiBhbmltTGVhdmUucHJvbWlzZSxcbiAgICAgICAgICAgICAgJCRhbmltTGVhdmU6IGFuaW1MZWF2ZSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5nZG9jIGV2ZW50XG4gICAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGluZ1xuICAgICAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3XG4gICAgICAgICAgICAgKiBAZXZlbnRUeXBlIGVtaXRzIG9uIHVpLXZpZXcgZGlyZWN0aXZlIHNjb3BlXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGaXJlZCBvbmNlIHRoZSB2aWV3ICoqYmVnaW5zIGxvYWRpbmcqKiwgKmJlZm9yZSogdGhlIERPTSBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdOYW1lIE5hbWUgb2YgdGhlIHZpZXcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5ld1Njb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkaW5nJywgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9ICR0cmFuc2NsdWRlKG5ld1Njb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3QW5pbScsICR1aVZpZXdBbmltKTtcbiAgICAgICAgICAgICAgY2xvbmUuZGF0YSgnJHVpVmlldycsICR1aVZpZXdEYXRhKTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIuZW50ZXIoY2xvbmUsICRlbGVtZW50LCBmdW5jdGlvbiBvblVJVmlld0VudGVyKCkge1xuICAgICAgICAgICAgICAgIGFuaW1FbnRlci5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRBbmltYXRpb25FbmRlZCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKChpc0RlZmluZWQoYXV0b1Njcm9sbEV4cCkgJiYgIWF1dG9TY3JvbGxFeHApIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSB7XG4gICAgICAgICAgICAgICAgICAkdWlWaWV3U2Nyb2xsKGNsb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0VmlldygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IGNsb25lZDtcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkZWRcbiAgICAgICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlld1xuICAgICAgICAgICAgICogQGV2ZW50VHlwZSBlbWl0cyBvbiB1aS12aWV3IGRpcmVjdGl2ZSBzY29wZVxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGaXJlZCBvbmNlIHRoZSB2aWV3IGlzICoqbG9hZGVkKiosICphZnRlciogdGhlIERPTSBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudExvYWRlZCcsIGNvbmZpZyB8fCB2aWV3Q29uZmlnKTtcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZXZhbChvbmxvYWRFeHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBkaXJlY3RpdmU7XG4gIH0sXG5dO1xuXG4kVmlld0RpcmVjdGl2ZUZpbGwuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJHRyYW5zaXRpb25zJywgJyR2aWV3JywgJyRxJywgJyR0aW1lb3V0J107XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiAkVmlld0RpcmVjdGl2ZUZpbGwoXG4gICRjb21waWxlOiBhbmd1bGFyLklDb21waWxlU2VydmljZSxcbiAgJGNvbnRyb2xsZXI6IGFuZ3VsYXIuSUNvbnRyb2xsZXJTZXJ2aWNlLFxuICAkdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25TZXJ2aWNlLFxuICAkdmlldzogVmlld1NlcnZpY2UsXG4gICRxOiBhbmd1bGFyLklRU2VydmljZSxcbiAgJHRpbWVvdXQ6IElUaW1lb3V0U2VydmljZVxuKSB7XG4gIGNvbnN0IGdldENvbnRyb2xsZXJBcyA9IHBhcnNlKCd2aWV3RGVjbC5jb250cm9sbGVyQXMnKTtcbiAgY29uc3QgZ2V0UmVzb2x2ZUFzID0gcGFyc2UoJ3ZpZXdEZWNsLnJlc29sdmVBcycpO1xuXG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgIHByaW9yaXR5OiAtNDAwLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtZW50OiBKUXVlcnkpIHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSB0RWxlbWVudC5odG1sKCk7XG4gICAgICB0RWxlbWVudC5lbXB0eSgpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGU6IElTY29wZSwgJGVsZW1lbnQ6IEpRdWVyeSkge1xuICAgICAgICBjb25zdCBkYXRhOiBVSVZpZXdEYXRhID0gJGVsZW1lbnQuZGF0YSgnJHVpVmlldycpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAkZWxlbWVudC5odG1sKGluaXRpYWwpO1xuICAgICAgICAgICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkgYXMgYW55KShzY29wZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2ZnOiBOZzFWaWV3Q29uZmlnID0gZGF0YS4kY2ZnIHx8IDxhbnk+eyB2aWV3RGVjbDoge30sIGdldFRlbXBsYXRlOiBub29wIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVDdHg6IFJlc29sdmVDb250ZXh0ID0gY2ZnLnBhdGggJiYgbmV3IFJlc29sdmVDb250ZXh0KGNmZy5wYXRoKTtcbiAgICAgICAgJGVsZW1lbnQuaHRtbChjZmcuZ2V0VGVtcGxhdGUoJGVsZW1lbnQsIHJlc29sdmVDdHgpIHx8IGluaXRpYWwpO1xuICAgICAgICB0cmFjZS50cmFjZVVJVmlld0ZpbGwoZGF0YS4kdWlWaWV3LCAkZWxlbWVudC5odG1sKCkpO1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpIGFzIGFueSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjZmcuY29udHJvbGxlciBhcyBhbmd1bGFyLklDb250cm9sbGVyU2VydmljZTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlckFzOiBzdHJpbmcgPSBnZXRDb250cm9sbGVyQXMoY2ZnKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZUFzOiBzdHJpbmcgPSBnZXRSZXNvbHZlQXMoY2ZnKTtcbiAgICAgICAgY29uc3QgbG9jYWxzID0gcmVzb2x2ZUN0eCAmJiBnZXRMb2NhbHMocmVzb2x2ZUN0eCk7XG5cbiAgICAgICAgc2NvcGVbcmVzb2x2ZUFzXSA9IGxvY2FscztcblxuICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXJJbnN0YW5jZSA9IDxOZzFDb250cm9sbGVyPihcbiAgICAgICAgICAgICRjb250cm9sbGVyKGNvbnRyb2xsZXIsIGV4dGVuZCh7fSwgbG9jYWxzLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChjb250cm9sbGVyQXMpIHtcbiAgICAgICAgICAgIHNjb3BlW2NvbnRyb2xsZXJBc10gPSBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgICAgICAgICBzY29wZVtjb250cm9sbGVyQXNdW3Jlc29sdmVBc10gPSBsb2NhbHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogVXNlICR2aWV3IHNlcnZpY2UgYXMgYSBjZW50cmFsIHBvaW50IGZvciByZWdpc3RlcmluZyBjb21wb25lbnQtbGV2ZWwgaG9va3NcbiAgICAgICAgICAvLyBUaGVuLCB3aGVuIGEgY29tcG9uZW50IGlzIGNyZWF0ZWQsIHRlbGwgdGhlICR2aWV3IHNlcnZpY2UsIHNvIGl0IGNhbiBpbnZva2UgaG9va3NcbiAgICAgICAgICAvLyAkdmlldy5jb21wb25lbnRMb2FkZWQoY29udHJvbGxlckluc3RhbmNlLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KTtcbiAgICAgICAgICAvLyBzY29wZS4kb24oJyRkZXN0cm95JywgKCkgPT4gJHZpZXcuY29tcG9uZW50VW5sb2FkZWQoY29udHJvbGxlckluc3RhbmNlLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KSk7XG5cbiAgICAgICAgICAkZWxlbWVudC5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICAgICAgJGVsZW1lbnQuY2hpbGRyZW4oKS5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHEsICR0cmFuc2l0aW9ucywgY29udHJvbGxlckluc3RhbmNlLCBzY29wZSwgY2ZnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjb21wb25lbnQgdG8gYXBwZWFyIGluIHRoZSBET01cbiAgICAgICAgaWYgKGlzU3RyaW5nKGNmZy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgY29uc3Qga2Vib2JOYW1lID0ga2Vib2JTdHJpbmcoY2ZnLmNvbXBvbmVudCk7XG4gICAgICAgICAgY29uc3QgdGFnUmVnZXhwID0gbmV3IFJlZ0V4cChgXih4LXxkYXRhLSk/JHtrZWJvYk5hbWV9JGAsICdpJyk7XG5cbiAgICAgICAgICBjb25zdCBnZXRDb21wb25lbnRDb250cm9sbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlRWwgPSBbXS5zbGljZVxuICAgICAgICAgICAgICAuY2FsbCgkZWxlbWVudFswXS5jaGlsZHJlbilcbiAgICAgICAgICAgICAgLmZpbHRlcigoZWw6IEVsZW1lbnQpID0+IGVsICYmIGVsLnRhZ05hbWUgJiYgdGFnUmVnZXhwLmV4ZWMoZWwudGFnTmFtZSkpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlRWwgJiYgYW5ndWxhci5lbGVtZW50KGRpcmVjdGl2ZUVsKS5kYXRhKGAkJHtjZmcuY29tcG9uZW50fUNvbnRyb2xsZXJgKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgZGVyZWdpc3RlcldhdGNoID0gc2NvcGUuJHdhdGNoKGdldENvbXBvbmVudENvbnRyb2xsZXIsIGZ1bmN0aW9uKGN0cmxJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKCFjdHJsSW5zdGFuY2UpIHJldHVybjtcbiAgICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjdHJsSW5zdGFuY2UsIHNjb3BlLCBjZmcpO1xuICAgICAgICAgICAgZGVyZWdpc3RlcldhdGNoKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rKHNjb3BlKTtcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGhhc0NvbXBvbmVudEltcGwgPSB0eXBlb2YgKGFuZ3VsYXIgYXMgYW55KS5tb2R1bGUoJ3VpLnJvdXRlcicpWydjb21wb25lbnQnXSA9PT0gJ2Z1bmN0aW9uJztcbi8qKiBAaGlkZGVuIGluY3JlbWVudGluZyBpZCAqL1xubGV0IF91aUNhbkV4aXRJZCA9IDA7XG5cbi8qKiBAaGlkZGVuIFRPRE86IG1vdmUgdGhlc2UgY2FsbGJhY2tzIHRvICR2aWV3IGFuZC9vciBgL2hvb2tzL2NvbXBvbmVudHMudHNgIG9yIHNvbWV0aGluZyAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb250cm9sbGVyQ2FsbGJhY2tzKFxuICAkcTogYW5ndWxhci5JUVNlcnZpY2UsXG4gICR0cmFuc2l0aW9uczogVHJhbnNpdGlvblNlcnZpY2UsXG4gIGNvbnRyb2xsZXJJbnN0YW5jZTogTmcxQ29udHJvbGxlcixcbiAgJHNjb3BlOiBJU2NvcGUsXG4gIGNmZzogTmcxVmlld0NvbmZpZ1xuKSB7XG4gIC8vIENhbGwgJG9uSW5pdCgpIEFTQVBcbiAgaWYgKGlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLiRvbkluaXQpICYmICEoKGNmZy52aWV3RGVjbC5jb21wb25lbnQgfHwgY2ZnLnZpZXdEZWNsLmNvbXBvbmVudFByb3ZpZGVyKSAmJiBoYXNDb21wb25lbnRJbXBsKSkge1xuICAgIGNvbnRyb2xsZXJJbnN0YW5jZS4kb25Jbml0KCk7XG4gIH1cblxuICBjb25zdCB2aWV3U3RhdGU6IE5nMVN0YXRlRGVjbGFyYXRpb24gPSB0YWlsKGNmZy5wYXRoKS5zdGF0ZS5zZWxmO1xuXG4gIGNvbnN0IGhvb2tPcHRpb25zOiBIb29rUmVnT3B0aW9ucyA9IHsgYmluZDogY29udHJvbGxlckluc3RhbmNlIH07XG4gIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3Igb25VaVBhcmFtc0NoYW5nZWRcbiAgaWYgKGlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLnVpT25QYXJhbXNDaGFuZ2VkKSkge1xuICAgIGNvbnN0IHJlc29sdmVDb250ZXh0OiBSZXNvbHZlQ29udGV4dCA9IG5ldyBSZXNvbHZlQ29udGV4dChjZmcucGF0aCk7XG4gICAgY29uc3Qgdmlld0NyZWF0aW9uVHJhbnMgPSByZXNvbHZlQ29udGV4dC5nZXRSZXNvbHZhYmxlKCckdHJhbnNpdGlvbiQnKS5kYXRhO1xuXG4gICAgLy8gRmlyZSBjYWxsYmFjayBvbiBhbnkgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gICAgY29uc3QgcGFyYW1zVXBkYXRlZCA9ICgkdHJhbnNpdGlvbiQ6IFRyYW5zaXRpb24pID0+IHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCBpcyB0aGUgc2FtZSBhcyB0aGUgdmlldyB3YXMgY3JlYXRlZCB3aXRoaW4uXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSAkdHJhbnNpdGlvbiQgd2lsbCBleGl0IHRoZSBzdGF0ZSB0aGUgdmlldyBpcyBmb3IuXG4gICAgICBpZiAoJHRyYW5zaXRpb24kID09PSB2aWV3Q3JlYXRpb25UcmFucyB8fCAkdHJhbnNpdGlvbiQuZXhpdGluZygpLmluZGV4T2Yodmlld1N0YXRlIGFzIFN0YXRlRGVjbGFyYXRpb24pICE9PSAtMSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjb25zdCB0b1BhcmFtcyA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoJ3RvJykgYXMgVHlwZWRNYXA8YW55PjtcbiAgICAgIGNvbnN0IGZyb21QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zPFR5cGVkTWFwPGFueT4+KCdmcm9tJykgYXMgVHlwZWRNYXA8YW55PjtcbiAgICAgIGNvbnN0IGdldE5vZGVTY2hlbWEgPSAobm9kZTogUGF0aE5vZGUpID0+IG5vZGUucGFyYW1TY2hlbWE7XG4gICAgICBjb25zdCB0b1NjaGVtYTogUGFyYW1bXSA9ICR0cmFuc2l0aW9uJFxuICAgICAgICAudHJlZUNoYW5nZXMoJ3RvJylcbiAgICAgICAgLm1hcChnZXROb2RlU2NoZW1hKVxuICAgICAgICAucmVkdWNlKHVubmVzdFIsIFtdKTtcbiAgICAgIGNvbnN0IGZyb21TY2hlbWE6IFBhcmFtW10gPSAkdHJhbnNpdGlvbiRcbiAgICAgICAgLnRyZWVDaGFuZ2VzKCdmcm9tJylcbiAgICAgICAgLm1hcChnZXROb2RlU2NoZW1hKVxuICAgICAgICAucmVkdWNlKHVubmVzdFIsIFtdKTtcblxuICAgICAgLy8gRmluZCB0aGUgdG8gcGFyYW1zIHRoYXQgaGF2ZSBkaWZmZXJlbnQgdmFsdWVzIHRoYW4gdGhlIGZyb20gcGFyYW1zXG4gICAgICBjb25zdCBjaGFuZ2VkVG9QYXJhbXMgPSB0b1NjaGVtYS5maWx0ZXIoKHBhcmFtOiBQYXJhbSkgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSBmcm9tU2NoZW1hLmluZGV4T2YocGFyYW0pO1xuICAgICAgICByZXR1cm4gaWR4ID09PSAtMSB8fCAhZnJvbVNjaGVtYVtpZHhdLnR5cGUuZXF1YWxzKHRvUGFyYW1zW3BhcmFtLmlkXSwgZnJvbVBhcmFtc1twYXJhbS5pZF0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9ubHkgdHJpZ2dlciBjYWxsYmFjayBpZiBhIHRvIHBhcmFtIGhhcyBjaGFuZ2VkIG9yIGlzIG5ld1xuICAgICAgaWYgKGNoYW5nZWRUb1BhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZEtleXM6IHN0cmluZ1tdID0gY2hhbmdlZFRvUGFyYW1zLm1hcCh4ID0+IHguaWQpO1xuICAgICAgICAvLyBGaWx0ZXIgdGhlIHBhcmFtcyB0byBvbmx5IGNoYW5nZWQvbmV3IHRvIHBhcmFtcy4gIGAkdHJhbnNpdGlvbiQucGFyYW1zKClgIG1heSBiZSB1c2VkIHRvIGdldCBhbGwgcGFyYW1zLlxuICAgICAgICBjb25zdCBuZXdWYWx1ZXMgPSBmaWx0ZXIodG9QYXJhbXMsICh2YWwsIGtleSkgPT4gY2hhbmdlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnRyb2xsZXJJbnN0YW5jZS51aU9uUGFyYW1zQ2hhbmdlZChuZXdWYWx1ZXMsICR0cmFuc2l0aW9uJCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIDxhbnk+JHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7fSwgcGFyYW1zVXBkYXRlZCwgaG9va09wdGlvbnMpKTtcbiAgfVxuXG4gIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3IgdWlDYW5FeGl0XG4gIGlmIChpc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS51aUNhbkV4aXQpKSB7XG4gICAgY29uc3QgaWQgPSBfdWlDYW5FeGl0SWQrKztcbiAgICBjb25zdCBjYWNoZVByb3AgPSAnX3VpQ2FuRXhpdElkcyc7XG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgYSByZWRpcmVjdCB0cmFuc2l0aW9uIGFscmVhZHkgYW5zd2VyZWQgdHJ1dGh5XG4gICAgY29uc3QgcHJldlRydXRoeUFuc3dlciA9ICh0cmFuczogVHJhbnNpdGlvbikgPT5cbiAgICAgICEhdHJhbnMgJiYgKCh0cmFuc1tjYWNoZVByb3BdICYmIHRyYW5zW2NhY2hlUHJvcF1baWRdID09PSB0cnVlKSB8fCBwcmV2VHJ1dGh5QW5zd2VyKHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkpKTtcblxuICAgIC8vIElmIGEgdXNlciBhbnN3ZXJlZCB5ZXMsIGJ1dCB0aGUgdHJhbnNpdGlvbiB3YXMgbGF0ZXIgcmVkaXJlY3RlZCwgZG9uJ3QgYWxzbyBhc2sgZm9yIHRoZSBuZXcgcmVkaXJlY3QgdHJhbnNpdGlvblxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gKHRyYW5zOiBUcmFuc2l0aW9uKSA9PiB7XG4gICAgICBsZXQgcHJvbWlzZTtcbiAgICAgIGNvbnN0IGlkcyA9ICh0cmFuc1tjYWNoZVByb3BdID0gdHJhbnNbY2FjaGVQcm9wXSB8fCB7fSk7XG5cbiAgICAgIGlmICghcHJldlRydXRoeUFuc3dlcih0cmFucykpIHtcbiAgICAgICAgcHJvbWlzZSA9ICRxLndoZW4oY29udHJvbGxlckluc3RhbmNlLnVpQ2FuRXhpdCh0cmFucykpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsID0+IChpZHNbaWRdID0gdmFsICE9PSBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyaXRlcmlhID0geyBleGl0aW5nOiB2aWV3U3RhdGUubmFtZSB9O1xuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgPGFueT4kdHJhbnNpdGlvbnMub25CZWZvcmUoY3JpdGVyaWEsIHdyYXBwZWRIb29rLCBob29rT3B0aW9ucykpO1xuICB9XG59XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsIDxhbnk+dWlWaWV3KTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsIDxhbnk+JFZpZXdEaXJlY3RpdmVGaWxsKTtcbiIsIi8qKiBAcHVibGljYXBpIEBtb2R1bGUgbmcxICovIC8qKiAqL1xuaW1wb3J0IHsgbmcgYXMgYW5ndWxhciB9IGZyb20gJy4vYW5ndWxhcic7XG5pbXBvcnQgeyBJU2VydmljZVByb3ZpZGVyRmFjdG9yeSB9IGZyb20gJ2FuZ3VsYXInO1xuaW1wb3J0IElBbmNob3JTY3JvbGxTZXJ2aWNlID0gYW5ndWxhci5JQW5jaG9yU2Nyb2xsU2VydmljZTtcbmltcG9ydCBJVGltZW91dFNlcnZpY2UgPSBhbmd1bGFyLklUaW1lb3V0U2VydmljZTtcblxuZXhwb3J0IGludGVyZmFjZSBVSVZpZXdTY3JvbGxQcm92aWRlciB7XG4gIC8qKlxuICAgKiBVc2VzIHN0YW5kYXJkIGFuY2hvclNjcm9sbCBiZWhhdmlvclxuICAgKlxuICAgKiBSZXZlcnRzIFtbJHVpVmlld1Njcm9sbF1dIGJhY2sgdG8gdXNpbmcgdGhlIGNvcmUgW2AkYW5jaG9yU2Nyb2xsYF0oaHR0cDovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcuJGFuY2hvclNjcm9sbClcbiAgICogc2VydmljZSBmb3Igc2Nyb2xsaW5nIGJhc2VkIG9uIHRoZSB1cmwgYW5jaG9yLlxuICAgKi9cbiAgdXNlQW5jaG9yU2Nyb2xsKCk6IHZvaWQ7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiAkVmlld1Njcm9sbFByb3ZpZGVyKCkge1xuICBsZXQgdXNlQW5jaG9yU2Nyb2xsID0gZmFsc2U7XG5cbiAgdGhpcy51c2VBbmNob3JTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICB1c2VBbmNob3JTY3JvbGwgPSB0cnVlO1xuICB9O1xuXG4gIHRoaXMuJGdldCA9IFtcbiAgICAnJGFuY2hvclNjcm9sbCcsXG4gICAgJyR0aW1lb3V0JyxcbiAgICBmdW5jdGlvbigkYW5jaG9yU2Nyb2xsOiBJQW5jaG9yU2Nyb2xsU2VydmljZSwgJHRpbWVvdXQ6IElUaW1lb3V0U2VydmljZSk6IEZ1bmN0aW9uIHtcbiAgICAgIGlmICh1c2VBbmNob3JTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuICRhbmNob3JTY3JvbGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigkZWxlbWVudDogSlF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiAkdGltZW91dChcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRlbGVtZW50WzBdLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0sXG4gIF07XG59XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5wcm92aWRlcignJHVpVmlld1Njcm9sbCcsIDxJU2VydmljZVByb3ZpZGVyRmFjdG9yeT4kVmlld1Njcm9sbFByb3ZpZGVyKTtcbiIsIi8qKlxuICogTWFpbiBlbnRyeSBwb2ludCBmb3IgYW5ndWxhciAxLnggYnVpbGRcbiAqIEBwdWJsaWNhcGkgQG1vZHVsZSBuZzFcbiAqLyAvKiogKi9cbmV4cG9ydCAqIGZyb20gJy4vaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vc2VydmljZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9zdGF0ZWJ1aWxkZXJzL3ZpZXdzJztcbmV4cG9ydCAqIGZyb20gJy4vc3RhdGVQcm92aWRlcic7XG5leHBvcnQgKiBmcm9tICcuL3VybFJvdXRlclByb3ZpZGVyJztcblxuaW1wb3J0ICcuL2luamVjdGFibGVzJztcbmltcG9ydCAnLi9kaXJlY3RpdmVzL3N0YXRlRGlyZWN0aXZlcyc7XG5pbXBvcnQgJy4vc3RhdGVGaWx0ZXJzJztcbmltcG9ydCAnLi9kaXJlY3RpdmVzL3ZpZXdEaXJlY3RpdmUnO1xuaW1wb3J0ICcuL3ZpZXdTY3JvbGwnO1xuXG5leHBvcnQgZGVmYXVsdCAndWkucm91dGVyJztcblxuaW1wb3J0ICogYXMgY29yZSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5leHBvcnQgeyBjb3JlIH07XG5leHBvcnQgKiBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG4iXX0=
